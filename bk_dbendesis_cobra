--
-- PostgreSQL database dump
--

-- Dumped from database version 9.0.4
-- Dumped by pg_dump version 9.0.4
-- Started on 2012-06-19 10:56:50 BOT

SET statement_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = off;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET escape_string_warning = off;

--
-- TOC entry 42 (class 2615 OID 3175997)
-- Name: actif; Type: SCHEMA; Schema: -; Owner: rchumacero
--

CREATE SCHEMA actif;


ALTER SCHEMA actif OWNER TO rchumacero;

--
-- TOC entry 7 (class 2615 OID 16497)
-- Name: adqui; Type: SCHEMA; Schema: -; Owner: rchumacero
--

CREATE SCHEMA adqui;


ALTER SCHEMA adqui OWNER TO rchumacero;

--
-- TOC entry 30 (class 2615 OID 18905)
-- Name: cobra; Type: SCHEMA; Schema: -; Owner: dbendesis_cobra_admin
--

CREATE SCHEMA cobra;


ALTER SCHEMA cobra OWNER TO dbendesis_cobra_admin;

--
-- TOC entry 8 (class 2615 OID 16498)
-- Name: conta; Type: SCHEMA; Schema: -; Owner: rchumacero
--

CREATE SCHEMA conta;


ALTER SCHEMA conta OWNER TO rchumacero;

--
-- TOC entry 43 (class 2615 OID 56271)
-- Name: factur; Type: SCHEMA; Schema: -; Owner: rchumacero
--

CREATE SCHEMA factur;


ALTER SCHEMA factur OWNER TO rchumacero;

--
-- TOC entry 9 (class 2615 OID 16499)
-- Name: gen; Type: SCHEMA; Schema: -; Owner: rchumacero
--

CREATE SCHEMA gen;


ALTER SCHEMA gen OWNER TO rchumacero;

--
-- TOC entry 90 (class 2615 OID 3175965)
-- Name: gev; Type: SCHEMA; Schema: -; Owner: rchumacero
--

CREATE SCHEMA gev;


ALTER SCHEMA gev OWNER TO rchumacero;

--
-- TOC entry 45 (class 2615 OID 1363940)
-- Name: hidro; Type: SCHEMA; Schema: -; Owner: rac
--

CREATE SCHEMA hidro;


ALTER SCHEMA hidro OWNER TO rac;

--
-- TOC entry 10 (class 2615 OID 16500)
-- Name: log; Type: SCHEMA; Schema: -; Owner: rchumacero
--

CREATE SCHEMA log;


ALTER SCHEMA log OWNER TO rchumacero;

--
-- TOC entry 11 (class 2615 OID 16501)
-- Name: param; Type: SCHEMA; Schema: -; Owner: rchumacero
--

CREATE SCHEMA param;


ALTER SCHEMA param OWNER TO rchumacero;

--
-- TOC entry 12 (class 2615 OID 16502)
-- Name: rhum; Type: SCHEMA; Schema: -; Owner: rchumacero
--

CREATE SCHEMA rhum;


ALTER SCHEMA rhum OWNER TO rchumacero;

--
-- TOC entry 91 (class 2615 OID 1944382)
-- Name: saj; Type: SCHEMA; Schema: -; Owner: mzambrana
--

CREATE SCHEMA saj;


ALTER SCHEMA saj OWNER TO mzambrana;

--
-- TOC entry 92 (class 2615 OID 1961576)
-- Name: sast; Type: SCHEMA; Schema: -; Owner: mflores
--

CREATE SCHEMA sast;


ALTER SCHEMA sast OWNER TO mflores;

--
-- TOC entry 13 (class 2615 OID 16503)
-- Name: secont; Type: SCHEMA; Schema: -; Owner: rchumacero
--

CREATE SCHEMA secont;


ALTER SCHEMA secont OWNER TO rchumacero;

--
-- TOC entry 14 (class 2615 OID 16504)
-- Name: segu; Type: SCHEMA; Schema: -; Owner: rchumacero
--

CREATE SCHEMA segu;


ALTER SCHEMA segu OWNER TO rchumacero;

--
-- TOC entry 15 (class 2615 OID 16505)
-- Name: tesor; Type: SCHEMA; Schema: -; Owner: rchumacero
--

CREATE SCHEMA tesor;


ALTER SCHEMA tesor OWNER TO rchumacero;

--
-- TOC entry 44 (class 2615 OID 56464)
-- Name: tesoro; Type: SCHEMA; Schema: -; Owner: rchumacero
--

CREATE SCHEMA tesoro;


ALTER SCHEMA tesoro OWNER TO rchumacero;

--
-- TOC entry 2435 (class 2612 OID 11574)
-- Name: plpgsql; Type: PROCEDURAL LANGUAGE; Schema: -; Owner: postgres
--

CREATE OR REPLACE PROCEDURAL LANGUAGE plpgsql;


ALTER PROCEDURAL LANGUAGE plpgsql OWNER TO postgres;

--
-- TOC entry 2436 (class 2612 OID 16508)
-- Name: plpythonu; Type: PROCEDURAL LANGUAGE; Schema: -; Owner: rchumacero
--

CREATE OR REPLACE PROCEDURAL LANGUAGE plpythonu;


ALTER PROCEDURAL LANGUAGE plpythonu OWNER TO rchumacero;

SET search_path = public, pg_catalog;

--
-- TOC entry 2118 (class 0 OID 0)
-- Name: box2d; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE box2d;


--
-- TOC entry 840 (class 1255 OID 1898134)
-- Dependencies: 5 2118
-- Name: box2d_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box2d_in(cstring) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_in';


ALTER FUNCTION public.box2d_in(cstring) OWNER TO postgres;

--
-- TOC entry 841 (class 1255 OID 1898135)
-- Dependencies: 5 2118
-- Name: box2d_out(box2d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box2d_out(box2d) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_out';


ALTER FUNCTION public.box2d_out(box2d) OWNER TO postgres;

--
-- TOC entry 2117 (class 1247 OID 1898111)
-- Dependencies: 5 840 841
-- Name: box2d; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE box2d (
    INTERNALLENGTH = 16,
    INPUT = box2d_in,
    OUTPUT = box2d_out,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE public.box2d OWNER TO postgres;

--
-- TOC entry 2108 (class 0 OID 0)
-- Name: box3d; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE box3d;


--
-- TOC entry 815 (class 1255 OID 1898103)
-- Dependencies: 5 2108
-- Name: box3d_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box3d_in(cstring) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_in';


ALTER FUNCTION public.box3d_in(cstring) OWNER TO postgres;

--
-- TOC entry 816 (class 1255 OID 1898104)
-- Dependencies: 5 2108
-- Name: box3d_out(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box3d_out(box3d) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_out';


ALTER FUNCTION public.box3d_out(box3d) OWNER TO postgres;

--
-- TOC entry 2107 (class 1247 OID 1898100)
-- Dependencies: 5 815 816
-- Name: box3d; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE box3d (
    INTERNALLENGTH = 48,
    INPUT = box3d_in,
    OUTPUT = box3d_out,
    ALIGNMENT = double,
    STORAGE = plain
);


ALTER TYPE public.box3d OWNER TO postgres;

--
-- TOC entry 2112 (class 0 OID 0)
-- Name: box3d_extent; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE box3d_extent;


--
-- TOC entry 817 (class 1255 OID 1898107)
-- Dependencies: 5 2112
-- Name: box3d_extent_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box3d_extent_in(cstring) RETURNS box3d_extent
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_in';


ALTER FUNCTION public.box3d_extent_in(cstring) OWNER TO postgres;

--
-- TOC entry 818 (class 1255 OID 1898108)
-- Dependencies: 5 2112
-- Name: box3d_extent_out(box3d_extent); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box3d_extent_out(box3d_extent) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_extent_out';


ALTER FUNCTION public.box3d_extent_out(box3d_extent) OWNER TO postgres;

--
-- TOC entry 2111 (class 1247 OID 1898106)
-- Dependencies: 817 5 818
-- Name: box3d_extent; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE box3d_extent (
    INTERNALLENGTH = 48,
    INPUT = box3d_extent_in,
    OUTPUT = box3d_extent_out,
    ALIGNMENT = double,
    STORAGE = plain
);


ALTER TYPE public.box3d_extent OWNER TO postgres;

--
-- TOC entry 2115 (class 0 OID 0)
-- Name: chip; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE chip;


--
-- TOC entry 834 (class 1255 OID 1898127)
-- Dependencies: 5 2115
-- Name: chip_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION chip_in(cstring) RETURNS chip
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_in';


ALTER FUNCTION public.chip_in(cstring) OWNER TO postgres;

--
-- TOC entry 835 (class 1255 OID 1898128)
-- Dependencies: 5 2115
-- Name: chip_out(chip); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION chip_out(chip) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_out';


ALTER FUNCTION public.chip_out(chip) OWNER TO postgres;

--
-- TOC entry 2114 (class 1247 OID 1898126)
-- Dependencies: 5 834 835
-- Name: chip; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE chip (
    INTERNALLENGTH = variable,
    INPUT = chip_in,
    OUTPUT = chip_out,
    ALIGNMENT = double,
    STORAGE = extended
);


ALTER TYPE public.chip OWNER TO postgres;

--
-- TOC entry 1606 (class 1247 OID 16511)
-- Dependencies: 5 3703
-- Name: dblink_pkey_results; Type: TYPE; Schema: public; Owner: rchumacero
--

CREATE TYPE dblink_pkey_results AS (
	"position" integer,
	colname text
);


ALTER TYPE public.dblink_pkey_results OWNER TO rchumacero;

--
-- TOC entry 1985 (class 1247 OID 1379091)
-- Dependencies: 5
-- Name: enum_tipo_dato; Type: TYPE; Schema: public; Owner: rac
--

CREATE TYPE enum_tipo_dato AS ENUM (
    'varchar',
    'integer',
    'float',
    'numeric',
    'boolean',
    'text'
);


ALTER TYPE public.enum_tipo_dato OWNER TO rac;

--
-- TOC entry 1608 (class 1247 OID 16513)
-- Dependencies: 5
-- Name: estado_reg; Type: TYPE; Schema: public; Owner: rchumacero
--

CREATE TYPE estado_reg AS ENUM (
    'activo',
    'inactivo'
);


ALTER TYPE public.estado_reg OWNER TO rchumacero;

--
-- TOC entry 2132 (class 0 OID 0)
-- Name: geography; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE geography;


--
-- TOC entry 686 (class 1255 OID 1898861)
-- Dependencies: 5
-- Name: geography_analyze(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_analyze(internal) RETURNS boolean
    LANGUAGE c STRICT
    AS '$libdir/postgis-1.5', 'geography_analyze';


ALTER FUNCTION public.geography_analyze(internal) OWNER TO postgres;

--
-- TOC entry 684 (class 1255 OID 1898859)
-- Dependencies: 5 2132
-- Name: geography_in(cstring, oid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_in(cstring, oid, integer) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_in';


ALTER FUNCTION public.geography_in(cstring, oid, integer) OWNER TO postgres;

--
-- TOC entry 685 (class 1255 OID 1898860)
-- Dependencies: 5 2132
-- Name: geography_out(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_out(geography) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_out';


ALTER FUNCTION public.geography_out(geography) OWNER TO postgres;

--
-- TOC entry 682 (class 1255 OID 1898856)
-- Dependencies: 5
-- Name: geography_typmod_in(cstring[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_typmod_in(cstring[]) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_typmod_in';


ALTER FUNCTION public.geography_typmod_in(cstring[]) OWNER TO postgres;

--
-- TOC entry 683 (class 1255 OID 1898857)
-- Dependencies: 5
-- Name: geography_typmod_out(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_typmod_out(integer) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_typmod_out';


ALTER FUNCTION public.geography_typmod_out(integer) OWNER TO postgres;

--
-- TOC entry 2131 (class 1247 OID 1898858)
-- Dependencies: 5 684 685 682 683 686
-- Name: geography; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE geography (
    INTERNALLENGTH = variable,
    INPUT = geography_in,
    OUTPUT = geography_out,
    TYPMOD_IN = geography_typmod_in,
    TYPMOD_OUT = geography_typmod_out,
    ANALYZE = geography_analyze,
    ALIGNMENT = double,
    STORAGE = main
);


ALTER TYPE public.geography OWNER TO postgres;

--
-- TOC entry 2105 (class 0 OID 0)
-- Name: geometry; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE geometry;


--
-- TOC entry 1082 (class 1255 OID 1898072)
-- Dependencies: 5
-- Name: geometry_analyze(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_analyze(internal) RETURNS boolean
    LANGUAGE c STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_analyze';


ALTER FUNCTION public.geometry_analyze(internal) OWNER TO postgres;

--
-- TOC entry 1080 (class 1255 OID 1898070)
-- Dependencies: 5 2105
-- Name: geometry_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_in(cstring) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_in';


ALTER FUNCTION public.geometry_in(cstring) OWNER TO postgres;

--
-- TOC entry 1081 (class 1255 OID 1898071)
-- Dependencies: 5 2105
-- Name: geometry_out(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_out(geometry) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_out';


ALTER FUNCTION public.geometry_out(geometry) OWNER TO postgres;

--
-- TOC entry 787 (class 1255 OID 1898073)
-- Dependencies: 5 2105
-- Name: geometry_recv(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_recv(internal) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_recv';


ALTER FUNCTION public.geometry_recv(internal) OWNER TO postgres;

--
-- TOC entry 788 (class 1255 OID 1898074)
-- Dependencies: 5 2105
-- Name: geometry_send(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_send(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_send';


ALTER FUNCTION public.geometry_send(geometry) OWNER TO postgres;

--
-- TOC entry 2104 (class 1247 OID 1898064)
-- Dependencies: 5 1080 1081 787 788 1082
-- Name: geometry; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE geometry (
    INTERNALLENGTH = variable,
    INPUT = geometry_in,
    OUTPUT = geometry_out,
    RECEIVE = geometry_recv,
    SEND = geometry_send,
    ANALYZE = geometry_analyze,
    DELIMITER = ':',
    ALIGNMENT = int4,
    STORAGE = main
);


ALTER TYPE public.geometry OWNER TO postgres;

--
-- TOC entry 2120 (class 1247 OID 1898386)
-- Dependencies: 5 3947
-- Name: geometry_dump; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE geometry_dump AS (
	path integer[],
	geom geometry
);


ALTER TYPE public.geometry_dump OWNER TO postgres;

--
-- TOC entry 2135 (class 0 OID 0)
-- Name: gidx; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE gidx;


--
-- TOC entry 687 (class 1255 OID 1898864)
-- Dependencies: 5 2135
-- Name: gidx_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gidx_in(cstring) RETURNS gidx
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'gidx_in';


ALTER FUNCTION public.gidx_in(cstring) OWNER TO postgres;

--
-- TOC entry 688 (class 1255 OID 1898865)
-- Dependencies: 5 2135
-- Name: gidx_out(gidx); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gidx_out(gidx) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'gidx_out';


ALTER FUNCTION public.gidx_out(gidx) OWNER TO postgres;

--
-- TOC entry 2134 (class 1247 OID 1898863)
-- Dependencies: 5 687 688
-- Name: gidx; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE gidx (
    INTERNALLENGTH = variable,
    INPUT = gidx_in,
    OUTPUT = gidx_out,
    ALIGNMENT = double,
    STORAGE = plain
);


ALTER TYPE public.gidx OWNER TO postgres;

--
-- TOC entry 2052 (class 0 OID 0)
-- Name: intbig_gkey; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE intbig_gkey;


--
-- TOC entry 1254 (class 1255 OID 2964586)
-- Dependencies: 5 2052
-- Name: _intbig_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _intbig_in(cstring) RETURNS intbig_gkey
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_intbig_in';


ALTER FUNCTION public._intbig_in(cstring) OWNER TO postgres;

--
-- TOC entry 1255 (class 1255 OID 2964587)
-- Dependencies: 5 2052
-- Name: _intbig_out(intbig_gkey); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _intbig_out(intbig_gkey) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_intbig_out';


ALTER FUNCTION public._intbig_out(intbig_gkey) OWNER TO postgres;

--
-- TOC entry 2051 (class 1247 OID 2964585)
-- Dependencies: 1254 5 1255
-- Name: intbig_gkey; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE intbig_gkey (
    INTERNALLENGTH = variable,
    INPUT = _intbig_in,
    OUTPUT = _intbig_out,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE public.intbig_gkey OWNER TO postgres;

--
-- TOC entry 2129 (class 0 OID 0)
-- Name: pgis_abs; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE pgis_abs;


--
-- TOC entry 393 (class 1255 OID 1898565)
-- Dependencies: 5 2129
-- Name: pgis_abs_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pgis_abs_in(cstring) RETURNS pgis_abs
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'pgis_abs_in';


ALTER FUNCTION public.pgis_abs_in(cstring) OWNER TO postgres;

--
-- TOC entry 394 (class 1255 OID 1898566)
-- Dependencies: 5 2129
-- Name: pgis_abs_out(pgis_abs); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pgis_abs_out(pgis_abs) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'pgis_abs_out';


ALTER FUNCTION public.pgis_abs_out(pgis_abs) OWNER TO postgres;

--
-- TOC entry 2128 (class 1247 OID 1898564)
-- Dependencies: 5 393 394
-- Name: pgis_abs; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE pgis_abs (
    INTERNALLENGTH = 8,
    INPUT = pgis_abs_in,
    OUTPUT = pgis_abs_out,
    ALIGNMENT = double,
    STORAGE = plain
);


ALTER TYPE public.pgis_abs OWNER TO postgres;

--
-- TOC entry 2010 (class 0 OID 0)
-- Name: query_int; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE query_int;


--
-- TOC entry 1220 (class 1255 OID 2964518)
-- Dependencies: 5 2010
-- Name: bqarr_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION bqarr_in(cstring) RETURNS query_int
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'bqarr_in';


ALTER FUNCTION public.bqarr_in(cstring) OWNER TO postgres;

--
-- TOC entry 1221 (class 1255 OID 2964519)
-- Dependencies: 5 2010
-- Name: bqarr_out(query_int); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION bqarr_out(query_int) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'bqarr_out';


ALTER FUNCTION public.bqarr_out(query_int) OWNER TO postgres;

--
-- TOC entry 2009 (class 1247 OID 2964517)
-- Dependencies: 1221 5 1220
-- Name: query_int; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE query_int (
    INTERNALLENGTH = variable,
    INPUT = bqarr_in,
    OUTPUT = bqarr_out,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE public.query_int OWNER TO postgres;

--
-- TOC entry 2102 (class 0 OID 0)
-- Name: spheroid; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE spheroid;


--
-- TOC entry 1073 (class 1255 OID 1898061)
-- Dependencies: 5 2102
-- Name: spheroid_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION spheroid_in(cstring) RETURNS spheroid
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ellipsoid_in';


ALTER FUNCTION public.spheroid_in(cstring) OWNER TO postgres;

--
-- TOC entry 1074 (class 1255 OID 1898062)
-- Dependencies: 5 2102
-- Name: spheroid_out(spheroid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION spheroid_out(spheroid) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ellipsoid_out';


ALTER FUNCTION public.spheroid_out(spheroid) OWNER TO postgres;

--
-- TOC entry 2101 (class 1247 OID 1898058)
-- Dependencies: 5 1073 1074
-- Name: spheroid; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE spheroid (
    INTERNALLENGTH = 65,
    INPUT = spheroid_in,
    OUTPUT = spheroid_out,
    ALIGNMENT = double,
    STORAGE = plain
);


ALTER TYPE public.spheroid OWNER TO postgres;

SET search_path = segu, pg_catalog;

--
-- TOC entry 1610 (class 1247 OID 16516)
-- Dependencies: 14
-- Name: activo_inactivo; Type: DOMAIN; Schema: segu; Owner: rchumacero
--

CREATE DOMAIN activo_inactivo AS character varying(10) NOT NULL DEFAULT 'activo'::character varying;


ALTER DOMAIN segu.activo_inactivo OWNER TO rchumacero;

--
-- TOC entry 1611 (class 1247 OID 16517)
-- Dependencies: 14
-- Name: error_advertencia_informativo; Type: DOMAIN; Schema: segu; Owner: rchumacero
--

CREATE DOMAIN error_advertencia_informativo AS character varying(15);


ALTER DOMAIN segu.error_advertencia_informativo OWNER TO rchumacero;

--
-- TOC entry 1612 (class 1247 OID 16519)
-- Dependencies: 14
-- Name: estado; Type: TYPE; Schema: segu; Owner: rchumacero
--

CREATE TYPE estado AS ENUM (
    'activo',
    'inactivo'
);


ALTER TYPE segu.estado OWNER TO rchumacero;

--
-- TOC entry 1614 (class 1247 OID 16522)
-- Dependencies: 14
-- Name: si_no; Type: DOMAIN; Schema: segu; Owner: rchumacero
--

CREATE DOMAIN si_no AS character varying(10) DEFAULT 'si'::character varying;


ALTER DOMAIN segu.si_no OWNER TO rchumacero;

SET search_path = cobra, pg_catalog;

--
-- TOC entry 272 (class 1255 OID 2991807)
-- Dependencies: 2435 30
-- Name: f_cb_obtener_consumo_historico(integer); Type: FUNCTION; Schema: cobra; Owner: rchumacero
--

CREATE FUNCTION f_cb_obtener_consumo_historico(cb_id_factura_cob integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
/*
Autor: RCM
Fecha: 07-03-2012
Propósito: Desplegar todo el consumo histórico de una factura en función a la cantidad parametrizada
*/
DECLARE

	v_cantidad integer = 0;

BEGIN
return;
END;
$$;


ALTER FUNCTION cobra.f_cb_obtener_consumo_historico(cb_id_factura_cob integer) OWNER TO rchumacero;

--
-- TOC entry 305 (class 1255 OID 1509956)
-- Dependencies: 30 2435
-- Name: f_tcb_agencia_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_agencia_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_agencia_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_agencia'
 AUTOR: 		 (fprudencio)
 FECHA:	        20-09-2011 19:15:41
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_agencia	integer;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_agencia_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_AGEN_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 19:15:41
	***********************************/

	if(p_transaccion='CB_AGEN_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_agencia(
			observaciones,
			estado_reg,
			nombre,
			id_enti_fin,
			codigo,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.observaciones,
			'activo',
			v_parametros.nombre,
			v_parametros.id_enti_fin,
			v_parametros.codigo,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_agencia into v_id_agencia;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Agencia almacenado(a) con exito (id_agencia'||v_id_agencia||')'); 
            v_resp = f_agrega_clave(v_resp,'id_agencia',v_id_agencia::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_AGEN_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 19:15:41
	***********************************/

	elsif(p_transaccion='CB_AGEN_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_agencia set
			observaciones = v_parametros.observaciones,
			nombre = v_parametros.nombre,
			id_enti_fin = v_parametros.id_enti_fin,
			codigo = v_parametros.codigo,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_agencia=v_parametros.id_agencia;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Agencia modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_agencia',v_parametros.id_agencia::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_AGEN_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 19:15:41
	***********************************/

	elsif(p_transaccion='CB_AGEN_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_agencia
            where id_agencia=v_parametros.id_agencia;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Agencia eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_agencia',v_parametros.id_agencia::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION cobra.f_tcb_agencia_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 306 (class 1255 OID 1509957)
-- Dependencies: 30 2435
-- Name: f_tcb_agencia_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_agencia_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_agencia_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_agencia'
 AUTOR: 		 (fprudencio)
 FECHA:	        20-09-2011 19:15:41
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_agencia_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_AGEN_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 19:15:41
	***********************************/

	if(p_transaccion='CB_AGEN_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						agen.id_agencia,
						agen.observaciones,
						agen.estado_reg,
						agen.nombre,
						agen.id_enti_fin,
						agen.codigo,
						agen.id_usuario_reg,
						agen.fecha_reg,
						agen.id_usuario_mod,
						agen.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_agencia agen
						inner join segu.tusuario usu1 on usu1.id_usuario = agen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = agen.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_AGEN_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 19:15:41
	***********************************/

	elsif(p_transaccion='CB_AGEN_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_agencia)
					    from cobra.tcb_agencia agen
					    inner join segu.tusuario usu1 on usu1.id_usuario = agen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = agen.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION cobra.f_tcb_agencia_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 323 (class 1255 OID 1570485)
-- Dependencies: 30 2435
-- Name: f_tcb_arqueo_det_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_arqueo_det_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_arqueo_det_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_arqueo_det'
 AUTOR: 		 (fprudencio)
 FECHA:	        29-09-2011 17:20:27
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_arqueo_det	integer;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_arqueo_det_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_ARQDET_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 17:20:27
	***********************************/

	if(p_transaccion='CB_ARQDET_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_arqueo_det(
			estado_reg,
			cantidad,
			id_corte,
			importe,
			id_arqueo,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.cantidad,
			v_parametros.id_corte,
			v_parametros.importe,
			v_parametros.id_arqueo,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_arqueo_det into v_id_arqueo_det;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Arqueo almacenado(a) con exito (id_arqueo_det'||v_id_arqueo_det||')'); 
            v_resp = f_agrega_clave(v_resp,'id_arqueo_det',v_id_arqueo_det::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_ARQDET_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 17:20:27
	***********************************/

	elsif(p_transaccion='CB_ARQDET_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_arqueo_det set
			cantidad = v_parametros.cantidad,
			id_corte = v_parametros.id_corte,
			importe = v_parametros.importe,
			id_arqueo = v_parametros.id_arqueo,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_arqueo_det=v_parametros.id_arqueo_det;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Arqueo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_arqueo_det',v_parametros.id_arqueo_det::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_ARQDET_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 17:20:27
	***********************************/

	elsif(p_transaccion='CB_ARQDET_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_arqueo_det
            where id_arqueo_det=v_parametros.id_arqueo_det;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Arqueo eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_arqueo_det',v_parametros.id_arqueo_det::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION cobra.f_tcb_arqueo_det_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 320 (class 1255 OID 1570484)
-- Dependencies: 30 2435
-- Name: f_tcb_arqueo_det_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_arqueo_det_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_arqueo_det_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_arqueo_det'
 AUTOR: 		 (fprudencio)
 FECHA:	        29-09-2011 17:20:27
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_arqueo_det_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_ARQDET_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 17:20:27
	***********************************/

	if(p_transaccion='CB_ARQDET_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						arqdet.id_arqueo_det,
						arqdet.estado_reg,
						arqdet.cantidad,
						arqdet.id_corte,
                        cormon.descri_corte,
						arqdet.importe,
						arqdet.id_arqueo,
						arqdet.id_usuario_reg,
						arqdet.fecha_reg,
						arqdet.id_usuario_mod,
						arqdet.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_arqueo_det arqdet
						inner join segu.tusuario usu1 on usu1.id_usuario = arqdet.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = arqdet.id_usuario_mod 
                        inner join tesoro.tts_corte_moneda cormon on cormon.id_corte=arqdet.id_corte
                        inner join cobra.tcb_arqueo arq on arq.id_arqueo=arqdet.id_arqueo
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_ARQDET_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 17:20:27
	***********************************/

	elsif(p_transaccion='CB_ARQDET_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_arqueo_det)
					    from cobra.tcb_arqueo_det arqdet
					    inner join segu.tusuario usu1 on usu1.id_usuario = arqdet.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = arqdet.id_usuario_mod
                        inner join tesoro.tts_corte_moneda cormon on cormon.id_corte=arqdet.id_corte
                        inner join cobra.tcb_arqueo arq on arq.id_arqueo=arqdet.id_arqueo
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION cobra.f_tcb_arqueo_det_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 786 (class 1255 OID 1545849)
-- Dependencies: 30 2435
-- Name: f_tcb_arqueo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_arqueo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_arqueo_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_arqueo'
 AUTOR: 		 (fprudencio)
 FECHA:	        27-09-2011 11:02:53
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_arqueo	integer;
  
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_arqueo_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_ARQ_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		27-09-2011 11:02:53
	***********************************/

	if(p_transaccion='CB_ARQ_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_arqueo(
			estado_reg,
			observaciones,
			estado,
			id_caja,
			fecha,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.observaciones,
			v_parametros.estado,
			v_parametros.id_caja,
			v_parametros.fecha,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_arqueo into v_id_arqueo;
             
             --Insertamos a la tabla arqueo_estado
             insert into cobra.tcb_arqueo_estado(
			id_arqueo,
			estado_arqueo,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_id_arqueo,
			v_parametros.estado,
			'activo',
			p_id_usuario,
			now(),
			null,
			null
			);  
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Arqueo almacenado(a) con exito (id_arqueo'||v_id_arqueo||')'); 
            v_resp = f_agrega_clave(v_resp,'id_arqueo',v_id_arqueo::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_ARQ_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		27-09-2011 11:02:53
	***********************************/

	elsif(p_transaccion='CB_ARQ_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_arqueo set
			observaciones = v_parametros.observaciones,
			estado = v_parametros.estado,
			id_caja = v_parametros.id_caja,
			fecha = v_parametros.fecha,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_arqueo=v_parametros.id_arqueo;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Arqueo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_arqueo',v_parametros.id_arqueo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_ARQ_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		27-09-2011 11:02:53
	***********************************/

	elsif(p_transaccion='CB_ARQ_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_arqueo
            where id_arqueo=v_parametros.id_arqueo;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Arqueo eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_arqueo',v_parametros.id_arqueo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
    /*********************************    
 	#TRANSACCION:  'CB_REV_ARQUEO'
 	#DESCRIPCION:	Cambio de estado del arqueo
 	#AUTOR:		fprudencio	
 	#FECHA:		27-09-2011 11:02:53
	***********************************/

	elsif(p_transaccion='CB_REV_ARQUEO')then

		begin
			
            
            update cobra.tcb_arqueo set
			estado = v_parametros.operacion,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_arqueo=v_parametros.id_arqueo;
             
            --Actualizacion de la tabla arqueo_estado
           
             update cobra.tcb_arqueo_estado set    
			        estado_reg='inactivo',
			        id_usuario_mod=p_id_usuario,
			        fecha_mod=now()
             where estado_reg='activo' AND id_arqueo=v_parametros.id_arqueo; 
            
             --Inserto nuievo registro en caja_cajero
              insert into cobra.tcb_arqueo_estado(
			id_arqueo,
			estado_arqueo,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_arqueo,
			v_parametros.operacion,
			'activo',
			p_id_usuario,
			now(),
			null,
			null
			);  
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Arqueo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_arqueo',v_parametros.id_arqueo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;     
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION cobra.f_tcb_arqueo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 315 (class 1255 OID 1545848)
-- Dependencies: 30 2435
-- Name: f_tcb_arqueo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_arqueo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_arqueo_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_arqueo'
 AUTOR: 		 (fprudencio)
 FECHA:	        27-09-2011 11:02:53
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_arqueo_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_ARQ_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		27-09-2011 11:02:53
	***********************************/

	if(p_transaccion='CB_ARQ_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						arq.id_arqueo,
						arq.estado_reg,
						arq.observaciones,
						arq.estado,
						arq.id_caja,
                        caja.codigo,
						arq.fecha,
						arq.id_usuario_reg,
						arq.fecha_reg,
						arq.id_usuario_mod,
						arq.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_arqueo arq
						inner join segu.tusuario usu1 on usu1.id_usuario = arq.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = arq.id_usuario_mod 
                        inner join cobra.tcb_caja caja on caja.id_caja=arq.id_caja
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_ARQ_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		27-09-2011 11:02:53
	***********************************/

	elsif(p_transaccion='CB_ARQ_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_arqueo)
					    from cobra.tcb_arqueo arq
					    inner join segu.tusuario usu1 on usu1.id_usuario = arq.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = arq.id_usuario_mod 
                        inner join cobra.tcb_caja caja on caja.id_caja=arq.id_caja
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION cobra.f_tcb_arqueo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 432 (class 1255 OID 1542630)
-- Dependencies: 2435 30
-- Name: f_tcb_caja_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_caja_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_caja_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_caja'
 AUTOR: 		 (fprudencio)
 FECHA:	        26-09-2011 18:19:13
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_caja	integer; 
    v_id_caja_estado	integer;
    v_estado_anterior	varchar;
    v_estado			varchar;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_caja_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_CAJA_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		26-09-2011 18:19:13
	***********************************/

	if(p_transaccion='CB_CAJA_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_caja(
			observaciones,
			estado_reg,
			id_agencia,
			estado_caja,
			codigo,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.observaciones,
			'activo',
			v_parametros.id_agencia,
			v_parametros.estado_caja,
			v_parametros.codigo,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_caja into v_id_caja;
            
            --Sentencia de inserción en la tabla tcb_caja_estado 
             insert into cobra.tcb_caja_estado(
			id_caja,
			estado_act,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod,
            estado_reg
          	) values(
			v_id_caja,
			'borrador',
			p_id_usuario,
			now(),
			null,
			null,
            'activo'
			);
              
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Cajas almacenado(a) con exito (id_caja'||v_id_caja||')'); 
            v_resp = f_agrega_clave(v_resp,'id_caja',v_id_caja::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_CAJA_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		26-09-2011 18:19:13
	***********************************/

	elsif(p_transaccion='CB_CAJA_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_caja set
			observaciones = v_parametros.observaciones,
			id_agencia = v_parametros.id_agencia,
			estado_caja = v_parametros.estado_caja,
			codigo = v_parametros.codigo,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_caja=v_parametros.id_caja;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Cajas modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_caja',v_parametros.id_caja::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_CAJA_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		26-09-2011 18:19:13
	***********************************/

	elsif(p_transaccion='CB_CAJA_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_caja
            where id_caja=v_parametros.id_caja;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Cajas eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_caja',v_parametros.id_caja::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
    
    /*********************************    
 	#TRANSACCION:  'CB_ABRIR_CAJA'
 	#DESCRIPCION:	Apertura y Cierre de Cajas
 	#AUTOR:		fprudencio	
 	#FECHA:		26-09-2011 18:19:13
	***********************************/

	elsif(p_transaccion='CB_ABRIR_CAJA')then

		begin
			--Sentencia de la modificacion 
           
              
              update cobra.tcb_caja SET
              estado_caja=v_parametros.operacion
              where id_caja=v_parametros.id_caja; 
              
                    			
            
            --Obtengo el id_caja_estado y el estado_actual
            SELECT MAX(id_caja_estado),estado_act INTO v_id_caja_estado,v_estado_anterior
            FROM cobra.tcb_caja_estado
            WHERE id_caja=v_parametros.id_caja AND estado_reg='activo'
            GROUP BY estado_act;
            
            --Actualizo el estado_reg de caja_estado
            UPDATE cobra.tcb_caja_estado SET
            estado_reg='inactivo',
            id_usuario_mod=p_id_usuario,
            fecha_mod=now()
            WHERE id_caja_estado=v_id_caja_estado;
            
            --Ingreso un nuevo campo  para tcb_caja_estado
               insert into cobra.tcb_caja_estado(
			   id_caja,
			   estado_act,
               estado_ant,
			   id_usuario_reg,
			   fecha_reg,
			   id_usuario_mod,
			   fecha_mod,
               estado_reg
          	   ) values(
			   v_parametros.id_caja,
			   v_parametros.operacion,
               v_estado_anterior,
			   p_id_usuario,
			   now(),
			   null,
			   null,
               'activo'
			    );
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Cajas modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_caja',v_parametros.id_caja::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;     
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION cobra.f_tcb_caja_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1131 (class 1255 OID 1542641)
-- Dependencies: 2435 30
-- Name: f_tcb_caja_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_caja_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_caja_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_caja'
 AUTOR: 		 (fprudencio)
 FECHA:	        26-09-2011 18:19:13
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_caja_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_CAJA_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		26-09-2011 18:19:13
	***********************************/

	if(p_transaccion='CB_CAJA_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						caja.id_caja,
						caja.observaciones,
						caja.estado_reg,
						caja.id_agencia,
                        instit.nombre as institucion,
						caja.estado_caja,
						caja.codigo,
						caja.id_usuario_reg,
						caja.fecha_reg,
						caja.id_usuario_mod,
						caja.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        agencia.codigo as cod_agencia,
                        agencia.nombre as nombre_agencia
						from cobra.tcb_caja caja
						inner join segu.tusuario usu1 on usu1.id_usuario = caja.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = caja.id_usuario_mod 
                        inner join cobra.tcb_agencia agencia on agencia.id_agencia = caja.id_agencia
                        inner join cobra.tcb_enti_fin entfin on entfin.id_enti_fin=agencia.id_enti_fin
                        inner join param.tinstitucion instit on instit.id_institucion=entfin.id_institucion
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_CAJA_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		26-09-2011 18:19:13
	***********************************/

	elsif(p_transaccion='CB_CAJA_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_caja)
					    from cobra.tcb_caja caja
					    inner join segu.tusuario usu1 on usu1.id_usuario = caja.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = caja.id_usuario_mod
                        inner join cobra.tcb_agencia agencia on agencia.id_agencia = caja.id_agencia
                        inner join cobra.tcb_enti_fin entfin on entfin.id_enti_fin=agencia.id_enti_fin
                        inner join param.tinstitucion instit on instit.id_institucion=entfin.id_institucion
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION cobra.f_tcb_caja_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 317 (class 1255 OID 1545847)
-- Dependencies: 2435 30
-- Name: f_tcb_cajero_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_cajero_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_cajero_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_cajero'
 AUTOR: 		 (fprudencio)
 FECHA:	        28-09-2011 14:13:20
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_cajero	integer;       
    v_estado_cajero		varchar;
	v_caja_cajero		varchar;		    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_cajero_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_CAJERO_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		28-09-2011 14:13:20
	***********************************/

	if(p_transaccion='CB_CAJERO_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_cajero(
			id_usuario,
			estado_reg,
			estado_cajero,
			id_caja,
			tipo_cajero,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_usuario,
			'activo',
			v_parametros.estado_cajero,
			v_parametros.id_caja,
			v_parametros.tipo_cajero,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_cajero into v_id_cajero;
             --Insertamos a la tabla caja_cajero
             insert into cobra.tcb_caja_cajero(
			id_cajero,
			estado_cajero,
			estado_reg,
			id_caja,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_id_cajero,
			'activo',
			'activo',
			v_parametros.id_caja,
			p_id_usuario,
			now(),
			null,
			null
			);
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','CAJERO almacenado(a) con exito (id_cajero'||v_id_cajero||')'); 
            v_resp = f_agrega_clave(v_resp,'id_cajero',v_id_cajero::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_CAJERO_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		28-09-2011 14:13:20
	***********************************/

	elsif(p_transaccion='CB_CAJERO_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_cajero set
			id_usuario = v_parametros.id_usuario,
			estado_cajero = v_parametros.estado_cajero,
			id_caja = v_parametros.id_caja,
			tipo_cajero = v_parametros.tipo_cajero,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_cajero=v_parametros.id_cajero;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','CAJERO modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_cajero',v_parametros.id_cajero::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_CAJERO_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		28-09-2011 14:13:20
	***********************************/

	elsif(p_transaccion='CB_CAJERO_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_cajero
            where id_cajero=v_parametros.id_cajero;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','CAJERO eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_cajero',v_parametros.id_cajero::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
    /*********************************    
 	#TRANSACCION:  'CB_HABILITAR_CAJERO'
 	#DESCRIPCION:	Habilita o Deshabilita Cajeros
 	#AUTOR:		fprudencio	
 	#FECHA:		28-09-2011 14:13:20
	***********************************/

	elsif(p_transaccion='CB_HABILITAR_CAJERO')then

		begin
            -- Obtengo el estado del cajero
            SELECT estado_cajero INTO v_estado_cajero
            FROM cobra.tcb_cajero 
            WHERE id_cajero=v_parametros.id_cajero;
            
            --Verifico si el estado es activo o inactivo
            if (v_estado_cajero='activo')then
                v_caja_cajero='inactivo';    
            else
                v_caja_cajero='activo';
            end if;  
            
            --actualizo la tabla cajero
			 update cobra.tcb_cajero set
			           estado_cajero = v_caja_cajero,
			           id_usuario_mod = p_id_usuario,
			           fecha_mod = now()
			     where id_cajero=v_parametros.id_cajero;
            
             --actualizo la tabla caja_cajero
             update cobra.tcb_caja_cajero set            
			      --  estado_cajero=v_caja_cajero,
			        estado_reg='inactivo',
			        id_usuario_mod=p_id_usuario,
			        fecha_mod=now()
             where id_cajero=v_parametros.id_cajero AND estado_reg='activo' AND id_caja=v_parametros.id_caja; 
            
             --Inserto nuievo registro en caja_cajero
              insert into cobra.tcb_caja_cajero(
			id_cajero,
			estado_cajero,
			estado_reg,
			id_caja,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_cajero,
			v_caja_cajero,
			'activo',
			v_parametros.id_caja,
			p_id_usuario,
			now(),
			null,
			null
			);
                     
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','CAJERO habilitado(a) o deshabilitado'); 
            v_resp = f_agrega_clave(v_resp,'id_cajero',v_parametros.id_cajero::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;     
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION cobra.f_tcb_cajero_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1132 (class 1255 OID 1545846)
-- Dependencies: 30 2435
-- Name: f_tcb_cajero_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_cajero_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_cajero_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_cajero'
 AUTOR: 		 (fprudencio)
 FECHA:	        28-09-2011 14:13:20
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_cajero_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_CAJERO_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		28-09-2011 14:13:20
	***********************************/

	if(p_transaccion='CB_CAJERO_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						cajero.id_cajero,
						cajero.id_usuario,
                        person.nombre_completo2,
						cajero.estado_reg,
						cajero.estado_cajero,
						cajero.id_caja,
						cajero.tipo_cajero,
						cajero.id_usuario_reg,
						cajero.fecha_reg,
						cajero.id_usuario_mod,
						cajero.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_cajero cajero
						inner join segu.tusuario usu1 on usu1.id_usuario = cajero.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = cajero.id_usuario_mod
                        inner join cobra.tcb_caja caja on caja.id_caja=cajero.id_caja
                        inner join segu.tusuario usuari on usuari.id_usuario=cajero.id_usuario
                        inner join segu.vpersona person on person.id_persona=usuari.id_persona
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_CAJERO_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		28-09-2011 14:13:20
	***********************************/

	elsif(p_transaccion='CB_CAJERO_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_cajero)
					    from cobra.tcb_cajero cajero
					    inner join segu.tusuario usu1 on usu1.id_usuario = cajero.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = cajero.id_usuario_mod
                        inner join cobra.tcb_caja caja on caja.id_caja=cajero.id_caja
                        inner join segu.tusuario usuari on usuari.id_usuario=cajero.id_usuario
                        inner join segu.vpersona person on person.id_persona=usuari.id_persona
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
    
    /*********************************    
 	#TRANSACCION:  'CB_CAJSIS_SEL'
 	#DESCRIPCION:	Listado de los Cajeros por Sistema de Distribución
 	#AUTOR:		rchumacero	
 	#FECHA:		12/12/2011
	***********************************/

	elsif(p_transaccion='CB_CAJSIS_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
                         cajero.id_cajero, cajero.id_caja, sisdis.codigo as cod_sist_dist,
                         sisdis.nombre as sist_dist, caja.codigo as cod_caja,
                         caja.estado_caja,  usuari.cuenta,
                         person.nombre_completo2 as cajero
                         from cobra.tcb_cajero cajero
                         inner join cobra.tcb_caja caja
                         on caja.id_caja = cajero.id_caja
                         inner join cobra.tcb_agencia agen
                         on agen.id_agencia = caja.id_agencia
                         inner join cobra.tcb_sistema_dist_agencia sisage
                         on sisage.id_agencia = agen.id_agencia
                         inner join cobra.tcb_sistema_dist sisdis
                         on sisdis.id_sistema_dist = sisage.id_sistema_dist
                         inner join segu.tusuario usuari
                         on usuari.id_usuario = cajero.id_usuario
                         inner join segu.vpersona person
                         on person.id_persona = usuari.id_persona
				         where ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;
        
    /*********************************    
 	#TRANSACCION:  'CB_CAJSIS_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rchumacero	
 	#FECHA:		12/12/2011
	***********************************/

	elsif(p_transaccion='CB_CAJSIS_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(cajero.id_cajero)
					     from cobra.tcb_cajero cajero
                         inner join cobra.tcb_caja caja
                         on caja.id_caja = cajero.id_caja
                         inner join cobra.tcb_agencia agen
                         on agen.id_agencia = caja.id_agencia
                         inner join cobra.tcb_sistema_dist_agencia sisage
                         on sisage.id_agencia = agen.id_agencia
                         inner join cobra.tcb_sistema_dist sisdis
                         on sisdis.id_sistema_dist = sisage.id_sistema_dist
                         inner join segu.tusuario usuari
                         on usuari.id_usuario = cajero.id_usuario
                         inner join segu.vpersona person
                         on person.id_persona = usuari.id_persona
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION cobra.f_tcb_cajero_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1202 (class 1255 OID 1515049)
-- Dependencies: 2435 30
-- Name: f_tcb_cliente_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_cliente_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_cliente_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_cliente'
 AUTOR: 		 (fprudencio)
 FECHA:	        22-09-2011 11:53:34
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_cliente	integer;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_cliente_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_CLIE_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		22-09-2011 11:53:34
	***********************************/

	if(p_transaccion='CB_CLIE_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_cliente(
			estado_reg,
			nro_cuenta,
			tipo_cliente,
			nro_nit,
			id_sistema_dist,
			id_cliente_dist,
			nombre,
			nro_cuenta_ant,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.nro_cuenta,
			v_parametros.tipo_cliente,
			v_parametros.nro_nit,
			v_parametros.id_sistema_dist,
			v_parametros.id_cliente_dist,
			v_parametros.nombre,
			v_parametros.nro_cuenta_ant,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_cliente into v_id_cliente;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Clientes almacenado(a) con exito (id_cliente'||v_id_cliente||')'); 
            v_resp = f_agrega_clave(v_resp,'id_cliente',v_id_cliente::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_CLIE_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		22-09-2011 11:53:34
	***********************************/

	elsif(p_transaccion='CB_CLIE_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_cliente set
			nro_cuenta = v_parametros.nro_cuenta,
			tipo_cliente = v_parametros.tipo_cliente,
			nro_nit = v_parametros.nro_nit,
			id_sistema_dist = v_parametros.id_sistema_dist,
			id_cliente_dist = v_parametros.id_cliente_dist,
			nombre = v_parametros.nombre,
			nro_cuenta_ant = v_parametros.nro_cuenta_ant,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_cliente=v_parametros.id_cliente;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Clientes modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_cliente',v_parametros.id_cliente::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_CLIE_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		22-09-2011 11:53:34
	***********************************/

	elsif(p_transaccion='CB_CLIE_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_cliente
            where id_cliente=v_parametros.id_cliente;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Clientes eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_cliente',v_parametros.id_cliente::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION cobra.f_tcb_cliente_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 310 (class 1255 OID 1515050)
-- Dependencies: 30 2435
-- Name: f_tcb_cliente_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_cliente_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_cliente_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_cliente'
 AUTOR: 		 (fprudencio)
 FECHA:	        22-09-2011 11:53:34
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_cliente_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_CLIE_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		22-09-2011 11:53:34
	***********************************/

	if(p_transaccion='CB_CLIE_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						clie.id_cliente,
						clie.estado_reg,
						clie.nro_cuenta,
						clie.tipo_cliente,
						clie.nro_nit,
						clie.id_sistema_dist,
						clie.id_cliente_dist,
						clie.nombre,
						clie.nro_cuenta_ant,
						clie.id_usuario_reg,
						clie.fecha_reg,
						clie.id_usuario_mod,
						clie.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_cliente clie
						inner join segu.tusuario usu1 on usu1.id_usuario = clie.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = clie.id_usuario_mod
                        inner join cobra.tcb_sistema_dist sisdis on sisdis.id_sistema_dist=clie.id_sistema_dist 
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_CLIE_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		22-09-2011 11:53:34
	***********************************/

	elsif(p_transaccion='CB_CLIE_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_cliente)
					    from cobra.tcb_cliente clie
					    inner join segu.tusuario usu1 on usu1.id_usuario = clie.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = clie.id_usuario_mod
                        inner join cobra.tcb_sistema_dist sisdis on sisdis.id_sistema_dist=clie.id_sistema_dist
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION cobra.f_tcb_cliente_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 316 (class 1255 OID 1546787)
-- Dependencies: 2435 30
-- Name: f_tcb_cobro_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_cobro_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_cobro_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_cobro'
 AUTOR: 		 (gvelasquez)
 FECHA:	        27-09-2011 14:59:03
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_cobro				integer;
    
    v_id_factura_cob		varchar[];
	v_i 					integer;
	v_tamano 				integer;
    v_gestion				numeric; 
    v_periodo				numeric; 
    v_fecha_pago  			date;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_cobro_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_COBRO_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		27-09-2011 14:59:03
	***********************************/

	if(p_transaccion='CB_COBRO_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_cobro(
			id_cajero,
			id_cliente,
			cant_facturas,
			importe_cobro,
			importe_recibido,
			importe_cambio,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_cajero,
			v_parametros.id_cliente,
			v_parametros.cant_facturas,
			v_parametros.importe_cobro,
			v_parametros.importe_recibido,
			v_parametros.importe_cambio,
			'activo',
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_cobro into v_id_cobro;
            
           --insertamos los roles del usuario
           v_id_factura_cob= string_to_array(v_parametros.id_factura_cob,',');
           v_tamano = coalesce(array_length(v_id_factura_cob, 1),0);             

            
            FOR v_i IN 1..v_tamano LOOP
         
        		--validamos que las facturas seleccionadas no esten pagadas
                IF EXISTS (Select id_factura_cob 
                			From cobra.tcb_factura_cob 
                            Where id_factura_cob = v_id_factura_cob[v_i]::integer and estado_fac='pagado') Then
                	
                    Select gestion, periodo, fecha_pago
                    into v_gestion, v_periodo, v_fecha_pago 
                    from cobra.tcb_factura_cob 
                    where id_factura_cob = v_id_factura_cob[v_i]::integer 
                    and estado_fac='pagado';
                    
                    raise exception 'La factura de la gestion: % y periodo: %; ya fue pagada en fecha: %.',v_gestion,v_periodo,v_fecha_pago;
                END IF;
                
        
        	  --modificamos el estado de las facturas seleccionadas
              	update cobra.tcb_factura_cob set
                id_cobro = v_id_cobro,
				estado_fac = 'pagado',
                fecha_pago = now(),
                fecha_mod = now(),
                id_usuario_mod = p_id_usuario
				where id_factura_cob = v_id_factura_cob[v_i]::integer;
             
            END LOOP;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Cobro almacenado(a) con exito (id_cobro'||v_id_cobro||')'); 
            v_resp = f_agrega_clave(v_resp,'id_cobro',v_id_cobro::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_COBRO_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		27-09-2011 14:59:03
	***********************************/

	elsif(p_transaccion='CB_COBRO_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_cobro set
			id_cajero = v_parametros.id_cajero,
			id_cliente = v_parametros.id_cliente,
			cant_facturas = v_parametros.cant_facturas,
			importe_cobro = v_parametros.importe_cobro,
			importe_recibido = v_parametros.importe_recibido,
			importe_cambio = v_parametros.importe_cambio,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_cobro=v_parametros.id_cobro;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Cobro modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_cobro',v_parametros.id_cobro::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
            
            
             --modificamos lor roles relacionados al usuario
             --partimos los datos de id_roles en un vector    
           
             v_id_factura_cob= string_to_array(v_parametros.id_factura_cob,',');
             v_tamano = coalesce(array_length(v_id_factura_cob, 1),0);         
             
             
             -- inactivamos todas las facturas que no estan seleccionadas
             
            /* update cobra.tcb_factura_cob 
             set estado_fac='inactivo'
             where 
             id_usuario = v_parametros.id_usuario
             and 
             (id_rol::varchar != ANY(v_id_roles) or v_tamano=0);
             
            --pagamos las que faltan
  
            
            FOR v_i IN 1..v_tamano LOOP
                         
            --preguntamos si el id_rol ya se encuentra asignado si no insertamos
            IF  (NOT EXISTS (select 1 from segu.tusuario_rol 
                        where id_usuario = v_parametros.id_usuario
                        and id_rol = v_id_roles[v_i]::integer 
                        and estado_reg='activo')) THEN
              	  --insertamos  registro si no esta presente como activo
                  insert into segu.tusuario_rol 
                     (id_usuario, 
                     id_rol, 
                     estado_reg) 
                  values(
                  v_parametros.id_usuario,
                  v_id_roles[v_i]::integer,
                  'activo'); 
              END IF;
            END LOOP;*/
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_COBRO_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		27-09-2011 14:59:03
	***********************************/

	elsif(p_transaccion='CB_COBRO_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_cobro
            where id_cobro=v_parametros.id_cobro;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Cobro eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_cobro',v_parametros.id_cobro::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION cobra.f_tcb_cobro_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 318 (class 1255 OID 1546788)
-- Dependencies: 30 2435
-- Name: f_tcb_cobro_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_cobro_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_cobro_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_cobro'
 AUTOR: 		 (gvelasquez)
 FECHA:	        27-09-2011 14:59:03
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_cobro_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_COBRO_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		gvelasquez	
 	#FECHA:		27-09-2011 14:59:03
	***********************************/

	if(p_transaccion='CB_COBRO_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						cobro.id_cobro,
						cobro.id_cajero,
						cobro.id_cliente,
						cobro.cant_facturas,
						cobro.importe_cobro,
						cobro.importe_recibido,
						cobro.importe_cambio,
						cobro.estado_reg,
						cobro.id_usuario_reg,
						cobro.fecha_reg,
						cobro.id_usuario_mod,
						cobro.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_cobro cobro
						inner join segu.tusuario usu1 on usu1.id_usuario = cobro.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = cobro.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_COBRO_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		27-09-2011 14:59:03
	***********************************/

	elsif(p_transaccion='CB_COBRO_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_cobro)
					    from cobra.tcb_cobro cobro
					    inner join segu.tusuario usu1 on usu1.id_usuario = cobro.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = cobro.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION cobra.f_tcb_cobro_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1134 (class 1255 OID 1507861)
-- Dependencies: 30 2435
-- Name: f_tcb_enti_fin_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_enti_fin_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_enti_fin_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_enti_fin'
 AUTOR: 		 (gvelasquez)
 FECHA:	        20-09-2011 16:58:53
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_enti_fin	integer;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_enti_fin_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_ENTFIN_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		20-09-2011 16:58:53
	***********************************/

	if(p_transaccion='CB_ENTFIN_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_enti_fin(
			estado_reg,
			id_institucion,
			nro_cuenta,
			--tipo_entidad,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.id_institucion,
			v_parametros.nro_cuenta,
			--v_parametros.tipo_entidad,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_enti_fin into v_id_enti_fin;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Entidad Financiera almacenado(a) con exito (id_enti_fin'||v_id_enti_fin||')'); 
            v_resp = f_agrega_clave(v_resp,'id_enti_fin',v_id_enti_fin::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_ENTFIN_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		20-09-2011 16:58:53
	***********************************/

	elsif(p_transaccion='CB_ENTFIN_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_enti_fin set
			id_institucion = v_parametros.id_institucion,
			nro_cuenta = v_parametros.nro_cuenta,
			--tipo_entidad = v_parametros.tipo_entidad,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_enti_fin=v_parametros.id_enti_fin;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Entidad Financiera modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_enti_fin',v_parametros.id_enti_fin::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_ENTFIN_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		20-09-2011 16:58:53
	***********************************/

	elsif(p_transaccion='CB_ENTFIN_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_enti_fin
            where id_enti_fin=v_parametros.id_enti_fin;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Entidad Financiera eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_enti_fin',v_parametros.id_enti_fin::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION cobra.f_tcb_enti_fin_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 308 (class 1255 OID 1507862)
-- Dependencies: 30 2435
-- Name: f_tcb_enti_fin_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_enti_fin_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_enti_fin_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_enti_fin'
 AUTOR: 		 (gvelasquez)
 FECHA:	        20-09-2011 16:58:53
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			cobra.f_tcb_enti_fin_sel(p_administrador integer, p_id_usuario integer, p_tabla varchar, p_transaccion varchar)
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_enti_fin_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_ENTFIN_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		gvelasquez	
 	#FECHA:		20-09-2011 16:58:53
	***********************************/

	if(p_transaccion='CB_ENTFIN_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						entfin.id_enti_fin,
						entfin.estado_reg,
						entfin.id_institucion,
                        instit.nombre as institucion,
						entfin.nro_cuenta,
						entfin.tipo_entidad,
						entfin.id_usuario_reg,
						entfin.fecha_reg,
						entfin.id_usuario_mod,
						entfin.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_enti_fin entfin
                        inner join param.tinstitucion instit on instit.id_institucion=entfin.id_institucion
						inner join segu.tusuario usu1 on usu1.id_usuario = entfin.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = entfin.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_ENTFIN_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		20-09-2011 16:58:53
	***********************************/

	elsif(p_transaccion='CB_ENTFIN_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_enti_fin)
					    from cobra.tcb_enti_fin entfin
                        inner join param.tinstitucion instit on instit.id_institucion=entfin.id_institucion
					    inner join segu.tusuario usu1 on usu1.id_usuario = entfin.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = entfin.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION cobra.f_tcb_enti_fin_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 311 (class 1255 OID 1535139)
-- Dependencies: 2435 30
-- Name: f_tcb_factura_cob_det_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_factura_cob_det_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_factura_cob_det_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_factura_cob_det'
 AUTOR: 		 (gvelasquez)
 FECHA:	        23-09-2011 16:47:28
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_factura_cob_det	integer;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_factura_cob_det_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_FACODE_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 16:47:28
	***********************************/

	if(p_transaccion='CB_FACODE_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_factura_cob_det(
			id_tasa,
			id_descuento,
			importe,
			estado_reg,
			id_factura_cob,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_tasa,
			v_parametros.id_descuento,
			v_parametros.importe,
			'activo',
			v_parametros.id_factura_cob,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_factura_cob_det into v_id_factura_cob_det;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Cobro almacenado(a) con exito (id_factura_cob_det'||v_id_factura_cob_det||')'); 
            v_resp = f_agrega_clave(v_resp,'id_factura_cob_det',v_id_factura_cob_det::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_FACODE_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 16:47:28
	***********************************/

	elsif(p_transaccion='CB_FACODE_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_factura_cob_det set
			id_tasa = v_parametros.id_tasa,
			id_descuento = v_parametros.id_descuento,
			importe = v_parametros.importe,
			id_factura_cob = v_parametros.id_factura_cob,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_factura_cob_det=v_parametros.id_factura_cob_det;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Cobro modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_factura_cob_det',v_parametros.id_factura_cob_det::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_FACODE_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 16:47:28
	***********************************/

	elsif(p_transaccion='CB_FACODE_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_factura_cob_det
            where id_factura_cob_det=v_parametros.id_factura_cob_det;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Cobro eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_factura_cob_det',v_parametros.id_factura_cob_det::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION cobra.f_tcb_factura_cob_det_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 312 (class 1255 OID 1535140)
-- Dependencies: 30 2435
-- Name: f_tcb_factura_cob_det_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_factura_cob_det_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_factura_cob_det_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_factura_cob_det'
 AUTOR: 		 (gvelasquez)
 FECHA:	        23-09-2011 16:47:28
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_factura_cob_det_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_FACODE_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 16:47:28
	***********************************/

	if(p_transaccion='CB_FACODE_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						facode.id_factura_cob_det,
						facode.id_tasa,
						facode.id_descuento,
						facode.importe,
						facode.estado_reg,
						facode.id_factura_cob,
						facode.id_usuario_reg,
						facode.fecha_reg,
						facode.id_usuario_mod,
						facode.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_factura_cob_det facode
						inner join segu.tusuario usu1 on usu1.id_usuario = facode.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = facode.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_FACODE_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 16:47:28
	***********************************/

	elsif(p_transaccion='CB_FACODE_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_factura_cob_det)
					    from cobra.tcb_factura_cob_det facode
					    inner join segu.tusuario usu1 on usu1.id_usuario = facode.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = facode.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION cobra.f_tcb_factura_cob_det_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 314 (class 1255 OID 1535141)
-- Dependencies: 30 2435
-- Name: f_tcb_factura_cob_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_factura_cob_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_factura_cob_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_factura_cob'
 AUTOR: 		 (gvelasquez)
 FECHA:	        23-09-2011 17:21:15
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_factura_cob	integer;  
    v_id_cobro			integer; 
    v_id_cajero			integer;
    v_id_caja           integer;  
    v_registros			record; 
    v_estado_ant		varchar;
    
    v_i 				integer;
    v_tamano 			integer;
    v_id_factura_cob_cadena	varchar[];
    v_estado_fac		varchar;
    v_id_factura_cob_antiguas	varchar[];
    v_rec				record;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_factura_cob_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_FACCOB_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/

	if(p_transaccion='CB_FACCOB_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_factura_cob(
			importe_cred_fis,
			estado_reg,
			tipo_lectura,
			reconex_val,
			credito_pagado,
			consumo_cambio,
			nombre_fac,
			potencia_val,
			nro_factura,
			consumo_libre,
			nro_orden,
			sw_deb_fis,
			consumo_total,
			cod_alfanum,
			cod_control,
			id_caja,
			fecha_act,
			conexion_val,
			fecha_ant,
			nit_fact,
			fecha_prox_med,
			estado_fac,
			lectura_kw,
			cod_ubica,
			nro_autorizacion,
			multi_kwh,
			gestion,
			id_cajero,
			id_cliente,
			periodo,
			consumo_val,
			fecha_pago,
			direccion,
			importe_dev,
			nro_medidor,
			lectura_act,
			importe_total,
			num_formulario,
			fecha_vence,
			fecha_factura,
			id_moneda,
			consumo_periodo,
			lectura_ant,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.importe_cred_fis,
			'activo',
			v_parametros.tipo_lectura,
			v_parametros.reconex_val,
			v_parametros.credito_pagado,
			v_parametros.consumo_cambio,
			v_parametros.nombre_fac,
			v_parametros.potencia_val,
			v_parametros.nro_factura,
			v_parametros.consumo_libre,
			v_parametros.nro_orden,
			v_parametros.sw_deb_fis,
			v_parametros.consumo_total,
			v_parametros.cod_alfanum,
			v_parametros.cod_control,
			v_parametros.id_caja,
			v_parametros.fecha_act,
			v_parametros.conexion_val,
			v_parametros.fecha_ant,
			v_parametros.nit_fact,
			v_parametros.fecha_prox_med,
			v_parametros.estado_fac,
			v_parametros.lectura_kw,
			v_parametros.cod_ubica,
			v_parametros.nro_autorizacion,
			v_parametros.multi_kwh,
			v_parametros.gestion,
			v_parametros.id_cajero,
			v_parametros.id_cliente,
			v_parametros.periodo,
			v_parametros.consumo_val,
			v_parametros.fecha_pago,
			v_parametros.direccion,
			v_parametros.importe_dev,
			v_parametros.nro_medidor,
			v_parametros.lectura_act,
			v_parametros.importe_total,
			v_parametros.num_formulario,
			v_parametros.fecha_vence,
			v_parametros.fecha_factura,
			v_parametros.id_moneda,
			v_parametros.consumo_periodo,
			v_parametros.lectura_ant,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_factura_cob into v_id_factura_cob;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Cobranza almacenado(a) con exito (id_factura_cob'||v_id_factura_cob||')'); 
            v_resp = f_agrega_clave(v_resp,'id_factura_cob',v_id_factura_cob::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_FACCOB_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/

	elsif(p_transaccion='CB_FACCOB_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_factura_cob set
			importe_cred_fis = v_parametros.importe_cred_fis,
			tipo_lectura = v_parametros.tipo_lectura,
			reconex_val = v_parametros.reconex_val,
			credito_pagado = v_parametros.credito_pagado,
			consumo_cambio = v_parametros.consumo_cambio,
			nombre_fac = v_parametros.nombre_fac,
			potencia_val = v_parametros.potencia_val,
			nro_factura = v_parametros.nro_factura,
			consumo_libre = v_parametros.consumo_libre,
			nro_orden = v_parametros.nro_orden,
			sw_deb_fis = v_parametros.sw_deb_fis,
			consumo_total = v_parametros.consumo_total,
			cod_alfanum = v_parametros.cod_alfanum,
			cod_control = v_parametros.cod_control,
			id_caja = v_parametros.id_caja,
			fecha_act = v_parametros.fecha_act,
			conexion_val = v_parametros.conexion_val,
			fecha_ant = v_parametros.fecha_ant,
			nit_fact = v_parametros.nit_fact,
			fecha_prox_med = v_parametros.fecha_prox_med,
			estado_fac = v_parametros.estado_fac,
			lectura_kw = v_parametros.lectura_kw,
			cod_ubica = v_parametros.cod_ubica,
			nro_autorizacion = v_parametros.nro_autorizacion,
			multi_kwh = v_parametros.multi_kwh,
			gestion = v_parametros.gestion,
			id_cajero = v_parametros.id_cajero,
			id_cliente = v_parametros.id_cliente,
			periodo = v_parametros.periodo,
			consumo_val = v_parametros.consumo_val,
			fecha_pago = v_parametros.fecha_pago,
			direccion = v_parametros.direccion,
			importe_dev = v_parametros.importe_dev,
			nro_medidor = v_parametros.nro_medidor,
			lectura_act = v_parametros.lectura_act,
			importe_total = v_parametros.importe_total,
			num_formulario = v_parametros.num_formulario,
			fecha_vence = v_parametros.fecha_vence,
			fecha_factura = v_parametros.fecha_factura,
			id_moneda = v_parametros.id_moneda,
			consumo_periodo = v_parametros.consumo_periodo,
			lectura_ant = v_parametros.lectura_ant,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_factura_cob=v_parametros.id_factura_cob;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Cobranza modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_factura_cob',v_parametros.id_factura_cob::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_FACCOB_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/

	elsif(p_transaccion='CB_FACCOB_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_factura_cob
            where id_factura_cob=v_parametros.id_factura_cob;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Cobranza eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_factura_cob',v_parametros.id_factura_cob::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
    /*********************************    
 	#TRANSACCION:  'CB_PAGA_FAC'
 	#DESCRIPCION:	Pago de facturas pendientes
 	#AUTOR:		fprudencio	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/

	elsif(p_transaccion='CB_PAGA_FAC')then

		begin
            --obtenemos la cantidad de facturas a pagar
            v_id_factura_cob_cadena= string_to_array(v_parametros.id_factura_cob,',');

            --Obtiene la cantidad de facturas a pagar
            v_tamano = coalesce(array_length(v_id_factura_cob_cadena, 1),0);
            
            --Se obtiene las n facturas más antiguas del cliente como un array
            select '{'|| list(id_factura_cob::text)||'}'
            into v_id_factura_cob_antiguas
            from
            (select id_factura_cob
            from cobra.tcb_factura_cob
            where id_cliente=v_parametros.id_cliente
            and estado_fac in ('no_pagado','refacturado')
            order by fecha_factura ASC
            limit v_tamano) fact;
            
            --Ordena los arrays en función de los valores para luego compararlos
            v_id_factura_cob_cadena=sort(v_id_factura_cob_cadena::integer[],'asc');
            v_id_factura_cob_antiguas=sort(v_id_factura_cob_antiguas::integer[],'asc');
            
            --Compara los dos arrays para verificar si está pagando las n facturas más antiguas
            if v_id_factura_cob_cadena != v_id_factura_cob_antiguas then
                raise exception 'No es posible proceder con el Cobro porque existen facturas antiguas sin pagar o porque alguna de las facturas no existe. Verifique que las facturas a pagar correspondan desde la más antigua a la nueva o que todas las facturas existan.';
            end if;

            --Obtenemos el id_cajero en base al usuario
            select id_cajero into v_id_cajero
            from cobra.tcb_cajero 
            where id_usuario=p_id_usuario and estado_cajero='activo'; 
            select id_caja into v_id_caja
            from cobra.tcb_caja_cajero
            where id_cajero=v_id_cajero and estado_reg='activo' and estado_cajero='activo';
            
            
            --inserción del cobro
            insert into cobra.tcb_cobro(
			id_cliente,
            id_cajero,
			cant_facturas,
			importe_cobro,
			importe_recibido,
			importe_cambio,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_cliente,
            v_id_cajero,
			v_parametros.facturas_pagadas,
			v_parametros.acumulado,
			v_parametros.importe_recibido,
			v_parametros.importe_cambio,
			'activo',
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_cobro into v_id_cobro;
            
            --Ciclo para obtener las facturas que se pagaran
       		FOR v_rec IN SELECT estado_fac, id_factura_cob
            			FROM cobra.tcb_factura_cob
                        WHERE id_factura_cob = any(v_id_factura_cob_cadena::integer[])
                        ORDER BY fecha_factura LOOP
            	--Actualizamos los valores de facturas cobradas
                 UPDATE cobra.tcb_factura_cob SET
                 estado_fac		= 'pagado',
            	 id_cajero		= v_id_cajero,
            	 id_caja		= v_id_caja,
            	 id_cobro		= v_id_cobro,
            	 fecha_pago		= now(),
            	 id_usuario_mod	= p_id_usuario,
            	 fecha_mod		= now(),
                 estado_fac_ant	= v_estado_fac
                 WHERE id_factura_cob = v_rec.id_factura_cob;
                 
                  --TODO: aumentar llamada dblink para actualizar el estado del cobro
                 
            END LOOP;
            
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Facturas Pagadas'); 
            v_resp = f_agrega_clave(v_resp,'id_factura_cob',v_parametros.id_factura_cob::varchar);
            v_resp = f_agrega_clave(v_resp,'cambio',v_parametros.importe_cambio::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
    /*********************************    
 	#TRANSACCION:  'CB_ANULA_FAC'
 	#DESCRIPCION:	Anula los pagos de las facturas
 	#AUTOR:		fprudencio	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/

	elsif(p_transaccion='CB_ANULA_FAC')then

		begin                                              
            --Obtengo el estado anterior
              SELECT estado_fac_ant INTO v_estado_ant
              FROM cobra.tcb_factura_cob 
              WHERE id_factura_cob=v_parametros.id_factura_cob;
              
			--Sentencia para actualizar o anular la factura
			 UPDATE cobra.tcb_factura_cob SET
                 estado_fac=v_estado_ant,
            	 id_cajero=NULL,
            	 id_caja=NULL,
            	 id_cobro=NULL,
            	 fecha_pago=NULL,
            	 id_usuario_mod=p_id_usuario,
            	 fecha_mod=now(),
                 estado_fac_ant='no_pagado'
             WHERE id_factura_cob=v_parametros.id_factura_cob;
             
            --Insertamos los valores para historial en factura_cob_anulado
                 insert into cobra.tcb_factura_cob_anulado(
                 id_factura_cob,
			     nro_formulario,
				 estado_reg,
				 id_usuario_reg,
				 fecha_reg,
				 id_usuario_mod,
				 fecha_mod,
                 estado_fac,
                 estado_fac_ant,
                 id_cobro
          		 ) values(
                 v_parametros.id_factura_cob,
				 --v_parametros.importe_total,
                 0,
				'activo',
				 p_id_usuario,
				 now(),
				 null,
				 null,
                 v_estado_ant,
                 'pagado',
                 v_parametros.id_cobro
				 );
                 --Control de las facturas pagadas por cobro
                    
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Factura Anulada'); 
            v_resp = f_agrega_clave(v_resp,'id_factura_cob',v_parametros.id_factura_cob::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION cobra.f_tcb_factura_cob_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1124 (class 1255 OID 1535143)
-- Dependencies: 30 2435
-- Name: f_tcb_factura_cob_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_factura_cob_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_factura_cob_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_factura_cob'
 AUTOR: 		 (gvelasquez)
 FECHA:	        23-09-2011 17:21:15
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_factura_cob_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_FACCOB_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/
    
    --raise exception '%',p_transaccion;

	if(p_transaccion='CB_FACCOB_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						faccob.id_factura_cob,
						faccob.importe_cred_fis,
						faccob.estado_reg,
						faccob.tipo_lectura,
						faccob.reconex_val,
						faccob.credito_pagado,
						faccob.consumo_cambio,
						faccob.nombre_fac,
						faccob.potencia_val,
						faccob.nro_factura,
						faccob.consumo_libre,
						faccob.nro_orden,
						faccob.sw_deb_fis,
						faccob.consumo_total,
						faccob.cod_alfanum,
						faccob.cod_control,
						faccob.id_caja,
						faccob.fecha_act,
						faccob.conexion_val,
						faccob.fecha_ant,
						faccob.nit_fact,
						faccob.fecha_prox_med,
						faccob.estado_fac,
						faccob.lectura_kw,
						faccob.cod_ubica,
						faccob.nro_autorizacion,
						faccob.multi_kwh,
						faccob.gestion,
						faccob.id_cajero,
						faccob.id_cliente,
						faccob.periodo,
						faccob.consumo_val,
						faccob.fecha_pago,
						faccob.direccion,
						faccob.importe_dev,
						faccob.nro_medidor,
						faccob.lectura_act,
						faccob.importe_total,
                        (select sum(f.importe_total) from cobra.tcb_factura_cob f where f.id_factura_cob <= faccob.id_factura_cob AND f.id_cliente=faccob.id_cliente AND f.estado_fac in (''no_pagado'',''refacturado'')) as acumulado,
                        (select count(f.id_factura_cob) from cobra.tcb_factura_cob f where f.periodo        <= faccob.periodo AND f.gestion = faccob.gestion AND f.id_cliente=faccob.id_cliente )as facturas_pagadas,
						faccob.num_formulario,
						faccob.fecha_vence,
						faccob.fecha_factura,
						faccob.id_moneda,
						faccob.consumo_periodo,
						faccob.lectura_ant,
						faccob.id_usuario_reg,
						faccob.fecha_reg,
						faccob.id_usuario_mod,
						faccob.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        
                        ((((((((faccob.gestion  || '' - '' ::text) || faccob.periodo ::text ) || '' - ''::text)||faccob.nombre_fac::text)||'' - ''::text)||faccob.importe_total::text)||'' - ''::text) ||faccob.nro_factura::text) as desc_factura
                        
						from cobra.tcb_factura_cob faccob
						inner join segu.tusuario usu1 on usu1.id_usuario = faccob.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = faccob.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_FACCOB_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/

	elsif(p_transaccion='CB_FACCOB_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_factura_cob)
					    from cobra.tcb_factura_cob faccob
					    inner join segu.tusuario usu1 on usu1.id_usuario = faccob.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = faccob.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
        
    /*********************************    
 	#TRANSACCION:  'CB_FACPEN_SEL'
 	#DESCRIPCION:	Listado de la facturación pendiente en un periodo de tiempo por Sistema de Distribución
 	#AUTOR:		rchumacero
 	#FECHA:		23-09-2011 17:21:15
	***********************************/
    elsif(p_transaccion='CB_FACPEN_SEL')then
     				
    	begin
        
    		--Sentencia de la consulta
			v_consulta:='select
                          cli.nombre, cli.nro_cuenta, facob.cod_alfanum, facob.cod_control,
                          facob.fecha_factura, facob.fecha_vence,facob.importe_total
                          from cobra.tcb_factura_cob facob
                          inner join cobra.tcb_cliente cli on cli.id_cliente = facob.id_cliente
				        where';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta|| ' cli.id_sistema_dist = ' || v_parametros.id_sistema_dist;
--            v_consulta:=v_consulta|| ' and and facob.estado_fac = ''' || v_parametros.estado_fac || '''';
            v_consulta:=v_consulta|| ' and facob.fecha_factura between ''' || v_parametros.fecha_ini || '''and ''' ||v_parametros.fecha_fin || '''';
			v_consulta:=v_consulta|| ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;
	
	/*********************************    
 	#TRANSACCION:  'CB_FACPEN_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rchumacero	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/
	elsif(p_transaccion='CB_FACPEN_CONT')then
     				
    	begin
        
    		--Sentencia de la consulta
			v_consulta:='select count(cli.nombre)
                          from cobra.tcb_factura_cob facob
                          inner join cobra.tcb_cliente cli on cli.id_cliente = facob.id_cliente
				        where';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta|| ' cli.id_sistema_dist = ' || v_parametros.id_sistema_dist;
--            v_consulta:=v_consulta|| ' and and facob.estado_fac = ''' || v_parametros.estado_fac || '''';
            v_consulta:=v_consulta|| ' and facob.fecha_factura between ''' || v_parametros.fecha_ini || '''and ''' ||v_parametros.fecha_fin || '''';

			--Devuelve la respuesta
			return v_consulta;
						
		end;
	
	/*********************************    
 	#TRANSACCION:  'CB_FACANU_SEL'
 	#DESCRIPCION:	Listado de la facturación anulada por cajero en un periodo de tiempo
 	#AUTOR:		rchumacero
 	#FECHA:		23-09-2011 17:21:15
	***********************************/
	elsif(p_transaccion='CB_FACANU_SEL')then
     				
    	begin
        
    		--Sentencia de la consulta
			v_consulta:='select fc.id_cajero, cl.nro_cuenta, cl.nombre, fa.nro_formulario,
            			fa.motivo, p.nombre_completo2 as cajero, fc.importe_total
                        from cobra.tcb_factura_cob fc
                        inner join cobra.tcb_factura_cob_anulado fa on fc.id_factura_cob=fa.id_factura_cob
                        inner join cobra.tcb_caja c on fc.id_caja=c.id_caja
                        inner join cobra.tcb_cajero cj on fc.id_cajero=cj.id_cajero
                        inner join cobra.tcb_cliente cl on cl.id_cliente=fc.id_cliente
                        inner join segu.tusuario u on u.id_usuario=fa.id_usuario
                        inner join segu.vpersona p on u.id_persona=p.id_persona
                        where fa.id_cajero = ' || v_parametros.id_cajero || '
                        and fa.fecha_reg between ''' || v_parametros.fecha_ini || ''' and ''' || v_parametros.fecha_fin  || '''';
			
			--Definicion de la respuesta
            raise notice '%',v_consulta;
			return v_consulta;
						
		end;
        
    
    /*********************************    
 	#TRANSACCION:  'CB_FACANU_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rchumacero	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/    
	elsif(p_transaccion='CB_FACANU_CONT')then
     				
    	begin
        
    		--Sentencia de la consulta
			v_consulta:='select count(fa.id_factura_cob_anulado)
                        from cobra.tcb_factura_cob fc
                        inner join cobra.tcb_factura_cob_anulado fa on fc.id_factura_cob=fa.id_factura_cob
                        inner join cobra.tcb_caja c on fc.id_caja=c.id_caja
                        inner join cobra.tcb_cajero cj on fc.id_cajero=cj.id_cajero
                        inner join cobra.tcb_cliente cl on cl.id_cliente=fc.id_cliente
                        inner join segu.tusuario u on u.id_usuario=fa.id_usuario
                        inner join segu.vpersona p on u.id_persona=p.id_persona
                        where fa.id_cajero = ' || v_parametros.id_cajero || '
                        and fa.fecha_reg between ''' || v_parametros.fecha_ini || ''' and ''' || v_parametros.fecha_fin  || '''';
			
			--Definicion de la respuesta
			return v_consulta;
						
		end;
        
        
    /*********************************    
 	#TRANSACCION:  'CB_INGPORCAJ_SEL'
 	#DESCRIPCION:	Listado de los ingresos por cajero en un periodo de tiempo
 	#AUTOR:		Grover Velasquez Colque
 	#FECHA:		23-09-2011 17:21:15
	***********************************/
	elsif(p_transaccion='CB_INGPORCAJ_SEL')then
     				
    	begin
        
    		--Sentencia de la consulta
			v_consulta:='select fc.id_cajero, 
            			p.nombre_completo2 as cajero, 
                        count (fc.id_factura_cob) as cantidad_facturas,
                        sum(fc.importe_total)
                        
                        from cobra.tcb_factura_cob fc
                        inner join cobra.tcb_caja c on fc.id_caja=c.id_caja
                        inner join cobra.tcb_cajero cj on fc.id_cajero=cj.id_cajero
                        inner join segu.tusuario u on u.id_usuario=cj.id_usuario
                        inner join segu.vpersona p on u.id_persona=p.id_persona
                        
                        where c.id_agencia = ' || v_parametros.id_agencia || '
                        and fc.fecha_pago between ''' || v_parametros.fecha_ini || ''' and ''' || v_parametros.fecha_fin  || '''
                        group by fc.id_cajero, 
                        p.nombre_completo2 ';
			raise notice '%',v_consulta;
			--Definicion de la respuesta
			return v_consulta;
						
		end;
        
    
    /*********************************    
 	#TRANSACCION:  'CB_INGPORCAJ_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		GroverVelasquez Colque	
 	#FECHA:		27-12-2011 17:21:15
	***********************************/    
	elsif(p_transaccion='CB_INGPORCAJ_CONT')then
     				
    	begin
        
    		--Sentencia de la consulta
			v_consulta:='select count(fc.id_factura_cob)
            
                        from cobra.tcb_factura_cob fc
                        inner join cobra.tcb_caja c on fc.id_caja=c.id_caja
                        inner join cobra.tcb_cajero cj on fc.id_cajero=cj.id_cajero
                        inner join segu.tusuario u on u.id_usuario=cj.id_usuario
                        inner join segu.vpersona p on u.id_persona=p.id_persona
                        
                        where c.id_agencia = ' || v_parametros.id_agencia || '
                        and fc.fecha_pago between ''' || v_parametros.fecha_ini || ''' and ''' || v_parametros.fecha_fin  || '''
                       ';
			
			--Definicion de la respuesta
			return v_consulta;
						
		end;	

	 /*********************************    
 	#TRANSACCION:  'CB_RESFAC_SEL'
 	#DESCRIPCION:	Listado del resumen de facturacion
 	#AUTOR:		José Mita Huanca
 	#FECHA:		30-01-2012 17:21:15
	***********************************/
	elsif(p_transaccion='CB_RESFAC_SEL')then
     				
    	begin
        
    		--Sentencia de la consulta
			v_consulta:='select  count(fc.id_cliente) as cant_clientes, sum(fc.consumo_total) as energia,
 sum (fc.conexion_val + fc.reconex_val) as importe_reconex, sum(fc.credito_pagado + fc.importe_dev ) as devol,sum(fc.consumo_val) as importe_suministro,
 sum(fcd.importe) as descuento_1, sum(fcd1.importe) as descuento_2, sum(fcd2.importe) as tasa_1, sum(fcd3.importe) as tasa_2, sum(fcd4.importe) as descuento_3, sum(fc.importe_total) as importe_total
 from cobra.tcb_factura_cob fc 
 inner join cobra.tcb_cliente c on fc.id_cliente=c.id_cliente 
 inner join cobra.tcb_sistema_dist sd on sd.id_sistema_dist=c.id_sistema_dist
 left join cobra.tcb_factura_cob_det fcd on fc.id_factura_cob=fcd.id_factura_cob and fcd.id_descuento=1
 left join cobra.tcb_factura_cob_det fcd1 on fc.id_factura_cob=fcd1.id_factura_cob and fcd1.id_descuento=2
 left join cobra.tcb_factura_cob_det fcd2 on fc.id_factura_cob=fcd2.id_factura_cob and fcd2.id_tasa=1
 left join cobra.tcb_factura_cob_det fcd3 on fc.id_factura_cob=fcd3.id_factura_cob and fcd3.id_tasa=2
 left join cobra.tcb_factura_cob_det fcd4 on fc.id_factura_cob=fcd4.id_factura_cob and fcd4.id_descuento=3
 where c.id_sistema_dist= ' || v_parametros.id_sistema_dist || ' and by fc.periodo= ' || v_parametros.periodo || ' and fc.gestion= ' || v_parametros.gestion || '
 group by fc.periodo, fc.gestion, sd.nombre ';
			raise notice '%',v_consulta;
			--Definicion de la respuesta
			return v_consulta;
						
		end;
        
    
    /*********************************    
 	#TRANSACCION:  'CB_RESFAC_CONT'
 	#DESCRIPCION:	cantidad del resumen de facturacion
 	#AUTOR:		José Mita Huanca
 	#FECHA:		30-01-2012 17:21:15
	***********************************/    
	elsif(p_transaccion='CB_RESFAC_CONT')then
     				
    	begin
        
    		--Sentencia de la consulta
			v_consulta:='select 1';
			
			--Definicion de la respuesta
			return v_consulta;
						
		end;			
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION cobra.f_tcb_factura_cob_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1128 (class 1255 OID 3196570)
-- Dependencies: 2435 30
-- Name: f_tcb_factura_rep_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: rchumacero
--

CREATE FUNCTION f_tcb_factura_rep_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_factura_rep_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas para la impresión de la factura
 AUTOR: 		 (rcm)
 FECHA:	        14-03-2012
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_reg				record;
    v_limite			integer;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_factura_rep_sel';
    v_parametros = f_get_record(p_tabla);
    v_limite = 3;

	/*********************************    
 	#TRANSACCION:  'CB_FADAGE_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			rcm	
 	#FECHA:			14-03-2012
	***********************************/

	if(p_transaccion='CB_FADAGE_SEL')then --FActura DAtos GEnerales
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select 
                        --datos cliente
                        fac.nro_factura, fac.nro_autorizacion,fac.fecha_factura as fecha_emision,
                        cli.nombre as cliente, cli.nro_nit as nit_cliente, fac.nro_medidor, cli.nro_cuenta,
                        fac.direccion, fac.desc_categoria as categoria, fac.cod_ubica,
                        fac.periodo as periodo_consumo, fac.fecha_act - fac.fecha_ant as dias,
                        fac.lectura_ant, fac.lectura_act, fac.consumo_total, fac.tipo_lectura, fac.multi_kwh,
                        fac.lectura_kw as potencia, fac.fecha_prox_med, fac.fecha_vence,
                        --importes consumo
                        fac.consumo_val as importe_energia,
                        fac.potencia_val as importe_portencia,
                        fac.conexion_val + fac.reconex_val as importe_conex_reconex,
                        fac.importe_dev-fac.credito_pagado as cred_deb_dev
                        from cobra.tcb_factura_cob fac
                        inner join cobra.tcb_cliente cli on cli.id_cliente = fac.id_cliente
                        where fac.id_factura_cob = ' || v_parametros.id_factura_cob;
			
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_FADADE_SEL'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:			rcm
 	#FECHA:			14-03-2012
	***********************************/

	elsif(p_transaccion='CB_FADADE_SEL')then --FActura DAtos DEtalle

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select
                        case coalesce(facdet.id_descuento,0)
                            when 0 then tas.desc_tasa
                            else des.desc_descuento
                        end as concepto,
                        facdet.importe
                        from cobra.tcb_factura_cob fac
                        inner join cobra.tcb_factura_cob_det facdet
                        on facdet.id_factura_cob = fac.id_factura_cob
                        left join factur.tfv_descuento des on des.id_descuento = facdet.id_descuento
                        left join factur.tfv_tasa tas on tas.id_tasa = facdet.id_tasa
                        where fac.id_factura_cob = ' || v_parametros.id_factura_cob;

			--Devuelve la respuesta
			return v_consulta;

		end;
        
	/*********************************    
 	#TRANSACCION:  'CB_FAHICO_SEL'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:			rcm
 	#FECHA:			14-03-2012
	***********************************/

	elsif(p_transaccion='CB_FAHICO_SEL')then --FActura HIstorico COnsumo

		begin
        	--Se obtiene el id_cliente y la fecha de la factura actual
            select id_cliente, fecha_factura
            into v_reg
            from cobra.tcb_factura_cob fac
            where fac.id_factura_cob = v_parametros.id_factura_cob;
            
            if v_reg.id_cliente is null or v_reg.fecha_factura is null then
            	raise exception 'No se puede encontrar el detalle del Consumo Histórico del cliente.';
            end if;
            
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select
                        periodo, consumo_total
                        from (
                        select
                        f_llenar_ceros(fac.periodo,2) || ''/'' || fac.gestion as periodo,fac.consumo_total,
                        fac.fecha_factura
                        from cobra.tcb_factura_cob fac
                        where fac.id_cliente = '||v_rec.id_cliente||'
                        and fac.fecha_factura <= '||v_rec.fecha_factura||'
                        order by fac.fecha_factura desc
                        limit '||v_limite||') res
                        order by fecha_factura';

			--Devuelve la respuesta
			return v_consulta;

		end;        
        		
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION cobra.f_tcb_factura_rep_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1069 (class 1255 OID 1799071)
-- Dependencies: 30 2435
-- Name: f_tcb_importar_factur_resum_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: jmita
--

CREATE FUNCTION f_tcb_importar_factur_resum_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_importar_factur_resum_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_sistema_dist_usuario'
 AUTOR: 		 (jmita)
 FECHA:	        19-10-2011 10:41:58
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_importar_factur_resum_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_IMPRES_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		jmita	
 	#FECHA:		19-10-2011 10:41:58
	***********************************/

	if(p_transaccion='CB_IMPRES_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select fc.periodo,
            					fc.gestion,
                                count(fc.id_cliente) as cant_clientes,
                                sum(fc.importe_total) as importe_total
                         from cobra.tcb_factura_cob fc 
                         inner join cobra.tcb_cliente c on fc.id_cliente=c.id_cliente 
                         where c.id_sistema_dist=4 
                         group by fc.periodo, fc.gestion
                         order by fc.periodo, fc.gestion asc  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
            
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            raise notice '%',v_consulta;
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_IMPRES_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		jmita	
 	#FECHA:		19-10-2011 10:41:58
	***********************************/

	elsif(p_transaccion='CB_IMPRES_CONT')then


		begin
        
         EXECUTE('CREATE TEMP TABLE tt_facturacion_periodo("id_cliente" integer,                                                                      
                                                                 "nro_cuenta" VARCHAR,
                                                                 "nro_cuenta_ant" VARCHAR,
                                                                 "nombre" VARCHAR,
                                                                 "nro_nit" NUMERIC,
                                                                 "tipo_cliente" VARCHAR
                                                                      )  ON COMMIT DROP;');
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_sistema_dist_usuario)
					    from cobra.tcb_sistema_dist_usuario ushab
						inner join segu.tusuario usu1 on usu1.id_usuario = ushab.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ushab.id_usuario_mod
                        inner join segu.tusuario usu3 on usu3.id_usuario=ushab.id_usuario
                        inner join cobra.tcb_sistema_dist sisdis on sisdis.id_sistema_dist=ushab.id_sistema_dist 
                        INNER JOIN segu.vpersona PERSON on PERSON.id_persona = usu3.id_persona
				        where  ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION cobra.f_tcb_importar_factur_resum_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO jmita;

--
-- TOC entry 250 (class 1255 OID 49491)
-- Dependencies: 30 2435
-- Name: f_tcb_prueba_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_prueba_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_prueba_ime
 DESCRIPCION:   Función que gestiona las operaciones básicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_prueba'
 AUTOR: 		 (admin)
 FECHA:	        17-08-2011 17:53:45
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_prueba	integer;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_prueba_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_PRUEBA_INS'
 	#DESCRIPCION:	Inserción de registros
 	#AUTOR:		admin	
 	#FECHA:		17-08-2011 17:53:45
	***********************************/

	if(p_transaccion='CB_PRUEBA_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_prueba(
			empleado,
			estado,
			estado_reg,
			fecha,
			nombre,
			sueldo,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			v_parametros.empleado,
			v_parametros.estado,
			v_parametros.estado_reg,
			v_parametros.fecha,
			v_parametros.nombre,
			v_parametros.sueldo,
			now(),
			p_id_usuario,
			null,
			null
			)RETURNING id_prueba into v_id_prueba;
               
			--Definición de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Prueba almacenado(a) con exito (id_prueba'||v_id_prueba||')'); 
            v_resp = f_agrega_clave(v_resp,'id_prueba',v_id_prueba::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_PRUEBA_MOD'
 	#DESCRIPCION:	Modificación de registros
 	#AUTOR:		admin	
 	#FECHA:		17-08-2011 17:53:45
	***********************************/

	elsif(p_transaccion='CB_PRUEBA_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_prueba set
			empleado = v_parametros.empleado,
			estado = v_parametros.estado,
			estado_reg = v_parametros.estado_reg,
			fecha = v_parametros.fecha,
			nombre = v_parametros.nombre,
			sueldo = v_parametros.sueldo,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_prueba=v_parametros.id_prueba;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Prueba modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_prueba',v_parametros.id_prueba::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_PRUEBA_ELI'
 	#DESCRIPCION:	Eliminación de registros
 	#AUTOR:		admin	
 	#FECHA:		17-08-2011 17:53:45
	***********************************/

	elsif(p_transaccion='CB_PRUEBA_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_prueba
            where id_prueba=v_parametros.id_prueba;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Prueba eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_prueba',v_parametros.id_prueba::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION cobra.f_tcb_prueba_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 253 (class 1255 OID 49492)
-- Dependencies: 30 2435
-- Name: f_tcb_prueba_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_prueba_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_prueba_sel
 DESCRIPCION:   Función que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_prueba'
 AUTOR: 		 (admin)
 FECHA:	        17-08-2011 17:53:45
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_prueba_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_PRUEBA_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		admin	
 	#FECHA:		17-08-2011 17:53:45
	***********************************/

	if(p_transaccion='CB_PRUEBA_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						prueba.id_prueba,
						prueba.empleado,
						prueba.estado,
						prueba.estado_reg,
						prueba.fecha,
						prueba.nombre,
						prueba.sueldo,
						prueba.fecha_reg,
						prueba.id_usuario_reg,
						prueba.fecha_mod,
						prueba.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_prueba prueba
						inner join segu.tusuario usu1 on usu1.id_usuario = prueba.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = prueba.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_PRUEBA_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		admin	
 	#FECHA:		17-08-2011 17:53:45
	***********************************/

	elsif(p_transaccion='CB_PRUEBA_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_prueba)
					    from cobra.tcb_prueba prueba
					    inner join segu.tusuario usu1 on usu1.id_usuario = prueba.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = prueba.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION cobra.f_tcb_prueba_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 304 (class 1255 OID 1506146)
-- Dependencies: 30 2435
-- Name: f_tcb_sistema_dist_agencia_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_sistema_dist_agencia_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_sistema_dist_agencia_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_sistema_dist_agencia'
 AUTOR: 		 (fprudencio)
 FECHA:	        20-09-2011 16:24:24
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_sistema_dist_agencia	integer;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_sistema_dist_agencia_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_ENTI_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 16:24:24
	***********************************/

	if(p_transaccion='CB_ENTI_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_sistema_dist_agencia(
			estado_reg,
			id_sistema_dist,
			id_agencia,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.id_sistema_dist,
			v_parametros.id_agencia,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_sistema_dist_agencia into v_id_sistema_dist_agencia;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Entidades o Agencias Habilitadas almacenado(a) con exito (id_sistema_dist_agencia'||v_id_sistema_dist_agencia||')'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist_agencia',v_id_sistema_dist_agencia::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_ENTI_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 16:24:24
	***********************************/

	elsif(p_transaccion='CB_ENTI_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_sistema_dist_agencia set
			id_sistema_dist = v_parametros.id_sistema_dist,
			id_agencia = v_parametros.id_agencia,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_sistema_dist_agencia=v_parametros.id_sistema_dist_agencia;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Entidades o Agencias Habilitadas modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist_agencia',v_parametros.id_sistema_dist_agencia::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_ENTI_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 16:24:24
	***********************************/

	elsif(p_transaccion='CB_ENTI_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_sistema_dist_agencia
            where id_sistema_dist_agencia=v_parametros.id_sistema_dist_agencia;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Entidades o Agencias Habilitadas eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist_agencia',v_parametros.id_sistema_dist_agencia::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION cobra.f_tcb_sistema_dist_agencia_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 307 (class 1255 OID 1506147)
-- Dependencies: 30 2435
-- Name: f_tcb_sistema_dist_agencia_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_sistema_dist_agencia_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_sistema_dist_agencia_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_sistema_dist_agencia'
 AUTOR: 		 (fprudencio)
 FECHA:	        20-09-2011 16:24:24
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_sistema_dist_agencia_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_ENTI_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 16:24:24
	***********************************/

	if(p_transaccion='CB_ENTI_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						enti.id_sistema_dist_agencia,
						enti.estado_reg,
						enti.id_sistema_dist, 
                        sisdis.nombre as nombre_sistema,
						enti.id_agencia,               
                        agen.nombre as nombre_agencia,
						enti.id_usuario_reg,
						enti.fecha_reg,
						enti.id_usuario_mod,
						enti.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_sistema_dist_agencia enti
						inner join segu.tusuario usu1 on usu1.id_usuario = enti.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = enti.id_usuario_mod
                        inner join cobra.tcb_sistema_dist sisdis on sisdis.id_sistema_dist=enti.id_sistema_dist
                        inner join cobra.tcb_agencia agen on agen.id_agencia=enti.id_agencia
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_ENTI_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 16:24:24
	***********************************/

	elsif(p_transaccion='CB_ENTI_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_sistema_dist_agencia)
					    from cobra.tcb_sistema_dist_agencia enti
						inner join segu.tusuario usu1 on usu1.id_usuario = enti.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = enti.id_usuario_mod
                        inner join cobra.tcb_sistema_dist sisdis on sisdis.id_sistema_dist=enti.id_sistema_dist
                        inner join cobra.tcb_agencia agen on agen.id_agencia=enti.id_agencia
				        where  ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION cobra.f_tcb_sistema_dist_agencia_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 303 (class 1255 OID 1360885)
-- Dependencies: 2435 30
-- Name: f_tcb_sistema_dist_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_sistema_dist_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_sistema_dist_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_sistema_dist'
 AUTOR: 		 (fprudencio)
 FECHA:	        20-09-2011 10:22:05
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_sistema_dist	integer;
    v_registros			record; 
    v_ss		text;
    v_periodo			numeric;
    v_gestion			numeric;
    v_pru				integer;
    v_consulta varchar;
    v_codigo_sis		varchar;
    v_id_cliente_cob	integer;
    v_id_fac_cob		bigint;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_sistema_dist_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_SISDIS_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 10:22:05
	***********************************/

	if(p_transaccion='CB_SISDIS_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_sistema_dist(
			codigo,
			conexion,
			nombre,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.codigo,
			v_parametros.conexion,
			v_parametros.nombre,
			'activo',
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_sistema_dist into v_id_sistema_dist;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Sistemas de DistribuciÃ³n almacenado(a) con exito (id_sistema_dist'||v_id_sistema_dist||')'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist',v_id_sistema_dist::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_SISDIS_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 10:22:05
	***********************************/

	elsif(p_transaccion='CB_SISDIS_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_sistema_dist set
			codigo = v_parametros.codigo,
			conexion = v_parametros.conexion,
			nombre = v_parametros.nombre,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_sistema_dist=v_parametros.id_sistema_dist;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Sistemas de DistribuciÃ³n modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist',v_parametros.id_sistema_dist::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_SISDIS_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 10:22:05
	***********************************/

	elsif(p_transaccion='CB_SISDIS_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_sistema_dist
            where id_sistema_dist=v_parametros.id_sistema_dist;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Sistemas de DistribuciÃ³n eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist',v_parametros.id_sistema_dist::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
     /*********************************    
 	#TRANSACCION:  'CB_IMPOR_CLIENTE'
 	#DESCRIPCION:	Para importar clientes de las diferentes bases de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 10:22:05
	***********************************/

	elsif(p_transaccion='CB_IMPOR_CLIENTE')then

		begin  
       
            -- Creamos la tabla temporal para 
             EXECUTE('CREATE TEMP TABLE tt_cliente_distribucion("id_cliente" integer,                                                                      
                                                                 "nro_cuenta" VARCHAR,
                                                                 "nro_cuenta_ant" VARCHAR,
                                                                 "nombre" VARCHAR,
                                                                 "nro_nit" NUMERIC,
                                                                 "tipo_cliente" VARCHAR
                                                                      )  ON COMMIT DROP;');  
                                                                      
                                                                      
            --Conexion a la base de datos con la cadena enviada  
           /* v_ss='insert into tt_cliente_distribucion
                                 SELECT P.id_cliente, P.nro_cuenta,P.nro_cuenta_ant,P.desc_cliente,P.nro_nit,P.tipo_cliente
                                 FROM dblink('''||v_parametros.conexion||''',
                                             ''SELECT cli.id_cliente,                                                    
                                                      cli.nro_cuenta,
                                                      cli.nro_cuenta_ant,
                                                      cli.desc_cliente,
                                                      cli.nro_nit,
                                                      (case when (cli.razon_social!='''' '''') THEN ''''Persona''''
                                                            else ''''Empresa''''
                                                            end) as tipo_cliente
                                               FROM factur.vfv_cliente cli'') AS P(
                                                                                  "id_cliente" integer,                                                                                  
                                                                                  "nro_cuenta" VARCHAR , 
                                                                                  "nro_cuenta_ant" VARCHAR,
                                                                                  "desc_cliente" TEXT,
                                                                                  "nro_nit" NUMERIC,
                                                                                  "tipo_cliente" VARCHAR);';  
                                                                                  raise exception '%',v_ss;   */
            execute('insert into tt_cliente_distribucion
                                 SELECT P.id_cliente, P.nro_cuenta,P.nro_cuenta_ant,P.desc_cliente,P.nro_nit,P.tipo_cliente
                                 FROM dblink('''||v_parametros.conexion||''',
                                             ''SELECT cli.id_cliente,                                                    
                                                      cli.nro_cuenta,
                                                      cli.nro_cuenta_ant,
                                                      cli.desc_cliente,
                                                      cli.nro_nit,
                                                      (case when (cli.razon_social!='''' '''') THEN ''''Empresa''''
                                                            else ''''Persona''''
                                                            end) as tipo_cliente
                                               FROM factur.vfv_cliente cli'') AS P(
                                                                                  "id_cliente" integer,                                                                                  
                                                                                  "nro_cuenta" VARCHAR , 
                                                                                  "nro_cuenta_ant" VARCHAR,
                                                                                  "desc_cliente" TEXT,
                                                                                  "nro_nit" NUMERIC,
                                                                                  "tipo_cliente" VARCHAR);');  
                                                                                  
                                                                              --raise exception'llegaaaa';
            --Recorremos la tabla para identificar los clientes que ya se importaron
            FOR v_registros IN(SELECT * FROM tt_cliente_distribucion)Loop
               IF NOT EXISTS(SELECT 1 FROM cobra.tcb_cliente WHERE id_sistema_dist=v_parametros.id_sistema_dist AND id_cliente_dist=v_registros.id_cliente)THEN
                  insert into cobra.tcb_cliente(
			                  estado_reg,
			                  nro_cuenta,
			                  tipo_cliente,
			                  nro_nit,
			                  id_sistema_dist,
			                  id_cliente_dist,
			                  nombre,
			                  nro_cuenta_ant,
			                  id_usuario_reg,
			                  fecha_reg,
			                  id_usuario_mod,
			                  fecha_mod
          	                  ) values(
			                  'activo',
			                  v_registros.nro_cuenta,
			                  v_registros.tipo_cliente,
			                  v_registros.nro_nit,
			                  v_parametros.id_sistema_dist,
			                  v_registros.id_cliente,
			                  v_registros.nombre,
			                  v_registros.nro_cuenta_ant,
			                  p_id_usuario,
			                  now(),
			                  null,
			                  null
			                  ); 
               END IF; 
            END LOOP;                                                                                                                                          			
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Clientes del Sistema importados'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist',v_parametros.id_sistema_dist::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;    
        
        /*********************************    
 	#TRANSACCION:  'CB_IMPOR_FACTUR'
 	#DESCRIPCION:	Para importar la facutacion de la regional seleccionada
 	#AUTOR:		jmita
 	#FECHA:		12-10-2011 10:22:05
	***********************************/

	elsif(p_transaccion='CB_IMPOR_FACTUR')then

		begin  
       
            -- Creamos la tabla temporal para 
             EXECUTE('CREATE TEMP TABLE tt_lectura("id_cliente" integer,        "periodo_lec" numeric,   "gestion_lec" numeric,      "tipo_lectura" numeric,      "fecha_factura" date,      "nro_factura" integer,
                                                   "cod_control" varchar,       "nro_autoriza" numeric,  "nro_orden" varchar,        "cod_alfanum" varchar,       "importe_total" numeric,   "fecha_vence" date,
                                                   "fecha_anterior" date,       "fecha_actual" date,     "lectura_anterior" numeric, "lectura_actual" numeric,    "consumo_cambio" numeric,  "consumo_peri" numeric,
                                                   "consumo_total" numeric,     "lectura_kw" numeric,    "consumo_val" numeric,      "conexion_val" numeric,      "reconex_val" numeric,     "importe_dev" numeric,
                                                   "credito_pagado" numeric,    "potencia_val" numeric,  "importe_cred_fis" numeric, "multi_kwh" numeric,         "fecha_proxmed" date,      "consumo_libre" integer,
                                                   "sw_debito_fiscal" varchar,  "cod_ubica" varchar,     "direccion" varchar,        "nombre_factura" varchar,    "nro_nit" numeric,         "nroserie_med" varchar,
                                                   "desc_categoria" varchar,    "id_ap" integer,         "importe_ap" numeric,       "id_aseo" integer,           "importe_aseo" numeric,    "id_vejez" integer,
													"importe_vejez" numeric,    "id_dignidad" integer,   "importe_dignidad" numeric)  ON COMMIT DROP;');  
                                                                      
                                                                  
            --Conexion a la base de datos con la cadena enviada  
 			/*
			SELECT P.periodo into v_periodo
           FROM dblink('hostaddr=10.10.0.11 port=5432 dbname=dbendesis user=db_link password=db_link','SELECT periodo from factur.tfv_parametro') AS P( "periodo" NUMERIC); 
           SELECT P.gestion into v_gestion
           FROM dblink('hostaddr=10.10.0.11 port=5432 dbname=dbendesis user=db_link password=db_link','SELECT gestion from factur.tfv_parametro') AS P( "gestion" NUMERIC);*/
     	  	  v_periodo=6;  
              v_gestion=2011;                                                                             
			   raise notice '%   %','periodo:'||v_periodo||'-gest:'||v_gestion, v_parametros.conexion; 
               
               
               v_consulta = 'insert into tt_lectura
                                 SELECT P.id_cliente,       P.periodo_lec,  P.gestion_lec,      P.tipo_lectura,   P.fecha_factura,  P.nro_factura,
                                        P.cod_control,      P.nro_autoriza, P.nro_orden,        P.cod_alfanum,    P.importe_total,  P.fecha_vence,
                                        P.fecha_anterior,   P.fecha_actual, P.lectura_anterior, P.lectura_actual, P.consumo_cambio, P.consumo_peri,
                                        P.consumo_total,    P.lectura_kw,   P.consumo_val,      P.conexion_val,   P.reconex_val,    P.importe_dev,
                                        P.credito_pagado,   P.potencia_val, P.importe_cred_fis, P.multi_kwh,      P.fecha_proxmed,  P.consumo_libre,
                                        P.sw_debito_fiscal, P.cod_ubica,    P.direccion,        P.nombre_factura, P.nro_nit,        P.nroserie_med, 
                                        P.desc_categoria,   P.id_ap,        P.importe_ap,       P.id_aseo,        P.importe_aseo,   P.id_vejez,
										P.importe_vejez,    P.id_dignidad,  P.importe_dignidad                 
                                 FROM dblink('''||v_parametros.conexion||''',
                                 ''select 
                                        ld.id_cliente ,      ld.periodo_lec,  ld.gestion_lec,      ld.tipo_lectura,   ld.fecha_factura,   ld.nro_factura,
                                        ld.cod_control,      ld.nro_autoriza, ld.nro_orden,        ld.cod_alfanum,    ld.importe_total,   ld.fecha_vence,
                                        ld.fecha_anterior,   ld.fecha_actual, ld.lectura_anterior, ld.lectura_actual, ld.consumo_cambio,  ld.consumo_peri,
                                        ld.consumo_total,    ld.lectura_kw,   ld.consumo_val,      ld.conexion_val,   ld.reconex_val,     ld.importe_dev,
                                        ld.credito_pagado,   ld.potencia_val, ld.importe_cred_fis, ld.multi_kwh,      ld.fecha_proxmed,   ld.consumo_libre,
                                        ld.sw_debito_fiscal, ld.cod_ubica,    ld.direccion,        ld.nombre_factura, ld.nro_nit,         ld.nroserie_med,
                                        ld.desc_categoria,   ld.id_ap,        ld.importe_ap,       ld.id_aseo,        ld.importe_aseo,    ld.id_vejez,
										ld.importe_vejez,    ld.id_dignidad,  ld.importe_dignidad
                                                      from factur.vfv_lectura_dblink ld 
                                                      where ld.periodo_lec='||v_periodo||' and ld.gestion_lec='||v_gestion||'
                                                       '') 
                                                      AS P( "id_cliente" bigint,"periodo_lec" numeric, "gestion_lec" numeric, "tipo_lectura" numeric, "fecha_factura" date, "nro_factura" integer,
                                                   "cod_control" varchar, "nro_autoriza" numeric, "nro_orden" varchar, "cod_alfanum" varchar, "importe_total" numeric, "fecha_vence" date,
                                                   "fecha_anterior" date, "fecha_actual" date, "lectura_anterior" numeric, "lectura_actual" numeric, "consumo_cambio" numeric, "consumo_peri" numeric,
                                                   "consumo_total" numeric, "lectura_kw" numeric, "consumo_val" numeric, "conexion_val" numeric, "reconex_val" numeric, "importe_dev" numeric,
                                                   "credito_pagado" numeric, "potencia_val" numeric, "importe_cred_fis" numeric, "multi_kwh" numeric, "fecha_proxmed" date, "consumo_libre" integer,
                                                   "sw_debito_fiscal" varchar, "cod_ubica" varchar, "direccion" varchar, "nombre_factura" varchar, "nro_nit" numeric, "nroserie_med" varchar, 
                                                   "desc_categoria" varchar,    "id_ap" integer,    "importe_ap" numeric,     "id_aseo" integer,  "importe_aseo" numeric,   "id_vejez" integer,
													"importe_vejez" numeric,    "id_dignidad" integer,  "importe_dignidad" numeric);';
--raise exception 'SALE: %',v_consulta;
execute(v_consulta);
                                                                                             
            /*execute('insert into tt_lectura
                                 SELECT P.id_cliente,       P.periodo_lec,  P.gestion_lec,      P.tipo_lectura,   P.fecha_factura,  P.nro_factura,
                                        P.cod_control,      P.nro_autoriza, P.nro_orden,        P.cod_alfanum,    P.importe_total,  P.fecha_vence,
                                        P.fecha_anterior,   P.fecha_actual, P.lectura_anterior, P.lectura_actual, P.consumo_cambio, P.consumo_peri,
                                        P.consumo_total,    P.lectura_kw,   P.consumo_val,      P.conexion_val,   P.reconex_val,    P.importe_dev,
                                        P.credito_pagado,   P.potencia_val, P.importe_cred_fis, P.multi_kwh,      P.fecha_proxmed,  P.consumo_libre,
                                        P.sw_debito_fiscal, P.cod_ubica,    P.direccion,        P.nombre_factura, P.nro_nit,        P.nroserie_med,    P.desc_categoria                    
                                 FROM dblink('''||v_parametros.conexion||''',
                                 ''select 
                                        c.id_cliente,       l.periodo_lec,  l.gestion_lec,      l.tipo_lectura,   f.fecha_factura,  f.nro_factura,
                                        f.cod_control,      d.nro_autoriza, coalesce(f.nro_orden,'''') as nro_orden,  coalesce(f.cod_alfanum,'''') as cod_alfanum,    co.importe_total,   l.fecha_vence,
                                        l.fecha_anterior,   l.fecha_actual, l.lectura_anterior, l.lectura_actual, l.consumo_cambio, l.consumo_peri,
                                        l.consumo_total,    l.lectura_kw,   l.consumo_val,      l.conexion_val,   l.reconex_val,    l.importe_dev,
                                        l.credito_pagado,   l.potencia_val, l.importe_total as importe_cred_fis,  l.multi_kwh,      l.fecha_proxmed,    coalesce(li.consumo_maximo,0) as consumo_libre,
                                        c.sw_debito_fiscal, l.cod_ubica,    c.direccion,        c.nombre_factura, c.nro_nit,        c.nroserie_med,     ca.desc_categoria
                                                      from factur.vfv_lectura_dblink ld 
                                                      where ld.periodo_fac='||v_periodo||' and co.gestion_fac='||v_gestion||''') 
                                                      AS P( "id_cliente" integer,"periodo_lec" numeric, "gestion_lec" numeric, "tipo_lectura" numeric, "fecha_factura" date, "nro_factura" integer,
                                                   "cod_control" varchar, "nro_autoriza" numeric, "nro_orden" varchar, "cod_alfanum" varchar, "importe_total" numeric, "fecha_vence" date,
                                                   "fecha_anterior" date, "fecha_actual" date, "lectura_anterior" numeric, "lectura_actual" numeric, "consumo_cambio" numeric, "consumo_peri" numeric,
                                                   "consumo_total" numeric, "lectura_kw" numeric, "consumo_val" numeric, "conexion_val" numeric, "reconex_val" numeric, "importe_dev" numeric,
                                                   "credito_pagado" numeric, "potencia_val" numeric, "importe_cred_fis" numeric, "multi_kwh" numeric, "fecha_proxmed" date, "consumo_libre" integer,
                                                   "sw_debito_fiscal" varchar, "cod_ubica" varchar, "direccion" varchar, "nombre_factura" varchar, "nro_nit" numeric, "nroserie_med" varchar, "desc_categoria" varchar);');  
                    select id_cliente into v_pru from  tt_lectura where id_cliente = 9520;
                    raise notice '%','id:'||v_pru; */
                    
                   ---- select id_cliente into v_pru from  tt_lectura where id_cliente = 9520;
                    --raise notice '%','como que null';
                    --raise notice '%','id:'||v_pru;  
                    
                    --select codigo into v_codigo_sis from cobra.tcb_sistema_dist where id_sistema_dist=v_parametros.id_sistema_dist;  
                    --select c.id_cliente into v_id_cliente_cob from cobra.tcb_cliente c where  c.id_cliente_dist=9520 and c.id_sistema_dist=v_parametros.id_sistema_dist;                                                     
                    --raise notice '%','id_cliente_cob:'||v_id_cliente_cob;   
                                                                              --raise exception'llegaaaa';
            --Recorremos la tabla para identificar los clientes que ya se importaron
            FOR v_registros IN(SELECT * FROM tt_lectura)Loop
            
            	select c.id_cliente into v_id_cliente_cob from cobra.tcb_cliente c where  c.id_cliente_dist=v_registros.id_cliente and c.id_sistema_dist=v_parametros.id_sistema_dist;
               IF NOT EXISTS(SELECT 1 FROM cobra.tcb_factura_cob WHERE id_cliente=v_id_cliente_cob and periodo=v_registros.periodo_lec and gestion=v_registros.gestion_lec)THEN
                  insert into cobra.tcb_factura_cob(
			                  			id_usuario_reg,   id_cliente,       periodo,          gestion,          estado_fac,     tipo_lectura,    fecha_factura,    nro_factura,
                                        cod_control,      nro_autorizacion, nro_orden,        cod_alfanum,    importe_total,   fecha_vence,
                                        fecha_ant,        fecha_act,        lectura_ant,      lectura_act,    consumo_cambio,  consumo_periodo,
                                        consumo_total,    lectura_kw,       consumo_val,      conexion_val,   reconex_val,     importe_dev,
                                        credito_pagado,   potencia_val,     importe_cred_fis, multi_kwh,      fecha_prox_med,  consumo_libre,
                                        sw_deb_fis,       cod_ubica,        direccion,        nombre_fac,     nit_fact,        nro_medidor,      desc_categoria
          	                  ) values(
			                   			p_id_usuario,				  v_id_cliente_cob,             v_registros.periodo_lec,  v_registros.gestion_lec,      'no_pagado',				  v_registros.tipo_lectura,   v_registros.fecha_factura,  v_registros.nro_factura,
                                        v_registros.cod_control,      v_registros.nro_autoriza, v_registros.nro_orden,        v_registros.cod_alfanum,    v_registros.importe_total,  v_registros.fecha_vence,
                                        v_registros.fecha_anterior,   v_registros.fecha_actual, v_registros.lectura_anterior, v_registros.lectura_actual, v_registros.consumo_cambio, v_registros.consumo_peri,
                                        v_registros.consumo_total,    v_registros.lectura_kw,   v_registros.consumo_val,      v_registros.conexion_val,   v_registros.reconex_val,    v_registros.importe_dev,
                                        v_registros.credito_pagado,   v_registros.potencia_val, v_registros.importe_cred_fis, v_registros.multi_kwh,      v_registros.fecha_proxmed,  v_registros.consumo_libre,
                                        v_registros.sw_debito_fiscal, v_registros.cod_ubica,    v_registros.direccion,        v_registros.nombre_factura, v_registros.nro_nit,        v_registros.nroserie_med,    v_registros.desc_categoria
                                                                                
			                  ); 
                  select max(id_factura_cob) into v_id_fac_cob from cobra.tcb_factura_cob; 
                    if (v_registros.importe_ap>0)THEN
                    insert into cobra.tcb_factura_cob_det (id_factura_cob,	id_tasa,			importe)
                    								VALUES(v_id_fac_cob,	v_registros.id_ap,	v_registros.importe_ap);
                    END if;
                    if (v_registros.importe_aseo>0)THEN
                    insert into cobra.tcb_factura_cob_det (id_factura_cob,	id_tasa,			importe)
                    								VALUES(v_id_fac_cob,	v_registros.id_aseo,	v_registros.importe_aseo);
                    END if;
                    if (v_registros.importe_vejez>0)THEN
                    insert into cobra.tcb_factura_cob_det (id_factura_cob,	id_descuento,			importe)
                    								VALUES(v_id_fac_cob,	v_registros.id_vejez,	v_registros.importe_vejez);
                    END if;
                    if (v_registros.importe_dignidad>0)THEN
                    insert into cobra.tcb_factura_cob_det (id_factura_cob,	id_descuento,			importe)
                    								VALUES(v_id_fac_cob,	v_registros.id_dignidad,	v_registros.importe_dignidad);
                    END if;     
                       
               END IF; 
            END LOOP;                                                                                                                                         			
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Facturación Importada'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist',v_parametros.id_sistema_dist::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end; 
        
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

/*EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
	*/			        
END;
$$;


ALTER FUNCTION cobra.f_tcb_sistema_dist_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1198 (class 1255 OID 1360886)
-- Dependencies: 2435 30
-- Name: f_tcb_sistema_dist_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_sistema_dist_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_sistema_dist_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_sistema_dist'
 AUTOR: 		 (fprudencio)
 FECHA:	        20-09-2011 10:22:05
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_sistema_dist_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_SISDIS_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 10:22:05
	***********************************/

	if(p_transaccion='CB_SISDIS_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						sisdis.id_sistema_dist,
						sisdis.codigo,
						sisdis.conexion,
						sisdis.nombre,
						sisdis.estado_reg,
						sisdis.id_usuario_reg,
						sisdis.fecha_reg,
						sisdis.id_usuario_mod,
						sisdis.fecha_mod, --::varchar,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_sistema_dist sisdis
						inner join segu.tusuario usu1 on usu1.id_usuario = sisdis.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = sisdis.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			raise notice '%',v_consulta;
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_SISDIS_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 10:22:05
	***********************************/

	elsif(p_transaccion='CB_SISDIS_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_sistema_dist)
					    from cobra.tcb_sistema_dist sisdis
					    inner join segu.tusuario usu1 on usu1.id_usuario = sisdis.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = sisdis.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION cobra.f_tcb_sistema_dist_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 309 (class 1255 OID 1513145)
-- Dependencies: 30 2435
-- Name: f_tcb_sistema_dist_usuario_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_sistema_dist_usuario_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_sistema_dist_usuario_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_sistema_dist_usuario'
 AUTOR: 		 (fprudencio)
 FECHA:	        21-09-2011 10:41:58
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_sistema_dist_usuario	integer;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_sistema_dist_usuario_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_USHAB_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		21-09-2011 10:41:58
	***********************************/

	if(p_transaccion='CB_USHAB_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_sistema_dist_usuario(
			estado_reg,
			id_usuario,
			id_sistema_dist,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.id_usuario,
			v_parametros.id_sistema_dist,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_sistema_dist_usuario into v_id_sistema_dist_usuario;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Usuarios Habilitados almacenado(a) con exito (id_sistema_dist_usuario'||v_id_sistema_dist_usuario||')'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist_usuario',v_id_sistema_dist_usuario::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_USHAB_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		21-09-2011 10:41:58
	***********************************/

	elsif(p_transaccion='CB_USHAB_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_sistema_dist_usuario set
			id_usuario = v_parametros.id_usuario,
			id_sistema_dist = v_parametros.id_sistema_dist,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_sistema_dist_usuario=v_parametros.id_sistema_dist_usuario;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Usuarios Habilitados modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist_usuario',v_parametros.id_sistema_dist_usuario::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_USHAB_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		21-09-2011 10:41:58
	***********************************/

	elsif(p_transaccion='CB_USHAB_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_sistema_dist_usuario
            where id_sistema_dist_usuario=v_parametros.id_sistema_dist_usuario;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Usuarios Habilitados eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist_usuario',v_parametros.id_sistema_dist_usuario::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION cobra.f_tcb_sistema_dist_usuario_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1068 (class 1255 OID 1513144)
-- Dependencies: 30 2435
-- Name: f_tcb_sistema_dist_usuario_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: postgres
--

CREATE FUNCTION f_tcb_sistema_dist_usuario_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_sistema_dist_usuario_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_sistema_dist_usuario'
 AUTOR: 		 (fprudencio)
 FECHA:	        21-09-2011 10:41:58
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_sistema_dist_usuario_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_USHAB_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		21-09-2011 10:41:58
	***********************************/

	if(p_transaccion='CB_USHAB_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						ushab.id_sistema_dist_usuario,
						ushab.estado_reg,
						ushab.id_usuario,
                        usu3.cuenta ||'' - ''|| PERSON.nombre_completo2 as desc_usuario,
						ushab.id_sistema_dist,
                        sisdis.nombre as nombre_sisdis,
						ushab.id_usuario_reg,
						ushab.fecha_reg,
						ushab.id_usuario_mod,
						ushab.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_sistema_dist_usuario ushab
						inner join segu.tusuario usu1 on usu1.id_usuario = ushab.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ushab.id_usuario_mod
                        inner join segu.tusuario usu3 on usu3.id_usuario=ushab.id_usuario
                        inner join cobra.tcb_sistema_dist sisdis on sisdis.id_sistema_dist=ushab.id_sistema_dist 
                        INNER JOIN segu.vpersona PERSON on PERSON.id_persona = usu3.id_persona
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
            
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            raise notice '%',v_consulta;
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_USHAB_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		21-09-2011 10:41:58
	***********************************/

	elsif(p_transaccion='CB_USHAB_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_sistema_dist_usuario)
					    from cobra.tcb_sistema_dist_usuario ushab
						inner join segu.tusuario usu1 on usu1.id_usuario = ushab.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ushab.id_usuario_mod
                        inner join segu.tusuario usu3 on usu3.id_usuario=ushab.id_usuario
                        inner join cobra.tcb_sistema_dist sisdis on sisdis.id_sistema_dist=ushab.id_sistema_dist 
                        INNER JOIN segu.vpersona PERSON on PERSON.id_persona = usu3.id_persona
				        where  ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
        
	/*********************************    
 	#TRANSACCION:  'CB_FACPER_SEL'
 	#DESCRIPCION:	Listado de registros
 	#AUTOR:		jmita	
 	#FECHA:		10-11-2011 10:41:58
	***********************************/

	elsif(p_transaccion='CB_FACPER_SEL')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:=' select fc.periodo, 
            					 fc.gestion, 
                                 count(fc.id_cliente) as cant_clientes, 
                                 sum(fc.importe_total) as importe_total
	 							from cobra.tcb_factura_cob fc 
								 inner join cobra.tcb_cliente c on fc.id_cliente=c.id_cliente 
						 where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:= v_consulta||' group by fc.periodo, fc.gestion ';
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            
			--raise notice '%',v_consulta;
			--Devuelve la respuesta
			return v_consulta;

		end;
		
        /*********************************    
 	#TRANSACCION:  'CB_FACPER_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		jmita	
 	#FECHA:		10-09-2011 10:41:58
	***********************************/

	elsif(p_transaccion='CB_FACPER_CONT')then

		begin
        	EXECUTE(' CREATE TEMP TABLE  tt_periodo (periodo numeric(2,0), gestion numeric(4,0),cant_clientes NUMERIC(18,2),importe_total numeric(18,2))ON COMMIT DROP;');
            EXECUTE('insert into tt_periodo select fc.periodo, fc.gestion, count(fc.id_cliente) as cant_clientes, sum(fc.importe_total) as importe_total
	 							from cobra.tcb_factura_cob fc 
								inner join cobra.tcb_cliente c on fc.id_cliente=c.id_cliente 
						 		where '||v_parametros.filtro||' group by fc.periodo, fc.gestion '||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero);
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count (*) from tt_periodo ';
			
			--Definicion de la respuesta		    
			--v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;						
	else
				     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION cobra.f_tcb_sistema_dist_usuario_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

SET search_path = conta, pg_catalog;

--
-- TOC entry 107 (class 1255 OID 16523)
-- Dependencies: 8 2435
-- Name: ft_auxiliar_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: conta; Owner: rchumacero
--

CREATE FUNCTION ft_auxiliar_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		conta.ft_auxiliar_ime
 DESCRIPCIÓN:   modificaciones de auxiliars contables
 AUTOR: 		
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		02-02-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='conta.ft_auxiliar_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   CT_AUXILI_INS
 #DESCRIPCION:	Inserta auxiliars Contables
 #AUTOR:			
 #FECHA:		02-02-2011	
***********************************/
     if(par_transaccion='CT_AUXILI_INS')then

        
          BEGIN
              
               --insercion de nuevo parametro
               INSERT INTO conta.tauxiliar(codigo, nombre, estado_reg,fecha_reg)
               values(v_parametros.codigo,v_parametros.nombre,'activo',now()::date);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','auxiliar contable'||v_parametros.codigo||' insertada con exito ');
               v_resp = f_agrega_clave(v_resp,'id_periodo',v_id_funcion::varchar);
         END;
 /*******************************    
 #TRANSACCION:  CT_AUXILI_MOD
 #DESCRIPCION:	Modifica el auxiliar contable seleccionado
 #AUTOR:			
 #FECHA:		02-02-2011
***********************************/
     elsif(par_transaccion='CT_AUXILI_MOD')then

          
          BEGIN
               --modificacion de periodo
                update conta.tauxiliar
                set codigo=v_parametros.codigo,
                nombre=v_parametros.nombre
                where id_auxiliar=v_parametros.id_auxiliar;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','auxiliar contable modificado con exito '||v_parametros.codigo);
               v_resp = f_agrega_clave(v_resp,'id_auxiliar',v_parametros.id_auxiliar::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  CT_AUXILI_ELI
 #DESCRIPCION:	Inactiva el auxiliar contable selecionado
 #AUTOR:			
 #FECHA:		02-02-2011
***********************************/

    elsif(par_transaccion='CT_AUXILI_ELI')then
        BEGIN
        
         --inactivacion de la periodo
               delete from conta.tauxiliar
               where id_auxiliar=v_parametros.id_auxiliar;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','auxiliar contable eliminada con exito '||v_parametros.id_auxiliar);
               v_resp = f_agrega_clave(v_resp,'id_auxiliar',v_parametros.id_auxiliar::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION conta.ft_auxiliar_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 108 (class 1255 OID 16524)
-- Dependencies: 8 2435
-- Name: ft_auxiliar_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: conta; Owner: rchumacero
--

CREATE FUNCTION ft_auxiliar_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 parametro_conta: 		conta.ft_auxiliar_sel
 DESCRIPCIÓN:  listado de auxiliar contable
 AUTOR: 		
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		02-02-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='conta.ft_auxiliar_sel';


     if(par_transaccion='CT_AUXILI_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            AUXILI.id_auxiliar,
                            AUXILI.codigo,
                            AUXILI.nombre,
                            AUXILI.estado_reg,
                            AUXILI.fecha_reg
                            FROM CONTA.tauxiliar AUXILI
                            WHERE ';

               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='CT_AUXILI_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                            count(AUXILI.id_auxiliar)
                            FROM conta.tauxiliar AUXILI
                            WHERE  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION conta.ft_auxiliar_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 290 (class 1255 OID 16525)
-- Dependencies: 8 2435
-- Name: ft_cuenta_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: conta; Owner: rchumacero
--

CREATE FUNCTION ft_cuenta_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		conta.ft_cuenta_ime
 DESCRIPCIÓN:   modificaciones de cuentas contables
 AUTOR: 		KPLIAN
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		01-02-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='conta.ft_cuenta_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   CT_CUENTA_INS
 #DESCRIPCION:	Inserta Cuentas Contables
 #AUTOR:		KPLIAN	
 #FECHA:		01-02-2011	
***********************************/
     if(par_transaccion='CT_CUENTA_INS')then

        
          BEGIN
              
               --insercion de nuevo parametro
               INSERT INTO conta.tcuenta(codigo, nombre, estado_reg,fecha_reg)
               values(v_parametros.codigo,v_parametros.nombre,'activo',now()::date);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','Cuenta contable'||v_parametros.codigo||' insertada con exito ');
               v_resp = f_agrega_clave(v_resp,'id_periodo',v_id_funcion::varchar);
         END;
 /*******************************    
 #TRANSACCION:      CT_CUENTA_MOD
 #DESCRIPCION:	Modifica la cuenta contable seleccionada
 #AUTOR:		KPLIAN	
 #FECHA:		01-02-2011
***********************************/
     elsif(par_transaccion='CT_CUENTA_MOD')then

          
          BEGIN
               --modificacion de periodo
                update conta.tcuenta
                set codigo=v_parametros.codigo,
                nombre=v_parametros.nombre
                where id_cuenta=v_parametros.id_cuenta;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','Cuenta contable modificado con exito '||v_parametros.codigo);
               v_resp = f_agrega_clave(v_resp,'id_cuenta',v_parametros.id_cuenta::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  CT_CUENTA_ELI
 #DESCRIPCION:	Inactiva la cuenta contable selecionada
 #AUTOR:		KPLIAN	
 #FECHA:		01-02-2011
***********************************/

    elsif(par_transaccion='CT_CUENTA_ELI')then
        BEGIN
        
         --inactivacion de la periodo
               delete from conta.tcuenta
               where id_cuenta=v_parametros.id_cuenta;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Cuenta contable eliminada con exito '||v_parametros.id_cuenta);
               v_resp = f_agrega_clave(v_resp,'id_cuenta',v_parametros.id_cuenta::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION conta.ft_cuenta_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 109 (class 1255 OID 16526)
-- Dependencies: 8 2435
-- Name: ft_cuenta_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: conta; Owner: rchumacero
--

CREATE FUNCTION ft_cuenta_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 parametro_conta: 		conta.ft_cuenta_sel
 DESCRIPCIÓN:  listado de cuenta contable
 AUTOR: 		
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		01-02-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='conta.ft_cuenta_sel';


     if(par_transaccion='CT_CUENTA_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            CUENTA.id_cuenta,
                            CUENTA.codigo,
                            CUENTA.nombre,
                            CUENTA.estado_reg,
                            CUENTA.fecha_reg
                            FROM CONTA.tcuenta CUENTA
                            WHERE ';

               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='CT_CUENTA_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                            count(CUENTA.id_cuenta)
                            FROM conta.tcuenta CUENTA
                            WHERE  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION conta.ft_cuenta_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

SET search_path = gen, pg_catalog;

--
-- TOC entry 252 (class 1255 OID 22779)
-- Dependencies: 9 2435
-- Name: f_obtener_datos_tabla_sel(integer, character varying, character varying); Type: FUNCTION; Schema: gen; Owner: rchumacero
--

CREATE FUNCTION f_obtener_datos_tabla_sel(p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
/*
Autor: RCM
Fecha: 19/11/201
Descripción: Función que devuelve los datos de las columnas y de la tabla para el generador
*/

DECLARE

	v_consulta    		varchar;
	v_rec  				record;
	v_nombre_funcion   	text;
    v_resp				varchar;
    v_sql				varchar;

BEGIN

    v_nombre_funcion:='gen.f_obtener_datos_tabla_sel';

    if p_transaccion = 'GEN_COLUMN_SEL' then

    	begin
        	--1. Creación de la tabla temporal para almacenar todos los datos de la columna
            v_sql = 'create temp table tt_tabla_metadatos(id integer,
             												columna varchar,
                                                            descripcion varchar,
                                                            tipo_dato varchar,
                                                            longitud text,
                                                            nulo varchar,
                                                            checks varchar,
                                                            valor_defecto varchar,
                                                            grid_ancho integer,
                                                            grid_mostrar varchar,
                                                            form_ancho_porcen integer,
                                                            orden smallint,
                                                            grupo smallint

            ) on commit drop;';
            
            execute(v_sql);
            
            v_sql = 'create temp table tt_constraints(id integer,
            											nombre varchar
            ) on commit drop';
            execute(v_sql);
                        
            --2. Obtención de las columnas y sus metadatos
            v_sql = 'insert into tt_tabla_metadatos(
            		columna, descripcion, tipo_dato, checks, nulo, longitud,
                    valor_defecto, grid_ancho, grid_mostrar, form_ancho_porcen,
                    orden, grupo
            		)
                    SELECT DISTINCT
                    a.attname as column_name,
                    pg_catalog.obj_description(c.oid) as descripcion,
                    t.typname as tipo_dato,
                    CASE
                    WHEN cc.contype=''p'' THEN ''PK''
                    WHEN cc.contype=''u'' THEN ''UQ''
                    WHEN cc.contype=''f'' THEN ''FK''
                    ELSE '''' END AS cheks,
                    CASE WHEN a.attnotnull=false THEN ''si'' ELSE ''no'' END AS  nulo,
                    CASE WHEN a.attlen=''-1'' THEN (a.atttypmod - 4) ELSE a.attlen END as  longitud,
                    d.adsrc as valor_defecto,
                    100, ''si'', 80, null::smallint, 1::smallint
                    FROM pg_catalog.pg_attribute a
                    LEFT JOIN pg_catalog.pg_type t ON t.oid = a.atttypid
                    LEFT JOIN pg_catalog.pg_class c ON c.oid = a.attrelid
                    LEFT JOIN pg_catalog.pg_constraint cc ON cc.conrelid = c.oid AND cc.conkey[1] = a.attnum
                    LEFT JOIN pg_catalog.pg_attrdef d ON d.adrelid = c.oid AND a.attnum = d.adnum
                    WHERE c.relname = ''' || p_tabla || '''
                    AND a.attnum > 0
                    AND t.oid = a.atttypid
                    AND NOT a.attisdropped';

            --raise exception '%',v_sql;
            execute(v_sql);
            
            --5. Consulta de la tabla resultado
            for v_rec in execute('select distinct columna, descripcion, tipo_dato,
            					longitud, nulo, checks, valor_defecto,
                                grid_ancho, grid_mostrar, form_ancho_porcen,
                                orden, grupo
                                from tt_tabla_metadatos') loop
            	return next v_rec;
            end loop;
            
            --6. Respuesta
            return;
 
		end;

     else
     
         raise exception 'Transaccion inexistente';
         
     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gen.f_obtener_datos_tabla_sel(p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 114 (class 1255 OID 16528)
-- Dependencies: 2435 9
-- Name: ft_columna_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gen; Owner: rchumacero
--

CREATE FUNCTION ft_columna_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

    v_nro_requerimiento    	integer;
    v_parametros           	record;
    v_id_requerimiento     	integer;
    v_resp		            varchar;
    v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_columna			integer;


/*

 id_proyecto
 denominacion 
 descripcion
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='gen.ft_columna_ime';
     v_parametros:=f_get_record(p_tabla);

     if(p_transaccion='GEN_COLUMN_INS')then

          BEGIN
               
               insert into gen.tcolumna(
		 		nombre,
                 descripcion,
                 id_tabla,
                 id_usuario_reg,
                 id_usuario_mod,
                 fecha_reg,
                 fecha_mod,
                 estado_reg,
                 etiqueta,
                 guardar
               ) values(
                v_parametros.nombre,
                v_parametros.descripcion,
                v_parametros.id_tabla,
                v_parametros.id_usuario_reg,
                NULL,
                now(),
                NULL,
                'activo',
                v_parametros.etiqueta,
                v_parametros.guardar
               )RETURNING id_columna into v_id_columna;
               
		v_resp = f_agrega_clave(v_resp,'mensaje','Columna almacenada con exito (id_columna'||v_id_columna||')'); 
               v_resp = f_agrega_clave(v_resp,'id_columna',v_id_columna::varchar);

               return v_resp;

         END;

     elsif(p_transaccion='GEN_COLUMN_MOD')then

          BEGIN

               update gen.tcolumna set
               nombre=v_parametros.nombre,
               descripcion=v_parametros.descripcion,
               id_tabla=v_parametros.id_tabla,
               id_usuario_mod=v_parametros.id_usuario_mod,
               fecha_mod=now(),
               etiqueta=v_parametros.etiqueta,
               guardar=v_parametros.guardar,
               longitud=v_parametros.longitud,
               grid_ancho=v_parametros.grid_ancho,
               grid_mostrar=v_parametros.grid_mostrar,
               form_ancho_porcen=v_parametros.form_ancho_porcen,
               orden=v_parametros.orden,
               grupo=v_parametros.grupo
               where id_columna=v_parametros.id_columna;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Columna modificada'); 
               v_resp = f_agrega_clave(v_resp,'id_columna',v_parametros.id_columna::varchar);
               
               return v_resp;
          END;

    elsif(p_transaccion='GEN_COLUMN_ELI')then

          BEGIN

               delete from gen.tcolumna
               where id_columna=v_parametros.id_columna;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Columna eliminada'); 
               v_resp = f_agrega_clave(v_resp,'id_columna',v_parametros.id_columna::varchar);
              
               return v_resp;
         END;
         
     else
     
         raise exception 'Transacción inexistente: %',p_transaccion;

     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
        
END;
$$;


ALTER FUNCTION gen.ft_columna_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 113 (class 1255 OID 16529)
-- Dependencies: 9 2435
-- Name: ft_columna_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gen; Owner: rchumacero
--

CREATE FUNCTION ft_columna_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*
Autor: RCM
Fecha: 30/11/2010
Descripción: Función que devuelve conjuntos de datos
*/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
    v_resp				varchar;

BEGIN

    v_parametros:=f_get_record(p_tabla);
    v_nombre_funcion:='gen.ft_columna_sel';

    if p_transaccion = 'GEN_COLUMN_SEL' then

    	begin
        	v_consulta:='select
            			id_columna, nombre, descripcion,
            			id_tabla, id_usuario_reg, id_usuario_mod, fecha_reg,
            			fecha_mod, estado_reg, etiqueta,guardar,
                        tipo_dato, longitud, nulo, checks, valor_defecto,
                        grid_ancho, grid_mostrar, form_ancho_porcen, orden,
                        grupo
            			from gen.tcolumna
                        where ';
            v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            raise notice '%',v_consulta;
            return v_consulta;
		end;

    elsif p_transaccion = 'GEN_COLUMN_CONT' then

        begin
        	v_consulta:='select count(id_columna)
            			from gen.tcolumna
                        where ';
            v_consulta:=v_consulta||v_parametros.filtro;
            return v_consulta;
        end;

     elsif p_transaccion = 'GEN_DATCOL_SEL' then

    	begin
        	v_consulta:='
SELECT (col.table_schema)::character varying AS esquema,
    (col.table_name)::character varying AS tabla, (col.column_name)::character
    varying AS columna, (col.ordinal_position)::integer AS posicion,
    (col.column_default)::character varying AS defecto,
    (col.is_nullable)::character varying AS blanco, (col.data_type)::character
    varying AS tipo, CASE WHEN ((col.data_type)::text =
    ''character varying''::text) THEN (col.character_maximum_length)::integer
    WHEN ((col.data_type)::text = ''numeric''::text) THEN
    (col.numeric_precision)::integer ELSE 0 END AS length, CASE WHEN
    ((col.data_type)::text = ''numeric''::text) THEN (col.numeric_scale)::integer
    ELSE 0 END AS "precision", (cons.conname)::character varying AS
    nombre_constraint, (cons.consrc)::character varying AS definicion_constraint,
    col1.guardar,col1.etiqueta
FROM information_schema.columns col
INNER JOIN gen.tcolumna col1
    on(col1.nombre=col.column_name)
LEFT JOIN information_schema.constraint_column_usage colcon ON
    col.table_schema::text = colcon.table_schema::text AND
    col.table_name::text = colcon.table_name::text AND
    col.column_name::text = colcon.column_name::text
LEFT JOIN pg_constraint cons ON
    cons.conname = colcon.constraint_name::name AND
    cons.contype = ''c''::"char"
LEFT JOIN pg_class c ON
cons.conrelid =c.oid AND c.relname = col.table_name::name
WHERE '; --col.table_schema::text = 'rhum'::text AND
    --col.table_name::text = 'tcolumna'::text AND id_tabla=21;
      
            v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            return v_consulta;
		end;

     elsif p_transaccion = 'GEN_DATCOL_CONT' then

        begin
        	v_consulta:='select count(col1.relname)
            		from gen.vcolumna col1
			left join gen.tcolumna col2
			on col2.nombre = col1.relname
                        where ';
            v_consulta:=v_consulta||v_parametros.filtro;
            return v_consulta;
        end;

     else
     
         raise exception 'Transaccion inexistente';
         
     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gen.ft_columna_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 112 (class 1255 OID 16530)
-- Dependencies: 9 2435
-- Name: ft_esquema_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gen; Owner: rchumacero
--

CREATE FUNCTION ft_esquema_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_esquema_sel
 DESCRIPCION:   lista las interfaces en el generador
 AUTOR: 	jrr	
 FECHA:	        25/01/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/


DECLARE


v_consulta   		varchar;
v_parametros  		record;
v_nombre_funcion  	text;
v_mensaje_error    	text;
v_resp              varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_esquema_sel';
     
/*******************************    
 #TRANSACCION:  GEN_ESQUEM_SEL
 #DESCRIPCION:	Listado de esquemas en los metadatos para el combo del generador
 #AUTOR:		Jaime Rivera Rojas	
 #FECHA:		25/01/11	
***********************************/

     if(par_transaccion='GEN_ESQUEM_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT n.oid::integer,
                                n.nspname::varchar AS name,
                                u.usename::varchar
                            FROM pg_namespace n
                            LEFT OUTER JOIN pg_user u ON n.nspowner = u.usesysid
                            LEFT OUTER JOIN pg_description ds ON n.oid = ds.objoid
                            where n.nspname not like ''pg_%'' and
                                n.nspname not like ''information_schema'' and ';
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by n.nspname limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

/*******************************
 #TRANSACCION:  GEN_ESQUEM_CONT
 #DESCRIPCION:	Listado de esquemas en los metadatos para el combo del generador
 #AUTOR:		Jaime Rivera Rojas	
 #FECHA:		25/01/11	
***********************************/
     elsif(par_transaccion='GEN_ESQUEM_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(n.oid)
                            FROM pg_namespace n
                            LEFT OUTER JOIN pg_user u ON n.nspowner = u.usesysid
                            LEFT OUTER JOIN pg_description ds ON n.oid = ds.objoid
                            where n.nspname not like ''pg_%'' and
                                n.nspname not like ''information_schema'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;      
END;
$$;


ALTER FUNCTION gen.ft_esquema_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 245 (class 1255 OID 16531)
-- Dependencies: 9 2435
-- Name: ft_tabla_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gen; Owner: rchumacero
--

CREATE FUNCTION ft_tabla_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

    v_nro_requerimiento    	integer;
    v_parametros           	record;
    v_id_requerimiento     	integer;
    v_resp		            varchar;
    v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_tabla			integer;
    v_registros         record;
    v_tabla_antigua     varchar;
    v_esquema           varchar;


/*

 id_proyecto
 denominacion 
 descripcion
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='gen.ft_tabla_ime';
     v_parametros:=f_get_record(p_tabla);

     if(p_transaccion='GEN_TABLA_INS')then

          BEGIN
                select lower(s.codigo)
                into v_esquema
                from segu.tsubsistema s
                where id_subsistema=v_parametros.id_subsistema;
                
               insert into gen.ttabla(
		          esquema,
		          nombre,
                 titulo,
                 id_subsistema,
                 id_usuario_reg,
                 id_usuario_mod,
                 fecha_reg,
                 fecha_mod,
                 estado_reg,
                 alias,
                 --reemplazar,
                 --menu,
                 direccion,
                 cant_grupos
               ) values(
                v_esquema,
                v_parametros.nombre,
                v_parametros.titulo,
                v_parametros.id_subsistema,
                p_id_usuario,
                NULL,
                now(),
                NULL,
                'activo',
                v_parametros.alias,
                --v_parametros.reemplazar,
                --v_parametros.menu,
                v_parametros.direccion,
                v_parametros.cant_grupos
               )RETURNING id_tabla into v_id_tabla;
                --raise exception 'llega%',v_parametros.nombre;
              
          		--Registro de las colummas de la tabla
                insert into gen.tcolumna(
                id_usuario_reg, estado_reg, nombre, descripcion,  tipo_dato, longitud, nulo,
                id_tabla, etiqueta, guardar, checks, valor_defecto, grid_ancho, grid_mostrar,
                form_ancho_porcen, orden, grupo
                )
                select
                p_id_usuario, 'activo', columna, descripcion, tipo_dato, longitud, nulo,
                v_id_tabla, columna, 'si', checks, valor_defecto,grid_ancho, grid_mostrar,
                form_ancho_porcen, orden, grupo
                from gen.f_obtener_datos_tabla_sel(p_id_usuario,v_parametros.nombre,'GEN_COLUMN_SEL') as (
                columna varchar,descripcion varchar,tipo_dato varchar,longitud text,
                nulo varchar,checks varchar, valor_defecto varchar, grid_ancho INTEGER,
                grid_mostrar varchar, form_ancho_porcen integer, orden smallint, grupo smallint);
                --
               
				v_resp = f_agrega_clave(v_resp,'mensaje','Tabla almacenada con exito (id_tabla'||v_id_tabla||')'); 
          		v_resp = f_agrega_clave(v_resp,'id_tabla',v_id_tabla::varchar);

               return v_resp;

         END;

     elsif(p_transaccion='GEN_TABLA_MOD')then

          BEGIN

              select nombre
              into v_tabla_antigua
              from gen.ttabla
              where id_tabla=v_parametros.id_tabla;
              select lower(s.codigo)
                into v_esquema
                from segu.tsubsistema s
                where id_subsistema=v_parametros.id_subsistema;
              if(v_tabla_antigua!=v_parametros.nombre)then
                delete from gen.tcolumna
                where id_tabla=v_parametros.id_tabla;
                
                --Registro de las colummas de la tabla
                insert into gen.tcolumna(
                id_usuario_reg, estado_reg, nombre, descripcion,  tipo_dato, longitud, nulo,
                id_tabla, etiqueta, guardar
                )
                select
                p_id_usuario, 'activo', columna, descripcion, tipo_dato, longitud, nulo,
                v_parametros.id_tabla, columna, 'si'
                from gen.f_obtener_datos_tabla_sel(p_id_usuario,v_parametros.nombre,'GEN_COLUMN_SEL') as (
                id integer,columna varchar,descripcion varchar,tipo_dato varchar,longitud integer,nulo varchar,checks varchar);
                --
              
              end if;
              

               update gen.ttabla set
               esquema=v_esquema,
               nombre=v_parametros.nombre,
               titulo=v_parametros.titulo,
               id_subsistema=v_parametros.id_subsistema,
               id_usuario_mod=v_parametros.id_usuario_mod,
               fecha_mod=now(),
               alias = v_parametros.alias,
               reemplazar = v_parametros.reemplazar,
               menu = v_parametros.menu,
               direccion=v_parametros.direccion,
               cant_grupos=v_parametros.cant_grupos
               where id_tabla=v_parametros.id_tabla;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Tabla modificada'); 
               v_resp = f_agrega_clave(v_resp,'id_tabla',v_parametros.id_tabla::varchar);
               
               return v_resp;
          END;

    elsif(p_transaccion='GEN_TABLA_ELI')then

          BEGIN
                delete from gen.tcolumna
               where id_tabla=v_parametros.id_tabla;
               
               delete from gen.ttabla
               where id_tabla=v_parametros.id_tabla;

               v_resp = f_agrega_clave(v_resp,'mensaje','Tabla eliminada'); 
               v_resp = f_agrega_clave(v_resp,'id_tabla',v_parametros.id_tabla::varchar);
              
               return v_resp;
         END;
         
     else
     
         raise exception 'Transacción inexistente: %',p_transaccion;

     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
        
END;
$$;


ALTER FUNCTION gen.ft_tabla_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 248 (class 1255 OID 16532)
-- Dependencies: 9 2435
-- Name: ft_tabla_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gen; Owner: rchumacero
--

CREATE FUNCTION ft_tabla_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*
Autor: RCM
Fecha: 30/11/2010
Descripción: Función que devuelve conjuntos de datos
*/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
    v_resp				varchar;

BEGIN

    v_parametros:=f_get_record(p_tabla);
    v_nombre_funcion:='gen.ft_tabla_sel';

    if p_transaccion = 'GEN_TABLA_SEL' then

    	begin
        	v_consulta:='select
            			tabla.id_tabla, tabla.esquema, tabla.nombre, tabla.titulo,
            			tabla.id_subsistema, tabla.id_usuario_reg, tabla.id_usuario_mod,
            			tabla.fecha_reg,tabla.fecha_mod, tabla.estado_reg,
            			subsis.nombre as desc_subsistema, subsis.prefijo, tabla.alias,
            			tabla.reemplazar, tabla.menu,tabla.direccion,subsis.nombre_carpeta,
                        (select nombre from gen.tcolumna where id_tabla = tabla.id_tabla and checks = ''PK'' LIMIT 1) as llave_primaria,
                        cant_grupos
            			from gen.ttabla tabla
            			inner join segu.tsubsistema subsis
            			on subsis.id_subsistema = tabla.id_subsistema
                        where  ';
            v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            return v_consulta;
		end;

    elsif p_transaccion = 'GEN_TABLA_CONT' then

        begin
        	v_consulta:='select count(id_tabla)
            			from gen.ttabla tabla
            			inner join segu.tsubsistema subsis
            			on subsis.id_subsistema = tabla.id_subsistema
                        where ';
            v_consulta:=v_consulta||v_parametros.filtro;
            return v_consulta;
        end;

     elsif p_transaccion = 'GEN_TABLACOM_SEL' then

        begin
        	v_consulta:='SELECT n.oid::integer as oid_esquema,
                                n.nspname::varchar AS nombre_esquema,
                                c.oid::integer as oid_tabla ,
                                c.relname::varchar as nombre

                        FROM pg_namespace n
                        INNER JOIN pg_class c ON c.relnamespace = n.oid
                        where n.nspname not like ''pg_%'' and
                            n.nspname not like ''information_schema'' and c.relkind=''r'' and ';
            v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:=v_consulta||' order by c.relname limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            return v_consulta;
        end;
     elsif p_transaccion = 'GEN_TABLACOM_CONT' then

        begin
        	v_consulta:='select count(c.oid)
            			FROM pg_namespace n
                        INNER JOIN pg_class c ON c.relnamespace = n.oid
                        where n.nspname not like ''pg_%'' and
                            n.nspname not like ''information_schema'' and c.relkind=''r'' and ';
            v_consulta:=v_consulta||v_parametros.filtro;
            return v_consulta;
        end;

     else
     
         raise exception 'Transaccion inexistente';
         
     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gen.ft_tabla_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

SET search_path = gev, pg_catalog;

--
-- TOC entry 1135 (class 1255 OID 3208509)
-- Dependencies: 90 2435
-- Name: f_rpt_prueba(numeric, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_rpt_prueba(actid numeric, fechaini timestamp without time zone, fechafin timestamp without time zone) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
  pv_rec RECORD;
BEGIN

	for pv_rec in select afr.latitud,afr.longitud,afr.fecha_satelite from gev.tgv_activo_fijo_rastreo afr where afr.id_activo_fijo = actId and afr.fecha_satelite BETWEEN fechaini and fechafin loop
      return next pv_rec;
  	end loop;
  
 	
END;
$$;


ALTER FUNCTION gev.f_rpt_prueba(actid numeric, fechaini timestamp without time zone, fechafin timestamp without time zone) OWNER TO rchumacero;

--
-- TOC entry 1136 (class 1255 OID 3208510)
-- Dependencies: 2435 90
-- Name: f_tgv_activo_datos_tec_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_activo_datos_tec_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_activo_datos_tec_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_activo_datos_tec'
 AUTOR: 		 (rcm)
 FECHA:	        02-02-2012 22:47:06
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_activo_datos_tec	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_activo_datos_tec_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_VEHIC_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 22:47:06
	***********************************/

	if(p_transaccion='tgv_VEHIC_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_activo_datos_tec(
			rend_litro_km,
			fecha_ult_km,
			estado_reg,
			id_activo_fijo,
			chasis,
			num_motor,
			ult_kilometraje,
			placa,
			cilindrada_cc,
			modem_id,
			soat,
			id_modelo,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.rend_litro_km,
			v_parametros.fecha_ult_km,
			'activo',
			v_parametros.id_activo_fijo,
			v_parametros.chasis,
			v_parametros.num_motor,
			v_parametros.ult_kilometraje,
			v_parametros.placa,
			v_parametros.cilindrada_cc,
			v_parametros.modem_id,
			v_parametros.soat,
			v_parametros.id_modelo,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_activo_datos_tec into v_id_activo_datos_tec;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Vehículos almacenado(a) con exito (id_activo_datos_tec'||v_id_activo_datos_tec||')'); 
            v_resp = f_agrega_clave(v_resp,'id_activo_datos_tec',v_id_activo_datos_tec::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_VEHIC_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 22:47:06
	***********************************/

	elsif(p_transaccion='tgv_VEHIC_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_activo_datos_tec set
			rend_litro_km = v_parametros.rend_litro_km,
			fecha_ult_km = v_parametros.fecha_ult_km,
			id_activo_fijo = v_parametros.id_activo_fijo,
			chasis = v_parametros.chasis,
			num_motor = v_parametros.num_motor,
			ult_kilometraje = v_parametros.ult_kilometraje,
			placa = v_parametros.placa,
			cilindrada_cc = v_parametros.cilindrada_cc,
			modem_id = v_parametros.modem_id,
			soat = v_parametros.soat,
			id_modelo = v_parametros.id_modelo,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_activo_datos_tec=v_parametros.id_activo_datos_tec;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Vehículos modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_activo_datos_tec',v_parametros.id_activo_datos_tec::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_VEHIC_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 22:47:06
	***********************************/

	elsif(p_transaccion='tgv_VEHIC_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_activo_datos_tec
            where id_activo_datos_tec=v_parametros.id_activo_datos_tec;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Vehículos eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_activo_datos_tec',v_parametros.id_activo_datos_tec::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION gev.f_tgv_activo_datos_tec_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1140 (class 1255 OID 3208511)
-- Dependencies: 90 2435
-- Name: f_tgv_activo_datos_tec_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_activo_datos_tec_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_activo_datos_tec_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_activo_datos_tec'
 AUTOR: 		 (rcm)
 FECHA:	        02-02-2012 22:47:06
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_activo_datos_tec_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_VEHIC_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 22:47:06
	***********************************/

	if(p_transaccion='tgv_VEHIC_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						vehic.id_activo_datos_tec,
						vehic.rend_litro_km,
						vehic.fecha_ult_km,
						vehic.estado_reg,
						vehic.id_activo_fijo,
						vehic.chasis,
						vehic.num_motor,
						vehic.ult_kilometraje,
						vehic.placa,
						vehic.cilindrada_cc,
						vehic.modem_id,
						vehic.soat,
						vehic.id_modelo,
						vehic.id_usuario_reg,
						vehic.fecha_reg,
						vehic.id_usuario_mod,
						vehic.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        (actif.codigo || '' - '' || actif.descripcion)::varchar as desc_activo_fijo	,
                        model.modelo,
                        marca.marca,
                        marca.id_marca
						from gev.tgv_activo_datos_tec vehic
                        inner join actif.taf_activo_fijo actif on actif.id_activo_fijo = vehic.id_activo_fijo
                        inner join gev.tgv_modelo model on model.id_modelo = vehic.id_modelo
                        inner join gev.tgv_marca marca on marca.id_marca = model.id_marca
						inner join segu.tusuario usu1 on usu1.id_usuario = vehic.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = vehic.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_VEHIC_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 22:47:06
	***********************************/

	elsif(p_transaccion='tgv_VEHIC_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_activo_datos_tec)
					    from gev.tgv_activo_datos_tec vehic
                        inner join gev.tgv_modelo model on model.id_modelo = vehic.id_modelo
                        inner join gev.tgv_marca marca on marca.id_marca = model.id_marca
                        inner join actif.taf_activo_fijo actif on actif.id_activo_fijo = vehic.id_activo_fijo
					    inner join segu.tusuario usu1 on usu1.id_usuario = vehic.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = vehic.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gev.f_tgv_activo_datos_tec_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1141 (class 1255 OID 3208512)
-- Dependencies: 2435 90
-- Name: f_tgv_activo_fijo_rastreo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_activo_fijo_rastreo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_activo_fijo_rastreo_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_activo_fijo_rastreo'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 15:47:13
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_activo_fijo_rastreo	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_activo_fijo_rastreo_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_AFR_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 15:47:13
	***********************************/

	if(p_transaccion='tgv_AFR_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_activo_fijo_rastreo(
			id_empleado,
			estado_reg,
			fecha_servidor,
			aux2,
			fecha_satelite,
			curso,
			fecha_hora,
			aux1,
			odometro,
			mensaje,
			hora_gps,
			velocidad,
			advisories,
			longitud,
			id_activo_fijo,
			dia,
			aux3,
			punto_cercano,
			altitud,
			ciudad,
			numero_actualizado,
			estado,
			aux4,
			latitud,
			events,
			mes,
			anio,
			calle,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_empleado,
			'activo',
			v_parametros.fecha_servidor,
			v_parametros.aux2,
			v_parametros.fecha_satelite,
			v_parametros.curso,
			v_parametros.fecha_hora,
			v_parametros.aux1,
			v_parametros.odometro,
			v_parametros.mensaje,
			v_parametros.hora_gps,
			v_parametros.velocidad,
			v_parametros.advisories,
			v_parametros.longitud,
			v_parametros.id_activo_fijo,
			v_parametros.dia,
			v_parametros.aux3,
			v_parametros.punto_cercano,
			v_parametros.altitud,
			v_parametros.ciudad,
			v_parametros.numero_actualizado,
			v_parametros.estado,
			v_parametros.aux4,
			v_parametros.latitud,
			v_parametros.events,
			v_parametros.mes,
			v_parametros.anio,
			v_parametros.calle,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_activo_fijo_rastreo into v_id_activo_fijo_rastreo;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Rastreo almacenado(a) con exito (id_activo_fijo_rastreo'||v_id_activo_fijo_rastreo||')'); 
            v_resp = f_agrega_clave(v_resp,'id_activo_fijo_rastreo',v_id_activo_fijo_rastreo::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_AFR_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 15:47:13
	***********************************/

	elsif(p_transaccion='tgv_AFR_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_activo_fijo_rastreo set
			id_empleado = v_parametros.id_empleado,
			fecha_servidor = v_parametros.fecha_servidor,
			aux2 = v_parametros.aux2,
			fecha_satelite = v_parametros.fecha_satelite,
			curso = v_parametros.curso,
			fecha_hora = v_parametros.fecha_hora,
			aux1 = v_parametros.aux1,
			odometro = v_parametros.odometro,
			mensaje = v_parametros.mensaje,
			hora_gps = v_parametros.hora_gps,
			velocidad = v_parametros.velocidad,
			advisories = v_parametros.advisories,
			longitud = v_parametros.longitud,
			id_activo_fijo = v_parametros.id_activo_fijo,
			dia = v_parametros.dia,
			aux3 = v_parametros.aux3,
			punto_cercano = v_parametros.punto_cercano,
			altitud = v_parametros.altitud,
			ciudad = v_parametros.ciudad,
			numero_actualizado = v_parametros.numero_actualizado,
			estado = v_parametros.estado,
			aux4 = v_parametros.aux4,
			latitud = v_parametros.latitud,
			events = v_parametros.events,
			mes = v_parametros.mes,
			anio = v_parametros.anio,
			calle = v_parametros.calle,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_activo_fijo_rastreo=v_parametros.id_activo_fijo_rastreo;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Rastreo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_activo_fijo_rastreo',v_parametros.id_activo_fijo_rastreo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_AFR_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 15:47:13
	***********************************/

	elsif(p_transaccion='tgv_AFR_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_activo_fijo_rastreo
            where id_activo_fijo_rastreo=v_parametros.id_activo_fijo_rastreo;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Rastreo eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_activo_fijo_rastreo',v_parametros.id_activo_fijo_rastreo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION gev.f_tgv_activo_fijo_rastreo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1142 (class 1255 OID 3208514)
-- Dependencies: 90 2435
-- Name: f_tgv_activo_fijo_rastreo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_activo_fijo_rastreo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_activo_fijo_rastreo_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_activo_fijo_rastreo'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 15:47:13
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_activo_fijo_rastreo_sel';
    v_parametros = f_get_record(p_tabla);
    
    /*********************************    
 	#TRANSACCION:  'TGV_AFRDET_SEL'
 	#DESCRIPCION:	Consulta el total de los datos de la posicion del vehiculos
                    para mostrar en mapa  (no tiene COUNT ni paginacion)
 	#AUTOR:		RAC	
 	#FECHA:		03-02-2012 15:47:13
    ***********************************/

	if(p_transaccion='TGV_AFRDET_SEL')then
     				
    	begin
    		--Sentencia de la consulta
            IF (v_parametros.fecha_fin is NULL or v_parametros.fecha_fin is NULL) then
	            raise exception 'los datos de fecha no pueden ser nulos';
            end if;
            
			v_consulta:='   select 
						afr.id_activo_fijo_rastreo,
                        afr.id_funcionario,
						afr.fecha_satelite,
						afr.curso,
                        afr.velocidad,
						afr.longitud,
						afr.id_activo_fijo,
                        afr.punto_cercano,
						afr.altitud,
						afr.latitud,
                        f.desc_funcionario1
                        from gev.tgv_activo_fijo_rastreo afr
                        left join rhum.vfuncionario f 
                        on afr.id_funcionario = f.id_funcionario
						where  id_activo_fijo='||v_parametros.id_activo_fijo ||'
                          and fecha_satelite::date <=  '''||v_parametros.fecha_fin||''' 
                          and fecha_satelite::date >= '''||v_parametros.fecha_ini||''' 
                      
                        order by afr.fecha_satelite DESC';
                        
                         

			--Devuelve la respuesta
            
            raise notice '%',v_consulta;
			return v_consulta;
						
		end;
    

	/*********************************    
 	#TRANSACCION:  'tgv_AFR_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 15:47:13
    ***********************************/

	elseif(p_transaccion='tgv_AFR_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						afr.id_activo_fijo_rastreo,
						afr.id_empleado,
						afr.estado_reg,
						afr.fecha_servidor,
						afr.aux2,
						afr.fecha_satelite,
						afr.curso,
						afr.fecha_hora,
						afr.aux1,
						afr.odometro,
						afr.mensaje,
						afr.hora_gps,
						afr.velocidad,
						afr.advisories,
						afr.longitud,
						afr.id_activo_fijo,
						afr.dia,
						afr.aux3,
						afr.punto_cercano,
						afr.altitud,
						afr.ciudad,
						afr.numero_actualizado,
						afr.estado,
						afr.aux4,
						afr.latitud,
						afr.events,
						afr.mes,
						afr.anio,
						afr.calle,
						afr.id_usuario_reg,
						afr.fecha_reg,
						afr.id_usuario_mod,
						afr.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gev.tgv_activo_fijo_rastreo afr
						inner join segu.tusuario usu1 on usu1.id_usuario = afr.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = afr.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_AFR_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 15:47:13
	***********************************/

	elsif(p_transaccion='tgv_AFR_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_activo_fijo_rastreo)
					    from gev.tgv_activo_fijo_rastreo afr
					    inner join segu.tusuario usu1 on usu1.id_usuario = afr.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = afr.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gev.f_tgv_activo_fijo_rastreo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1148 (class 1255 OID 3208516)
-- Dependencies: 2435 90
-- Name: f_tgv_activo_fijo_ultimo_registro_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_activo_fijo_ultimo_registro_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_activo_fijo_ultimo_registro_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_activo_fijo_ultimo_registro'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 02:57:40
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_ultimo_registro	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_activo_fijo_ultimo_registro_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_urg_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 02:57:40
	***********************************/

	if(p_transaccion='tgv_urg_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_activo_fijo_ultimo_registro(
			id_empleado,
			estado_reg,
			aux2,
			curso,
			chofer,
			latitud,
			aux1,
			fecha_satelite,
			id_activo_fijo,
			aux3,
			aux4,
			velocidad,
			longitud,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_empleado,
			'activo',
			v_parametros.aux2,
			v_parametros.curso,
			v_parametros.chofer,
			v_parametros.latitud,
			v_parametros.aux1,
			v_parametros.fecha_satelite,
			v_parametros.id_activo_fijo,
			v_parametros.aux3,
			v_parametros.aux4,
			v_parametros.velocidad,
			v_parametros.longitud,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_ultimo_registro into v_id_ultimo_registro;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','ultimo_registro almacenado(a) con exito (id_ultimo_registro'||v_id_ultimo_registro||')'); 
            v_resp = f_agrega_clave(v_resp,'id_ultimo_registro',v_id_ultimo_registro::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_urg_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 02:57:40
	***********************************/

	elsif(p_transaccion='tgv_urg_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_activo_fijo_ultimo_registro set
			id_empleado = v_parametros.id_empleado,
			aux2 = v_parametros.aux2,
			curso = v_parametros.curso,
			chofer = v_parametros.chofer,
			latitud = v_parametros.latitud,
			aux1 = v_parametros.aux1,
			fecha_satelite = v_parametros.fecha_satelite,
			id_activo_fijo = v_parametros.id_activo_fijo,
			aux3 = v_parametros.aux3,
			aux4 = v_parametros.aux4,
			velocidad = v_parametros.velocidad,
			longitud = v_parametros.longitud,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_ultimo_registro=v_parametros.id_ultimo_registro;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','ultimo_registro modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_ultimo_registro',v_parametros.id_ultimo_registro::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_urg_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 02:57:40
	***********************************/

	elsif(p_transaccion='tgv_urg_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_activo_fijo_ultimo_registro
            where id_ultimo_registro=v_parametros.id_ultimo_registro;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','ultimo_registro eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_ultimo_registro',v_parametros.id_ultimo_registro::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION gev.f_tgv_activo_fijo_ultimo_registro_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1149 (class 1255 OID 3208517)
-- Dependencies: 2435 90
-- Name: f_tgv_activo_fijo_ultimo_registro_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_activo_fijo_ultimo_registro_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_activo_fijo_ultimo_registro_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_activo_fijo_ultimo_registro'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 02:57:40
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_activo_fijo_ultimo_registro_sel';
    v_parametros = f_get_record(p_tabla);
    
     /*********************************    
 	#TRANSACCION:  'TGV_AFRDETULT_SEL'
 	#DESCRIPCION:	Consulta el ultimo registro de la posicion del vehiculo
                    para mostrar en mapa  (no tiene COUNT ni paginacion)
 	#AUTOR:		RAC	
 	#FECHA:		03-02-2012 15:47:13
    ***********************************/

	if(p_transaccion='TGV_AFRDETULT_SEL')then
     				
    	begin
    		--Sentencia de la consulta
         
            
			v_consulta:='SELECT
		                afr.id_ultimo_registro,
                        afr.id_funcionario,
						afr.fecha_satelite,
						afr.curso,
                        afr.velocidad,
						afr.longitud,
						afr.id_activo_fijo,
                        afr.latitud,
                        f.desc_funcionario1,
                        afr.punto_cercano
                        from gev.tgv_activo_fijo_ultimo_registro afr
                        left join rhum.vfuncionario f 
                        on afr.id_funcionario = f.id_funcionario
						WHERE  id_activo_fijo in ('||COALESCE(v_parametros.id_activo_fijo,'0')||')
                        order by afr.fecha_satelite DESC';
           --Devuelve la respuesta
          
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_urg_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 02:57:40
	***********************************/

	elseif(p_transaccion='tgv_urg_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						urg.id_ultimo_registro,
						urg.id_empleado,
						urg.estado_reg,
						urg.aux2,
						urg.curso,
						urg.chofer,
						urg.latitud,
						urg.aux1,
						urg.fecha_satelite,
						urg.id_activo_fijo,
						urg.aux3,
						urg.aux4,
						urg.velocidad,
						urg.longitud,
						urg.id_usuario_reg,
						urg.fecha_reg,
						urg.id_usuario_mod,
						urg.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gev.tgv_activo_fijo_ultimo_registro urg
						inner join segu.tusuario usu1 on usu1.id_usuario = urg.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = urg.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_urg_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 02:57:40
	***********************************/

	elsif(p_transaccion='tgv_urg_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_ultimo_registro)
					    from gev.tgv_activo_fijo_ultimo_registro urg
					    inner join segu.tusuario usu1 on usu1.id_usuario = urg.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = urg.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gev.f_tgv_activo_fijo_ultimo_registro_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1159 (class 1255 OID 3208518)
-- Dependencies: 2435 90
-- Name: f_tgv_agrupacion_evento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_agrupacion_evento_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_agrupacion_evento_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_agrupacion_evento'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 19:07:27
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_agrupacion_evento	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_agrupacion_evento_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_aev_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 19:07:27
	***********************************/

	if(p_transaccion='tgv_aev_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_agrupacion_evento(
			estado_reg,
			id_agrupacion,
			id_evento,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.id_agrupacion,
			v_parametros.id_evento,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_agrupacion_evento into v_id_agrupacion_evento;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Agrupacion Evento almacenado(a) con exito (id_agrupacion_evento'||v_id_agrupacion_evento||')'); 
            v_resp = f_agrega_clave(v_resp,'id_agrupacion_evento',v_id_agrupacion_evento::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_aev_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 19:07:27
	***********************************/

	elsif(p_transaccion='tgv_aev_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_agrupacion_evento set
			id_agrupacion = v_parametros.id_agrupacion,
			id_evento = v_parametros.id_evento,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_agrupacion_evento=v_parametros.id_agrupacion_evento;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Agrupacion Evento modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_agrupacion_evento',v_parametros.id_agrupacion_evento::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_aev_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 19:07:27
	***********************************/

	elsif(p_transaccion='tgv_aev_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_agrupacion_evento
            where id_agrupacion_evento=v_parametros.id_agrupacion_evento;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Agrupacion Evento eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_agrupacion_evento',v_parametros.id_agrupacion_evento::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION gev.f_tgv_agrupacion_evento_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1156 (class 1255 OID 3208519)
-- Dependencies: 90 2435
-- Name: f_tgv_agrupacion_evento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_agrupacion_evento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_agrupacion_evento_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_agrupacion_evento'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 19:07:27
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_agrupacion_evento_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_aev_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 19:07:27
	***********************************/

	if(p_transaccion='tgv_aev_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						aev.id_agrupacion_evento,
						aev.estado_reg,
						aev.id_agrupacion,
						aev.id_evento,
						aev.id_usuario_reg,
						aev.fecha_reg,
						aev.id_usuario_mod,
						aev.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        eve.nombre as evento	
						from gev.tgv_agrupacion_evento aev
                        inner join gev.tgv_evento eve on eve.id_evento = aev.id_evento
						inner join segu.tusuario usu1 on usu1.id_usuario = aev.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = aev.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_aev_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 19:07:27
	***********************************/

	elsif(p_transaccion='tgv_aev_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_agrupacion_evento)
					    from gev.tgv_agrupacion_evento aev
                        inner join gev.tgv_evento eve on eve.id_evento = aev.id_evento
					    inner join segu.tusuario usu1 on usu1.id_usuario = aev.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = aev.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gev.f_tgv_agrupacion_evento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1160 (class 1255 OID 3208520)
-- Dependencies: 2435 90
-- Name: f_tgv_agrupacion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_agrupacion_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_agrupacion_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_agrupacion'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 16:12:10
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_agrupacion	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_agrupacion_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_agr_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 16:12:10
	***********************************/

	if(p_transaccion='tgv_agr_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_agrupacion(
			estado_reg,
			nombre,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.nombre,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_agrupacion into v_id_agrupacion;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Agrupacion almacenado(a) con exito (id_agrupacion'||v_id_agrupacion||')'); 
            v_resp = f_agrega_clave(v_resp,'id_agrupacion',v_id_agrupacion::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_agr_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 16:12:10
	***********************************/

	elsif(p_transaccion='tgv_agr_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_agrupacion set
			nombre = v_parametros.nombre,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_agrupacion=v_parametros.id_agrupacion;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Agrupacion modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_agrupacion',v_parametros.id_agrupacion::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_agr_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 16:12:10
	***********************************/

	elsif(p_transaccion='tgv_agr_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_agrupacion
            where id_agrupacion=v_parametros.id_agrupacion;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Agrupacion eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_agrupacion',v_parametros.id_agrupacion::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION gev.f_tgv_agrupacion_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1161 (class 1255 OID 3208521)
-- Dependencies: 90 2435
-- Name: f_tgv_agrupacion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_agrupacion_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_agrupacion_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_agrupacion'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 16:12:10
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_agrupacion_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_agr_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 16:12:10
	***********************************/

	if(p_transaccion='tgv_agr_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						agr.id_agrupacion,
						agr.estado_reg,
						agr.nombre,
						agr.id_usuario_reg,
						agr.fecha_reg,
						agr.id_usuario_mod,
						agr.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gev.tgv_agrupacion agr
						inner join segu.tusuario usu1 on usu1.id_usuario = agr.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = agr.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_agr_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 16:12:10
	***********************************/

	elsif(p_transaccion='tgv_agr_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_agrupacion)
					    from gev.tgv_agrupacion agr
					    inner join segu.tusuario usu1 on usu1.id_usuario = agr.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = agr.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gev.f_tgv_agrupacion_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1162 (class 1255 OID 3208522)
-- Dependencies: 2435 90
-- Name: f_tgv_bitacora_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_bitacora_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_bitacora_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_bitacora'
 AUTOR: 		 (rac)
 FECHA:	        02-02-2012 21:38:38
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_bitacora	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_bitacora_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_BIT_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:38:38
	***********************************/

	if(p_transaccion='tgv_BIT_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_bitacora(
			observaciones,
			estado_reg,
			id_servicio_det,
			combustible,
			combustible_lts,
			destino,
			origen,
			fecha,
			num_factura,
			importe,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.observaciones,
			'activo',
			v_parametros.id_servicio_det,
			v_parametros.combustible,
			v_parametros.combustible_lts,
			v_parametros.destino,
			v_parametros.origen,
			v_parametros.fecha,
			v_parametros.num_factura,
			v_parametros.importe,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_bitacora into v_id_bitacora;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Bitacora almacenado(a) con exito (id_bitacora'||v_id_bitacora||')'); 
            v_resp = f_agrega_clave(v_resp,'id_bitacora',v_id_bitacora::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_BIT_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:38:38
	***********************************/

	elsif(p_transaccion='tgv_BIT_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_bitacora set
			observaciones = v_parametros.observaciones,
			id_servicio_det = v_parametros.id_servicio_det,
			combustible = v_parametros.combustible,
			combustible_lts = v_parametros.combustible_lts,
			destino = v_parametros.destino,
			origen = v_parametros.origen,
			fecha = v_parametros.fecha,
			num_factura = v_parametros.num_factura,
			importe = v_parametros.importe,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_bitacora=v_parametros.id_bitacora;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Bitacora modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_bitacora',v_parametros.id_bitacora::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_BIT_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:38:38
	***********************************/

	elsif(p_transaccion='tgv_BIT_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_bitacora
            where id_bitacora=v_parametros.id_bitacora;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Bitacora eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_bitacora',v_parametros.id_bitacora::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION gev.f_tgv_bitacora_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1163 (class 1255 OID 3208523)
-- Dependencies: 90 2435
-- Name: f_tgv_bitacora_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_bitacora_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_bitacora_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_bitacora'
 AUTOR: 		 (rac)
 FECHA:	        02-02-2012 21:38:38
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_bitacora_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_BIT_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:38:38
	***********************************/

	if(p_transaccion='tgv_BIT_SEL')then
         				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						bit.id_bitacora,
						bit.observaciones,
						bit.estado_reg,
						bit.id_servicio_det,
						bit.combustible,
						bit.combustible_lts,
						bit.destino,
						bit.origen,
						bit.fecha,
						bit.num_factura,
						bit.importe,
						bit.id_usuario_reg,
						bit.fecha_reg,
						bit.id_usuario_mod,
						bit.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gev.tgv_bitacora bit
						inner join segu.tusuario usu1 on usu1.id_usuario = bit.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = bit.id_usuario_mod
				     where  ';
                        
                        
               --Definicion de la respuesta                    
            v_consulta:=v_consulta||v_parametros.filtro;
            if(public.f_existe_parametro(p_tabla,'id_servicio_det')) then
               v_consulta:=v_consulta || '  and  bit.id_servicio_det='||COALESCE(v_parametros.id_servicio_det,0);
            end if;          
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
             
            
             raise notice '%',v_consulta;


			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_BIT_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:38:38
	***********************************/

	elsif(p_transaccion='tgv_BIT_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_bitacora)
					    from gev.tgv_bitacora bit
					    inner join segu.tusuario usu1 on usu1.id_usuario = bit.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = bit.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;
             if(public.f_existe_parametro(p_tabla,'id_servicio_det')) then
               v_consulta:=v_consulta || ' and bit.id_servicio_det='||v_parametros.id_servicio_det;
            end if;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gev.f_tgv_bitacora_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1164 (class 1255 OID 3208524)
-- Dependencies: 2435 90
-- Name: f_tgv_distancia_entre_dos_puntos(numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_distancia_entre_dos_puntos(lat1 numeric, lon1 numeric, lat2 numeric, lon2 numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
  FACOS FLOAT;
  radio INT;
  RESULTADO FLOAT;
BEGIN
	radio := 6378; -- RADIO DE LA TIERRA EN Km. ECUATORIAL
    FACOS := SIN(RADIANS(LON1)) * SIN( RADIANS(LON2)) + COS(RADIANS(LON1)) * COS(RADIANS(LON2)) * COS(RADIANS(LAT1) -  RADIANS(LAT2));

    IF FACOS > 1 then
        FACOS := 1;
    end if;
    IF FACOS < -1 then
        FACOS := -1;
	end if;
    
    RESULTADO := (Acos(FACOS) * RADIO);
    
    return resultado;
END;
$$;


ALTER FUNCTION gev.f_tgv_distancia_entre_dos_puntos(lat1 numeric, lon1 numeric, lat2 numeric, lon2 numeric) OWNER TO rchumacero;

--
-- TOC entry 1166 (class 1255 OID 3208525)
-- Dependencies: 2435 90
-- Name: f_tgv_evento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_evento_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_evento_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_evento'
 AUTOR: 		 (rcm)
 FECHA:	        02-02-2012 01:22:03
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_evento	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_evento_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_EVENT_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:22:03
	***********************************/

	if(p_transaccion='tgv_EVENT_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_evento(
			estado_reg,
			descripcion,
			nombre,
			id_tipo_evento,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.descripcion,
			v_parametros.nombre,
			v_parametros.id_tipo_evento,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_evento into v_id_evento;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Evento almacenado(a) con exito (id_evento'||v_id_evento||')'); 
            v_resp = f_agrega_clave(v_resp,'id_evento',v_id_evento::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_EVENT_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:22:03
	***********************************/

	elsif(p_transaccion='tgv_EVENT_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_evento set
			descripcion = v_parametros.descripcion,
			nombre = v_parametros.nombre,
			id_tipo_evento = v_parametros.id_tipo_evento,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_evento=v_parametros.id_evento;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Evento modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_evento',v_parametros.id_evento::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_EVENT_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:22:03
	***********************************/

	elsif(p_transaccion='tgv_EVENT_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_evento
            where id_evento=v_parametros.id_evento;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Evento eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_evento',v_parametros.id_evento::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION gev.f_tgv_evento_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1167 (class 1255 OID 3208526)
-- Dependencies: 2435 90
-- Name: f_tgv_evento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_evento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_evento_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_evento'
 AUTOR: 		 (rcm)
 FECHA:	        02-02-2012 01:22:03
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_evento_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_EVENT_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:22:03
	***********************************/

	if(p_transaccion='tgv_EVENT_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						event.id_evento,
						event.estado_reg,
						event.descripcion,
						event.nombre,
						event.id_tipo_evento,
						event.id_usuario_reg,
						event.fecha_reg,
						event.id_usuario_mod,
						event.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gev.tgv_evento event
						inner join segu.tusuario usu1 on usu1.id_usuario = event.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = event.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_EVENT_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:22:03
	***********************************/

	elsif(p_transaccion='tgv_EVENT_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_evento)
					    from gev.tgv_evento event
					    inner join segu.tusuario usu1 on usu1.id_usuario = event.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = event.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gev.f_tgv_evento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1170 (class 1255 OID 3208527)
-- Dependencies: 2435 90
-- Name: f_tgv_iboton_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_iboton_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_iboton_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_iboton'
 AUTOR: 		 (rcm)
 FECHA:	        04-02-2012 19:23:49
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_iboton				integer;
    v_id_funcionario		integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_iboton_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_IBUT_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rcm	
 	#FECHA:		04-02-2012 19:23:49
	***********************************/

	if(p_transaccion='tgv_IBUT_INS')then
					
        begin
        	--Verifica que no duplique funcionario ni codigo
            if exists(select 1 from gev.tgv_iboton
            		where id_funcionario = v_parametros.id_funcionario) then
            	raise exception 'El funcionario ya fue registrado anteriormente.';
            end if;
            if exists(select 1 from gev.tgv_iboton
            		where codigo = v_parametros.codigo) then
            	raise exception 'El Código ya fue asignado a otro Funcionario.';
            end if;
        	--Sentencia de la insercion
        	insert into gev.tgv_iboton(
			id_funcionario,
			codigo,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_funcionario,
			v_parametros.codigo,
			'activo',
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_iboton into v_id_iboton;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Ibutton almacenado(a) con exito (id_iboton'||v_id_iboton||')'); 
            v_resp = f_agrega_clave(v_resp,'id_iboton',v_id_iboton::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_IBUT_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		04-02-2012 19:23:49
	***********************************/

	elsif(p_transaccion='tgv_IBUT_MOD')then

		begin
        	--Obtiene el id_funciionario almacenado para verificar que no duplique
            select id_funcionario into v_id_funcionario from gev.tgv_iboton where id_iboton = v_parametros.id_iboton;
            
        	--Verifica que no duplique funcionario ni codigo
            if v_id_funcionario <> v_parametros.id_funcionario then
                if exists(select 1 from gev.tgv_iboton
                        where id_funcionario = v_parametros.id_funcionario) then
                    raise exception 'El funcionario ya fue registrado anteriormente.';
                end if;
            end if;
            if exists(select 1 from gev.tgv_iboton
            		where codigo = v_parametros.codigo
                    and id_funcionario <> v_id_funcionario) then
            	raise exception 'El Código ya fue asignado a otro Funcionario.';
            end if;
            
            
			--Sentencia de la modificacion
			update gev.tgv_iboton set
			id_funcionario = v_parametros.id_funcionario,
			codigo = v_parametros.codigo,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_iboton=v_parametros.id_iboton;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Ibutton modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_iboton',v_parametros.id_iboton::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_IBUT_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		04-02-2012 19:23:49
	***********************************/

	elsif(p_transaccion='tgv_IBUT_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_iboton
            where id_iboton=v_parametros.id_iboton;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Ibutton eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_iboton',v_parametros.id_iboton::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION gev.f_tgv_iboton_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1171 (class 1255 OID 3208528)
-- Dependencies: 90 2435
-- Name: f_tgv_iboton_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_iboton_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_iboton_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_iboton'
 AUTOR: 		 (rcm)
 FECHA:	        04-02-2012 19:23:49
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_iboton_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_IBUT_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rcm	
 	#FECHA:		04-02-2012 19:23:49
	***********************************/

	if(p_transaccion='tgv_IBUT_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						ibut.id_iboton,
						ibut.id_funcionario,
						ibut.codigo,
						ibut.estado_reg,
						ibut.id_usuario_reg,
						ibut.fecha_reg,
						ibut.id_usuario_mod,
						ibut.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        emplea.desc_funcionario1 as desc_funcionario
						from gev.tgv_iboton ibut
                        inner join rhum.vfuncionario emplea on emplea.id_funcionario=ibut.id_funcionario
						inner join segu.tusuario usu1 on usu1.id_usuario = ibut.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ibut.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_IBUT_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rcm	
 	#FECHA:		04-02-2012 19:23:49
	***********************************/

	elsif(p_transaccion='tgv_IBUT_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_iboton)
					    from gev.tgv_iboton ibut
                        inner join rhum.vfuncionario emplea on emplea.id_funcionario=ibut.id_funcionario
					    inner join segu.tusuario usu1 on usu1.id_usuario = ibut.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ibut.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gev.f_tgv_iboton_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1172 (class 1255 OID 3208529)
-- Dependencies: 90 2435
-- Name: f_tgv_mantenimiento_det_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_mantenimiento_det_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_mantenimiento_det_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_mantenimiento_det'
 AUTOR: 		 (rcm)
 FECHA:	        03-02-2012 20:37:16
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_mantenimiento_det	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_mantenimiento_det_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_DETMAN_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:37:16
	***********************************/

	if(p_transaccion='tgv_DETMAN_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_mantenimiento_det(
			id_activo_fijo,
			id_evento,
			descripcion,
			estado_reg,
			id_mantenimiento,
			estado,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_activo_fijo,
			v_parametros.id_evento,
			v_parametros.descripcion,
			'activo',
			v_parametros.id_mantenimiento,
			v_parametros.estado,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_mantenimiento_det into v_id_mantenimiento_det;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Mantenmiento almacenado(a) con exito (id_mantenimiento_det'||v_id_mantenimiento_det||')'); 
            v_resp = f_agrega_clave(v_resp,'id_mantenimiento_det',v_id_mantenimiento_det::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_DETMAN_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:37:16
	***********************************/

	elsif(p_transaccion='tgv_DETMAN_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_mantenimiento_det set
			id_activo_fijo = v_parametros.id_activo_fijo,
			id_evento = v_parametros.id_evento,
			descripcion = v_parametros.descripcion,
			id_mantenimiento = v_parametros.id_mantenimiento,
			estado = v_parametros.estado,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_mantenimiento_det=v_parametros.id_mantenimiento_det;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Mantenmiento modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_mantenimiento_det',v_parametros.id_mantenimiento_det::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_DETMAN_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:37:16
	***********************************/

	elsif(p_transaccion='tgv_DETMAN_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_mantenimiento_det
            where id_mantenimiento_det=v_parametros.id_mantenimiento_det;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Mantenmiento eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_mantenimiento_det',v_parametros.id_mantenimiento_det::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION gev.f_tgv_mantenimiento_det_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1173 (class 1255 OID 3208530)
-- Dependencies: 2435 90
-- Name: f_tgv_mantenimiento_det_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_mantenimiento_det_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_mantenimiento_det_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_mantenimiento_det'
 AUTOR: 		 (rcm)
 FECHA:	        03-02-2012 20:37:16
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_mantenimiento_det_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_DETMAN_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:37:16
	***********************************/

	if(p_transaccion='tgv_DETMAN_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						detman.id_mantenimiento_det,
						detman.id_activo_fijo,
						detman.id_evento,
						detman.descripcion,
						detman.estado_reg,
						detman.id_mantenimiento,
						detman.estado,
						detman.id_usuario_reg,
						detman.fecha_reg,
						detman.id_usuario_mod,
						detman.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        (actif.codigo || '' - '' || actif.descripcion)::varchar as desc_activo_fijo,
                        event.nombre
						from gev.tgv_mantenimiento_det detman
                        inner join actif.taf_activo_fijo actif on actif.id_activo_fijo = detman.id_activo_fijo
                        inner join gev.tgv_evento event on event.id_evento = detman.id_evento
						inner join segu.tusuario usu1 on usu1.id_usuario = detman.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = detman.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_DETMAN_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:37:16
	***********************************/

	elsif(p_transaccion='tgv_DETMAN_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_mantenimiento_det)
					    from gev.tgv_mantenimiento_det detman
                        inner join actif.taf_activo_fijo actif on actif.id_activo_fijo = detman.id_activo_fijo
                        inner join gev.tgv_evento event on event.id_evento = detman.id_evento
					    inner join segu.tusuario usu1 on usu1.id_usuario = detman.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = detman.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gev.f_tgv_mantenimiento_det_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1180 (class 1255 OID 3208531)
-- Dependencies: 90 2435
-- Name: f_tgv_mantenimiento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_mantenimiento_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_mantenimiento_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_mantenimiento'
 AUTOR: 		 (rcm)
 FECHA:	        03-02-2012 20:09:09
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_mantenimiento	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_mantenimiento_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_man_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:09:09
	***********************************/

	if(p_transaccion='tgv_man_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_mantenimiento(
			id_tipo_evento,
			descripcion,
			id_proveedor,
			fecha_ini,
			fecha_fin,
			id_funcionario,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_tipo_evento,
			v_parametros.descripcion,
			v_parametros.id_proveedor,
			v_parametros.fecha_ini,
			v_parametros.fecha_fin,
			v_parametros.id_funcionario,
			'activo',
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_mantenimiento into v_id_mantenimiento;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Mantenimiento almacenado(a) con exito (id_mantenimiento'||v_id_mantenimiento||')'); 
            v_resp = f_agrega_clave(v_resp,'id_mantenimiento',v_id_mantenimiento::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_man_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:09:09
	***********************************/

	elsif(p_transaccion='tgv_man_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_mantenimiento set
			id_tipo_evento = v_parametros.id_tipo_evento,
			descripcion = v_parametros.descripcion,
			id_proveedor = v_parametros.id_proveedor,
			fecha_ini = v_parametros.fecha_ini,
			fecha_fin = v_parametros.fecha_fin,
			id_funcionario = v_parametros.id_funcionario,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_mantenimiento=v_parametros.id_mantenimiento;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Mantenimiento modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_mantenimiento',v_parametros.id_mantenimiento::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_man_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:09:09
	***********************************/

	elsif(p_transaccion='tgv_man_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_mantenimiento
            where id_mantenimiento=v_parametros.id_mantenimiento;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Mantenimiento eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_mantenimiento',v_parametros.id_mantenimiento::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION gev.f_tgv_mantenimiento_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1185 (class 1255 OID 3208532)
-- Dependencies: 2435 90
-- Name: f_tgv_mantenimiento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_mantenimiento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_mantenimiento_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_mantenimiento'
 AUTOR: 		 (rcm)
 FECHA:	        03-02-2012 20:09:09
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_mantenimiento_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_man_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:09:09
	***********************************/

	if(p_transaccion='tgv_man_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						man.id_mantenimiento,
						man.id_tipo_evento,
						man.descripcion,
						man.id_proveedor,
						man.fecha_ini,
						man.fecha_fin,
						man.id_funcionario,
						man.estado_reg,
						man.id_usuario_reg,
						man.fecha_reg,
						man.id_usuario_mod,
						man.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        prov.desc_proveedor,
                        fun.desc_funcionario1 as desc_person,
                        tipeve.nombre
						from gev.tgv_mantenimiento man
                        inner join param.vproveedor prov on prov.id_proveedor = man.id_proveedor
                        inner join rhum.vfuncionario fun on fun.id_funcionario = man.id_funcionario
                        inner join gev.tgv_tipo_evento tipeve on tipeve.id_tipo_evento = man.id_tipo_evento
						inner join segu.tusuario usu1 on usu1.id_usuario = man.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = man.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_man_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:09:09
	***********************************/

	elsif(p_transaccion='tgv_man_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_mantenimiento)
					    from gev.tgv_mantenimiento man
                        inner join param.vproveedor prov on prov.id_proveedor = man.id_proveedor
                        inner join rhum.vfuncionario fun on fun.id_funcionario = man.id_funcionario
                        inner join gev.tgv_tipo_evento tipeve on tipeve.id_tipo_evento = man.id_tipo_evento
					    inner join segu.tusuario usu1 on usu1.id_usuario = man.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = man.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gev.f_tgv_mantenimiento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1188 (class 1255 OID 3208533)
-- Dependencies: 2435 90
-- Name: f_tgv_marca_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_marca_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_marca_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_marca'
 AUTOR: 		 (rac)
 FECHA:	        01-02-2012 03:36:14
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_marca	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_marca_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_mar_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		01-02-2012 03:36:14
	***********************************/

	if(p_transaccion='tgv_mar_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_marca(
			estado_reg,
			procedencia,
			marca,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.procedencia,
			v_parametros.marca,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_marca into v_id_marca;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','marca almacenado(a) con exito (id_marca'||v_id_marca||')'); 
            v_resp = f_agrega_clave(v_resp,'id_marca',v_id_marca::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_mar_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		01-02-2012 03:36:14
	***********************************/

	elsif(p_transaccion='tgv_mar_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_marca set
			procedencia = v_parametros.procedencia,
			marca = v_parametros.marca,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_marca=v_parametros.id_marca;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','marca modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_marca',v_parametros.id_marca::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_mar_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		01-02-2012 03:36:14
	***********************************/

	elsif(p_transaccion='tgv_mar_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_marca
            where id_marca=v_parametros.id_marca;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','marca eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_marca',v_parametros.id_marca::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION gev.f_tgv_marca_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1190 (class 1255 OID 3208534)
-- Dependencies: 2435 90
-- Name: f_tgv_marca_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_marca_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_marca_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_marca'
 AUTOR: 		 (rac)
 FECHA:	        01-02-2012 03:36:14
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_marca_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_mar_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		01-02-2012 03:36:14
	***********************************/

	if(p_transaccion='tgv_mar_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						mar.id_marca,
						mar.estado_reg,
						mar.procedencia,
						mar.marca,
						mar.id_usuario_reg,
						mar.fecha_reg,
						mar.id_usuario_mod,
						mar.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gev.tgv_marca mar
						inner join segu.tusuario usu1 on usu1.id_usuario = mar.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = mar.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_mar_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		01-02-2012 03:36:14
	***********************************/

	elsif(p_transaccion='tgv_mar_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_marca)
					    from gev.tgv_marca mar
					    inner join segu.tusuario usu1 on usu1.id_usuario = mar.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = mar.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gev.f_tgv_marca_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1191 (class 1255 OID 3208535)
-- Dependencies: 2435 90
-- Name: f_tgv_modelo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_modelo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_modelo_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_modelo'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 01:44:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_modelo	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_modelo_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_mdl_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 01:44:30
	***********************************/

	if(p_transaccion='tgv_mdl_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_modelo(
			estado_reg,
			id_marca,
			descripcion,
			modelo,
			anio,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.id_marca,
			v_parametros.descripcion,
			v_parametros.modelo,
			v_parametros.anio,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_modelo into v_id_modelo;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','modelo almacenado(a) con exito (id_modelo'||v_id_modelo||')'); 
            v_resp = f_agrega_clave(v_resp,'id_modelo',v_id_modelo::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_mdl_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 01:44:30
	***********************************/

	elsif(p_transaccion='tgv_mdl_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_modelo set
			id_marca = v_parametros.id_marca,
			descripcion = v_parametros.descripcion,
			modelo = v_parametros.modelo,
			anio = v_parametros.anio,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_modelo=v_parametros.id_modelo;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','modelo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_modelo',v_parametros.id_modelo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_mdl_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 01:44:30
	***********************************/

	elsif(p_transaccion='tgv_mdl_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_modelo
            where id_modelo=v_parametros.id_modelo;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','modelo eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_modelo',v_parametros.id_modelo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION gev.f_tgv_modelo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1195 (class 1255 OID 3208536)
-- Dependencies: 90 2435
-- Name: f_tgv_modelo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_modelo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_modelo_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_modelo'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 01:44:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_modelo_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_mdl_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 01:44:30
	***********************************/

	if(p_transaccion='tgv_mdl_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						mdl.id_modelo,
						mdl.estado_reg,
						mdl.id_marca,
						mdl.descripcion,
						mdl.modelo,
						mdl.anio,
						mdl.id_usuario_reg,
						mdl.fecha_reg,
						mdl.id_usuario_mod,
						mdl.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gev.tgv_modelo mdl
						inner join segu.tusuario usu1 on usu1.id_usuario = mdl.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = mdl.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_mdl_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 01:44:30
	***********************************/

	elsif(p_transaccion='tgv_mdl_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_modelo)
					    from gev.tgv_modelo mdl
					    inner join segu.tusuario usu1 on usu1.id_usuario = mdl.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = mdl.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gev.f_tgv_modelo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1196 (class 1255 OID 3208537)
-- Dependencies: 90 2435
-- Name: f_tgv_obtenerFechaGPS(integer, integer); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION "f_tgv_obtenerFechaGPS"(v_date_time integer, v_gps_time integer) RETURNS timestamp without time zone
    LANGUAGE plpgsql
    AS $$
DECLARE
  pFechaAux timestamp;
  pFecha DATE;
  pStrAux varchar;
  g_registro record;
BEGIN
	pStrAux := 'SELECT TIMESTAMP ''01/01/1970 0:0:0.000'' + INTERVAL '||''''||(v_date_time-14400)::varchar || ' second''';
    
  	execute pStrAux into pFecha;
    
    pStrAux := 'SELECT TIMESTAMP '''|| pFecha::VARCHAR ||''' + INTERVAL '||''''||(v_gps_time)::varchar || ' second''';
    
    execute pStrAux into pFechaAux;
 
	return pFechaAux;
END;
$$;


ALTER FUNCTION gev."f_tgv_obtenerFechaGPS"(v_date_time integer, v_gps_time integer) OWNER TO rchumacero;

--
-- TOC entry 1197 (class 1255 OID 3208538)
-- Dependencies: 90 2435
-- Name: f_tgv_servicio_det_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_servicio_det_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_servicio_det_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_servicio_det'
 AUTOR: 		 (rac)
 FECHA:	        02-02-2012 21:56:04
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_servicio_det	integer;    
    
    v_fecha_ini         date;
    v_fecha_fin         date;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_servicio_det_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_SDE_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:56:04
	***********************************/

	if(p_transaccion='tgv_SDE_INS')then
					
        begin     
        select fecha_asig_ini , fecha_asig_fin 
            into v_fecha_ini, v_fecha_fin
            from gev.tgv_servicio 
            where id_servicio=v_parametros.id_servicio;  
            
            if exists (select 1 from gev.tgv_servicio s inner join gev.tgv_servicio_det sd
            on sd.id_servicio=s.id_servicio where  s.estado!='concluido' and sd.id_funcionario=v_parametros.id_funcionario 
            and v_fecha_ini < s.fecha_asig_fin) then
               raise exception 'Asignacion no realizada. El funcionario tiene servicios pendientes sin concluir';  
            end if;                                                                
            
            
            --validar que el kilometraje ini no sea mayor al kilometraje fin
            if(v_parametros.kilometraje_fin<v_parametros.kilometraje_ini) then
              raise exception 'Asignacion no realizada. Revise la cantidad de kilometraje registrado';
            end if;
        
        	--Sentencia de la insercion
        	insert into gev.tgv_servicio_det(
			estado_reg,
			kilometraje_ini,
			id_activo_fijo,
			id_funcionario,
			id_servicio,
			kilometraje_fin,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.kilometraje_ini,
			v_parametros.id_activo_fijo,
			v_parametros.id_funcionario,
			v_parametros.id_servicio,
			v_parametros.kilometraje_fin,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_servicio_det into v_id_servicio_det;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','servicio_det almacenado(a) con exito (id_servicio_det'||v_id_servicio_det||')'); 
            v_resp = f_agrega_clave(v_resp,'id_servicio_det',v_id_servicio_det::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_SDE_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:56:04
	***********************************/

	elsif(p_transaccion='tgv_SDE_MOD')then

		begin
			--Sentencia de la modificacion   
            --verificar que el reponsable(funcionario) a asignar no esté en algun detalle servicio activo en el rango de fechas de la asignacion 
            select fecha_asig_ini , fecha_asig_fin 
            into v_fecha_ini, v_fecha_fin
            from gev.tgv_servicio 
            where id_servicio=v_parametros.id_servicio;  
            
            if exists (select 1 from gev.tgv_servicio s inner join gev.tgv_servicio_det sd
            on sd.id_servicio=s.id_servicio where  s.estado!='concluido' and sd.id_funcionario=v_parametros.id_funcionario 
            and v_fecha_ini < s.fecha_asig_fin and s.id_servicio!=v_parametros.id_servicio) then
               raise exception 'Asignacion no realizada. El funcionario tiene servicios pendientes sin concluir';  
            end if;                                                                
            
            
            --validar que el kilometraje ini no sea mayor al kilometraje fin
            if(v_parametros.kilometraje_fin<v_parametros.kilometraje_ini) then
              raise exception 'Asignacion no realizada. Revise la cantidad de kilometraje registrado';
            end if; 
            
			update gev.tgv_servicio_det set
			kilometraje_ini = v_parametros.kilometraje_ini,
			id_activo_fijo = v_parametros.id_activo_fijo,
			id_funcionario = v_parametros.id_funcionario,
			id_servicio = v_parametros.id_servicio,
			kilometraje_fin = v_parametros.kilometraje_fin,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_servicio_det=v_parametros.id_servicio_det;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','servicio_det modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_servicio_det',v_parametros.id_servicio_det::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_SDE_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:56:04
	***********************************/

	elsif(p_transaccion='tgv_SDE_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_servicio_det
            where id_servicio_det=v_parametros.id_servicio_det;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','servicio_det eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_servicio_det',v_parametros.id_servicio_det::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION gev.f_tgv_servicio_det_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1199 (class 1255 OID 3208540)
-- Dependencies: 2435 90
-- Name: f_tgv_servicio_det_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_servicio_det_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_servicio_det_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_servicio_det'
 AUTOR: 		 (rac)
 FECHA:	        02-02-2012 21:56:04
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_servicio_det_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_SDE_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:56:04
	***********************************/

	if(p_transaccion='tgv_SDE_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						sde.id_servicio_det,
						sde.estado_reg,
						sde.kilometraje_ini,
						sde.id_activo_fijo,
						sde.id_funcionario,
						sde.id_servicio,
						sde.kilometraje_fin,
						sde.id_usuario_reg,
						sde.fecha_reg,
						sde.id_usuario_mod,
						sde.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        f.desc_funcionario1,
                        adt.desc_activo_fijo
						from gev.tgv_servicio_det sde
						inner join segu.tusuario usu1 on usu1.id_usuario = sde.id_usuario_reg
                        inner join rhum.vfuncionario f on sde.id_funcionario = f.id_funcionario
                        inner join gev.vgv_activo_datos_tec adt on adt.id_activo_fijo=sde.id_activo_fijo
						left join segu.tusuario usu2 on usu2.id_usuario = sde.id_usuario_mod
				        where  ';   
                        
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;         
            
            if(public.f_existe_parametro(p_tabla,'tipo_interfaz')) then
                if(v_parametros.tipo_interfaz='SERVICIODETREGISTRO')     then     --raise exception 'id%',v_parametros.id_servicio;
                     v_consulta:=v_consulta|| ' and sde.id_servicio='|| v_parametros.id_servicio;
                end if;
            end if;
            
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_SDE_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:56:04
	***********************************/

	elsif(p_transaccion='tgv_SDE_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_servicio_det)
					    from gev.tgv_servicio_det sde
						inner join segu.tusuario usu1 on usu1.id_usuario = sde.id_usuario_reg
                        inner join rhum.vfuncionario f on sde.id_funcionario = f.id_funcionario
                        inner join gev.vgv_activo_datos_tec adt on adt.id_activo_fijo=sde.id_activo_fijo
						left join segu.tusuario usu2 on usu2.id_usuario = sde.id_usuario_mod
				       where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;
             if(public.f_existe_parametro(p_tabla,'tipo_interfaz')) then
                if(v_parametros.tipo_interfaz='SERVICIODETREGISTRO')     then
                     v_consulta:=v_consulta|| ' and sde.id_servicio='|| v_parametros.id_servicio;
                end if;
            end if;
			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gev.f_tgv_servicio_det_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1200 (class 1255 OID 3208541)
-- Dependencies: 2435 90
-- Name: f_tgv_servicio_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_servicio_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_servicio_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_servicio'
 AUTOR: 		 (rcm)
 FECHA:	        02-02-2012 02:56:44
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_servicio	integer;
			    
BEGIN
                --  raise exception 'aa%',p_transaccion;
    v_nombre_funcion = 'gev.f_tgv_servicio_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_SERVIC_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 02:56:44
	***********************************/

	if(p_transaccion='tgv_SERVIC_INS')then
					
        begin
        
        	--Verifica que el aprobador no sea el mismo que el solicitante
            if v_parametros.id_funcionario = v_parametros.id_funcionario_autoriz then
            	raise exception 'El Aprobador no puede ser el mismo que el Solicitante.';
            end if;
            if v_parametros.fecha_sol_fin < v_parametros.fecha_sol_ini then
            	raise exception 'La fecha de finalización no puede ser anterior al a fecha de inicio.';
            end if;
            
        	--Sentencia de la insercion
        	insert into gev.tgv_servicio(
			estado,
			estado_reg,
			id_lugar_destino,
			id_ep,
			--fecha_asig_fin,
			fecha_sol_ini,
			descripcion,
			id_lugar_origen,
			cant_personas,
			fecha_sol_fin,
			id_funcionario,
		--	fecha_asig_ini,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod,
            id_funcionario_autoriz,
            observaciones
          	) values(
			'borrador',
			'activo',
			v_parametros.id_lugar_destino,
			v_parametros.id_ep,
			--v_parametros.fecha_asig_fin,
			v_parametros.fecha_sol_ini,
			v_parametros.descripcion,
			v_parametros.id_lugar_origen,
			v_parametros.cant_personas,
			v_parametros.fecha_sol_fin,
			v_parametros.id_funcionario,
			--v_parametros.fecha_asig_ini,
			p_id_usuario,
			now(),
			null,
			null,
            v_parametros.id_funcionario_autoriz,
            v_parametros.observaciones
			)RETURNING id_servicio into v_id_servicio;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Servicio almacenado(a) con exito (id_servicio'||v_id_servicio||')'); 
            v_resp = f_agrega_clave(v_resp,'id_servicio',v_id_servicio::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_SERVIC_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 02:56:44
	***********************************/

	elsif(p_transaccion='tgv_SERVIC_MOD')then

		begin
        	--Verifica que el aprobador no sea el mismo que el solicitante
            if v_parametros.id_funcionario = v_parametros.id_funcionario_autoriz then
            	raise exception 'El Aprobador no puede ser el mismo que el Solicitante.';
            end if;
            if v_parametros.fecha_sol_fin < v_parametros.fecha_sol_ini then
            	raise exception 'La fecha de finalización no puede ser anterior al a fecha de inicio.';
            end if;
             
			--Sentencia de la modificacion
			update gev.tgv_servicio set
			--estado = v_parametros.estado,
			id_lugar_destino = v_parametros.id_lugar_destino,
			id_ep = v_parametros.id_ep,
			--fecha_asig_fin = v_parametros.fecha_asig_fin,
			fecha_sol_ini = v_parametros.fecha_sol_ini,
			descripcion = v_parametros.descripcion,
			id_lugar_origen = v_parametros.id_lugar_origen,
			cant_personas = v_parametros.cant_personas,
			fecha_sol_fin = v_parametros.fecha_sol_fin,
			id_funcionario = v_parametros.id_funcionario,
			--fecha_asig_ini = v_parametros.fecha_asig_ini,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now(),
            id_funcionario_autoriz = v_parametros.id_funcionario_autoriz,
            observaciones = v_parametros.observaciones
			where id_servicio=v_parametros.id_servicio;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Servicio modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_servicio',v_parametros.id_servicio::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_SERVIC_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 02:56:44
	***********************************/

	elsif(p_transaccion='tgv_SERVIC_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_servicio
            where id_servicio=v_parametros.id_servicio;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Servicio eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_servicio',v_parametros.id_servicio::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
   
  elsif(p_transaccion='tgv_SERCAMEST_MOD')then

		begin
			--Sentencia de la eliminacion   
            
            IF(public.f_existe_parametro(p_tabla,'operacion')) then   
            
              if(v_parametros.operacion='fin_solicitud') then 
                update gev.tgv_servicio
                set estado='para_asig'
                where id_servicio=v_parametros.id_servicio;
              elsif(v_parametros.operacion='anterior') then  
                update gev.tgv_servicio
                set estado='borrador',
                fecha_asig_ini=null,
                fecha_asig_fin=null
                where id_servicio=v_parametros.id_servicio; 
              
              end if;
            end if;
            
			
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Servicio finalizado para asignacio(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_servicio',v_parametros.id_servicio::varchar);
              
            --Devuelve la respuesta
            return v_resp;
    
  
  
		end; 
  
  elsif(p_transaccion='tgv_DEFFECHA_MOD')then

		begin 
            IF NOT EXISTS ( select 1 from gev.tgv_servicio  where id_servicio=v_parametros.id_servicio and estado_reg!='para_asig') THEN      
               raise exception 'Definicion no realizada. El estado del servicio debe ser para_asig';
            END IF;      
             
            update gev.tgv_servicio
            set fecha_asig_ini=v_parametros.fecha_asig_ini,
            fecha_asig_fin  =   v_parametros.fecha_asig_fin
            where id_servicio=v_parametros.id_servicio;
            
             --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Asigancion de fechas realizado'); 
            v_resp = f_agrega_clave(v_resp,'id_servicio',v_parametros.id_servicio::varchar);
              
            --Devuelve la respuesta
            return v_resp;
        
        END;
  else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION gev.f_tgv_servicio_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1208 (class 1255 OID 3208543)
-- Dependencies: 2435 90
-- Name: f_tgv_servicio_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_servicio_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_servicio_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_servicio'
 AUTOR: 		 (rcm)
 FECHA:	        02-02-2012 02:56:44
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_servicio_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_SERVIC_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 02:56:44
	***********************************/

	if(p_transaccion='tgv_SERVIC_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						servic.id_servicio,
						servic.estado,
						servic.estado_reg,
						servic.id_lugar_destino,
						servic.id_ep,
						servic.fecha_asig_fin,
						servic.fecha_sol_ini,
						servic.descripcion,
						servic.id_lugar_origen,
						servic.cant_personas,
						servic.fecha_sol_fin,
						servic.id_funcionario,
						servic.fecha_asig_ini,
						servic.id_usuario_reg,
						servic.fecha_reg,
						servic.id_usuario_mod,
						servic.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	,
                        emplea.desc_funcionario1 as desc_funcionario,
                        lug_ini.nombre as desc_lugar_ini,
                        lug_des.nombre as desc_lugar_des,
                        servic.id_funcionario_autoriz,
                        servic.observaciones,
                        empaut.desc_funcionario1 as desc_funcionario_autoriz
                        from gev.tgv_servicio servic  
						inner join segu.tusuario usu1 on usu1.id_usuario = servic.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = servic.id_usuario_mod 
                        inner join rhum.vfuncionario emplea on emplea.id_funcionario=servic.id_funcionario
                        inner join rhum.vfuncionario empaut on empaut.id_funcionario=servic.id_funcionario_autoriz
                        inner join param.tlugar lug_ini on lug_ini.id_lugar=servic.id_lugar_origen
                        inner join param.tlugar lug_des on lug_des.id_lugar=servic.id_lugar_destino
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro; 
                         
            
            IF(public.f_existe_parametro(p_tabla,'tipo_interfaz')) then  -- raise exception 'aa%', v_parametros.tipo_interfaz;  
                if(v_parametros.tipo_interfaz='SOLICITUDSERVICIO') then
                   v_consulta:=v_consulta|| ' and servic.estado=''borrador'' ';
                end if;  
                
                 if(v_parametros.tipo_interfaz='GESTIONSERVICIO') then
                   v_consulta:=v_consulta|| ' and servic.estado=''para_asig'' ';
                end if; 
         
            
            END IF;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_SERVIC_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 02:56:44
	***********************************/

	elsif(p_transaccion='tgv_SERVIC_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_servicio)
					    from gev.tgv_servicio servic
					    inner join segu.tusuario usu1 on usu1.id_usuario = servic.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = servic.id_usuario_mod
                        inner join rhum.vfuncionario empaut on empaut.id_funcionario=servic.id_funcionario_autoriz
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gev.f_tgv_servicio_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1217 (class 1255 OID 3208544)
-- Dependencies: 2435 90
-- Name: f_tgv_testing_sel(integer); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_testing_sel(v_id_activo_fijo integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
  paux				INTEGER;
  pv_rec			RECORD;
  pRecorrido 		decimal(19, 2);
  pVelocidadMax 	decimal(19, 2);
  pVelocidadProm 	decimal(19, 2);
  pVMaxLatitud 		NUMERIC;
  pVMaxLongitud 	NUMERIC;
  pVMaxPuntoCercano varchar(150);
  pNroParadas 		INTEGER;
  pTiempoTotalMovimiento BIGINT;
  pTiempoTotalParado BIGINT;
  pVMaxFecha 		date;
  pPriMovFecha 		date;
  pPriMovLatitud 	NUMERIC;
  pPriMovLongitud 	NUMERIC;
  pPriMovPuntoCercano varchar(150);
  pUltMovFecha 		date;
  pUltMovLatitud 	NUMERIC;
  pUltMovLongitud 	NUMERIC;
  pUltMovPuntoCercano varchar(150);
BEGIN
   CREATE TEMPORARY TABLE v_resumenDia (
	id_activo_fijo INTEGER NOT NULL,
	Recorrido decimal(19, 2) NULL,
	VelocidadMax decimal(19, 2) NULL,
	VelocidadProm decimal(19, 2) NULL,
	VMaxLatitud NUMERIC NULL,
	VMaxLongitud NUMERIC NULL,
	VMaxPuntoCercano varchar(150) NULL,
	NroParadas INTEGER NULL,
	TiempoTotalMovimiento BIGINT NULL,
	TiempoTotalParado BIGINT NULL,
	VMaxFecha date NULL,
	PriMovFecha date NULL,
	PriMovLatitud NUMERIC NULL,
	PriMovLongitud NUMERIC NULL,
	PriMovPuntoCercano varchar(150) NULL,
	UltMovFecha date NULL,
	UltMovLatitud NUMERIC NULL,
	UltMovLongitud NUMERIC NULL,
	UltMovPuntoCercano varchar(150) NULL
  ) ON COMMIT DROP;

  CREATE TEMPORARY TABLE  TRAKING(  
    DATESATELITE TIMESTAMP,
    LONGITUDE NUMERIC, 
    LATITUDE NUMERIC, 
    SPEED NUMERIC, 
    PUNTO_CERCANO VARCHAR( 200 ) 
  )  ON COMMIT DROP;


  INSERT INTO TRAKING
  SELECT  fecha_satelite, longitud, latitud, velocidad, punto_cercano
			FROM gev.tgv_activo_fijo_rastreo  WHERE gev.tgv_activo_fijo_rastreo.id_activo_fijo =  v_id_activo_fijo
			ORDER BY  fecha_satelite;

  for pv_rec in select * from TRAKING loop
      return next pv_rec;
  end loop;
  
  return ;
END;
$$;


ALTER FUNCTION gev.f_tgv_testing_sel(v_id_activo_fijo integer) OWNER TO rchumacero;

--
-- TOC entry 1265 (class 1255 OID 3208545)
-- Dependencies: 2435 90
-- Name: f_tgv_tipo_evento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_tipo_evento_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_tipo_evento_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_tipo_evento'
 AUTOR: 		 (rcm)
 FECHA:	        02-02-2012 01:00:14
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_tipo_evento	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_tipo_evento_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_TIPEVE_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:00:14
	***********************************/

	if(p_transaccion='tgv_TIPEVE_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_tipo_evento(
			estado_reg,
			codigo,
			nombre,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.codigo,
			v_parametros.nombre,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_tipo_evento into v_id_tipo_evento;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Tipos de Eventos almacenado(a) con exito (id_tipo_evento'||v_id_tipo_evento||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_evento',v_id_tipo_evento::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_TIPEVE_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:00:14
	***********************************/

	elsif(p_transaccion='tgv_TIPEVE_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_tipo_evento set
			codigo = v_parametros.codigo,
			nombre = v_parametros.nombre,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_tipo_evento=v_parametros.id_tipo_evento;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipos de Eventos modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_evento',v_parametros.id_tipo_evento::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_TIPEVE_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:00:14
	***********************************/

	elsif(p_transaccion='tgv_TIPEVE_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_tipo_evento
            where id_tipo_evento=v_parametros.id_tipo_evento;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipos de Eventos eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_evento',v_parametros.id_tipo_evento::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION gev.f_tgv_tipo_evento_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1267 (class 1255 OID 3208546)
-- Dependencies: 90 2435
-- Name: f_tgv_tipo_evento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION f_tgv_tipo_evento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_tipo_evento_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_tipo_evento'
 AUTOR: 		 (rcm)
 FECHA:	        02-02-2012 01:00:14
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_tipo_evento_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_TIPEVE_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:00:14
	***********************************/

	if(p_transaccion='tgv_TIPEVE_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						tipeve.id_tipo_evento,
						tipeve.estado_reg,
						tipeve.codigo,
						tipeve.nombre,
						tipeve.id_usuario_reg,
						tipeve.fecha_reg,
						tipeve.id_usuario_mod,
						tipeve.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gev.tgv_tipo_evento tipeve
						inner join segu.tusuario usu1 on usu1.id_usuario = tipeve.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipeve.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_TIPEVE_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:00:14
	***********************************/

	elsif(p_transaccion='tgv_TIPEVE_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_evento)
					    from gev.tgv_tipo_evento tipeve
					    inner join segu.tusuario usu1 on usu1.id_usuario = tipeve.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipeve.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION gev.f_tgv_tipo_evento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1288 (class 1255 OID 3208547)
-- Dependencies: 2435 90
-- Name: ftrig_activo_fijo_rastreo(); Type: FUNCTION; Schema: gev; Owner: rchumacero
--

CREATE FUNCTION ftrig_activo_fijo_rastreo() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
    Pid_empleado	   		INTEGER;
    Pempleado				VARCHAR;
    Pid_ultimo_registro 	INTEGER;
    Pid_activo_fijo			INTEGER;
    Pcodigo_iboton			VARCHAR;
    Pcodigo_defecto			VARCHAR;
BEGIN

/***************************************************************************
 XPHS - GESTION INTERNA DE DATOS DE VEHICULOS
***************************************************************************
 SCRITP: 		ges.ftrig_activo_fijo_rastreo
 DESCRIPCION: 	Ingreso de registros a activo_fijo_rastreo
 AUTOR: 		Daniel Araki(dav)
 FECHA:			01/02/2012
 COMENTARIOS:
***************************************************************************
	1) descripcion luego
*/

Pcodigo_defecto := 'IB';
SELECT id_activo_fijo INTO Pid_activo_fijo FROM gev.tgv_activo_datos_tec WHERE MODEM_ID = NEW.aux1;

if ( Pid_activo_fijo IS NOT NULL ) then --si el codigo del activo existe, procedemos a realizar los procesos

SELECT gev.tgv_activo_fijo_ultimo_registro.id_ultimo_registro INTO Pid_ultimo_registro
FROM gev.tgv_activo_fijo_ultimo_registro
WHERE gev.tgv_activo_fijo_ultimo_registro.id_activo_fijo = Pid_activo_fijo;


--IDENTIFICACION DEL CHOFER EN BASE AL IBOTON
  if ( position(Pcodigo_defecto in NEW.mensaje) = 1) then --si el ha llegado un mensaje con el encabezado de IBOTON

    Pcodigo_iboton := substring(NEW.mensaje from '.....$'); --si sí, obtenemos el código
      --obtenemos el nombre del funcionario y su id en base al iboton
    SELECT  SEGU.tpersona.apellido_paterno || ' ' || SEGU.tpersona.nombre,
    rhum.tfuncionario.id_funcionario INTO Pempleado, Pid_empleado
    FROM SEGU.tpersona INNER JOIN rhum.tfuncionario
    ON segu.tpersona.id_persona = rhum.tfuncionario.id_persona
    INNER JOIN gev.tgv_iboton
    ON gev.tgv_iboton.id_empleado = rhum.tfuncionario.id_funcionario
    WHERE gev.tgv_iboton.codigo = Pcodigo_defecto;

  ELSE

  	SELECT gev.tgv_activo_fijo_ultimo_registro.chofer,
    gev.tgv_activo_fijo_ultimo_registro.id_funcionario INTO Pempleado, Pid_empleado
    FROM gev.tgv_activo_fijo_ultimo_registro
    WHERE gev.tgv_activo_fijo_ultimo_registro.id_activo_fijo = Pid_activo_fijo;

  end if;

  if (  Pid_ultimo_registro IS NULL) THEN
  	SELECT MAX(id_ultimo_registro) INTO pid_ultimo_registro FROM gev.tgv_activo_fijo_ultimo_registro;

    IF ( Pid_ultimo_registro IS NULL) THEN
      Pid_ultimo_registro := 0;
    ELSE
      Pid_ultimo_registro := Pid_ultimo_registro + 1;
    END IF;

  	INSERT INTO gev.tgv_activo_fijo_ultimo_registro
    (id_usuario_reg,id_usuario_mod,fecha_reg,fecha_mod,estado_reg,id_ultimo_registro,fecha_satelite,latitud,longitud,velocidad,curso,id_funcionario,chofer,id_activo_fijo,aux1,aux2,aux3,aux4,punto_cercano)
    VALUES
    (NULL, NULL, now(),now(),null, Pid_ultimo_registro, new.fecha_satelite, new.latitud, new.longitud,
	 new.velocidad,new.curso,Pid_empleado,Pempleado,Pid_activo_fijo,new.aux1,new.aux2,new.aux3,new.aux4,new.punto_cercano);
  else
      UPDATE gev.tgv_activo_fijo_ultimo_registro
      SET
        fecha_mod = now(),
        fecha_satelite = NEW.fecha_satelite,
        latitud = NEW.latitud,
        longitud = NEW.longitud,
        velocidad = NEW.velocidad,
        curso = NEW.curso,
        id_funcionario = Pid_empleado,
        chofer = Pempleado,
        aux1 = NEW.aux1,
        aux2 = NEW.aux2,
        aux3 = NEW.aux3,
        aux4 = NEW.aux4,
        punto_cercano = NEW.punto_cercano
      WHERE id_ultimo_registro = Pid_ultimo_registro;
  end if;

  UPDATE gev.tgv_activo_fijo_rastreo
  SET id_activo_fijo = Pid_activo_fijo
  WHERE id_activo_fijo_rastreo = NEW.id_activo_fijo_rastreo;

else
	if char_length(new.aux1)>0 then
    	raise exception 'No llego el Dato MODEM';
    else
	    raise exception 'Modem % no está registrado', NEW.aux1;
    end if;
end if;
 RETURN NEW;
END;
$_$;


ALTER FUNCTION gev.ftrig_activo_fijo_rastreo() OWNER TO rchumacero;

SET search_path = hidro, pg_catalog;

--
-- TOC entry 401 (class 1255 OID 1396076)
-- Dependencies: 45 2435
-- Name: f_thd_administrador_hidro_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: mflores
--

CREATE FUNCTION f_thd_administrador_hidro_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_administrador_hidro_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_rio'
 AUTOR: 		 (rac)
 FECHA:	        31-08-2011 15:32:32
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    		integer;
	v_parametros           		record;
	v_id_requerimiento     		integer;
	v_resp		            	varchar;
	v_nombre_funcion       	 	text;
	v_mensaje_error         	text;
	v_id_administrador			integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_administrador_hidro_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_ADM_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:			mflores	
 	#FECHA:			01-09-2011
	***********************************/

	if(p_transaccion='HD_ADM_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_administrador_hidro
            (
              codigo,
              estado_reg,
              hidro,
              meteo,
              nombre,
              fecha_reg,
              id_usuario_reg,
              fecha_mod,
              id_usuario_mod
          	) 
            values
            (
              v_parametros.codigo,
              'activo',
              v_parametros.hidro,
              v_parametros.meteo,
              v_parametros.nombre,
              now(),
              p_id_usuario,
              null,
              null
			)RETURNING id_administrador into v_id_administrador;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','ADMINISTRADOR almacenado(a) con exito (id_rio'||v_id_administrador||')'); 
            v_resp = f_agrega_clave(v_resp,'id_administrador',v_id_administrador::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_ADM_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:			mflores	
 	#FECHA:			01-09-2011
	***********************************/

	elsif(p_transaccion='HD_ADM_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_administrador_hidro set
			codigo = v_parametros.codigo,
            hidro = v_parametros.hidro,
			meteo = v_parametros.meteo,
			nombre = v_parametros.nombre,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_administrador =v_parametros.id_administrador;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','ADMINISTRADOR modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_administrador',v_parametros.id_administrador::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_ADM_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:			mflores	
 	#FECHA:			01-09-2011	
	***********************************/

	elsif(p_transaccion='HD_ADM_ELI')then

		begin
                
            --Sentencia de la eliminacion
			--delete from hidro.thd_administrador_hidro

            --mflores 03-10-11 estado inactivo en vez de eliminar el registro
            UPDATE hidro.thd_administrador_hidro
            SET estado_reg = 'inactivo'
            where id_administrador = v_parametros.id_administrador;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','ADMINISTRADOR eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_administrador',v_parametros.id_administrador::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_administrador_hidro_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO mflores;

--
-- TOC entry 375 (class 1255 OID 1396075)
-- Dependencies: 2435 45
-- Name: f_thd_administrador_hidro_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: mflores
--

CREATE FUNCTION f_thd_administrador_hidro_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_administrador_hidro_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'hidro.thd_administrador_hidro'
 AUTOR: 		mflores
 FECHA:	        01-09-2011
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_administrador_hidro_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_ADM_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			mflores	
 	#FECHA:			01-09-2011
	***********************************/

	if(p_transaccion='HD_ADM_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						admhd.id_administrador,
						admhd.codigo,
                        admhd.estado_reg,
                        admhd.hidro,
                        admhd.meteo,
                        admhd.nombre,
                        admhd.fecha_reg,
                        admhd.id_usuario_reg,
                        admhd.fecha_mod,
                        admhd.id_usuario_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod
						from hidro.thd_administrador_hidro admhd
						inner join segu.tusuario usu1 on usu1.id_usuario = admhd.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = admhd.id_usuario_mod
				        where admhd.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_ADM_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:			mflores	
 	#FECHA:			01-09-2011
	***********************************/

	elsif(p_transaccion='HD_ADM_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_administrador)
					    from hidro.thd_administrador_hidro admhd
					    inner join segu.tusuario usu1 on usu1.id_usuario = admhd.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = admhd.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_administrador_hidro_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO mflores;

--
-- TOC entry 1206 (class 1255 OID 2065589)
-- Dependencies: 45 2435
-- Name: f_thd_archivo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_archivo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_archivo_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_archivo'
 AUTOR: 		 (mflores)
 FECHA:	        23-11-2011 09:50:28
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_archivo	integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_archivo_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_ARCHIV_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:28
	***********************************/

	if(p_transaccion='HD_ARCHIV_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_archivo(
			id_operador,
			archivo_temp,
			nombre_archivo_real,
			fecha,
			id_tipo_archivo,
			estado_reg,
			obs,
			id_usuario_reg,
			fecha_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			v_parametros.id_operador,
			v_parametros.archivo_temp,
			v_parametros.nombre_archivo_real,
			v_parametros.fecha,
			v_parametros.id_tipo_archivo,
			'activo',
			v_parametros.obs,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_archivo into v_id_archivo;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Archivo almacenado(a) con exito (id_archivo'||v_id_archivo||')'); 
            v_resp = f_agrega_clave(v_resp,'id_archivo',v_id_archivo::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_ARCHIV_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:28
	***********************************/

	elsif(p_transaccion='HD_ARCHIV_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_archivo set
			id_operador = v_parametros.id_operador,
			archivo_temp = v_parametros.archivo_temp,
			nombre_archivo_real = v_parametros.nombre_archivo_real,
			fecha = v_parametros.fecha,
			id_tipo_archivo = v_parametros.id_tipo_archivo,
			obs = v_parametros.obs,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_archivo=v_parametros.id_archivo;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Archivo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_archivo',v_parametros.id_archivo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_ARCHIV_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:28
	***********************************/

	elsif(p_transaccion='HD_ARCHIV_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from hidro.thd_archivo
            where id_archivo=v_parametros.id_archivo;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Archivo eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_archivo',v_parametros.id_archivo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_archivo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1205 (class 1255 OID 2065657)
-- Dependencies: 2435 45
-- Name: f_thd_archivo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_archivo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_archivo_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_archivo'
 AUTOR: 		 (mflores)
 FECHA:	        23-11-2011 09:50:28
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_archivo_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_ARCHIV_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:28
	***********************************/

	if(p_transaccion='HD_ARCHIV_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						archiv.id_archivo,
						archiv.id_operador,
						archiv.archivo_temp,
						archiv.nombre_archivo_real,
						archiv.fecha,
						archiv.id_tipo_archivo,
						archiv.estado_reg,
						archiv.obs,
						archiv.id_usuario_reg,
						archiv.fecha_reg,
						archiv.fecha_mod,
						archiv.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from hidro.thd_archivo archiv
						inner join segu.tusuario usu1 on usu1.id_usuario = archiv.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = archiv.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_ARCHIV_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:28
	***********************************/

	elsif(p_transaccion='HD_ARCHIV_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_archivo)
					    from hidro.thd_archivo archiv
					    inner join segu.tusuario usu1 on usu1.id_usuario = archiv.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = archiv.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_archivo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1273 (class 1255 OID 2065662)
-- Dependencies: 45 2435
-- Name: f_thd_archivo_sensor_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_archivo_sensor_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_archivo_sensor_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_archivo_sensor'
 AUTOR: 		 (mflores)
 FECHA:	        23-11-2011 09:50:23
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_archivo_sensor	integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_archivo_sensor_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_ARSEN_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:23
	***********************************/

	if(p_transaccion='HD_ARSEN_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_archivo_sensor(
			id_sensor,
			orden,
			id_tipo_archivo,
			estado_reg,
			nombre_col_file,
			id_usuario_reg,
			fecha_reg,
			fecha_mod,
			id_usuario_mod,
            orden_col_fecha,
            nombre_col_fecha,
            orden_col_hora,
            nombre_col_hora
          	) values(
			v_parametros.id_sensor,
			v_parametros.orden,
			v_parametros.id_tipo_archivo,
			'activo',
			v_parametros.nombre_col_file,
			p_id_usuario,
			now(),
			null,
			null,
            v_parametros.orden_col_fecha,
            v_parametros.nombre_col_fecha,
            v_parametros.orden_col_hora,
            v_parametros.nombre_col_hora
			)RETURNING id_archivo_sensor into v_id_archivo_sensor;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Archivo Sensor almacenado(a) con exito (id_archivo_sensor'||v_id_archivo_sensor||')'); 
            v_resp = f_agrega_clave(v_resp,'id_archivo_sensor',v_id_archivo_sensor::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_ARSEN_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:23
	***********************************/

	elsif(p_transaccion='HD_ARSEN_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_archivo_sensor set
			id_sensor = v_parametros.id_sensor,
			orden = v_parametros.orden,
			id_tipo_archivo = v_parametros.id_tipo_archivo,
			nombre_col_file = v_parametros.nombre_col_file,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario,
            orden_col_fecha = v_parametros.orden_col_fecha,
            nombre_col_fecha = v_parametros.nombre_col_fecha,
            orden_col_hora = v_parametros.orden_col_hora,
            nombre_col_hora = v_parametros.nombre_col_hora
			where id_archivo_sensor=v_parametros.id_archivo_sensor;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Archivo Sensor modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_archivo_sensor',v_parametros.id_archivo_sensor::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_ARSEN_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:23
	***********************************/

	elsif(p_transaccion='HD_ARSEN_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from hidro.thd_archivo_sensor
            where id_archivo_sensor=v_parametros.id_archivo_sensor;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Archivo Sensor eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_archivo_sensor',v_parametros.id_archivo_sensor::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_archivo_sensor_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1209 (class 1255 OID 2065750)
-- Dependencies: 2435 45
-- Name: f_thd_archivo_sensor_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_archivo_sensor_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_archivo_sensor_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_archivo_sensor'
 AUTOR: 		 (mflores)
 FECHA:	        23-11-2011 09:50:23
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_archivo_sensor_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_ARSEN_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:23
	***********************************/

	if(p_transaccion='HD_ARSEN_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						arsen.id_archivo_sensor,
						arsen.id_sensor,
						arsen.orden,
						arsen.id_tipo_archivo,
						arsen.estado_reg,
						arsen.nombre_col_file,
						arsen.id_usuario_reg,
						arsen.fecha_reg,
						arsen.fecha_mod,
						arsen.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        sen.codigo,
                        arsen.orden_col_fecha,
                        arsen.nombre_col_fecha,
                        arsen.orden_col_hora,
                        arsen.nombre_col_hora
						from hidro.thd_archivo_sensor arsen
						inner join segu.tusuario usu1 on usu1.id_usuario = arsen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = arsen.id_usuario_mod
                        inner join hidro.thd_tipo_archivo tipar on tipar.id_tipo_archivo = arsen.id_tipo_archivo
                        inner join hidro.thd_sensor sen on sen.id_sensor = arsen.id_sensor
				        where arsen.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_ARSEN_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:23
	***********************************/

	elsif(p_transaccion='HD_ARSEN_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_archivo_sensor)
					    from hidro.thd_archivo_sensor arsen
					    inner join segu.tusuario usu1 on usu1.id_usuario = arsen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = arsen.id_usuario_mod
                        inner join hidro.thd_tipo_archivo tipar on tipar.id_tipo_archivo = arsen.id_tipo_archivo
					    where arsen.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_archivo_sensor_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 256 (class 1255 OID 1377915)
-- Dependencies: 45 2435
-- Name: f_thd_cuenca_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: mflores
--

CREATE FUNCTION f_thd_cuenca_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		idro.ft_cuenca_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, 
 				modificaciones, eliminaciones de la tabla 'hidro.thd_cuenca'
 AUTOR: 		mflores
 FECHA:	        31-08-2011 10:20
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
    v_id_cuenca				integer;
    v_codigo_largo 			varchar;
    g_registros				record;
    v_sw					integer; 
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_cuenca_ime';
    v_parametros = f_get_record(p_tabla);
    
    --raise notice 'param: %',v_parametros;

	/*********************************    
 	#TRANSACCION:  'HID_CUENCA_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:			mflores	
 	#FECHA:			31-08-2011 10:20
	***********************************/

	if(p_transaccion='HID_CUENCA_INS')then
					
        begin
        
           --obtiene codigo recursivamente
            IF v_parametros.id_cuenca_fk is null THEN
               v_codigo_largo = v_parametros.codigo;
               raise notice 'cod_largo: %',v_codigo_largo;
            ELSE
            
             WITH RECURSIVE t(id,id_fk,cod,n) AS 
             (
                 SELECT l.id_cuenca,
                 		l.id_cuenca_fk, 
                        l.codigo,1 
                 FROM hidro.thd_cuenca l 
                 WHERE l.id_cuenca = v_parametros.id_cuenca_fk
                 UNION ALL
                 SELECT l.id_cuenca,
                 		l.id_cuenca_fk, 
                        l.codigo, 
                        n+1
                 FROM hidro.thd_cuenca l, t
                 WHERE l.id_cuenca = t.id_fk
            )
            SELECT textcat_all(a.cod||'.')
            into  v_codigo_largo
            FROM (SELECT  cod
                  FROM t 
                 order by n desc)  a;
                                  
               v_codigo_largo = v_codigo_largo||v_parametros.codigo;
            END IF;
            
            
        	--Sentencia de la insercion
        	insert into hidro.thd_cuenca
            (
              id_cuenca_fk,
              tipo_cuenca,
              nombre,
              codigo,
              codigo_largo,
              estado_reg,
              id_usuario_reg,
              id_usuario_mod,
              fecha_reg,			
              fecha_mod
          	) 
            values
            (
              v_parametros.id_cuenca_fk,
              v_parametros.tipo_cuenca,
              v_parametros.nombre,
              v_parametros.codigo,
              v_codigo_largo,
              'activo',
              p_id_usuario,
              null,
              now(),
              null  
            )RETURNING id_cuenca into v_id_cuenca;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Cuenca almacenado(a) con exito (id_cuenca'||v_id_cuenca||')'); 
            v_resp = f_agrega_clave(v_resp,'id_cuenca',v_id_cuenca::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HID_CUENCA_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:			mflores
 	#FECHA:			31-08-2011 11:20
	***********************************/

	elsif(p_transaccion='HID_CUENCA_MOD')then

		begin
        	
        	v_sw = 0;
            
            --raise exception  'PRUEBAa';
        
        	/*FOR g_registros in EXECUTE('select codigo from hidro.thd_cuenca') LOOP
            	
				IF (v_parametros.codigo = g_registros.codigo) THEN
                	
                	v_sw = 1; 
                    raise notice 'v_sw: %',v_sw;
                
                END IF;
            
            END LOOP;	
            
            IF (v_sw = 0) THEN*/
                                       
                --obtiene codigo recursivamente
                IF v_parametros.id_cuenca_fk is null THEN
                   v_codigo_largo = v_parametros.codigo;
                   raise notice 'cod_largo: %',v_codigo_largo;
                ELSE
                
                 WITH RECURSIVE t(id,id_fk,cod,n) AS 
                 (
                     SELECT l.id_cuenca,
                            l.id_cuenca_fk, 
                            l.codigo,1 
                     FROM hidro.thd_cuenca l 
                     WHERE l.id_cuenca = v_parametros.id_cuenca_fk
                     UNION ALL
                     SELECT l.id_cuenca,
                            l.id_cuenca_fk, 
                            l.codigo, 
                            n+1
                     FROM hidro.thd_cuenca l, t
                     WHERE l.id_cuenca = t.id_fk
                )
                SELECT textcat_all(a.cod||'.')
                into  v_codigo_largo
                FROM (SELECT  cod
                      FROM t 
                     order by n desc)  a;
                                      
                   v_codigo_largo = v_codigo_largo||v_parametros.codigo;
                END IF;
            
           
                --Sentencia de la modificacion
                update hidro.thd_cuenca set
                id_cuenca_fk = v_parametros.id_cuenca_fk,
                tipo_cuenca = v_parametros.tipo_cuenca,			
                nombre = v_parametros.nombre,
                fecha_mod = now(),
                codigo=v_parametros.codigo,
                id_usuario_mod = p_id_usuario,
                codigo_largo=v_codigo_largo
                where id_cuenca=v_parametros.id_cuenca;
                   
                --Definicion de la respuesta
                v_resp = f_agrega_clave(v_resp,'mensaje','Cuenca modificado(a)'); 
                v_resp = f_agrega_clave(v_resp,'id_cuenca',v_parametros.id_cuenca::varchar);
            /*
            ELSE
            	
                v_resp='';
                v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
                v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
                v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
                raise exception '%',v_resp;

            END IF;*/
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HID_CUENCA_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:			mflores	
 	#FECHA:			31-08-2011 11:36
	***********************************/

	elsif(p_transaccion='HID_CUENCA_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from hidro.thd_cuenca
            where id_cuenca=v_parametros.id_cuenca;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Cuenca eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_cuenca',v_parametros.id_cuenca::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_cuenca_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO mflores;

--
-- TOC entry 257 (class 1255 OID 1377914)
-- Dependencies: 45 2435
-- Name: f_thd_cuenca_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: mflores
--

CREATE FUNCTION f_thd_cuenca_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		hidro.ft_cuenca_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'hidro.thd_cuenca'
 AUTOR: 		mflores
 FECHA:	        30-08-2011 18:38
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_where varchar;
    v_join varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_cuenca_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HID_CUENCA_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			mflores	
 	#FECHA:			30-08-2011 18:38
	***********************************/

	if(p_transaccion='HID_CUENCA_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						hid.id_cuenca,
						hid.id_cuenca_fk,
						hid.tipo_cuenca,
						hid.nombre,	
                        hid.codigo,
                        hid.codigo_largo,
                        hid.estado_reg,
            			hid.id_usuario_reg,
                        hid.id_usuario_mod,
						hid.fecha_reg,
						hid.fecha_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod				
							
						from hidro.thd_cuenca hid
                        inner join segu.tusuario usu1 on usu1.id_usuario = hid.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = hid.id_usuario_mod                        					
				        						
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;
        
        /*********************************    
        #TRANSACCION:  'HID_CUENCA_SEL'
        #DESCRIPCION:	Consulta de datos
        #AUTOR:			mflores	
        #FECHA:			30-08-2011 18:38
        ***********************************/
        elsif p_transaccion = 'HID_CUENCACOM_SEL' then

        begin
        	v_consulta:='SELECT cu.id_cuenca,
            					cu.id_cuenca_fk,
                                cu.tipo_cuenca,
                                cu.nombre,
                                cu.codigo,
                                cu.codigo_largo
                        FROM hidro.thd_cuenca cu
                        inner join segu.tusuario usu1 on usu1.id_usuario = cu.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = cu.id_usuario_mod
                        where cu.tipo_cuenca = ''Microcuenca'' and ';
                        
            v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:=v_consulta||' order by cu.nombre limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            return v_consulta;
        end;
        
        elsif(p_transaccion='HID_CUENCACOM_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_cuenca)
					    from hidro.thd_cuenca cu
					    inner join segu.tusuario usu1 on usu1.id_usuario = cu.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = cu.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
        
     /*********************************    
 	#TRANSACCION:  'HID_CUENCA_ARB_SEL'
 	#DESCRIPCION:	Consulta de datos
        #AUTOR:		mflores	
 	#FECHA:			30-08-2011 18:38
	***********************************/

	elseif(p_transaccion='HID_CUENCA_ARB_SEL')then
     				
    	begin
        
              if(v_parametros.id_padre = '%') then
                v_where := ' hid.id_cuenca_fk is NULL';
                 v_join:= 'LEFT';      
                      
              else
                v_where := ' hid.id_cuenca_fk = '||v_parametros.id_padre;
                v_join := 'INNER';
              end if;
        
        
    		--Sentencia de la consulta
			v_consulta:='select
						hid.id_cuenca,
						hid.id_cuenca_fk,
						hid.tipo_cuenca,
						hid.nombre,		
                        hid.codigo,
                        hid.codigo_largo,
                        hid.estado_reg,
            			hid.id_usuario_reg,
                        hid.id_usuario_mod,
						hid.fecha_reg,
						hid.fecha_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod
						from hidro.thd_cuenca hid	
					    inner join segu.tusuario usu1 on usu1.id_usuario = hid.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = hid.id_usuario_mod                        					
				        where  '||v_where|| '  
                        ORDER BY hid.id_cuenca';
			
			
			--Devuelve la respuesta
			return v_consulta;
						
		end;   

	/*********************************    
 	#TRANSACCION:  'HID_CUENCA_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		30-08-11
	***********************************/

	elsif(p_transaccion='HID_CUENCA_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_cuenca)
					    from hidro.thd_cuenca cu
					    inner join segu.tusuario usu1 on usu1.id_usuario = cu.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = cu.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_cuenca_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO mflores;

--
-- TOC entry 1122 (class 1255 OID 1410795)
-- Dependencies: 2435 45
-- Name: f_thd_estacion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_estacion_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_estacion_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_estacion'
 AUTOR: 		mflores
 FECHA:	        05-09-2011 10:30:01
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_estacion			integer;
    
    v_sensor				integer;
    v_coord_lat				text[];
    v_coord_long			text[];
    v_grados_lat			numeric;
    v_min_lat				numeric;
    v_seg_lat				numeric;
    v_orientacion_lat		text;
    v_latitud				numeric;
    
    v_grados_lon			numeric;
    v_min_lon				numeric;
    v_seg_lon				numeric;
    v_orientacion_lon		text;
    v_longitud				numeric;
    
    vec_proy				text[];
    tam_vec_proy			numeric;
    v_i 					integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_estacion_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_EST_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	if(p_transaccion='HD_EST_INS')then
        
    --CALCULOS PARA LATITUD
    v_coord_lat := string_to_array(v_parametros.latitud_carto,'°');
    v_grados_lat := v_coord_lat[1]::numeric;
    
    v_coord_lat := string_to_array(v_coord_lat[2],'''');
    v_min_lat := v_coord_lat[1]::numeric;
    
    v_coord_lat := string_to_array(v_coord_lat[2],'"');
    v_seg_lat := v_coord_lat[1]::numeric;
    v_orientacion_lat := v_coord_lat[2];
    
    v_latitud := (v_grados_lat + (v_min_lat / 60) + (v_seg_lat / 3600)); 
    
    if (v_orientacion_lat = 'S')then
    	v_latitud := v_latitud * (-1);
    
    end if;
            
        --CALCULOS PARA LONGITUD
    
    v_coord_long := string_to_array(v_parametros.longitud_carto,'°');
    v_grados_lon := v_coord_long[1]::numeric;
    
    v_coord_long := string_to_array(v_coord_long[2],'''');
    v_min_lon := v_coord_long[1]::numeric;
    
    v_coord_long := string_to_array(v_coord_long[2],'"');
    v_seg_lon := v_coord_long[1]::numeric;
    v_orientacion_lon := v_coord_long[2];
    
    v_longitud := (v_grados_lon + (v_min_lon / 60) + (v_seg_lon / 3600)); 
    
    if (v_orientacion_lon = 'O')then
    	v_longitud := v_longitud * (-1);
    
    end if;
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_estacion(
			altitud,
			codigo,
			comentario,
			direccion,
			estado,
			estado_reg,
			fecha_fin,
			fecha_ini,
			id_administrador,
			id_cuenca,
			id_lugar,
			id_rio,
			latitud_carto,
			longitud_carto,
            latitud,
            longitud,
			observador,
			superficie_cuenca,
			teletransmision,
			tipo,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod            
          	) 
            values
            (
			v_parametros.altitud,
			v_parametros.codigo,
			v_parametros.comentario,
			v_parametros.direccion,
			v_parametros.estado,
			'activo',
			v_parametros.fecha_fin,
			v_parametros.fecha_ini,
			v_parametros.id_administrador,
			v_parametros.id_cuenca,
			v_parametros.id_lugar,
			v_parametros.id_rio,
			v_parametros.latitud_carto,
			v_parametros.longitud_carto,
            v_latitud,
            v_longitud,
			v_parametros.observador,
			v_parametros.superficie_cuenca,
			v_parametros.teletransmision,
			v_parametros.tipo,
			now(),
			p_id_usuario,
			null,
			null
			)RETURNING id_estacion into v_id_estacion;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','EstaciÃ³n almacenado(a) con exito (id_estacion'||v_id_estacion||')'); 
            v_resp = f_agrega_clave(v_resp,'id_estacion',v_id_estacion::varchar);
            
            vec_proy := string_to_array(v_parametros.id_proyectos,',');
            raise notice '%',vec_proy;
          	select array_upper(vec_proy,1) into tam_vec_proy;
          
          	FOR v_i IN 1..tam_vec_proy LOOP
               
              --insertamos  registro si no esta presente como activo
              insert into hidro.thd_estacion_proyecto
              (
              	id_proyecto, 
               	id_estacion
              ) 
              values
              (
              	vec_proy[v_i]::integer,
              	v_id_estacion
              ); 
             
            END LOOP;

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_EST_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	elsif(p_transaccion='HD_EST_MOD')then
	
    --CALCULOS PARA LATITUD            
    v_coord_lat := string_to_array(v_parametros.latitud_carto,'°');
    v_grados_lat := v_coord_lat[1]::numeric;
    
    v_coord_lat := string_to_array(v_coord_lat[2],'''');
    v_min_lat := v_coord_lat[1]::numeric;
    
    v_coord_lat := string_to_array(v_coord_lat[2],'"');
    v_seg_lat := v_coord_lat[1]::numeric;
    v_orientacion_lat := v_coord_lat[2];
    
    v_latitud := (v_grados_lat + (v_min_lat / 60) + (v_seg_lat / 3600)); 
    
    if (v_orientacion_lat = 'S')then
    	v_latitud := v_latitud * (-1);
    
    end if;
            
	--CALCULOS PARA LONGITUD    
    v_coord_long := string_to_array(v_parametros.longitud_carto,'°');
    v_grados_lon := v_coord_long[1]::numeric;
    
    v_coord_long := string_to_array(v_coord_long[2],'''');
    v_min_lon := v_coord_long[1]::numeric;
    
    v_coord_long := string_to_array(v_coord_long[2],'"');
    v_seg_lon := v_coord_long[1]::numeric;
    v_orientacion_lon := v_coord_long[2];
    
    v_longitud := (v_grados_lon + (v_min_lon / 60) + (v_seg_lon / 3600)); 
    
    if (v_orientacion_lon = 'O')then
    	v_longitud := v_longitud * (-1);
    
    end if;

		begin
			--Sentencia de la modificacion
			update hidro.thd_estacion set
			altitud = v_parametros.altitud,
			codigo = v_parametros.codigo,
			comentario = v_parametros.comentario,
			direccion = v_parametros.direccion,
			estado = v_parametros.estado,
			fecha_fin = v_parametros.fecha_fin,
			fecha_ini = v_parametros.fecha_ini,
			id_administrador = v_parametros.id_administrador,
			id_cuenca = v_parametros.id_cuenca,
			id_lugar = v_parametros.id_lugar,
			id_rio = v_parametros.id_rio,
			latitud_carto = v_parametros.latitud_carto,
			longitud_carto = v_parametros.longitud_carto,
            latitud = v_latitud,
			longitud = v_longitud,
			observador = v_parametros.observador,
			superficie_cuenca = v_parametros.superficie_cuenca,
			teletransmision = v_parametros.teletransmision,
			tipo = v_parametros.tipo,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_estacion=v_parametros.id_estacion;
            
            --se obtiene un vector con los id de proyectos seleccionados            
            vec_proy := string_to_array(v_parametros.id_proyectos,',');
          	select array_upper(vec_proy,1) into tam_vec_proy;
            
            -- eliminamos todos los roles que no estan seleccionados
			delete from hidro.thd_estacion_proyecto
            where id_estacion = v_parametros.id_estacion;
			--and (id_proyecto::text != ANY(vec_proy));
          
            if (tam_vec_proy <> 0) then
            
                --insertar los id de proyecto que faltan
                FOR v_i IN 1..tam_vec_proy LOOP
                       
                    --preguntamos si el id_rol ya se encuentra asignado si no insertamos
                    IF (NOT EXISTS (select 1 from hidro.thd_estacion_proyecto
                            where id_estacion = v_parametros.id_estacion
                            and id_proyecto = vec_proy[v_i]::integer)) THEN
                                
                        --insertamos  registro si no esta presente
                        insert into hidro.thd_estacion_proyecto
                         (id_proyecto, 
                         id_estacion) 
                        values(
                        vec_proy[v_i]::integer,
                        v_parametros.id_estacion); 

                    end if;
                END LOOP;
            end if;
            
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','EstaciÃ³n modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_estacion',v_parametros.id_estacion::varchar);
               
            --Devuelve la respuesta
            return v_resp;                      
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_EST_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	elsif(p_transaccion='HD_EST_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from hidro.thd_estacion
            
            --mflores 03-10-11 estado inactivo en vez de eliminar el registro
            select id_sensor
            into v_sensor
            from hidro.thd_sensor
            where id_estacion=v_parametros.id_estacion;
            
            update hidro.thd_medicion
            SET estado_reg = 'inactivo'
            where id_sensor=v_sensor;
            
            UPDATE hidro.thd_sensor
            SET estado_reg = 'inactivo'
            where id_estacion=v_parametros.id_estacion;
            
            UPDATE hidro.thd_estacion
            SET estado_reg = 'inactivo'
            where id_estacion=v_parametros.id_estacion;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','EstaciÃ³n eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_estacion',v_parametros.id_estacion::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
        
 /*******************************
 #TRANSACCION:  HD_UPFOTOEST_MOD
 #DESCRIPCION:	Modifica la foto de la estación
 #AUTOR:		mflores		
 #FECHA:		27/10/11	
***********************************/
     elsif(p_transaccion='HD_UPFOTOEST_MOD')then

          BEGIN
               update hidro.thd_estacion
               set 
               foto=v_parametros.foto,
               extension=v_parametros.extension
               where id_estacion=v_parametros.id_estacion;
             
             v_resp = f_agrega_clave(v_resp,'mensaje','Foto de la estacion modificada con exito '||v_parametros.id_estacion); 
             v_resp = f_agrega_clave(v_resp,'id_estacion',v_parametros.id_estacion::varchar);

               
          END;        
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;
    
    return v_resp;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_estacion_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1125 (class 1255 OID 1410794)
-- Dependencies: 2435 45
-- Name: f_thd_estacion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_estacion_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_estacion_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'hidro.thd_estacion'
 AUTOR: 		mflores
 FECHA:	        05-09-2011 10:30:01
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_addfil 			varchar;
    v_filtro			varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_estacion_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_EST_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	if(p_transaccion='HD_EST_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select est.id_estacion,
                                 est.altitud,
                                 est.codigo,
                                 est.comentario,
                                 est.direccion,
                                 est.estado,
                                 est.estado_reg,
                                 est.fecha_fin,
                                 est.fecha_ini,
                                 est.id_administrador,
                                 est.id_cuenca,
                                 est.id_lugar,
                                 est.id_rio,
                                 est.latitud,
                                 est.longitud,
                                 est.latitud_carto,
                                 est.longitud_carto,
                                 est.observador,
                                 est.superficie_cuenca,
                                 est.teletransmision,
                                 est.tipo,
                                 est.fecha_reg,
                                 est.id_usuario_reg,
                                 est.fecha_mod,
                                 est.id_usuario_mod,
                                 usu1.cuenta as usr_reg,
                                 usu2.cuenta as usr_mod,
                                 admhd.nombre as admin,
                                 cu.nombre as cuenca,
                                 lug.nombre as lugar,
                                 rio.nombre as rio,
                                 text_concat(estproy.id_proyecto::text) as id_proyectos,
                                 text_concat(proy.codigo_proyecto::text) as proyectos
                          from hidro.thd_estacion est
                               inner join hidro.thd_administrador_hidro admhd on admhd.id_administrador = est.id_administrador
                               inner join hidro.thd_rio rio on rio.id_rio = est.id_rio
                               inner join hidro.thd_cuenca cu on est.id_cuenca = cu.id_cuenca
                               inner join param.tlugar lug on lug.id_lugar = est.id_lugar
                               inner join segu.tusuario usu1 on usu1.id_usuario = est.id_usuario_reg
                               left join segu.tusuario usu2 on usu2.id_usuario = est.id_usuario_mod
                               left join hidro.thd_estacion_proyecto estproy on estproy.id_estacion = est.id_estacion
                               left join param.tpm_proyecto proy on proy.id_proyecto = estproy.id_proyecto
				        where est.estado_reg = ''activo'' and ';  
                        
                        v_consulta:=v_consulta||v_parametros.filtro;              
               			v_consulta:=v_consulta||' group by est.id_estacion,
                                                           est.altitud,
                                                           est.codigo,
                                                           est.comentario,
                                                           est.direccion,
                                                           est.estado,
                                                           est.estado_reg,
                                                           est.fecha_fin,
                                                           est.fecha_ini,
                                                           est.id_administrador,
                                                           est.id_cuenca,
                                                           est.id_lugar,
                                                           est.id_rio,
                                                           est.latitud,
                                                           est.longitud,
                                                           est.latitud_carto,
                                                           est.longitud_carto,
                                                           est.observador,
                                                           est.superficie_cuenca,
                                                           est.teletransmision,
                                                           est.tipo,
                                                           est.fecha_reg,
                                                           est.id_usuario_reg,
                                                           est.fecha_mod,
                                                           est.id_usuario_mod,
                                                           usr_reg,
                                                           usr_mod,
                                                           admin,
                                                           cuenca,
                                                           lugar,
                                                           rio';
          
			--Definicion de la respuesta
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_EST_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	elsif(p_transaccion='HD_EST_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(est.id_estacion)
					    from hidro.thd_estacion est 
                        inner join hidro.thd_cuenca cu on est.id_cuenca = cu.id_cuenca                     
					    inner join segu.tusuario usu1 on usu1.id_usuario = est.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = est.id_usuario_mod
                      --  left join hidro.thd_estacion_proyecto estproy on estproy.id_estacion = est.id_estacion
                            
					    where est.estado_reg = ''activo'' and';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;
--            v_consulta:=v_consulta||' group by est.id_estacion';

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	/*********************************    
 	#TRANSACCION:  'HD_ESTPRO_SEL'
 	#DESCRIPCION:	Consulta estaciones segun vector de proyectos
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	elsif(p_transaccion='HD_ESTPRO_SEL')then
     				
    	begin
        
            --si no existe el parametro id_proyectos sacamos un error
             v_addfil='0';
            if(f_existe_parametro(p_tabla,'id_proyectos'))THEN
                
              if(v_parametros.id_proyectos!='')then
                 v_addfil=v_parametros.id_proyectos;
              else
                v_addfil='0';
              
              end if;

            END IF;

    		--Sentencia de la consulta
			v_consulta:='select est.id_estacion,
                                 est.altitud,
                                 est.codigo,
                                 est.comentario,
                                 est.direccion,
                                 est.estado,
                                 est.estado_reg,
                                 est.fecha_fin,
                                 est.fecha_ini,
                                 est.id_administrador,
                                 est.id_cuenca,
                                 est.id_lugar,
                                 est.id_rio,
                                 est.latitud,
                                 est.longitud,
                                 est.latitud_carto,
                                 est.longitud_carto,
                                 est.observador,
                                 est.superficie_cuenca,
                                 est.teletransmision,
                                 est.tipo,
                                 est.fecha_reg,
                                 est.id_usuario_reg,
                                 est.fecha_mod,
                                 est.id_usuario_mod,
                                 usu1.cuenta as usr_reg,
                                 usu2.cuenta as usr_mod,
                                 admhd.nombre as admin,
                                 cu.nombre as cuenca,
                                 lug.nombre as lugar,
                                 rio.nombre as rio,
                                 text_concat(estproy.id_proyecto::text) as id_proyectos,
                                 text_concat(proy.codigo_proyecto::text) as proyectos
                          from hidro.thd_estacion est
                               inner join hidro.thd_administrador_hidro admhd on admhd.id_administrador = est.id_administrador
                               inner join hidro.thd_rio rio on rio.id_rio = est.id_rio
                               inner join hidro.thd_cuenca cu on est.id_cuenca = cu.id_cuenca
                               inner join param.tlugar lug on lug.id_lugar = est.id_lugar
                               inner join segu.tusuario usu1 on usu1.id_usuario = est.id_usuario_reg
                               left join segu.tusuario usu2 on usu2.id_usuario = est.id_usuario_mod
                               inner join hidro.thd_estacion_proyecto estproy on estproy.id_estacion = est.id_estacion AND estproy.id_proyecto in ('||v_addfil||')
                               left join param.tpm_proyecto proy on proy.id_proyecto = estproy.id_proyecto
                              
				        where est.estado_reg = ''activo'' and ';  
                        
                        v_consulta:=v_consulta||v_parametros.filtro;              
               			v_consulta:=v_consulta||' group by est.id_estacion,
                                                           est.altitud,
                                                           est.codigo,
                                                           est.comentario,
                                                           est.direccion,
                                                           est.estado,
                                                           est.estado_reg,
                                                           est.fecha_fin,
                                                           est.fecha_ini,
                                                           est.id_administrador,
                                                           est.id_cuenca,
                                                           est.id_lugar,
                                                           est.id_rio,
                                                           est.latitud,
                                                           est.longitud,
                                                           est.latitud_carto,
                                                           est.longitud_carto,
                                                           est.observador,
                                                           est.superficie_cuenca,
                                                           est.teletransmision,
                                                           est.tipo,
                                                           est.fecha_reg,
                                                           est.id_usuario_reg,
                                                           est.fecha_mod,
                                                           est.id_usuario_mod,
                                                           usr_reg,
                                                           usr_mod,
                                                           admin,
                                                           cuenca,
                                                           lugar,
                                                           rio';
          
			--Definicion de la respuesta
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
raise notice '%',v_consulta;
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_ESTRO_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	elsif(p_transaccion='HD_ESTPRO_CONT')then

		begin
        
               v_addfil='0';
            if(f_existe_parametro(p_tabla,'id_proyectos'))THEN
                
              if(v_parametros.id_proyectos!='')then
                 v_addfil=v_parametros.id_proyectos;
              else
                v_addfil='0';
              
              end if;

            END IF;
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(est.id_estacion)
					    from hidro.thd_estacion est 
                        inner join hidro.thd_cuenca cu on est.id_cuenca = cu.id_cuenca                     
					    inner join segu.tusuario usu1 on usu1.id_usuario = est.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = est.id_usuario_mod
                        inner join hidro.thd_estacion_proyecto estproy 
                        on estproy.id_estacion = est.id_estacion AND
                                estproy.id_proyecto in ('||v_addfil||')

					    where est.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;
           
        

			--Devuelve la respuesta
			return v_consulta;

		end;
        
    /*********************************    
 	#TRANSACCION:  'HD_PROEST_SEL'
 	#DESCRIPCION:	Consulta estaciones segun vector de proyectos
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	elsif(p_transaccion='HD_PROEST_SEL')then
     				
    	begin
        
        --raise notice '%',v_parametros.id_proyectos;  
        v_addfil='0';
        
        if(f_existe_parametro(p_tabla,'id_proyectos'))THEN
                
          if(v_parametros.id_proyectos!='')then
             v_addfil=v_parametros.id_proyectos;
          else
            v_addfil='0';
          
          end if;
              
        end if;
        
        
        if (select strpos(v_parametros.id_proyectos, '00000') > 0) then --todos los proyectos
            
            v_parametros.filtro = 'est.id_estacion::varchar like ''%'' and ' || v_parametros.filtro;
            v_filtro = 'inner join hidro.thd_estacion_proyecto estproy on estproy.id_estacion = est.id_estacion AND estproy.id_proyecto::varchar like ''%''';

        else
        	if (v_parametros.id_proyectos <> '') then --de acuerdo a la seleccion
            	v_filtro = 'inner join hidro.thd_estacion_proyecto estproy on estproy.id_estacion = est.id_estacion AND estproy.id_proyecto in ('||v_parametros.id_proyectos||')';
        
        	else
        		v_filtro = 'inner join hidro.thd_estacion_proyecto estproy on estproy.id_estacion = est.id_estacion AND estproy.id_proyecto in ('||v_addfil||')';
            end if;

        end if;           

    		--Sentencia de la consulta
			v_consulta:='select est.id_estacion,
                                 est.altitud,
                                 est.codigo,
                                 est.comentario,
                                 est.direccion,
                                 est.estado,
                                 est.estado_reg,
                                 est.fecha_fin,
                                 est.fecha_ini,
                                 est.id_administrador,
                                 est.id_cuenca,
                                 est.id_lugar,
                                 est.id_rio,
                                 est.latitud,
                                 est.longitud,
                                 est.latitud_carto,
                                 est.longitud_carto,
                                 est.observador,
                                 est.superficie_cuenca,
                                 est.teletransmision,
                                 est.tipo,
                                 est.fecha_reg,
                                 est.id_usuario_reg,
                                 est.fecha_mod,
                                 est.id_usuario_mod,
                                 usu1.cuenta as usr_reg,
                                 usu2.cuenta as usr_mod,
                                 admhd.nombre as admin,
                                 cu.nombre as cuenca,
                                 lug.nombre as lugar,
                                 rio.nombre as rio,
                                 text_concat(estproy.id_proyecto::text) as id_proyectos,
                                 text_concat(proy.codigo_proyecto::text) as proyectos
                          from hidro.thd_estacion est
                               inner join hidro.thd_administrador_hidro admhd on admhd.id_administrador = est.id_administrador
                               inner join hidro.thd_rio rio on rio.id_rio = est.id_rio
                               inner join hidro.thd_cuenca cu on est.id_cuenca = cu.id_cuenca
                               inner join param.tlugar lug on lug.id_lugar = est.id_lugar
                               inner join segu.tusuario usu1 on usu1.id_usuario = est.id_usuario_reg
                               left join segu.tusuario usu2 on usu2.id_usuario = est.id_usuario_mod
                               '|| v_filtro ||'
                               left join param.tpm_proyecto proy on proy.id_proyecto = estproy.id_proyecto
                              
				        where est.estado_reg = ''activo'' and ';  
                        
                        v_consulta:=v_consulta||v_parametros.filtro;              
               			v_consulta:=v_consulta||' group by est.id_estacion,
                                                           est.altitud,
                                                           est.codigo,
                                                           est.comentario,
                                                           est.direccion,
                                                           est.estado,
                                                           est.estado_reg,
                                                           est.fecha_fin,
                                                           est.fecha_ini,
                                                           est.id_administrador,
                                                           est.id_cuenca,
                                                           est.id_lugar,
                                                           est.id_rio,
                                                           est.latitud,
                                                           est.longitud,
                                                           est.latitud_carto,
                                                           est.longitud_carto,
                                                           est.observador,
                                                           est.superficie_cuenca,
                                                           est.teletransmision,
                                                           est.tipo,
                                                           est.fecha_reg,
                                                           est.id_usuario_reg,
                                                           est.fecha_mod,
                                                           est.id_usuario_mod,
                                                           usr_reg,
                                                           usr_mod,
                                                           admin,
                                                           cuenca,
                                                           lugar,
                                                           rio';
          
			--Definicion de la respuesta
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			
            raise notice '%',v_consulta;
            
			--Devuelve la respuesta
			return v_consulta;                
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_PROEST_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	elsif(p_transaccion='HD_PROEST_CONT')then

		begin
        
               v_addfil='0';
            if(f_existe_parametro(p_tabla,'id_proyectos'))THEN
                
              if(v_parametros.id_proyectos!='')then
                 v_addfil=v_parametros.id_proyectos;
              else
                v_addfil='0';
              
              end if;

            END IF;
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(est.id_estacion)
					    from hidro.thd_estacion est 
                        inner join hidro.thd_cuenca cu on est.id_cuenca = cu.id_cuenca                     
					    inner join segu.tusuario usu1 on usu1.id_usuario = est.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = est.id_usuario_mod
                        inner join hidro.thd_estacion_proyecto estproy 
                        on estproy.id_estacion = est.id_estacion AND
                                estproy.id_proyecto in ('||v_addfil||')

					    where est.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;                 

			--Devuelve la respuesta
			return v_consulta;

		end;
    
	/*********************************    
 	#TRANSACCION:  'HD_OBTFOTOEST_SEL'
 	#DESCRIPCION:	Obtiene la foto de una estación
 	#AUTOR:		rac	
 	#FECHA:		09-11-2011 10:30:01
	***********************************/

	elseif(p_transaccion='HD_OBTFOTOEST_SEL')then
     				
   	begin
    		--Sentencia de la consulta
			v_consulta:='SELECT est.id_estacion,
                                est.foto,
                                est.extencion
                         FROM hidro.thd_estacion est
                         WHERE est.estado_reg = ''activo'' and est.id_estacion = '||v_parametros.id_estacion;  
               			                    	
     end;
    else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_estacion_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1294 (class 1255 OID 1468341)
-- Dependencies: 2435 45
-- Name: f_thd_medame_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: mflores
--

CREATE FUNCTION f_thd_medame_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_medame_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, 
 				eliminaciones de la tabla 'hidro.thd_medicion'
 AUTOR: 		(mflores)
 FECHA:	        07-09-2011 15:50:29
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_medicion			integer;
    v_id_dato_medida		integer;
    
    --para insercion de CSV 
    v_tabla					varchar;
    v_consulta    			varchar;
	v_resultado				text[];
    
    v_registros				record;
    v_id_operador			integer;
    v_aux					varchar;	
    v_titulo				VARCHAR[];				
	--fin
    		    
BEGIN
	
	--para insercion de CSV 
    v_tabla := 'tt_excel';
    --fin

    v_nombre_funcion = 'hidro.f_thd_medame_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_MEDAME_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:			mflores	
 	#FECHA:			07-09-2011 15:50:29
	***********************************/

	if(p_transaccion='HD_MEDAME_INS')then
		
     begin
    	                                                
            --Sentencia de la insercion
            insert into hidro.thd_medicion
            (
                --id_tipo_medicion,
                id_sensor,
                id_operador,  
                hora_medida,     
                fecha_medida,
                --fecha_fin,                
                valor_numeric,                
                estado_reg,
                fecha_reg,
                id_usuario_reg,
                fecha_mod,
                id_usuario_mod                   
            ) 
            values
            (
                --v_parametros.id_tipo_medicion,
                v_parametros.id_sensor,
                v_parametros.id_operador,  
                v_parametros.hora_medida, 
                v_parametros.fecha_medida,     
               -- v_parametros.fecha_fin,                             
                v_parametros.valor_numeric,                
                'activo',
                now(),
                p_id_usuario,
                null,
                null                           
            )RETURNING id_medicion into v_id_medicion;                          
        
        --Definicion de la respuesta
		v_resp = f_agrega_clave(v_resp,'mensaje','MediciÃ³n almacenado(a) con exito (id_medicion'||v_id_medicion||')'); 
        v_resp = f_agrega_clave(v_resp,'id_medicion',v_id_medicion::varchar);

        --Devuelve la respuesta
         return v_resp;
        
		end;

	/*********************************    
 	#TRANSACCION:  'HD_MEDAME_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	elsif(p_transaccion='HD_MEDAME_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_medicion 
            	set			
                    id_sensor = v_parametros.id_sensor,
                    id_operador = v_parametros.id_operador,
                    fecha_medida = v_parametros.fecha_medida,
                    --fecha_fin = v_parametros.fecha_fin,
                    hora_medida = v_parametros.hora_medida,
                    valor_numeric = v_parametros.valor_numeric,                  
                    fecha_mod = now(),
                    id_usuario_mod = p_id_usuario
				
                where id_medicion = v_parametros.id_medicion;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','MediciÃ³n modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_medicion',v_parametros.id_medicion::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_MED_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	elsif(p_transaccion='HD_MEDAME_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from hidro.thd_medicion
            
            --mflores 03-10-11 estado inactivo en vez de eliminar el registro
            UPDATE hidro.thd_medicion
            SET estado_reg = 'inactivo'
            where id_medicion=v_parametros.id_medicion;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','MediciÃ³n eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_medicion',v_parametros.id_medicion::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
    /*********************************    
 	#TRANSACCION:  'HD_EXL_INS'
 	#DESCRIPCION:	Insertar datos de EXCEL (CSV)
 	#AUTOR:			mflores	
 	#FECHA:			11-10-2011
	***********************************/

	elsif(p_transaccion='HD_EXL_INS')then
    
      BEGIN

       update hidro.thd_sensor set       
       medidas = v_parametros.excel
       where id_sensor = v_parametros.id_sensor;                            
       
       	v_titulo[1] := 'fecha_medida';
        v_titulo[2] := 'hora_medida';
        v_titulo[3] := 'valor_numeric';
        v_titulo[4] := 'codigo';
       
        v_consulta := 'create temp table '|| v_tabla ||' (fecha_medida date,hora_medida time,valor_numeric numeric, codigo varchar) on commit drop ';
        execute v_consulta;        		
          
        v_resultado := (select f_excel((select medidas from hidro.thd_sensor where id_sensor = v_parametros.id_sensor), v_tabla, v_titulo));
        v_consulta := 'select * from '|| v_tabla;        
        v_aux := NULL;                
                  	
        FOR v_registros in EXECUTE(v_consulta) LOOP
            
          if(v_aux = v_registros.codigo) then                    
            
            --Sentencia de la insercion
            insert into hidro.thd_medicion
            (
                --id_tipo_medicion,
                id_sensor,
                id_operador,  
                hora_medida,     
                fecha_medida,
                valor_numeric,
                estado_reg,
                fecha_reg,
                id_usuario_reg,
                fecha_mod,
                id_usuario_mod                   
            )             
            values
            (               
               -- v_parametros.id_tipo_medicion,
                v_parametros.id_sensor,
                v_id_operador,  
                v_registros.hora_medida::time,
                v_registros.fecha_medida::date,                
                v_registros.valor_numeric::numeric,                
                'activo',
                now(),
                p_id_usuario,
                null,
                null         
            );  
          
          else
          
          	v_id_operador := (select id_operador from hidro.thd_operador where codigo = v_registros.codigo);
            v_aux := v_registros.codigo;
            
            --Sentencia de la insercion
            insert into hidro.thd_medicion
            (
                --id_tipo_medicion,
                id_sensor,
                id_operador,  
                hora_medida,     
                fecha_medida,
                valor_numeric,
                estado_reg,
                fecha_reg,
                id_usuario_reg,
                fecha_mod,
                id_usuario_mod                   
            )             
            values
            (               
                --v_parametros.id_tipo_medicion,
                v_parametros.id_sensor,
                v_id_operador,  
                v_registros.hora_medida::time,
                v_registros.fecha_medida::date,                
                v_registros.valor_numeric::numeric,                
                'activo',
                now(),
                p_id_usuario,
                null,
                null         
            );
            
          end if;  
                            
       END LOOP;     
                  
       update hidro.thd_sensor set       
       medidas = NULL
       where id_sensor = v_parametros.id_sensor;
        
        --Definicion de la respuesta
        v_resp = f_agrega_clave(v_resp,'mensaje','MediciÃ³n almacenado(a) con exito (id_medicion'||v_id_medicion||')'); 
        v_resp = f_agrega_clave(v_resp,'id_medicion',v_id_medicion::varchar);

        --Devuelve la respuesta
        return v_resp;
          
      end;   
      
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_medame_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO mflores;

--
-- TOC entry 1311 (class 1255 OID 1466731)
-- Dependencies: 2435 45
-- Name: f_thd_medame_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: mflores
--

CREATE FUNCTION f_thd_medame_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_medame_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_medicion'
 AUTOR: 		 (mflores)
 FECHA:	        07-09-2011 15:50:29
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_tabla				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_medame_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_MEDAME_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	if(p_transaccion='HD_MEDAME_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select med.id_medicion,
                                 --med.id_tipo_medicion,
                                 med.id_sensor,                                 
                                 med.id_operador,
                                 med.fecha_medida,
                                 --med.fecha_fin,  
                                 med.hora_medida,
                                 med.valor_numeric,
                                 med.estado_reg,
                                 med.fecha_reg,
                                 med.id_usuario_reg,
                                 med.fecha_mod,
                                 med.id_usuario_mod,
                                 usu1.cuenta as usr_reg,
                                 usu2.cuenta as usr_mod,
                                 per.nombre_completo1
                                 --,tipme.unidad_medida
                          from hidro.thd_medicion med
                               left join hidro.thd_operador ope on ope.id_operador = med.id_operador
                               left join segu.vpersona per on ope.id_persona = per.id_persona
                               left join hidro.thd_sensor sen on sen.id_sensor = med.id_sensor
                               --left join hidro.thd_tipo_medicion tipme on tipme.id_tipo_medicion = med.id_tipo_medicion
                               inner join segu.tusuario usu1 on usu1.id_usuario = med.id_usuario_reg                               
                               left join segu.tusuario usu2 on usu2.id_usuario = med.id_usuario_mod
                          where med.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			
            raise notice '%',v_consulta;
            
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_MEDAME_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	elsif(p_transaccion='HD_MEDAME_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(med.id_medicion)
					    	from hidro.thd_medicion med
                               left join hidro.thd_operador ope on ope.id_operador = med.id_operador
                               left join segu.vpersona per on ope.id_persona = per.id_persona
                               left join hidro.thd_sensor sen on sen.id_sensor = med.id_sensor
                               --left join hidro.thd_tipo_medicion tipme on tipme.id_tipo_medicion = med.id_tipo_medicion
                               inner join segu.tusuario usu1 on usu1.id_usuario = med.id_usuario_reg                               
                               left join segu.tusuario usu2 on usu2.id_usuario = med.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
    
    /*********************************    
 	#TRANSACCION:  'HD_REPORTE'
 	#DESCRIPCION:	Prueba de reporte
 	#AUTOR:		mflores	
 	#FECHA:		14-11-2011 12:17
	***********************************/

	elsif(p_transaccion='HD_REPORTE')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select med.fecha_medida,
                                med.valor_numeric
                          from hidro.thd_medicion med
                               left join hidro.thd_operador ope on ope.id_operador = med.id_operador
                               left join segu.vpersona per on ope.id_persona = per.id_persona
                               left join hidro.thd_sensor sen on sen.id_sensor = med.id_sensor                               
                               inner join segu.tusuario usu1 on usu1.id_usuario = med.id_usuario_reg                               
                               left join segu.tusuario usu2 on usu2.id_usuario = med.id_usuario_mod
                          where med.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion; -- || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			
            raise notice '%',v_consulta;
            
			--Devuelve la respuesta
			return v_consulta;
						
		end;
	    
    /*********************************    
 	#TRANSACCION:  'HD_OBT_FECHA'
 	#DESCRIPCION:	Obtener fechas maxima y minima para precargar la vista de reporte
 	#AUTOR:			mflores	
 	#FECHA:			19-04-2012 10:08
	***********************************/

	elsif(p_transaccion='HD_OBT_FECHA')then
     			
   v_tabla := (select replace(v_parametros.tabla,'id_','thd_'));
   
   --raise notice 'v_tabla: %', v_tabla;
    	
    	begin
    		--Sentencia de la consulta
			v_consulta:='select min(med.'||v_parametros.columna_fecha||') as fecha_min,
	   							max(med.'||v_parametros.columna_fecha||') as fecha_max
                          from hidro.'||v_tabla||' med
                          where med.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			--v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion; -- || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			
            raise notice '%',v_consulta;
            
			--Devuelve la respuesta
			return v_consulta;
						
		end;
        
    /*********************************    
 	#TRANSACCION:  'HD_OBT_PROME'
 	#DESCRIPCION:	Obtener promedios
 	#AUTOR:			mflores	
 	#FECHA:			22-05-2012 16:30
	***********************************/

	elsif(p_transaccion='HD_OBT_PROME')then
     			
   v_tabla := (select replace(v_parametros.tabla,'id_','thd_'));
   
   --raise notice 'v_tabla: %', v_tabla;
    	
    	begin
    		--Sentencia de la consulta
			v_consulta:='select min(med.'||v_parametros.columna_fecha||') as fecha_min,
	   							max(med.'||v_parametros.columna_fecha||') as fecha_max
                          from hidro.'||v_tabla||' med
                          where med.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			--v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion; -- || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			
            raise notice '%',v_consulta;
            
			--Devuelve la respuesta
			return v_consulta;
						
		end;
   
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_medame_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO mflores;

--
-- TOC entry 271 (class 1255 OID 1427712)
-- Dependencies: 2435 45
-- Name: f_thd_medicion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_medicion_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_medicion_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_medicion'
 AUTOR: 		 (mflores)
 FECHA:	        07-09-2011 15:50:29
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_medicion	integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_medicion_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_MED_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	if(p_transaccion='HD_MED_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_medicion(
			estado_reg,
			fecha_fin,
            hora_medida,
			fecha_ini,
            valor_numeric,
			valor_varchar,
			h,
			h_fin,
			h_ini,
			h_maxi,
			h_mini,
			h_original,
			id_operador,
			id_sensor,
			q,
			q_original,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod
--            ,id_tipo_medicion
          	) values(
			'activo',
			v_parametros.fecha_fin,
            v_parametros.hora_medida,
			v_parametros.fecha_ini,
            v_parametros.valor_numeric,
			v_parametros.valor_varchar,
			v_parametros.h,
			v_parametros.h_fin,
			v_parametros.h_ini,
			v_parametros.h_maxi,
			v_parametros.h_mini,
			v_parametros.h_original,
			v_parametros.id_operador,
			v_parametros.id_sensor,
			v_parametros.q,
			v_parametros.q_original,
			now(),
			p_id_usuario,
			null,
			null
            --,v_parametros.id_tipo_medicion
			)RETURNING id_medicion into v_id_medicion;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','MediciÃ³n almacenado(a) con exito (id_medicion'||v_id_medicion||')'); 
            v_resp = f_agrega_clave(v_resp,'id_medicion',v_id_medicion::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_MED_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	elsif(p_transaccion='HD_MED_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_medicion set
			fecha_fin = v_parametros.fecha_fin,
            hora_medida = v_parametros.hora_medida,
			fecha_ini = v_parametros.fecha_ini,
            valor_numeric = v_parametros.valor_numeric,
			valor_varchar = v_parametros.valor_varchar,
			h = v_parametros.h,
			h_fin = v_parametros.h_fin,
			h_ini = v_parametros.h_ini,
			h_maxi = v_parametros.h_maxi,
			h_mini = v_parametros.h_mini,
			h_original = v_parametros.h_original,
			id_operador = v_parametros.id_operador,
			id_sensor = v_parametros.id_sensor,
			q = v_parametros.q,
			q_original = v_parametros.q_original,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_medicion=v_parametros.id_medicion;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','MediciÃ³n modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_medicion',v_parametros.id_medicion::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_MED_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	elsif(p_transaccion='HD_MED_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from hidro.thd_medicion
            
            --mflores 03-10-11 estado inactivo en vez de eliminar el registro
            UPDATE hidro.thd_medicion
            SET estado_reg = 'inactivo'
            where id_medicion=v_parametros.id_medicion;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','MediciÃ³n eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_medicion',v_parametros.id_medicion::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_medicion_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 270 (class 1255 OID 1427711)
-- Dependencies: 45 2435
-- Name: f_thd_medicion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_medicion_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_medicion_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_medicion'
 AUTOR: 		 (mflores)
 FECHA:	        07-09-2011 15:50:29
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_medicion_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_MED_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	if(p_transaccion='HD_MED_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						med.id_medicion,
						med.estado_reg,
						med.fecha_fin,
                        med.hora_medida,
						med.fecha_ini,
						med.h,
						med.h_fin,
						med.h_ini,
						med.h_maxi,
						med.h_mini,
						med.h_original,
						med.id_operador,
						med.id_sensor,
						med.q,
						med.q_original,
						med.fecha_reg,
						med.id_usuario_reg,
						med.fecha_mod,
						med.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        per.nombre_completo1,
                       -- med.id_tipo_medicion,
                        med.valor_numeric,
						med.valor_varchar
						from hidro.thd_medicion med
                        inner join hidro.thd_operador ope on ope.id_operador = med.id_operador
                        inner join segu.vpersona per on ope.id_persona = per.id_persona
                        inner join hidro.thd_sensor sen on sen.id_sensor = med.id_sensor
						inner join segu.tusuario usu1 on usu1.id_usuario = med.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = med.id_usuario_mod
				        where med.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_MED_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	elsif(p_transaccion='HD_MED_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_medicion)
					    from hidro.thd_medicion med
                        inner join hidro.thd_sensor sen on sen.id_sensor = med.id_sensor
					    inner join segu.tusuario usu1 on usu1.id_usuario = med.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = med.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_medicion_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 259 (class 1255 OID 1400118)
-- Dependencies: 45 2435
-- Name: f_thd_operador_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: mflores
--

CREATE FUNCTION f_thd_operador_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_operador_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas 
 				(inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_operador'
 AUTOR: 		mflores
 FECHA:	        02-09-2011 15:10
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    		integer;
	v_parametros           		record;
	v_id_requerimiento     		integer;
	v_resp		            	varchar;
	v_nombre_funcion       	 	text;
	v_mensaje_error         	text;
	v_id_operador				integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_operador_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_OPE_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:			mflores	
 	#FECHA:			02-09-2011
	***********************************/

	if(p_transaccion='HD_OPE_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_operador
            (
              estado_reg,
              fecha_presentacion,
              id_persona,
              id_proyecto,
              fecha_reg,
              id_usuario_reg,
              fecha_mod,
              id_usuario_mod,
              codigo
          	) 
            values
            (
              'activo',
              v_parametros.fecha_presentacion,
              v_parametros.id_persona,
              v_parametros.id_proyecto,
              now(),
              p_id_usuario,
              null,
              null,
              v_parametros.codigo
			)RETURNING id_operador into v_id_operador;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','OPERADOR almacenado(a) con exito (id_operador'||v_id_operador||')'); 
            v_resp = f_agrega_clave(v_resp,'id_operador',v_id_operador::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_OPE_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:			mflores	
 	#FECHA:			02-09-2011
	***********************************/

	elsif(p_transaccion='HD_OPE_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_operador set
			fecha_presentacion = v_parametros.fecha_presentacion,
            id_persona = v_parametros.id_persona,
			id_proyecto = v_parametros.id_proyecto,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario,
            codigo = v_parametros.codigo
 			where id_operador = v_parametros.id_operador;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','OPERADOR modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_operador',v_parametros.id_operador::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_OPE_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:			mflores	
 	#FECHA:			02-09-2011	
	***********************************/

	elsif(p_transaccion='HD_OPE_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from hidro.thd_operador
            
            --mflores 03-10-11 estado inactivo en vez de eliminar el registro
            UPDATE hidro.thd_operador
            SET estado_reg = 'inactivo'
            where id_operador = v_parametros.id_operador;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','OPERADOR eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_operador',v_parametros.id_operador::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_operador_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO mflores;

--
-- TOC entry 1121 (class 1255 OID 1400119)
-- Dependencies: 45 2435
-- Name: f_thd_operador_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: mflores
--

CREATE FUNCTION f_thd_operador_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_operador_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'hidro.thd_operador'
 AUTOR: 		mflores
 FECHA:	        02-09-2011
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_operador_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_OPE_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			mflores	
 	#FECHA:			02-09-2011
	***********************************/

	if(p_transaccion='HD_OPE_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select ope.id_operador,
                                 ope.estado_reg,
                                 ope.fecha_presentacion,
                                 ope.id_persona,
                                 ope.id_proyecto,
                                 ope.fecha_reg,
                                 ope.id_usuario_reg,
                                 ope.fecha_mod,
                                 ope.id_usuario_mod,
                                 usu1.cuenta as usr_reg,
                                 usu2.cuenta as usr_mod,
                                 per.nombre_completo1,
                                 per.ap_materno,
                                 per.ap_paterno,
                                 per.nombre,
                                 proy.nombre as proyecto,
                                 ope.codigo,
                                 perso.extension,
                                 perso.foto
                          from hidro.thd_operador ope
                               inner join segu.vpersona per on ope.id_persona = per.id_persona
                               inner join segu.tproyecto proy on ope.id_proyecto = proy.id_proyecto
                               inner join segu.tusuario usu1 on usu1.id_usuario = ope.id_usuario_reg
                               left join segu.tusuario usu2 on usu2.id_usuario = ope.id_usuario_mod
                               left join segu.tpersona perso on perso.id_persona = ope.id_persona
				          where ope.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_OPE_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:			mflores	
 	#FECHA:			01-09-2011
	***********************************/

	elsif(p_transaccion='HD_OPE_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_operador)
					    from hidro.thd_operador ope
                        inner join segu.vpersona per on ope.id_persona = per.id_persona
                        inner join segu.tproyecto proy on ope.id_proyecto = proy.id_proyecto
					    inner join segu.tusuario usu1 on usu1.id_usuario = ope.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ope.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;
            
            raise notice '%',v_consulta;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_operador_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO mflores;

--
-- TOC entry 409 (class 1255 OID 1382317)
-- Dependencies: 45 2435
-- Name: f_thd_rio_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_rio_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_rio_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_rio'
 AUTOR: 		 (rac)
 FECHA:	        31-08-2011 15:32:32
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_rio	integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_rio_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_RIO_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		31-08-2011 15:32:32
	***********************************/

	if(p_transaccion='HD_RIO_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_rio(
			codigo,
			estado_reg,
			nombre,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			v_parametros.codigo,
			'activo',
			v_parametros.nombre,
			now(),
			p_id_usuario,
			null,
			null
			)RETURNING id_rio into v_id_rio;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','RIO almacenado(a) con exito (id_rio'||v_id_rio||')'); 
            v_resp = f_agrega_clave(v_resp,'id_rio',v_id_rio::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_RIO_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		31-08-2011 15:32:32
	***********************************/

	elsif(p_transaccion='HD_RIO_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_rio set
			codigo = v_parametros.codigo,
			nombre = v_parametros.nombre,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_rio=v_parametros.id_rio;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','RIO modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_rio',v_parametros.id_rio::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_RIO_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		31-08-2011 15:32:32
	***********************************/

	elsif(p_transaccion='HD_RIO_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from hidro.thd_rio
            
            --mflores 03-10-11 estado inactivo en vez de eliminar el registro
            UPDATE hidro.thd_rio
            SET estado_reg = 'inactivo'
            where id_rio=v_parametros.id_rio;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','RIO eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_rio',v_parametros.id_rio::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_rio_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1204 (class 1255 OID 1382316)
-- Dependencies: 2435 45
-- Name: f_thd_rio_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_rio_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_rio_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_rio'
 AUTOR: 		 (rac)
 FECHA:	        31-08-2011 15:32:32
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_rio_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_RIO_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		31-08-2011 15:32:32
	***********************************/

	if(p_transaccion='HD_RIO_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						rio.id_rio,
						rio.codigo,
						rio.estado_reg,
						rio.nombre,
						rio.fecha_reg,
						rio.id_usuario_reg,
						rio.fecha_mod,
						rio.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from hidro.thd_rio rio
						inner join segu.tusuario usu1 on usu1.id_usuario = rio.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = rio.id_usuario_mod
				        where rio.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_RIO_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		31-08-2011 15:32:32
	***********************************/

	elsif(p_transaccion='HD_RIO_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_rio)
					    from hidro.thd_rio rio
					    inner join segu.tusuario usu1 on usu1.id_usuario = rio.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = rio.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_rio_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 265 (class 1255 OID 1420117)
-- Dependencies: 45 2435
-- Name: f_thd_sensor_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_sensor_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_sensor_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_sensor'
 AUTOR: 		 (mflores)
 FECHA:	        06-09-2011 11:45:42
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_sensor				integer;   
    
    v_codigo_sensor			varchar;
    v_codigo_est			varchar;
    v_abreviacion			varchar;
    v_contador				numeric;
    			    
BEGIN
	    
    v_nombre_funcion = 'hidro.f_thd_sensor_ime';
    v_parametros = f_get_record(p_tabla);    
        
	/*********************************    
 	#TRANSACCION:  'HD_SEN_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	if(p_transaccion='HD_SEN_INS')then
    
    select codigo
    into v_codigo_est
    from hidro.thd_estacion
    where id_estacion = v_parametros.id_estacion;
    
    select abreviacion
    into v_abreviacion
    from hidro.thd_tipo_sensor
    where id_tipo_sensor = v_parametros.id_tipo_sensor;
    
    select count(id_sensor)
    into v_contador
    from hidro.thd_sensor
    where id_estacion = v_parametros.id_estacion;
    
    v_contador := v_contador + 1;
    
    v_codigo_sensor := COALESCE(v_codigo_est || '-' || v_abreviacion || '-' || v_contador::varchar);
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_sensor(
			estado,
			estado_reg,
			fecha_fin,
			fecha_ini,
			ficticio,
			id_estacion,
            id_tipo_sensor,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod,
            codigo,
            id_sensor_fk
          	) values(
			'borrador',
			'activo',
			v_parametros.fecha_fin,
			v_parametros.fecha_ini,
			v_parametros.ficticio,
			v_parametros.id_estacion,
            v_parametros.id_tipo_sensor,
			now(),
			p_id_usuario,
			null,
			null,
            v_codigo_sensor,
            v_parametros.id_sensor_fk
			)RETURNING id_sensor into v_id_sensor;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Sensor almacenado(a) con exito (id_sensor'||v_id_sensor||')'); 
            v_resp = f_agrega_clave(v_resp,'id_sensor',v_id_sensor::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_SEN_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	elsif(p_transaccion='HD_SEN_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_sensor set
			--estado = v_parametros.estado,
			fecha_fin = v_parametros.fecha_fin,
			fecha_ini = v_parametros.fecha_ini,
			ficticio = v_parametros.ficticio,
			id_estacion = v_parametros.id_estacion,
            id_tipo_sensor = v_parametros.id_tipo_sensor,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario,
            id_sensor_fk = v_parametros.id_sensor_fk
			where id_sensor=v_parametros.id_sensor;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Sensor modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_sensor',v_parametros.id_sensor::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;
        
     

	/*********************************    
 	#TRANSACCION:  'HD_SEN_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	elsif(p_transaccion='HD_SEN_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from hidro.thd_sensor
            
            update hidro.thd_medicion
            SET estado_reg = 'inactivo'
            where id_sensor=v_parametros.id_sensor;
            
            UPDATE hidro.thd_sensor
            SET estado_reg = 'inactivo'
            where id_sensor=v_parametros.id_sensor;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Sensor eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_sensor',v_parametros.id_sensor::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;             
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_sensor_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1285 (class 1255 OID 1420116)
-- Dependencies: 45 2435
-- Name: f_thd_sensor_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_sensor_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_sensor_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_sensor'
 AUTOR: 		 (mflores)
 FECHA:	        06-09-2011 11:45:42
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_sensor_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_SEN_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	if(p_transaccion='HD_SEN_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						sen.id_sensor,
						sen.estado,
						sen.estado_reg,
						sen.fecha_fin,
						sen.fecha_ini,
						sen.ficticio,
						sen.id_estacion,
						sen.fecha_reg,
						sen.id_usuario_reg,
						sen.fecha_mod,
						sen.id_usuario_mod,
                        sen.id_tipo_sensor,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        est.codigo as estacion,
                        tipsen.nombre_sensor as tipo_sensor,
					    --tipcol.nombre_medida,
                        sen.codigo,
                        tipcols.unidad_medida,
                        (select codigo
                         from hidro.thd_sensor
                         where id_sensor = sen.id_sensor_fk) as sen_asociado,
                        tipsen.codigo as tipo_sensor_codigo
						from hidro.thd_sensor sen
                        inner join hidro.thd_estacion est on est.id_estacion = sen.id_estacion
                        inner join hidro.thd_tipo_sensor tipsen on tipsen.id_tipo_sensor = sen.id_tipo_sensor
                        inner join hidro.thd_tipo_columna_sensor tipcols on tipcols.id_tipo_sensor = sen.id_tipo_sensor
						inner join segu.tusuario usu1 on usu1.id_usuario = sen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = sen.id_usuario_mod
				        where sen.estado_reg = ''activo'' and ';
			
            raise notice '%',v_consulta;
            
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;
        
    /*********************************    
 	#TRANSACCION:  'HD_SENC_SEL'
 	#DESCRIPCION:	Consulta de datos para el combo de sensores
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	elsif(p_transaccion='HD_SENC_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						sen.id_sensor,
						sen.estado,
						sen.estado_reg,
						sen.fecha_fin,
						sen.fecha_ini,
						sen.ficticio,
						sen.id_estacion,
						sen.fecha_reg,
						sen.id_usuario_reg,
						sen.fecha_mod,
						sen.id_usuario_mod,
                        sen.id_tipo_sensor,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        est.codigo as estacion,
                        tipsen.nombre_sensor as tipo_sensor,
					   -- tipcol.nombre_medida,
                        sen.codigo
						from hidro.thd_sensor sen
                        inner join hidro.thd_estacion est on est.id_estacion = sen.id_estacion
                        inner join hidro.thd_tipo_sensor tipsen on tipsen.id_tipo_sensor = sen.id_tipo_sensor
                        inner join hidro.thd_tipo_columna_sensor tipcol on tipcol.id_tipo_sensor = sen.id_tipo_sensor
						inner join segu.tusuario usu1 on usu1.id_usuario = sen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = sen.id_usuario_mod
				        where sen.estado_reg = ''activo'' and sen.id_estacion = '|| v_parametros.id_estacion ||' and ';
			
            raise notice '%',v_consulta;
            
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;
    
    /*********************************    
 	#TRANSACCION:  'HD_SENFIC_SEL'
 	#DESCRIPCION:	Consulta de datos para el caso ficticio
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	elsif(p_transaccion='HD_SENFIC_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select distinct
						sen.id_sensor,
						sen.estado,
						sen.estado_reg,
						sen.fecha_fin,
						sen.fecha_ini,
						sen.ficticio,
						sen.id_estacion,
						sen.fecha_reg,
						sen.id_usuario_reg,
						sen.fecha_mod,
						sen.id_usuario_mod,
                        sen.id_tipo_sensor,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        est.codigo as estacion,
                        tipsen.nombre_sensor as tipo_sensor,
					    --tipcol.nombre_medida,
                        sen.codigo
						from hidro.thd_sensor sen
                        inner join hidro.thd_estacion est on est.id_estacion = sen.id_estacion
                        inner join hidro.thd_tipo_sensor tipsen on tipsen.id_tipo_sensor = sen.id_tipo_sensor
                        inner join hidro.thd_tipo_columna_sensor tipcol on tipcol.id_tipo_sensor = sen.id_tipo_sensor
						inner join segu.tusuario usu1 on usu1.id_usuario = sen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = sen.id_usuario_mod
				        where sen.estado_reg = ''activo'' and sen.ficticio = false and ';
			
            raise notice '%',v_consulta;
            
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_SEN_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	elsif(p_transaccion='HD_SEN_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_sensor)
					    from hidro.thd_sensor sen
                        inner join hidro.thd_estacion est on est.id_estacion = sen.id_estacion
					    inner join segu.tusuario usu1 on usu1.id_usuario = sen.id_usuario_reg
                        inner join hidro.thd_tipo_columna_sensor tipcols on tipcols.id_tipo_sensor = sen.id_tipo_sensor
						left join segu.tusuario usu2 on usu2.id_usuario = sen.id_usuario_mod
					    where sen.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
        
    /*********************************    
 	#TRANSACCION:  'HD_SENC_CONT'
 	#DESCRIPCION:	Conteo de registros para los datos del combo de sensores
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	elsif(p_transaccion='HD_SENC_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_sensor)
					    from hidro.thd_sensor sen
                        inner join hidro.thd_estacion est on est.id_estacion = sen.id_estacion
                        inner join hidro.thd_tipo_columna_sensor tipcols on tipcols.id_tipo_sensor = sen.id_tipo_sensor
					    inner join segu.tusuario usu1 on usu1.id_usuario = sen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = sen.id_usuario_mod
					    where sen.estado_reg = ''activo'' and sen.id_estacion = '|| v_parametros.id_estacion ||' and ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
    
    /*********************************    
 	#TRANSACCION:  'HD_SENFIC_CONT'
 	#DESCRIPCION:	Conteo de registros para los datos del combo de sensores
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	elsif(p_transaccion='HD_SENFIC_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_sensor)
					    from hidro.thd_sensor sen
                        inner join hidro.thd_estacion est on est.id_estacion = sen.id_estacion
                        inner join hidro.thd_tipo_columna_sensor tipcols on tipcols.id_tipo_sensor = sen.id_tipo_sensor
					    inner join segu.tusuario usu1 on usu1.id_usuario = sen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = sen.id_usuario_mod
					    where sen.estado_reg = ''activo'' and sen.ficticio = false and ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_sensor_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1210 (class 1255 OID 2065806)
-- Dependencies: 45 2435
-- Name: f_thd_tipo_archivo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_tipo_archivo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_archivo_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_tipo_archivo'
 AUTOR: 		 (mflores)
 FECHA:	        23-11-2011 09:48:02
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_tipo_archivo	integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_tipo_archivo_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPAR_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:48:02
	***********************************/

	if(p_transaccion='HD_TIPAR_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_tipo_archivo(
			patron_nombre_archivo,
			num_file_ini,
			fecha_fin,
			periodo,
			estado_reg,
			fecha_ini,
			id_estacion,
			id_usuario_reg,
			fecha_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			v_parametros.patron_nombre_archivo,
			v_parametros.num_file_ini,
			v_parametros.fecha_fin,
			v_parametros.periodo,
			'activo',
			v_parametros.fecha_ini,
			v_parametros.id_estacion,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_tipo_archivo into v_id_tipo_archivo;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Archivo almacenado(a) con exito (id_tipo_archivo'||v_id_tipo_archivo||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_archivo',v_id_tipo_archivo::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPAR_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:48:02
	***********************************/

	elsif(p_transaccion='HD_TIPAR_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_tipo_archivo set
			patron_nombre_archivo = v_parametros.patron_nombre_archivo,
			num_file_ini = v_parametros.num_file_ini,
			fecha_fin = v_parametros.fecha_fin,
			periodo = v_parametros.periodo,
			fecha_ini = v_parametros.fecha_ini,
			id_estacion = v_parametros.id_estacion,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_tipo_archivo=v_parametros.id_tipo_archivo;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Archivo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_archivo',v_parametros.id_tipo_archivo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPAR_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:48:02
	***********************************/

	elsif(p_transaccion='HD_TIPAR_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from hidro.thd_tipo_archivo
            --where id_tipo_archivo=v_parametros.id_tipo_archivo;
            
            UPDATE hidro.thd_tipo_archivo
            SET estado_reg = 'inactivo'
            where id_tipo_archivo = v_parametros.id_tipo_archivo;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Archivo eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_archivo',v_parametros.id_tipo_archivo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_tipo_archivo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1214 (class 1255 OID 2065825)
-- Dependencies: 2435 45
-- Name: f_thd_tipo_archivo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_tipo_archivo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_archivo_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_tipo_archivo'
 AUTOR: 		 (mflores)
 FECHA:	        23-11-2011 09:48:02
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_tipo_archivo_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPAR_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:48:02
	***********************************/

	if(p_transaccion='HD_TIPAR_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						tipar.id_tipo_archivo,
						tipar.patron_nombre_archivo,
						tipar.num_file_ini,
						tipar.fecha_fin,
						tipar.periodo,
						tipar.estado_reg,
						tipar.fecha_ini,
						tipar.id_estacion,
						tipar.id_usuario_reg,
						tipar.fecha_reg,
						tipar.fecha_mod,
						tipar.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        esta.codigo
						from hidro.thd_tipo_archivo tipar
						inner join segu.tusuario usu1 on usu1.id_usuario = tipar.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipar.id_usuario_mod
                        inner join hidro.thd_estacion esta on esta.id_estacion = tipar.id_estacion
				        where tipar.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPAR_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:48:02
	***********************************/

	elsif(p_transaccion='HD_TIPAR_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_archivo)
					    from hidro.thd_tipo_archivo tipar
					    inner join segu.tusuario usu1 on usu1.id_usuario = tipar.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipar.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_tipo_archivo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1291 (class 1255 OID 3216090)
-- Dependencies: 45 2435
-- Name: f_thd_tipo_columna_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_tipo_columna_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_columna_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_tipo_columna'
 AUTOR: 		 (mflores)
 FECHA:	        15-03-2012 10:27:40
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_tipo_columna	integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_tipo_columna_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPCOL_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:40
	***********************************/

	if(p_transaccion='HD_TIPCOL_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_tipo_columna(
			estado_reg,
			codigo,
			tipo_dato,
			nombre_columna,
			tipo_columna,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.codigo,
			v_parametros.tipo_dato,
			v_parametros.nombre_columna,
			v_parametros.tipo_columna,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_tipo_columna into v_id_tipo_columna;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Columna almacenado(a) con exito (id_tipo_columna'||v_id_tipo_columna||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_columna',v_id_tipo_columna::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPCOL_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:40
	***********************************/

	elsif(p_transaccion='HD_TIPCOL_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_tipo_columna set
			codigo = v_parametros.codigo,
			tipo_dato = v_parametros.tipo_dato,
			nombre_columna = v_parametros.nombre_columna,
			tipo_columna = v_parametros.tipo_columna,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_tipo_columna=v_parametros.id_tipo_columna;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Columna modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_columna',v_parametros.id_tipo_columna::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPCOL_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:40
	***********************************/

	elsif(p_transaccion='HD_TIPCOL_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from hidro.thd_tipo_columna
            where id_tipo_columna=v_parametros.id_tipo_columna;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Columna eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_columna',v_parametros.id_tipo_columna::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_tipo_columna_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1292 (class 1255 OID 3216146)
-- Dependencies: 45 2435
-- Name: f_thd_tipo_columna_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_tipo_columna_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_columna_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_tipo_columna'
 AUTOR: 		 (mflores)
 FECHA:	        15-03-2012 10:27:40
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_tipo_columna_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPCOL_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:40
	***********************************/

	if(p_transaccion='HD_TIPCOL_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						tipcol.id_tipo_columna,
						tipcol.estado_reg,
						tipcol.codigo,
						tipcol.tipo_dato,
						tipcol.nombre_columna,
						tipcol.tipo_columna,
						tipcol.id_usuario_reg,
						tipcol.fecha_reg,
						tipcol.id_usuario_mod,
						tipcol.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from hidro.thd_tipo_columna tipcol
						inner join segu.tusuario usu1 on usu1.id_usuario = tipcol.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipcol.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPCOL_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:40
	***********************************/

	elsif(p_transaccion='HD_TIPCOL_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_columna)
					    from hidro.thd_tipo_columna tipcol
					    inner join segu.tusuario usu1 on usu1.id_usuario = tipcol.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipcol.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_tipo_columna_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1295 (class 1255 OID 3216147)
-- Dependencies: 45 2435
-- Name: f_thd_tipo_columna_sensor_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_tipo_columna_sensor_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_columna_sensor_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_tipo_columna_sensor'
 AUTOR: 		 (rac)
 FECHA:	        16-03-2012 17:06:17
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_tipo_columna_sensor	integer;
    
    var_cod_1				varchar;
    var_codigo				varchar;
    v_aux					varchar;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_tipo_columna_sensor_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TICOSEN_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	if(p_transaccion='HD_TICOSEN_INS')then
    
     	var_codigo := '';
        v_aux := trim(both ' ' from v_parametros.codigo_columna);
        raise notice '%', v_aux;
        
        while (select position(' ' in v_aux)) > 0 loop                    
            
            var_cod_1 := (select substr(v_aux,1, (select position(' ' in v_aux)) -1));            
            v_aux := (select substr(v_aux, (select position(' ' in v_aux))));
            var_codigo := COALESCE(var_codigo||var_cod_1);                   
            v_aux := trim(both ' ' from v_aux);               
              
        end loop;
              
        v_aux := trim(both ' ' from v_aux);
        var_codigo := COALESCE(var_codigo||v_aux);
        raise notice '%', var_codigo;

        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_tipo_columna_sensor(
			estado_reg,
			unidad_medida,
			prioridad,
			tipo_dato,
			nombre_columna,
			codigo_columna,
			id_tipo_sensor,
			mapeo_archivo,
			orden,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.unidad_medida,
			v_parametros.prioridad,
			v_parametros.tipo_dato,
			v_parametros.nombre_columna,
			lower(var_codigo),   --lower(v_parametros.codigo_columna),
			v_parametros.id_tipo_sensor,
			v_parametros.mapeo_archivo,
			v_parametros.orden,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_tipo_columna_sensor into v_id_tipo_columna_sensor;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Columna Sensor almacenado(a) con exito (id_tipo_columna_sensor'||v_id_tipo_columna_sensor||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_columna_sensor',v_id_tipo_columna_sensor::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_TICOSEN_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	elsif(p_transaccion='HD_TICOSEN_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_tipo_columna_sensor set
			unidad_medida = v_parametros.unidad_medida,
			prioridad = v_parametros.prioridad,
			tipo_dato = v_parametros.tipo_dato,
			nombre_columna = v_parametros.nombre_columna,
			codigo_columna = lower(v_parametros.codigo_columna),
			id_tipo_sensor = v_parametros.id_tipo_sensor,
			mapeo_archivo = v_parametros.mapeo_archivo,
			orden = v_parametros.orden,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_tipo_columna_sensor=v_parametros.id_tipo_columna_sensor;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Columna Sensor modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_columna_sensor',v_parametros.id_tipo_columna_sensor::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TICOSEN_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	elsif(p_transaccion='HD_TICOSEN_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from hidro.thd_tipo_columna_sensor
            /*update hidro.thd_tipo_columna_sensor set
            estado_reg = 'inactivo'*/
            where id_tipo_columna_sensor=v_parametros.id_tipo_columna_sensor;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Columna Sensor eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_columna_sensor',v_parametros.id_tipo_columna_sensor::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_tipo_columna_sensor_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1312 (class 1255 OID 3216148)
-- Dependencies: 2435 45
-- Name: f_thd_tipo_columna_sensor_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_tipo_columna_sensor_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_columna_sensor_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_tipo_columna_sensor'
 AUTOR: 		 (rac)
 FECHA:	        16-03-2012 17:06:17
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_tipo_columna_sensor_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TICOSEN_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	if(p_transaccion='HD_TICOSEN_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						ticosen.id_tipo_columna_sensor,
						ticosen.estado_reg,
						ticosen.unidad_medida,
						ticosen.prioridad,
						ticosen.tipo_dato,
						ticosen.nombre_columna,
						ticosen.codigo_columna,
						ticosen.id_tipo_sensor,
						ticosen.mapeo_archivo,
						ticosen.orden,
						ticosen.id_usuario_reg,
						ticosen.fecha_reg,
						ticosen.id_usuario_mod,
						ticosen.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from hidro.thd_tipo_columna_sensor ticosen
						inner join segu.tusuario usu1 on usu1.id_usuario = ticosen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ticosen.id_usuario_mod
				        where ticosen.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;           
            
             if(public.f_existe_parametro(p_tabla,'id_tipo_sensor')) then
               v_consulta:=v_consulta || ' and ticosen.id_tipo_sensor ='||v_parametros.id_tipo_sensor;
            end if;
             
             if(public.f_existe_parametro(p_tabla,'par_filtro')) then
                 if v_parametros.par_filtro='fecha' then
                  v_consulta:=v_consulta || ' and ticosen.tipo_dato in (''date'',''timestamp'')';
                 else
                   v_consulta:=v_consulta || ' and ticosen.tipo_dato in (''numeric'',''integuer'')';
                 
                 end if;                   
           
             end if;
             
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            
            
            raise notice  '%',v_consulta;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TICOSEN_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	elsif(p_transaccion='HD_TICOSEN_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_columna_sensor)
					    from hidro.thd_tipo_columna_sensor ticosen
					    inner join segu.tusuario usu1 on usu1.id_usuario = ticosen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ticosen.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_tipo_columna_sensor_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 266 (class 1255 OID 3322858)
-- Dependencies: 45 2435
-- Name: f_thd_tipo_dato_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_tipo_dato_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_dato_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_tipo_dato'
 AUTOR: 		 (mflores)
 FECHA:	        02-04-2012 17:34:04
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_tipo_dato	integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_tipo_dato_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPDAT_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:04
	***********************************/

	if(p_transaccion='HD_TIPDAT_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_tipo_dato(
			estado_reg,
			tipo_dato,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.tipo_dato,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_tipo_dato into v_id_tipo_dato;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Tipo dato almacenado(a) con exito (id_tipo_dato'||v_id_tipo_dato||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_dato',v_id_tipo_dato::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPDAT_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:04
	***********************************/

	elsif(p_transaccion='HD_TIPDAT_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_tipo_dato set
			tipo_dato = v_parametros.tipo_dato,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_tipo_dato=v_parametros.id_tipo_dato;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo dato modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_dato',v_parametros.id_tipo_dato::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPDAT_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:04
	***********************************/

	elsif(p_transaccion='HD_TIPDAT_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from hidro.thd_tipo_dato
            where id_tipo_dato=v_parametros.id_tipo_dato;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo dato eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_dato',v_parametros.id_tipo_dato::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_tipo_dato_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 267 (class 1255 OID 3322859)
-- Dependencies: 45 2435
-- Name: f_thd_tipo_dato_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_tipo_dato_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_dato_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_tipo_dato'
 AUTOR: 		 (mflores)
 FECHA:	        02-04-2012 17:34:04
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_tipo_dato_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPDAT_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:04
	***********************************/

	if(p_transaccion='HD_TIPDAT_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						tipdat.id_tipo_dato,
						tipdat.estado_reg,
						tipdat.tipo_dato,
						tipdat.id_usuario_reg,
						tipdat.fecha_reg,
						tipdat.id_usuario_mod,
						tipdat.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from hidro.thd_tipo_dato tipdat
						inner join segu.tusuario usu1 on usu1.id_usuario = tipdat.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipdat.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPDAT_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:04
	***********************************/

	elsif(p_transaccion='HD_TIPDAT_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_dato)
					    from hidro.thd_tipo_dato tipdat
					    inner join segu.tusuario usu1 on usu1.id_usuario = tipdat.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipdat.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_tipo_dato_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1211 (class 1255 OID 2065911)
-- Dependencies: 45 2435
-- Name: f_thd_tipo_muestra_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_tipo_muestra_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_muestra_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_tipo_muestra'
 AUTOR: 		 (mflores)
 FECHA:	        23-11-2011 09:50:17
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_tipo_muestra	integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_tipo_muestra_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPMU_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:17
	***********************************/

	if(p_transaccion='HD_TIPMU_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_tipo_muestra(
			nombre,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.nombre,
			'activo',
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_tipo_muestra into v_id_tipo_muestra;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Muestra almacenado(a) con exito (id_tipo_muestra'||v_id_tipo_muestra||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_muestra',v_id_tipo_muestra::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPMU_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:17
	***********************************/

	elsif(p_transaccion='HD_TIPMU_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_tipo_muestra set
			nombre = v_parametros.nombre,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_tipo_muestra=v_parametros.id_tipo_muestra;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Muestra modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_muestra',v_parametros.id_tipo_muestra::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPMU_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:17
	***********************************/

	elsif(p_transaccion='HD_TIPMU_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from hidro.thd_tipo_muestra
            where id_tipo_muestra=v_parametros.id_tipo_muestra;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Muestra eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_muestra',v_parametros.id_tipo_muestra::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_tipo_muestra_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1213 (class 1255 OID 2065943)
-- Dependencies: 45 2435
-- Name: f_thd_tipo_muestra_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_tipo_muestra_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_muestra_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_tipo_muestra'
 AUTOR: 		 (mflores)
 FECHA:	        23-11-2011 09:50:17
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_tipo_muestra_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPMU_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:17
	***********************************/

	if(p_transaccion='HD_TIPMU_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						tipmu.id_tipo_muestra,
						tipmu.nombre,
						tipmu.estado_reg,
						tipmu.id_usuario_reg,
						tipmu.fecha_reg,
						tipmu.id_usuario_mod,
						tipmu.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from hidro.thd_tipo_muestra tipmu
						inner join segu.tusuario usu1 on usu1.id_usuario = tipmu.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipmu.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPMU_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:17
	***********************************/

	elsif(p_transaccion='HD_TIPMU_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_muestra)
					    from hidro.thd_tipo_muestra tipmu
					    inner join segu.tusuario usu1 on usu1.id_usuario = tipmu.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipmu.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_tipo_muestra_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1289 (class 1255 OID 3267502)
-- Dependencies: 2435 45
-- Name: f_thd_tipo_sensor_codigo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: rac
--

CREATE FUNCTION f_thd_tipo_sensor_codigo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_sensor_codigo_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_tipo_columna_sensor'
 AUTOR: 		 (rac)
 FECHA:	        16-03-2012 17:06:17
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_tipo_columna_sensor	integer;
    v_consulta varchar;
    v_consulta2 varchar;
    v_param varchar[]; 
    v_param_det varchar[]; 
    v_tamano  integer;
    v_i integer;
    v_array_tipos varchar[];
    v_array_codigos varchar[];
    v_array_orden integer[];
    v_cont integer;
    v_cont_reg integer;
    aux varchar;
    vector varchar[];
    fila varchar[];
    cols_titulo  integer;
    cant_filas integer;
    cant_cols integer;
    registros varchar[];
    v_registros record;
    v_registros_excel record;
   
    v_consulta_final varchar;
    v_consulta_final2 varchar;
    v_k integer;
    
    v_aux_val varchar;
    
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_tipo_sensor_codigo_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TISENCO_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	if(p_transaccion='HD_TISENCO_INS')then
					
        begin
        
        
        --Sentencia de la consulta
			  v_consulta:='insert into hidro.thd_tipo_sensor_'|| v_parametros.tipo_sensor_codigo ||' (';
                        
              v_consulta2:='	estado_reg,id_usuario_reg,fecha_reg) values(';
           
              raise notice '%',v_parametros.datos;
                        
              v_param= string_to_array(v_parametros.datos,'@');
              
              v_tamano = coalesce(array_length(v_param, 1),0);
             
	      raise notice '#####  % %','id_tipo_sensor_'||v_parametros.tipo_sensor_codigo,v_parametros.tipo_sensor_codigo;
            
            FOR v_i IN 1..v_tamano LOOP
            
              raise notice '>>> %',v_consulta;
              raise notice '<<< %',v_consulta2;
              raise notice 'v_i % v_tamano %',v_i,v_tamano;
            
            
              v_param_det= string_to_array(v_param[v_i],'#');
      
              --verifica que no sea la llave        
              
              --raise notice 'XXXXXXXXXX';
              
              if ( v_param_det[1] != ('id_tipo_sensor_'||v_parametros.tipo_sensor_codigo)) THEN
                
                
                --raise notice 'YYYYYYYYYYY';
              
                    v_consulta:=v_consulta||trim(v_param_det[1]::varchar)||',';
                    
                    IF(v_param_det[2]='varchar' or v_param_det[2]='text' or v_param_det[2]='date' or v_param_det[2]='timestamp' or v_param_det[2]='time')THEN
                      

                       v_consulta2:=v_consulta2||''''||trim(f_get_parametro(p_tabla,v_param_det[1]))||''',';
                      
                      
                    ELSE
                      
                       v_consulta2:=v_consulta2||trim(f_get_parametro(p_tabla,v_param_det[1]))||',';
                   
                    END IF;
                    
                    
                    
                    
              ELSE      
	              raise notice '#####  % %','id_tipo_sensor_'||v_parametros.tipo_sensor_codigo,v_parametros.tipo_sensor_codigo;
              
              END IF;
              
              
            END LOOP;
            
            v_consulta=v_consulta||v_consulta2||'''activo'','||p_id_usuario::varchar||','''||now()::varchar||''')';
           
            raise notice '%',v_consulta;
        
	        execute(v_consulta);
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Sensor Codigo insertado hidro.thd_tipo_sensor_'||v_parametros.tipo_sensor_codigo); 
         

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_TISENCO_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	elsif(p_transaccion='HD_TISENCO_MOD')then

		begin
        
          v_consulta:='update  hidro.thd_tipo_sensor_'|| v_parametros.tipo_sensor_codigo ||' set  ';
                        
        
           
              raise notice '%',v_parametros.datos;
                        
              v_param= string_to_array(v_parametros.datos,'@');
              
              v_tamano = coalesce(array_length(v_param, 1),0);
             
	        
            FOR v_i IN 1..v_tamano LOOP
             v_param_det= string_to_array(v_param[v_i],'#');
             
              v_consulta:=v_consulta||trim(v_param_det[1]::varchar)||'=';
             
             IF(v_param_det[2]='varchar' or v_param_det[2]='text' or v_param_det[2]='date' or v_param_det[2]='timestamp' or v_param_det[2]='time')THEN

                  v_consulta:=v_consulta||''''||trim(f_get_parametro(p_tabla,v_param_det[1]))||''',';
               ELSE 
               
                  v_consulta:=v_consulta||trim(f_get_parametro(p_tabla,v_param_det[1]))||',';
                   
              END IF ;      
            END LOOP;
            
            v_consulta=v_consulta||'id_usuario_mod ='|| p_id_usuario||',
			                        fecha_mod ='''||now()||'''
			                        where id_tipo_sensor_'|| v_parametros.tipo_sensor_codigo ||'='||trim(f_get_parametro(p_tabla,'id_tipo_sensor_'||v_parametros.tipo_sensor_codigo));
            
            
            raise notice '%',v_consulta;
        
	        execute(v_consulta);
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo id_tipo_sensor_'||v_parametros.tipo_sensor_codigo ||' '||trim(f_get_parametro(p_tabla,'id_tipo_sensor_'||v_parametros.tipo_sensor_codigo))); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_sensor_'||v_parametros.tipo_sensor_codigo,trim(f_get_parametro(p_tabla,'id_tipo_sensor_'||v_parametros.tipo_sensor_codigo)));
               
            --Devuelve la respuesta
            return v_resp;
            
		end;
    /*********************************    
 	#TRANSACCION:  'HD_TISECOFI_IME'
 	#DESCRIPCION:	Inserta un archivo excel de manera dinamica
 	#AUTOR:			rac	
 	#FECHA:			07-09-2011 15:50:29
	***********************************/

	elseif(p_transaccion='HD_TISECOFI_IME')then
		
     begin
     
      --crea una tabla temporal con las columnas del archivo excel
      
      --se obtiene el bytea y se quita la codificación
      aux := (select decode(v_parametros.excel::text,'base64')); 
    
      --descomponer el bytea en un vector que contenga una fila del CSV cada uno
	  --\\015\\012 --> ENTER o salto de linea/retorno de carro en el bytea	
    
      vector := string_to_array(aux,'\\015\\012'); 
      
      --desconpone la primera fila suponiendo que son los nombres de las columnas separados por ';'
      
      fila:= string_to_array(vector[1],';');
      
      
      --obtiene la cantidad de columnas
      cols_titulo = array_upper(fila,1);
      
      
    
      --creamo una tabla temporal con los valores y columnas del archivo
      v_consulta := 'create temp table valores_importados (id integer';
      
      for v_k in 1..cols_titulo loop
        
            v_consulta :=  v_consulta ||','||fila[v_k]||' varchar';
        
       
       end loop;
       
       
      
       
       v_consulta :=  v_consulta ||'  ) on commit drop';
       
       
      
       execute v_consulta; 
       
        
      
     --recorre los registro del archivo excel desde la segunda fila
      select array_upper(vector,1) into cant_filas; --cantidad de registros del CSV
      v_cont_reg =1;
      
      
      FOR v_i in 2..(cant_filas-1) loop
      
      
      
            v_consulta := 'insert into valores_importados values ('||v_cont_reg::varchar||','; --inicio de la consulta del insert
            
            v_cont_reg=v_cont_reg+1;
            
            
           --descomponer cada fila para obtener las columnas del CSV
            
            registros := string_to_array(vector[v_i],';'); 
            
            
             
             select array_upper(registros,1) into cant_cols; --cantidad de columnas del CSV
            
            
            for v_j in 1..(cant_cols-1) loop
                
                 --si el formato decimal csv  esta dividio por comas replazamos por puntos           
               
                 registros[v_j] := (select replace(registros[v_j]::text,',','.')); --reemplazar las comas por puntos
                
                v_consulta := v_consulta ||''''|| registros[v_j] || ''','; --continuar con la insercion hasta la columna N-1
                     	
            end loop;
           
            registros[cant_cols] := (select replace(registros[cant_cols]::text,',','.')); --reemplazar las comas por puntos
                
            
            v_consulta := v_consulta ||''''||  registros[cant_cols] || ''');'; --insertar la ultima columna 
            execute v_consulta; --ejecutar el inser
            
              
      END LOOP;
      
      
       
      
      -- consultas la columnas del tipo sensor correpondientes ordenadas por la columnas orden
         
       v_consulta_final:='insert into hidro.thd_tipo_sensor_'|| v_parametros.tipo_sensor_codigo ||' (id_sensor';
                           
    

         v_cont=0;
         
         FOR v_registros in ( Select cs.codigo_columna, cs.nombre_columna, 
         							 cs.mapeo_archivo,cs.tipo_dato,cs.orden
                              from hidro.thd_tipo_columna_sensor cs  
                              where cs.id_tipo_sensor=v_parametros.id_tipo_sensor) LOOP
                              
           --arma la primera parte de la consuulta
           v_consulta_final=v_consulta_final||','||v_registros.codigo_columna;
          v_cont=v_cont+1; 
          
           --arma vector con los nombre de las columnas y tipos para la segunda parte
           v_array_codigos[v_cont] = v_registros.codigo_columna;
           v_array_tipos[v_cont] = v_registros.tipo_dato;
           v_array_orden[v_cont] = v_registros.orden;
          
         
                              
         END LOOP;
         
    
         --consulta las columnas del tipo snsor
       
         v_consulta := 'select * from valores_importados'; 
       
         v_cont_reg=0;
       
        FOR v_registros_excel in (select * from valores_importados) LOOP
        
          v_cont_reg=v_cont_reg+1;
        
          v_consulta_final2:=',estado_reg,id_usuario_reg,fecha_reg) values('||v_parametros.id_sensor;
          
               FOR v_i IN 1..v_cont LOOP
                 v_aux_val=f_get_parametro_by_id('valores_importados',v_array_codigos[v_i],'id='||v_cont_reg::varchar);
                   -- 
                   
                   IF v_aux_val<> '' THEN
                     IF( v_array_tipos[v_i]='varchar' or  v_array_tipos[v_i]='text' or  v_array_tipos[v_i]='date' or  v_array_tipos[v_i]='timestamp' or  v_array_tipos[v_i]='time')THEN
                         
                         v_consulta_final2=v_consulta_final2||','''||v_aux_val||'''';
                      ELSE
                         v_consulta_final2=v_consulta_final2||','||v_aux_val;
                      END IF;
                    ELSE
                    v_consulta_final2=v_consulta_final2||','||'NULL';
                    END IF;
                
                
                END LOOP;
                 
                
                v_consulta_final2=v_consulta_final||v_consulta_final2||',''activo'','||p_id_usuario::varchar||','''||now()||''');';
                  
                --raise exception '%',v_consulta_final2;
                
                execute (v_consulta_final2);
              

          
          END LOOP;                     
        
        --Definicion de la respuesta
		v_resp = f_agrega_clave(v_resp,'mensaje','Mediciones importadas'); 
       

        --Devuelve la respuesta*/
         return v_resp;
        
		end;   
        

	/*********************************    
 	#TRANSACCION:  'HD_TISECO_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	elsif(p_transaccion='HD_TISECO_ELI')then

		begin
        
            --Sentencia de la eliminacion
            v_consulta='delete from hidro.thd_tipo_sensor_'||v_parametros.tipo_sensor_codigo ||'
                    where id_tipo_sensor_'||v_parametros.tipo_sensor_codigo||'='||v_parametros.id_tipo_sensor_codigo;
                    
             execute(v_consulta);
                    
			 --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Sensor Codigo  hidro.thd_tipo_sensor_'||v_parametros.tipo_sensor_codigo ||' eliminado(a)'||v_parametros.id_tipo_sensor_codigo); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_columna_sensor',v_parametros.id_tipo_sensor_codigo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_tipo_sensor_codigo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rac;

--
-- TOC entry 1130 (class 1255 OID 3264074)
-- Dependencies: 45 2435
-- Name: f_thd_tipo_sensor_codigo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: rac
--

CREATE FUNCTION f_thd_tipo_sensor_codigo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_sensor_codigo_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_tipo_columna_sensor'
 AUTOR: 		 (rac)
 FECHA:	        16-03-2012 17:06:17
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_param  varchar[];
    v_tamano integer;
    v_i integer;
    v_param_det varchar[];
      
BEGIN

	v_nombre_funcion = 'hidro.f_thd_tipo_sensor_codigo_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TISENCOD_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	if(p_transaccion='HD_TISENCOD_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select  ';
                        
                        
                        
              v_param= string_to_array(v_parametros.datos,'@');
              
              v_tamano = coalesce(array_length(v_param, 1),0);
             

            
            FOR v_i IN 1..v_tamano LOOP
              v_param_det= string_to_array(v_param[v_i],'#');
              v_consulta:=v_consulta||'ticosen.'||trim(v_param_det[1]::varchar)||',';
            END LOOP;          
                        
						
						
            v_consulta:=v_consulta||'
                        ticosen.estado_reg,
                        ticosen.id_usuario_reg,
						ticosen.fecha_reg,
						ticosen.id_usuario_mod,
						ticosen.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from hidro.thd_tipo_sensor_'|| v_parametros.tipo_sensor_codigo ||' ticosen
						inner join segu.tusuario usu1 on usu1.id_usuario = ticosen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ticosen.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
             if(public.f_existe_parametro(p_tabla,'id_sensor')) then
               v_consulta:=v_consulta || ' and ticosen.id_sensor='||v_parametros.id_sensor;
            end if;
            
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;	
            
            
            raise notice '%',v_consulta;



			--Devuelve la respuesta
			return v_consulta;
						
		end;



	/*********************************    
 	#TRANSACCION:  'HD_TISENCODREP_SEL'
 	#DESCRIPCION:	Consulta de datos dinamica para reportes
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	elseif(p_transaccion='HD_TISENCODREP_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select  
            			ticosen.'||v_parametros.tipo_columna_sensor_valor||'::numeric as valor,
						ticosen.'||v_parametros.tipo_columna_sensor_fecha||'::timestamp as fecha
						from hidro.thd_tipo_sensor_'||v_parametros.tipo_sensor_codigo||' ticosen
						where   
                        ticosen.id_sensor='||v_parametros.id_sensor||'
                        and ticosen.'||v_parametros.tipo_columna_sensor_fecha||'<='''||v_parametros.fecha_fin||'''
                        and ticosen.'||v_parametros.tipo_columna_sensor_fecha||'>='''||v_parametros.fecha_ini||'''';

            
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion;	
            
            
            raise notice '%',v_consulta;



			--Devuelve la respuesta
			return v_consulta;
						
		end;
        
    /*********************************    
 	#TRANSACCION:  'HD_PROM_HIDRO'
 	#DESCRIPCION:	Consulta de datos dinamica para reportes
 	#AUTOR:			mflores	
 	#FECHA:			23-05-2012 17:00
	***********************************/

	elseif(p_transaccion='HD_PROM_HIDRO')then     				    

    raise notice 'param: %',v_parametros;
    
    	begin
        
        
    		--Sentencia de la consulta
			v_consulta:='select  
            			ticosen.'||v_parametros.tipo_columna_sensor_valor||'::numeric as valor,
						ticosen.'||v_parametros.tipo_columna_sensor_fecha||'::timestamp as fecha
						from hidro.thd_tipo_sensor_'||v_parametros.tipo_sensor_codigo||' ticosen
						where   
                        ticosen.id_sensor='||v_parametros.id_sensor||'
                        and ticosen.'||v_parametros.tipo_columna_sensor_fecha||'<='''||v_parametros.fecha_fin||'''
                        and ticosen.'||v_parametros.tipo_columna_sensor_fecha||'>='''||v_parametros.fecha_ini||'''';

            
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion;	
            
            
            raise notice '%',v_consulta;



			--Devuelve la respuesta
			return v_consulta;
						
		end;           
    
	/*********************************    
 	#TRANSACCION:  'HD_TISENCOD_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	elsif(p_transaccion='HD_TISENCOD_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_sensor_'||v_parametros.tipo_sensor_codigo ||')
					    from hidro.thd_tipo_sensor_'||v_parametros.tipo_sensor_codigo ||' ticosen
					    inner join segu.tusuario usu1 on usu1.id_usuario = ticosen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ticosen.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta	
            raise notice '%',v_consulta;	    
			v_consulta:=v_consulta||v_parametros.filtro;
            if(public.f_existe_parametro(p_tabla,'id_sensor')) then
               v_consulta:=v_consulta || ' and ticosen.id_sensor='||v_parametros.id_sensor;
            end if;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_tipo_sensor_codigo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rac;

--
-- TOC entry 1290 (class 1255 OID 1400725)
-- Dependencies: 45 2435
-- Name: f_thd_tipo_sensor_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_tipo_sensor_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_sensor_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_tipo_sensor'
 AUTOR: 		 (mflores)
 FECHA:	        15-03-2012 10:27:35
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_tipo_sensor		integer;
    v_codigo				varchar;
    v_estado_ts 			varchar;
    v_consulta 				varchar;
    v_record 				record;
    
    var_cod_1				varchar;
    var_codigo				varchar;
    v_aux					varchar;
			    
BEGIN	

    v_nombre_funcion = 'hidro.f_thd_tipo_sensor_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPSEN_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:35
	***********************************/

	if (p_transaccion = 'HD_TIPSEN_INS') then
		
        var_codigo := '';
        v_aux := trim(both ' ' from v_parametros.codigo);
        raise notice '%', v_aux;
        
        while (select position(' ' in v_aux)) > 0 loop                    
            
            var_cod_1 := (select substr(v_aux,1, (select position(' ' in v_aux)) -1));            
            v_aux := (select substr(v_aux, (select position(' ' in v_aux))));
            var_codigo := COALESCE(var_codigo||var_cod_1);                   
            v_aux := trim(both ' ' from v_aux);               
              
        end loop;
              
        v_aux := trim(both ' ' from v_aux);
        var_codigo := COALESCE(var_codigo||v_aux);
        raise notice '%', var_codigo;
                      		
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_tipo_sensor(
			estado_reg,
			abreviacion,
			--tipo_dato,
			codigo,
			--equivalente_hidra,
			descrip,
			nombre_sensor,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.abreviacion,
			--v_parametros.tipo_dato,			
            lower(var_codigo), --v_parametros.codigo,
			--v_parametros.equivalente_hidra,
			v_parametros.descrip,
			v_parametros.nombre_sensor,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_tipo_sensor into v_id_tipo_sensor;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Sensor almacenado(a) con exito (id_tipo_sensor'||v_id_tipo_sensor||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_sensor',v_id_tipo_sensor::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPSEN_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:35
	***********************************/

	elsif(p_transaccion='HD_TIPSEN_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_tipo_sensor set
			abreviacion = v_parametros.abreviacion,
			--tipo_dato = v_parametros.tipo_dato,
			codigo = v_parametros.codigo,
			--equivalente_hidra = v_parametros.equivalente_hidra,
			descrip = v_parametros.descrip,
			nombre_sensor = v_parametros.nombre_sensor,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_tipo_sensor=v_parametros.id_tipo_sensor;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Sensor modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_sensor',v_parametros.id_tipo_sensor::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;
        
    /*********************************    
 	#TRANSACCION:  'HD_GENTAB_MOD'
 	#DESCRIPCION:	Genera la tabla dinamica para el tipo sensor y cambia de estado
 	#AUTOR:		rac	
 	#FECHA:		15-03-2012 10:27:35
	***********************************/

	elsif(p_transaccion='HD_GENTAB_MOD')then

		begin
          --0) obtiene datos iniciales
             select ts.estado_ts, ts.codigo into v_estado_ts, v_codigo
             from hidro.thd_tipo_sensor ts
             where ts.id_tipo_sensor=v_parametros.id_tipo_sensor;
             
          --1) verifica que este en estado borrado
          
            if(v_estado_ts <> 'borrador') then
            	raise exception  'Solo se puede generar tablas para el estado borrador';
            end if;
          
          --2) preprara prefijo de creacion de tabla
          
          v_consulta = 'CREATE TABLE hidro.thd_tipo_sensor_'||v_codigo||' (
                          id_tipo_sensor_'||v_codigo||' SERIAL NOT NULL, 
                          id_tipo_sensor INTEGER,
                          id_sensor INTEGER
                          ';
                          
          
          --3) FOR  consulta llas columas en orden de prioridad
          
          IF  exists (select 1 
                    from hidro.thd_tipo_columna_sensor tcs 
                    where tcs.id_tipo_sensor =v_parametros.id_tipo_sensor) THEN
          
                  FOR v_record in (select tcs.codigo_columna, tcs.tipo_dato 
                                   from hidro.thd_tipo_columna_sensor tcs 
                                   where tcs.id_tipo_sensor =v_parametros.id_tipo_sensor )LOOP
                  
                  --2.3) 
                  --2.4) va armando columnas para la creacion de la tabla
                   v_consulta = v_consulta ||','||v_record.codigo_columna ||'  '||v_record.tipo_dato;
                  
                  
                  END LOOP;
                  --4) cierra prefijo
                  
                 v_consulta = v_consulta ||', CONSTRAINT thd_tipo_sensor_'||v_codigo||'_pkey PRIMARY KEY(id_tipo_sensor_'||v_codigo||'), 
                                  CONSTRAINT fk_thd_tipo_sensor_'||v_codigo||'__id_tipo_sensor FOREIGN KEY (id_tipo_sensor)
                                  REFERENCES hidro.thd_tipo_sensor(id_tipo_sensor)
                                  ON DELETE NO ACTION
                                  ON UPDATE NO ACTION
                                  NOT DEFERRABLE,
                                  CONSTRAINT fk_thd_sensor_'||v_codigo||'__id_sensor FOREIGN KEY (id_sensor)
                                  REFERENCES hidro.thd_sensor(id_sensor)
                                  ON DELETE NO ACTION
                                  ON UPDATE NO ACTION
                                  NOT DEFERRABLE
                                  
                                ) INHERITS (public.tbase)
                                WITHOUT OIDS;';
                  
                  --5) crea tabla
                  RAISE NOTICE  '%',v_consulta;
                  execute (v_consulta);
                   RAISE NOTICE  '>>>>>>>>>>>';
                  
                  
                  --6) otorga permisos al rol generico de usuarios para base de datos sobre esquema hidro
                  
                   v_consulta= 'GRANT ALL PRIVILEGES ON hidro.thd_tipo_sensor_'||v_codigo||'  TO "rol_usuario_'||(current_database()::text)||'"';
                   RAISE NOTICE  '%',v_consulta;
                   EXECUTE (v_consulta);
                  
                  
                  --7)cambia estado del tipo sensor
                    update hidro.thd_tipo_sensor set
                    estado_ts='generado',
                    id_usuario_mod = p_id_usuario,
                    fecha_mod = now()
                    where id_tipo_sensor=v_parametros.id_tipo_sensor;
                       
                    --Definicion de la respuesta
                    v_resp = f_agrega_clave(v_resp,'mensaje','Tabla generada para el tipo sensor ' ||v_codigo); 
                    v_resp = f_agrega_clave(v_resp,'id_tipo_sensor',v_parametros.id_tipo_sensor::varchar);
                       
                    --Devuelve la respuesta
                    return v_resp;

           ELSE

             raise exception 'El tipo de sensor no tiene columnas definidas';

           END IF;
            
		end;
           

	/*********************************    
 	#TRANSACCION:  'HD_TIPSEN_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:35
	***********************************/

	elsif(p_transaccion='HD_TIPSEN_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from hidro.thd_tipo_sensor
            
            update hidro.thd_tipo_columna_sensor set
            estado_reg = 'inactivo'
            where id_tipo_sensor=v_parametros.id_tipo_sensor;
            
            update hidro.thd_tipo_sensor set
            estado_reg = 'inactivo'
            where id_tipo_sensor=v_parametros.id_tipo_sensor;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Sensor eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_sensor',v_parametros.id_tipo_sensor::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_tipo_sensor_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1138 (class 1255 OID 1400724)
-- Dependencies: 45 2435
-- Name: f_thd_tipo_sensor_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_tipo_sensor_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_sensor_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_tipo_sensor'
 AUTOR: 		 (mflores)
 FECHA:	        15-03-2012 10:27:35
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_tipo_sensor_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPSEN_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:35
	***********************************/

	if(p_transaccion='HD_TIPSEN_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						tipsen.id_tipo_sensor,
						tipsen.estado_reg,
						tipsen.abreviacion,
						--tipsen.tipo_dato,
						tipsen.codigo,
						-- tipsen.equivalente_hidra,
						tipsen.descrip,
						tipsen.nombre_sensor,
						tipsen.id_usuario_reg,
						tipsen.fecha_reg,
						tipsen.id_usuario_mod,
						tipsen.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        tipsen.estado_ts	
						from hidro.thd_tipo_sensor tipsen
						inner join segu.tusuario usu1 on usu1.id_usuario = tipsen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipsen.id_usuario_mod
				        where tipsen.estado_reg = ''activo'' and  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

--			raise notice '%', v_consulta;
            --Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPSEN_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:35
	***********************************/

	elsif(p_transaccion='HD_TIPSEN_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_sensor)
					    from hidro.thd_tipo_sensor tipsen
					    inner join segu.tusuario usu1 on usu1.id_usuario = tipsen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipsen.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_tipo_sensor_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1313 (class 1255 OID 3322857)
-- Dependencies: 45 2435
-- Name: f_thd_unidad_medida_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_unidad_medida_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_unidad_medida_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_unidad_medida'
 AUTOR: 		 (mflores)
 FECHA:	        02-04-2012 17:34:59
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_simbolo				varchar;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_unidad_medida_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_UNIMED_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:59
	***********************************/

	if(p_transaccion='HD_UNIMED_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_unidad_medida(
			estado_reg,
			simbolo,
			unidad_medida,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.simbolo,
			v_parametros.unidad_medida,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING simbolo into v_simbolo;
               
            raise exception '%', v_simbolo;
            
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Unidad medida almacenado(a) con exito (simbolo'||v_simbolo||')'); 
            v_resp = f_agrega_clave(v_resp,'simbolo',v_simbolo::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_UNIMED_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:59
	***********************************/

	elsif(p_transaccion='HD_UNIMED_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_unidad_medida set
			simbolo = v_parametros.simbolo,
			unidad_medida = v_parametros.unidad_medida,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where simbolo = v_parametros.simbolo;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Unidad medida modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'simbolo',v_parametros.simbolo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_UNIMED_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:59
	***********************************/

	elsif(p_transaccion='HD_UNIMED_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from hidro.thd_unidad_medida
            where simbolo=v_parametros.simbolo;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Unidad medida eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'simbolo',v_parametros.simbolo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION hidro.f_thd_unidad_medida_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1168 (class 1255 OID 3322856)
-- Dependencies: 2435 45
-- Name: f_thd_unidad_medida_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: postgres
--

CREATE FUNCTION f_thd_unidad_medida_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_unidad_medida_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_unidad_medida'
 AUTOR: 		 (mflores)
 FECHA:	        02-04-2012 17:34:59
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_unidad_medida_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_UNIMED_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:59
	***********************************/

	if(p_transaccion='HD_UNIMED_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						--unimed.id_unidad_medida,
						unimed.estado_reg,
						unimed.simbolo,
						unimed.unidad_medida,
						unimed.id_usuario_reg,
						unimed.fecha_reg,
						unimed.id_usuario_mod,
						unimed.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from hidro.thd_unidad_medida unimed
						inner join segu.tusuario usu1 on usu1.id_usuario = unimed.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = unimed.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_UNIMED_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:59
	***********************************/

	elsif(p_transaccion='HD_UNIMED_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(simbolo)
					    from hidro.thd_unidad_medida unimed
					    inner join segu.tusuario usu1 on usu1.id_usuario = unimed.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = unimed.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION hidro.f_thd_unidad_medida_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

SET search_path = param, pg_catalog;

--
-- TOC entry 278 (class 1255 OID 1475521)
-- Dependencies: 11 2435
-- Name: ___f_obtener_correlativo(integer, integer, integer, integer); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION ___f_obtener_correlativo(par_id_documento integer, par_id_periodo integer, par_id_gestion integer, par_id_usuario integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.f_obtener_correlativo
 DESCRIPCION:   Obtiene el correlativo de acuerdo al documento y periodo/gestion especificado
 AUTOR: 	    KPLIAN
 FECHA:	        03/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE

    
    v_resp                      varchar;
    v_nombre_funcion            text;
    v_mensaje_error             text;
    
    v_correlativo               integer;
    v_cadena                    varchar;
BEGIN
    v_nombre_funcion:='param.f_obtener_correlativo';
    -- verificar que los parametros de entrada no sean nulos (id_periodo e id_gestion) al mismo tiempo
    if(par_id_periodo is null and par_id_gestion is null) then
        raise exception 'Se debe indicar un modo de obtencion de Correlativos. Por PERIODO o GESTION';
    end if;
    
    if(par_id_periodo is not null and par_id_gestion is not null) then
        raise exception 'Solo se debe indicar un modo de obtencion de Correlativos. Por PERIODO o GESTION';
    end if;
    -- validar la existencia del documento para el que se quiere obtener el correlativo
    if not exists (select 1 from param.tdocumento where id_documento=par_id_documento) then
        raise exception 'Obtencion de correlativo no realizada. Documento inexistente';
    end if;
    
    if(par_id_periodo is null) then
      -- validar gestion activa
      if exists (select 1 from param.tgestion where id_gestion=par_id_gestion and estado_reg!='activo') then
         raise exception 'La gestion no esta activa';
      end if;
    else
      if exists (select 1 from param.tperiodo where id_periodo=par_id_periodo and estado_reg!='activo') then
         raise exception 'El periodo solicitado no esta activo';
      end if;
    end if;
    -- validar si existe alguna numeracion generada de acuerdo a los parametros de entrada
    if((select count(*) from param.tcorrelativo where id_documento=par_id_documento and (id_periodo=par_id_periodo or id_gestion=par_id_gestion))>0) then
         v_correlativo:=(select coalesce(num_actual,0) from param.tcorrelativo where id_documento=par_id_documento and ||' '||v_cadena );
    else
         v_correlativo:=0;
    end if;

   if (v_correlativo=0) then
     insert into param.tcorrelativo (id_documento,id_gestion, id_periodo,num_actual, num_siguiente, estado_reg, fecha_reg, id_usuario_reg )
     values (par_id_documento, par_id_gestion, par_id_periodo, v_correlativo+1, v_correlativo+2, 'activo', now(), par_id_usuario);
   else
        -- validar que el correlativo que se quiere generar siga el mismo tipo de periodicidad
        if not exists (select 1 from param.tcorrelativo where id_documento=par_id_documento and (
                   (par_id_periodo is null and id_periodo is null) and (par_id_gestion is not null and id_gestion is not null)
                 or (par_id_periodo is not null and id_periodo is not null) and (par_id_gestion is null and id_gestion is null)
                   )
        ) then
        raise exception 'No es posible obtener un correlativo por % ',f_iif (par_id_periodo is null, 'Gestion', 'Periodo') || 'pues el documento tiene periodicidad de ' ||f_iif (par_id_periodo is null, 'Periodo', 'Gestion');

        end if;
     
        update param.tcorrelativo set
            num_siguiente=num_actual+2,
            num_actual=num_actual+1
        where id_documento=par_id_documento
        and  (id_periodo=par_id_periodo or id_gestion=par_id_gestion);
   end if;

   return v_correlativo+1;
EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION param.___f_obtener_correlativo(par_id_documento integer, par_id_periodo integer, par_id_gestion integer, par_id_usuario integer) OWNER TO postgres;

--
-- TOC entry 273 (class 1255 OID 1475409)
-- Dependencies: 11 2435
-- Name: f_convertir_moneda(integer, integer, numeric, date, character varying, integer); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION f_convertir_moneda(p_id_moneda_1 integer, p_id_moneda_2 integer, p_importe numeric, p_fecha date, p_tipo character varying, p_num_decimales integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.f_convertir_moneda
 DESCRIPCION:   Convierte el importe de la moneda1 a la moneda2 con el tipo
                de cambio "O" Oficial "C" Compra y "V" venta por defecto "O" y con el redondeo
                p_num_decimales por defecto 2
 AUTOR: 	    KPLIAN (jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE


    v_resp                      varchar;
    v_nombre_funcion            text;
    v_mensaje_error             text;
    v_id_moneda_2               integer;
    v_registro                  record;
    v_id_moneda_base            integer;
    v_res                       numeric;
    v_id_moneda_1               integer;
    v_moneda                    varchar;
    v_tipo                      varchar;
    v_num_decimales             integer;
BEGIN
    v_nombre_funcion:='param.f_convertir_moneda';
    
    /*Dar valores por defecto*/
    if(p_tipo is null)then
        v_tipo='O';
    else
        v_tipo='O';
    end if;
    if(p_num_decimales is null)then
        v_num_decimales=2;
    else
        v_num_decimales=p_num_decimales;
    end if;
    
    if(p_fecha is null)then
        raise exception 'Debe definir una fecha para realizar la conversion de monedas';
    end if;
    
    /*Obtener la moneda base*/
    v_id_moneda_base=param.f_get_moneda_base();

    /*Si la moneda 2 es null obtener la moneda base*/
    if(p_id_moneda_2 is null)then
        v_id_moneda_2=v_id_moneda_base;
    else
        v_id_moneda_2=p_id_moneda_2;
    end if;
    
    /*Si la moneeda 1 y la 2 son la misma se devuelve el mismo importe*/
    if(p_id_moneda_1=v_id_moneda_2)then
        return p_importe;
    end if;
    
    /*Si la moneda 1 y la moneda 2 no son la moneda base se convierte la moneda 1 a la moneda base*/
    if(p_id_moneda_1!=v_id_moneda_base and v_id_moneda_2!=v_id_moneda_base)then
        v_res=  param.f_convertir_moneda(p_id_moneda_1,v_id_moneda_base,
                p_importe,p_fecha,v_tipo,-1);
        
        v_id_moneda_1=v_id_moneda_base;
    else
        v_id_moneda_1=p_id_moneda_1;
        v_res=p_importe;
    end if;

    /*Si la moneda base es la moneda 1 se divide por el tipo de cambio*/
    if(v_id_moneda_base=v_id_moneda_1)then
        select tc.oficial as tipo_cambio,
        (v_res/tc.oficial)as oficial ,
        (v_res/tc.compra) as compra,(v_res/tc.venta) as venta
        into v_registro
        from param.ttipo_cambio tc
        where   tc.id_moneda=v_id_moneda_2 and
                tc.fecha=p_fecha;
                
    /*Si la moneda base es la moneda 2 se multiplica por el tipo de cambio*/
    elsif(v_id_moneda_base=v_id_moneda_2)then
        
        select tc.oficial as tipo_cambio,
        (v_res*tc.oficial) as oficial,
        (v_res*tc.compra) as compra,(v_res*tc.venta)as venta
        into v_registro
        from param.ttipo_cambio tc
        where   tc.id_moneda=v_id_moneda_1 and
                tc.fecha=p_fecha;
        
                
        v_id_moneda_2=v_id_moneda_1;
    else
        raise exception 'Ha ocurrido un error al realizar la conversion de monedas';
    end if;
    
    if(v_registro.tipo_cambio is null)then
        select m.moneda
        into v_moneda
        from param.tmoneda m
        where id_moneda=v_id_moneda_2;
        raise exception 'No existe tipo de cambio para la fecha: % y la moneda: % ',
                        to_char(p_fecha,'DD/MM/YYYY'),v_moneda;
    end if;
    
    /*Retorna el valor q corresponda segun sea oficial, compra o venta y con el redondeo*/
    if(v_tipo='O')then
        if(v_num_decimales=-1)then
            return v_registro.oficial;
        else
            return round(v_registro.oficial,v_num_decimales);
        end if;
    elsif(v_tipo='C')then
        if(v_num_decimales=-1)then
            return v_registro.compra;
        else
            return round(v_registro.compra,v_num_decimales);
        end if;
    elsif(v_tipo='V')then
        if(v_num_decimales=-1)then
            return round(v_registro.venta,v_num_decimales);
        else
            return v_registro.venta;
        end if;
    ELSE
        raise exception 'No existe el tipo % para convertir las monedas',v_tipo;
    end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION param.f_convertir_moneda(p_id_moneda_1 integer, p_id_moneda_2 integer, p_importe numeric, p_fecha date, p_tipo character varying, p_num_decimales integer) OWNER TO postgres;

--
-- TOC entry 275 (class 1255 OID 1475481)
-- Dependencies: 11 2435
-- Name: f_get_moneda_base(); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION f_get_moneda_base() RETURNS integer
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.f_get_moneda_base
 DESCRIPCION:   Devuelve la moneda base de la empresa
 AUTOR: 	    KPLIAN (jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE

    
    v_resp                      varchar;
    v_nombre_funcion            text;
    v_mensaje_error             text;
    v_id_moneda                 integer;
BEGIN
    v_nombre_funcion:='param.f_get_moneda_base';
    
    select id_moneda
    into v_id_moneda
    from param.tmoneda
    where tipo_moneda='base';
    
    if(v_id_moneda is null)then
        raise exception 'No se ha definido una moneda base en el sistema';
    end if;
    return v_id_moneda;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION param.f_get_moneda_base() OWNER TO postgres;

--
-- TOC entry 1183 (class 1255 OID 2453335)
-- Dependencies: 2435 11
-- Name: f_inserta_alarma(integer, character varying, character varying, date, character varying, character varying, integer, character varying, character varying, character varying); Type: FUNCTION; Schema: param; Owner: fprudencio
--

CREATE FUNCTION f_inserta_alarma(par_id_funcionario integer, par_descripcion character varying, par_acceso_directo character varying, par_fecha date, par_tipo character varying, par_obs character varying, par_id_usuario integer, par_clase character varying, par_titulo character varying, par_parametros character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/************************************
FUNCION: f_inserta_alarma
AUTOR: 	    fprudencio
PARAMETROS: par_id_funcionario : indica el funcionario para el que se genera la alrma
            par_descripcion: una descripción de la alarma
            par_acceso_directo: es el link que lleva a la relacion de la alarma generada
            par_fecha: Indica la fecha de vencimiento de la alarma
            par_tipo: indica el tipo de alarma, puede ser alarma o notificacion
            par_obs: son las observaciones de la alarma

************************************/
DECLARE
    
    v_id_alarma                             integer;
    v_nombre_funcion						text;  
    v_resp                                  varchar;
BEGIN

v_nombre_funcion:='param.f_inserta_alarma';
   
   --realizamos la inserción de datos en alarma
   
   insert into param.talarma(
			acceso_directo,
			id_funcionario,
			fecha,
			estado_reg,
			descripcion,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod,
            tipo,
            obs,
            clase,
            titulo,
            parametros
          	) values(
			par_acceso_directo,
			par_id_funcionario,
			par_fecha,
			'activo',
			par_descripcion,
			par_id_usuario,
			now()::date,
			null,
			null,
            par_tipo,
            par_obs,
            par_clase,
            par_titulo,
            par_parametros
			)RETURNING id_alarma into v_id_alarma;
    
    return v_id_alarma;
    


EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION param.f_inserta_alarma(par_id_funcionario integer, par_descripcion character varying, par_acceso_directo character varying, par_fecha date, par_tipo character varying, par_obs character varying, par_id_usuario integer, par_clase character varying, par_titulo character varying, par_parametros character varying) OWNER TO fprudencio;

--
-- TOC entry 1299 (class 1255 OID 2214862)
-- Dependencies: 11 2435
-- Name: f_obtener_correlativo(character varying, integer, integer, integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: mzambrana
--

CREATE FUNCTION f_obtener_correlativo(par_codigo_documento character varying, par_id integer, par_id_uo integer, par_id_depto integer, par_id_usuario integer, par_codigo_subsistema character varying, par_formato character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.f_obtener_correlativo
 DESCRIPCION:   Obtiene el correlativo de acuerdo al id_documento y su configuracion
               periodo/gestion  depto/uo/depto_uo, el formato
 
 AUTOR: 	    KPLIAN (mzm)
 FECHA:	        03/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:  1)se cambia los parametros de entra  id_documento por codigo_documento
               2)se agregan los parametro par_codigo_subsistema
               3) se agrega la variable par_formato 
                 'sin' => solo devuelve el correlativo correspondiente solo numero
                 'is not NULL'=> evalua  las palabra clave :'depto','uo', 'codsub',
                 											'coddoc','periodo','gestion'
                                                            'correlativo' 
                                 y las remplaza por su valor correpondiente                           
                                                            
                 'NULL' => si el valor es nulo obtiene le formato por defecto
                           revisa el formato configurado en el documento si no existe 
                           usa formato por defecto segun tipo depto/uo/depto_uo
 
               4) cambia el tipo de dato de vuelto, antes integer ahora varchar
               
               
 AUTOR:		KPLIAN (rac)
 FECHA:		1/12/2011
 ***************************************************************************/
DECLARE

    
    v_resp                      varchar;
    v_nombre_funcion            text;
    v_mensaje_error             text;
    
    v_correlativo               integer;
    v_cadena                    varchar;
    v_periodo_gestion           varchar;
    v_tipo_numeracion           varchar;
    v_id                        integer;
    par_id_documento		integer;
    v_num_periodo integer;
    v_num_gestion integer;
    v_codigo_uo varchar;
    v_codigo_depto varchar;
    v_formula varchar;
    v_formato_doc varchar;
    g_registros record;
    v_consulta varchar;
    v_where varchar;
BEGIN
    
    v_nombre_funcion:='param.f_obtener_correlativo';
    
    --0)obtenemos el id_documento segun el codigo indicado
      --por tipo_documento se tiene la informacion de si se numera por periodo o gestion
      --si se envia null en un doc q se numera por periodo==> numerar de acuerdo a la fecha_actual(defecto)
 
 
         raise notice 'par_codigo_documento =% par_codigo_subsistema=%',par_codigo_documento,par_codigo_subsistema;
    
          SELECT d.id_documento, d.periodo_gestion, d.tipo_numeracion , d.formato
          into   par_id_documento,v_periodo_gestion, v_tipo_numeracion,v_formato_doc
          FROM param.tdocumento d
          INNER JOIN segu.tsubsistema s 
          on s.id_subsistema = d.id_subsistema and s.codigo = par_codigo_subsistema
          WHERE d.estado_reg='activo' and d.codigo = par_codigo_documento;
    
    
   -- raise exception 'par_id_documento=%',v_formato_doc;
    
     --     raise exception 'aa%',v_formato_doc;
    --1) validar la existencia del documento para el que se quiere obtener el correlativo
    if par_id_documento is NULL then
        raise exception 'Obtencion de correlativo no realizada. Documento inexistente % o esta inactivo',par_codigo_documento;
    end if;
    
    --2) verifica si el  tipo de numeracio es depto y si es asi que  exista la variable id_depto
    if (v_tipo_numeracion  in ('depto','depto_uo') and par_id_depto is null) then
        raise exception 'La numeracion del documento requiere indicar DEPTO';
    else
    --obtenemos codigo depto
     select d.codigo into v_codigo_depto from param.tdepto d where d.id_depto = par_id_depto;
    
    end if;
    
    --3) verifica si el  tipo de numeracio se UO y si es asi que  exista la variable id_uo
    if (v_tipo_numeracion  in ('uo','depto_uo') and par_id_uo is null) then
        raise exception 'La numeracion del documento requiere indicar UO';
    else
      --obtenemos codigo UO
      select u.codigo into v_codigo_uo from rhum.tuo u where u.id_uo = par_id_uo;
    end if;
    
    
    -- 4) IF - Si la numeracion se realiza por periodo obtiene el periodo correspondiente
        --     NOTA si el par_id esta definido indica le periodo al que se quiere
        --     obtener el correlativo
    v_id:=par_id;
    
    raise notice '% %',par_id,v_periodo_gestion;
    
    if(v_periodo_gestion='periodo') then
    
     raise notice 'periodo % %',v_id,v_num_periodo;
         
         --4.1) obtiene la id del periodo
         IF(par_id is null) THEN
         
            -- la numeracion se genera en base al periodo de la fecha actual
            select p.id_periodo, p.periodo,ges.gestion
            into v_id, v_num_periodo ,v_num_gestion
            from param.tperiodo p
            inner join param.tgestion ges on ges.id_gestion = p.id_gestion and ges.estado_reg ='activo'
            where p.estado_reg='activo' and  now()::date between fecha_ini and fecha_fin ;
            
            if(v_id is null) then
               raise exception 'Periodo para la fecha % inexistente', now()::date ;
            end if;
         ELSE 
         
            select p.id_periodo, p.periodo, ges.gestion
            into v_id, v_num_periodo,v_num_gestion
            from param.tperiodo p
            inner join param.tgestion ges on ges.id_gestion = p.id_gestion and ges.estado_reg ='activo'
            where  p.estado_reg='activo' and p.id_periodo = par_id;  
    
         END IF; 
         -- en funcion al id enviado
         if exists (select 1 from param.tperiodo where id_periodo=v_id and estado_reg!='activo') then
               raise exception 'El periodo solicitado no esta activo';
         end if;

        
       
   ELSE
    
       -- 5.1) obtiene el id de la gestion 
         IF(par_id is null) then
               select g.id_gestion , g.gestion
               into v_id, v_num_gestion
               from param.tgestion g
               where g.estado_reg='activo' and g.gestion=to_char(now()::date,'YYYY')::integer;
               
              if(v_id is null) then
                 raise exception 'Gestion % no existente', to_char(now()::date,'YYYY');
              end if;
              
         ELSE 
               select g.id_gestion , g.gestion
               into v_id, v_num_gestion
               from param.tgestion g
               where g.id_gestion = par_id; 
         END IF;

         if exists (select 1 from param.tgestion where id_gestion=v_id and estado_reg!='activo') then
               raise exception 'La gestion no esta activa';
         end if;
      
    end if;
    
   
    
    -- verifica si existe un registro de correlativo para este documento
                raise notice '0 id_documento % ',par_id_documento;
                raise notice '1 gestion >>> %',f_iif(v_periodo_gestion='gestion',v_id::varchar,0::varchar)::integer ;
                raise notice '2 periodo >>> %',f_iif (v_periodo_gestion='periodo',v_id::varchar,0::varchar)::integer;
                raise notice '3 uo >>> %',f_iif(v_tipo_numeracion in ('uo','depto_uo'), par_id_uo::varchar, 0::varchar)::integer;
                raise notice '4 depto >>> %',f_iif(v_tipo_numeracion in ('depto','depto_uo'),par_id_depto::varchar, 0::varchar)::integer;

    
    
    v_where = '   id_documento='||par_id_documento::varchar ||'
                  and id_gestion '|| f_iif(v_periodo_gestion='gestion','= '||v_id::varchar,'is NULL') ||'
                  and id_periodo '|| f_iif (v_periodo_gestion='periodo','= '||v_id::varchar,'is NULL')||'
                  and id_uo      '||  f_iif(v_tipo_numeracion in ('uo','depto_uo'), '= '||par_id_uo::varchar,'is NULL')||'
                  and id_depto   '|| f_iif(v_tipo_numeracion in ('depto','depto_uo'),'= '||par_id_depto::varchar, 'is NULL');
     
     
     FOR g_registros in EXECUTE('select 0 as res
                          from param.tcorrelativo 
                          where '|| v_where)
     LOOP
     
       
           v_correlativo:=g_registros.res;
            
       
     
     END LOOP;
     
     
     
raise notice '>> % correlativo ini %',v_where,v_correlativo;
            
    
    
    
   -- 6) si no existe correlativo para el periodo o gestion se crea un registro
   
      if(v_correlativo is NULL) then
      
      v_correlativo=0;

         insert into param.tcorrelativo 
         (id_documento,	 
          id_gestion, 
          id_periodo,  
          num_actual, 
          num_siguiente, 
          estado_reg, 
          fecha_reg,   
          id_usuario_reg , 
          id_uo,
          id_depto)
         values (
         	par_id_documento, 
            f_iif(v_periodo_gestion='gestion',v_id::varchar,NULL)::integer, 
            f_iif (v_periodo_gestion='periodo',v_id::varchar,NULL)::integer,
         	v_correlativo+1, 
            v_correlativo+2, 
            'activo', 
            now(), 
            par_id_usuario, 
            f_iif(v_tipo_numeracion in ('uo','depto_uo'), par_id_uo::varchar, NULL)::integer, 
            f_iif((v_tipo_numeracion in ('depto','depto_uo')),par_id_depto::varchar, NULL)::integer
            );
         	v_correlativo:=1;
      else
      
         -- 7) si  existe correlativo se actualiza la numeracion para el registro
         --    seleciona el registro bloqueando la tabla para evitar duplicados
         
             FOR g_registros in EXECUTE('SELECT
                                          id_correlativo,
                                          num_actual 
                                          FROM param.tcorrelativo
                                          WHERE '|| v_where ||'
                                          FOR UPDATE
                                          ')
             LOOP
             
              	update param.tcorrelativo
         	 	set num_siguiente=g_registros.num_actual+2,
          		num_actual=g_registros.num_actual+1
         		where 
            	id_correlativo=g_registros.id_correlativo;
            
               v_correlativo=g_registros.num_actual+1;
             
             END LOOP;
        
                       
         
    end if;
    
    raise notice 'correlativo % tipo  % gestion %',v_correlativo,v_tipo_numeracion,v_num_gestion;

 --9) verifica si es necesario retorna el numero con formato   
                        --raise exception 'aa%',par_formato;
  IF(par_formato = 'sin')THEN
                raise exception 'sinnn%',par_formato;
    return v_correlativo::varchar;
    
  ELSEIF par_formato is  not null THEN
                    raise exception 'not null%',par_formato;
     
       --validar q el valor enviado sea uno de los siguientes
       if(par_formato not in ('depto','uo','codsub','coddoc','periodo','gestion','correlativo')) then
             raise exception 'Formato no conocido para generacion de numeracion';
       end if;
      --'depto-docdoc-periodo/correlativo'
    
      v_formula = replace(par_formato,'depto', COALESCE(v_codigo_depto,'')::varchar);  
      v_formula = replace(v_formula,'uo', COALESCE(v_codigo_uo,'')::varchar);  
      v_formula = replace(v_formula,'codsub', COALESCE(par_codigo_subsistema,'')::varchar);
      v_formula = replace(v_formula,'coddoc', COALESCE(par_codigo_documento,'')::varchar);
      v_formula = replace(v_formula,'periodo', COALESCE(v_num_periodo::varchar,'')::varchar);
      v_formula = replace(v_formula,'gestion', COALESCE(v_num_gestion::varchar,'')::varchar);
      v_formula = replace(v_formula,'correlativo', COALESCE(v_correlativo::varchar,'')::varchar);
  
     return  v_formula;
  ELSE
        ---raise exception 'llega aqui%',par_formato ;
     IF(v_formato_doc is not null) THEN
                        raise exception 'iiiiffff%',par_formato;
          v_formula = replace(v_formato_doc,'depto', COALESCE(v_codigo_depto,'')::varchar);  
          v_formula = replace(v_formula,'uo', COALESCE(v_codigo_uo,'')::varchar);  
          v_formula = replace(v_formula,'codsub', COALESCE(par_codigo_subsistema,'')::varchar);
          v_formula = replace(v_formula,'coddoc', COALESCE(par_codigo_documento,'')::varchar);
          v_formula = replace(v_formula,'periodo', COALESCE(v_num_periodo::varchar,'')::varchar);
          v_formula = replace(v_formula,'gestion', COALESCE(v_num_gestion::varchar,'')::varchar);
          v_formula = replace(v_formula,'correlativo', COALESCE(v_correlativo::varchar,'')::varchar);
      
         return  v_formula;

     ELSE      --raise exception 'elseeeee%',par_formato;
             v_formula='';
              IF v_tipo_numeracion = 'uo' THEN
              
                  v_formula = v_codigo_uo;        
            
              ELSEIF v_tipo_numeracion = 'depto_uo' THEN  

                  v_formula = COALESCE(v_codigo_depto,'')||'-'||COALESCE(v_codigo_uo,'');  
                
              ELSEIF v_tipo_numeracion = 'depto' THEN  
                  v_formula = v_codigo_depto;        
                
              END IF;
            
               IF  v_periodo_gestion = 'periodo' THEN
                 v_formula = v_formula||'-'||COALESCE(par_codigo_documento,'')||'-'||COALESCE(v_num_periodo::varchar,'')||'/'||COALESCE(v_correlativo::varchar,'')||'-'||COALESCE(v_num_gestion::varchar,'');
               ELSE
                 v_formula = v_formula||'-'||COALESCE(par_codigo_documento,'')||'-'||COALESCE(v_correlativo::varchar,'')||'-'||COALESCE(v_num_gestion::varchar,'');     
               END IF;
               
             return  v_formula; 
               
      END IF;
        --raise exception 'finoooooo%',par_formato;
  END IF;
        --raise exception 'fin%',par_formato;
EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION param.f_obtener_correlativo(par_codigo_documento character varying, par_id integer, par_id_uo integer, par_id_depto integer, par_id_usuario integer, par_codigo_subsistema character varying, par_formato character varying) OWNER TO mzambrana;

--
-- TOC entry 1309 (class 1255 OID 3341729)
-- Dependencies: 11 2435
-- Name: f_sincroniza_proveedor_entre_bd(integer, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: param; Owner: mzambrana
--

CREATE FUNCTION f_sincroniza_proveedor_entre_bd(p_id_proveedor integer, p_host_destino character varying, p_port_destino character varying, p_user_destino character varying, p_pwd_destino character varying, p_bd_destino character varying, p_opcion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    
v_consulta  varchar;
v_respuesta varchar;
v_registros record;

BEGIN
                           
   
       
        IF p_opcion = 'INSERT' THEN
            BEGIN   
                              
             --raise exception 'host%, port%, user%, pwd%, bd%', p_host_destino, p_port_destino, p_user_destino, p_pwd_destino, p_bd_destino;
            /*
              v_consulta:='SELECT id_persona
                                               FROM segu.tpersona where id_persona='||p_id_persona;   */
                  --raise exception 'aa%',coalesce(new.genero,'');          
              if not exists (select P.id_proveedor from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_proveedor
                                               FROM compro.tad_proveedor where id_proveedor='||p_id_proveedor) AS P(
                                                                                id_proveedor integer) ) then
                     
                  select * into v_registros from param.tproveedor where id_proveedor=p_id_proveedor;                                       
                     
                    
                    --raise exception 'nombre_unidad%,v_registros.nombre_cargo%,v_registros.cargo_individual%,v_registros.descripcion%,v_registros.sw_presto%',v_registros.nombre_unidad,v_registros.nombre_cargo,v_registros.cargo_individual,v_registros.descripcion,v_registros.sw_presto;
                  if(v_registros.id_institucion is not null) then   
                       v_consulta:='insert into compro.tad_proveedor(id_proveedor, id_institucion, tipo,
                                    codigo,  fecha_reg, id_usuario_reg) 
                                    values ('||p_id_proveedor||','||v_registros.id_institucion||',
                                    '''||coalesce(v_registros.tipo,'-')||''','''||v_registros.codigo||''','''||now()::date||''','||1||'
                                    );';     
                  else
                       v_consulta:='insert into compro.tad_proveedor(id_proveedor,  id_persona, tipo,
                                    codigo, fecha_reg, id_usuario_reg) 
                                    values ('||p_id_proveedor||','||v_registros.id_persona||',
                                    '''||coalesce(v_registros.tipo,'-')||''','''||v_registros.codigo||''','''||now()::date||''','||1||'
                                    );';
                  end if;

                  v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                        
                  
                  return 'si';
             else 
                  raise exception 'ya existe';
             end if;                                   
            
          end;
        ELSEIF p_opcion='UPDATE' THEN
               BEGIN      
                      if exists (select P.id_proveedor from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_proveedor
                                               FROM compro.tad_proveedor where id_proveedor='||p_id_proveedor) AS P(
                                                                                id_proveedor integer) ) then
                                                                                
                          select * into v_registros from param.tproveedor where id_proveedor=p_id_proveedor;                                        
                     
                          v_consulta:='update compro.tad_proveedor
                          set 
                          id_institucion='||v_registros.id_institucion||', 
                          id_persona='||v_registros.id_persona||', 
                          tipo='''||coalesce(v_registros.tipo,'-')||''',
                          
                          codigo='''||v_registros.codigo||'''
                          where id_proveedor='||p_id_proveedor;   
                          
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);  
                           
                           /*----pendiente adicionar control para actualizacion de informacion de relacion entre uo's ----*/
                           
                            
                           return 'si';
                     else
                           return 'no';          
                     end if;
               END;
        ELSIF p_opcion='DELETE' THEN               
               BEGIN     
                      if exists (select P.id_proveedor from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_proveedor
                                               FROM compro.tad_proveedor where id_proveedor='||p_id_proveedor) AS P(
                                                                                id_proveedor integer) ) then
                                                                                

                           --eliminamos la relacion en estructura_uo                                                                                
                           v_consulta:='delete from compro.tproveedor where id_proveedor='||p_id_proveedor;
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
 
                           return 'si';                                                      
                     else
                       return 'no';
                     end if;
                   
               END;
        END IF;     
        
--RETURN NEW;
            
            
           
  RETURN NULL;
END;
$$;


ALTER FUNCTION param.f_sincroniza_proveedor_entre_bd(p_id_proveedor integer, p_host_destino character varying, p_port_destino character varying, p_user_destino character varying, p_pwd_destino character varying, p_bd_destino character varying, p_opcion character varying) OWNER TO mzambrana;

--
-- TOC entry 1215 (class 1255 OID 2110650)
-- Dependencies: 2435 11
-- Name: f_tdepto_usuario_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION f_tdepto_usuario_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.f_tdepto_usuario_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.tdepto_usuario'
 AUTOR: 		 (mzm)
 FECHA:	        24-11-2011 18:26:47
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_depto_usuario	integer;
			    
BEGIN

    v_nombre_funcion = 'param.f_tdepto_usuario_ime';
    v_parametros = f_get_record(p_tabla);

    /*********************************    
     #TRANSACCION:  'PM_DEPUSU_INS'
     #DESCRIPCION:    Insercion de registros
     #AUTOR:        mzm    
     #FECHA:        24-11-2011 18:26:47
    ***********************************/

    if(p_transaccion='PM_DEPUSU_INS')then
                    
        begin
            --Sentencia de la insercion
            insert into param.tdepto_usuario(
            estado_reg,
            id_depto,
            id_usuario,
            id_usuario_reg,
            fecha_reg,
            id_usuario_mod,
            fecha_mod    ,
            cargo
              ) values(
            'activo',
            v_parametros.id_depto,
            v_parametros.id_usuario,
            p_id_usuario,
            now(),
            null,
            null ,
            v_parametros.cargo
            )RETURNING id_depto_usuario into v_id_depto_usuario;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Usuario por Depto almacenado(a) con exito (id_depto_usuario'||v_id_depto_usuario||')'); 
            v_resp = f_agrega_clave(v_resp,'id_depto_usuario',v_id_depto_usuario::varchar);

            --Devuelve la respuesta
            return v_resp;

        end;

    /*********************************    
     #TRANSACCION:  'PM_DEPUSU_MOD'
     #DESCRIPCION:    Modificacion de registros
     #AUTOR:        mzm    
     #FECHA:        24-11-2011 18:26:47
    ***********************************/

    elsif(p_transaccion='PM_DEPUSU_MOD')then

        begin
            --Sentencia de la modificacion
            update param.tdepto_usuario set
            id_depto = v_parametros.id_depto,
            id_usuario = v_parametros.id_usuario,
            id_usuario_mod = p_id_usuario,
            fecha_mod = now() ,
            cargo=v_parametros.cargo
            where id_depto_usuario=v_parametros.id_depto_usuario;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Usuario por Depto modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_depto_usuario',v_parametros.id_depto_usuario::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end;

    /*********************************    
     #TRANSACCION:  'PM_DEPUSU_ELI'
     #DESCRIPCION:    Eliminacion de registros
     #AUTOR:        mzm    
     #FECHA:        24-11-2011 18:26:47
    ***********************************/

    elsif(p_transaccion='PM_DEPUSU_ELI')then

        begin
            --Sentencia de la eliminacion
            delete from param.tdepto_usuario
            where id_depto_usuario=v_parametros.id_depto_usuario;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Usuario por Depto eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_depto_usuario',v_parametros.id_depto_usuario::varchar);
              
            --Devuelve la respuesta
            return v_resp;

        end;
         
    else
     
        raise exception 'Transaccion inexistente: %',p_transaccion;

    end if;

EXCEPTION
                
    WHEN OTHERS THEN
        v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
        raise exception '%',v_resp;
                        
END;
$$;


ALTER FUNCTION param.f_tdepto_usuario_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1179 (class 1255 OID 2110637)
-- Dependencies: 11 2435
-- Name: f_tdepto_usuario_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION f_tdepto_usuario_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:        Parametros Generales
 FUNCION:         param.f_tdepto_usuario_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'param.tdepto_usuario'
 AUTOR:          (mzm)
 FECHA:            24-11-2011 18:26:47
 COMENTARIOS:    
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:    
 AUTOR:            
 FECHA:        
***************************************************************************/

DECLARE

    v_consulta            varchar;
    v_parametros          record;
    v_nombre_funcion       text;
    v_resp                varchar;
                
BEGIN

    v_nombre_funcion = 'param.f_tdepto_usuario_sel';
    v_parametros = f_get_record(p_tabla);

    /*********************************    
     #TRANSACCION:  'PM_DEPUSU_SEL'
     #DESCRIPCION:    Consulta de datos
     #AUTOR:        mzm    
     #FECHA:        24-11-2011 18:26:47
    ***********************************/

    if(p_transaccion='PM_DEPUSU_SEL')then
                     
        begin
            --Sentencia de la consulta
            v_consulta:='select
                        depusu.id_depto_usuario,
                        depusu.estado_reg,
                        depusu.id_depto,
                        depusu.id_usuario,
                        depusu.id_usuario_reg,
                        depusu.fecha_reg,
                        depusu.id_usuario_mod,
                        depusu.fecha_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod   ,
                        person.nombre_completo1 as desc_usuario     ,
                        depusu.cargo
                        from param.tdepto_usuario depusu 
                        inner join segu.tusuario usudep on usudep.id_usuario=depusu.id_usuario
                        inner join segu.vpersona person on person.id_persona=usudep.id_persona
                        inner join segu.tusuario usu1 on usu1.id_usuario = depusu.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = depusu.id_usuario_mod
                        where  ';
            
            --Definicion de la respuesta
            v_consulta:=v_consulta||v_parametros.filtro;
            
            if (public.f_existe_parametro(p_tabla,'id_depto')) then         
                v_consulta:= v_consulta || ' and depusu.id_depto='||v_parametros.id_depto;
            end if;
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

            --Devuelve la respuesta
            return v_consulta;
                        
        end;

    /*********************************    
     #TRANSACCION:  'PM_DEPUSU_CONT'
     #DESCRIPCION:    Conteo de registros
     #AUTOR:        mzm    
     #FECHA:        24-11-2011 18:26:47
    ***********************************/

    elsif(p_transaccion='PM_DEPUSU_CONT')then

        begin
            --Sentencia de la consulta de conteo de registros
            v_consulta:='select count(id_depto_usuario)
                        from param.tdepto_usuario depusu 
                        inner join segu.tusuario usudep on usudep.id_usuario=depusu.id_usuario
                        inner join segu.vpersona person on person.id_persona=usudep.id_persona
                        inner join segu.tusuario usu1 on usu1.id_usuario = depusu.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = depusu.id_usuario_mod
                        where  ';
            
            --Definicion de la respuesta            
            v_consulta:=v_consulta||v_parametros.filtro;
            if (public.f_existe_parametro(p_tabla,'id_depto')) then         
                v_consulta:= v_consulta || ' and depusu.id_depto='||v_parametros.id_depto;
            end if;
            --Devuelve la respuesta
            return v_consulta;

        end;
                    
    else
                         
        raise exception 'Transaccion inexistente';
                             
    end if;
                    
EXCEPTION
                    
    WHEN OTHERS THEN
            v_resp='';
            v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
            v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
            v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
            raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION param.f_tdepto_usuario_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1070 (class 1255 OID 1878906)
-- Dependencies: 11 2435
-- Name: f_tpm_proyecto_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION f_tpm_proyecto_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.f_tpm_proyecto_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.tpm_proyecto'
 AUTOR: 		 (rac)
 FECHA:	        26-10-2011 11:40:13
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_proyecto	integer;
			    
BEGIN

    v_nombre_funcion = 'param.f_tpm_proyecto_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_PRO_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		26-10-2011 11:40:13
	***********************************/

	if(p_transaccion='PM_PRO_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into param.tpm_proyecto(
			id_usuario,
			descripcion_proyecto,
			codigo_sisin,
			hora_ultima_modificacion,
			codigo_proyecto,
			hora_registro,
			nombre_corto,
			fecha_ultima_modificacion,
			fecha_registro,
			nombre_proyecto,
			id_proyecto_actif
          	) values(
			v_parametros.id_usuario,
			v_parametros.descripcion_proyecto,
			v_parametros.codigo_sisin,
			v_parametros.hora_ultima_modificacion,
			v_parametros.codigo_proyecto,
			v_parametros.hora_registro,
			v_parametros.nombre_corto,
			v_parametros.fecha_ultima_modificacion,
			v_parametros.fecha_registro,
			v_parametros.nombre_proyecto,
			v_parametros.id_proyecto_actif
			)RETURNING id_proyecto into v_id_proyecto;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','PRO almacenado(a) con exito (id_proyecto'||v_id_proyecto||')'); 
            v_resp = f_agrega_clave(v_resp,'id_proyecto',v_id_proyecto::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'PM_PRO_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		26-10-2011 11:40:13
	***********************************/

	elsif(p_transaccion='PM_PRO_MOD')then

		begin
			--Sentencia de la modificacion
			update param.tpm_proyecto set
			id_usuario = v_parametros.id_usuario,
			descripcion_proyecto = v_parametros.descripcion_proyecto,
			codigo_sisin = v_parametros.codigo_sisin,
			hora_ultima_modificacion = v_parametros.hora_ultima_modificacion,
			codigo_proyecto = v_parametros.codigo_proyecto,
			hora_registro = v_parametros.hora_registro,
			nombre_corto = v_parametros.nombre_corto,
			fecha_ultima_modificacion = v_parametros.fecha_ultima_modificacion,
			fecha_registro = v_parametros.fecha_registro,
			nombre_proyecto = v_parametros.nombre_proyecto,
			id_proyecto_actif = v_parametros.id_proyecto_actif
			where id_proyecto=v_parametros.id_proyecto;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','PRO modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proyecto',v_parametros.id_proyecto::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'PM_PRO_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		26-10-2011 11:40:13
	***********************************/

	elsif(p_transaccion='PM_PRO_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from param.tpm_proyecto
            where id_proyecto=v_parametros.id_proyecto;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','PRO eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proyecto',v_parametros.id_proyecto::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION param.f_tpm_proyecto_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1120 (class 1255 OID 1878907)
-- Dependencies: 11 2435
-- Name: f_tpm_proyecto_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION f_tpm_proyecto_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.f_tpm_proyecto_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'param.tpm_proyecto'
 AUTOR: 		 (rac)
 FECHA:	        26-10-2011 11:40:13
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_addfil varchar;
			    
BEGIN

	v_nombre_funcion = 'param.f_tpm_proyecto_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_PRO_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		26-10-2011 11:40:13
	***********************************/

	if(p_transaccion='PM_PRO_SEL')then
     				
    	begin
            --si existe el parametro hidro lo aplicamos en un filtro
            v_addfil='';
            if(f_existe_parametro(p_tabla,'hidro'))THEN
            v_addfil=' ( pro.hidro='''||v_parametros.hidro||''') AND ';
            
            END IF;
        
    		--Sentencia de la consulta
			v_consulta:='select
						pro.id_proyecto,
						pro.id_usuario,
						pro.descripcion_proyecto,
						pro.codigo_sisin,
						pro.hora_ultima_modificacion,
						pro.codigo_proyecto,
						pro.hora_registro,
						pro.nombre_corto,
						pro.fecha_ultima_modificacion,
						pro.fecha_registro,
						pro.nombre_proyecto,
						pro.id_proyecto_actif
						from param.tpm_proyecto pro
						where  '||v_addfil;
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'PM_PRO_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		26-10-2011 11:40:13
	***********************************/

	elsif(p_transaccion='PM_PRO_CONT')then

		begin
            v_addfil='';
            if(f_existe_parametro(p_tabla,'hidro'))THEN
            v_addfil=' (pro.hidro='''||v_parametros.hidro||''') AND ';
            
            END IF;
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_proyecto)
					    from param.tpm_proyecto pro
					    where '||v_addfil;
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
        
   
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION param.f_tpm_proyecto_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1146 (class 1255 OID 1962898)
-- Dependencies: 11 2435
-- Name: f_tproveedor_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION f_tproveedor_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.f_tproveedor_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.tproveedor'
 AUTOR: 		 (mzm)
 FECHA:	        15-11-2011 10:44:58
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento         integer;
    v_resp                    varchar;
    v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_proveedor          integer;
    v_codigo                varchar;
    
    --10abr12   
    v_respuesta_sinc       varchar;            
BEGIN
                           
    v_nombre_funcion = 'param.f_tproveedor_ime';
    v_parametros = f_get_record(p_tabla);

    /*********************************    
     #TRANSACCION:  'PM_PROVEE_INS'
     #DESCRIPCION:    Insercion de registros
     #AUTOR:        mzm    
     #FECHA:        15-11-2011 10:44:58
    ***********************************/

    if(p_transaccion='PM_PROVEE_INS')then
                    
        begin      
          
           --verificar que el proveedor no se duplique  para la misma institucion 
           -- o persona
           
           IF( v_parametros.id_institucion is not NULL 
                and (exists (select 1 from param.tproveedor  p
                      where p.id_institucion =  v_parametros.id_institucion
                      and p.estado_reg ='activo'))) THEN
                      
               raise exception 'ya esxiste un proveedor para esta institución';
           
           
           END IF;
           
           
           IF( v_parametros.id_persona is Not NULL 
               and (exists (select 1 from param.tproveedor  p
                      where p.id_persona =  v_parametros.id_persona
                      and p.estado_reg ='activo'))) THEN
                      
               raise exception 'ya esxiste un proveedor para esta persona';
           END IF;
           
           
        
            
            --Sentencia de la insercion
            insert into param.tproveedor(
              id_persona,
              --codigo,
             
              numero_sigma,
              tipo,
              estado_reg,
              id_institucion,
              id_usuario_reg,
              fecha_reg,
              id_usuario_mod,
              fecha_mod,
              nit
              ) values(
              v_parametros.id_persona,
              --v_codigo,
             
              v_parametros.numero_sigma,
              v_parametros.tipo,
              'activo',
              v_parametros.id_institucion,
              p_id_usuario,
              now(),
              null,
              null,
              v_parametros.nit
            )RETURNING id_proveedor into v_id_proveedor;
            
            v_codigo:=('PROV'||f_llenar_ceros(v_id_proveedor::numeric,4))::varchar;      
           
           
           
            update param.tproveedor
            set codigo=v_codigo
            where id_proveedor=v_id_proveedor;
            
            --10-04-2012: sincronizacion de UO entre BD
            v_respuesta_sinc:=param.f_sincroniza_proveedor_entre_bd(v_id_proveedor,'10.172.0.13','5432','db_link','db_link','dbendesis' ,'INSERT');
          
            if(v_respuesta_sinc!='si')  then
               raise exception 'Sincronizacion de proveedor en BD externa no realizada%',v_respuesta_sinc;
            end if;
            
                         
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proveedores almacenado(a) con exito (id_proveedor'||v_id_proveedor||')'); 
            v_resp = f_agrega_clave(v_resp,'id_proveedor',v_id_proveedor::varchar);

            --Devuelve la respuesta
            return v_resp;

        end;

    /*********************************    
     #TRANSACCION:  'PM_PROVEE_MOD'
     #DESCRIPCION:    Modificacion de registros
     #AUTOR:        mzm    
     #FECHA:        15-11-2011 10:44:58
    ***********************************/

    elsif(p_transaccion='PM_PROVEE_MOD')then

        begin
            --Sentencia de la modificacion
            update param.tproveedor set
            id_persona = v_parametros.id_persona,
             nit=v_parametros.nit,
            --codigo = v_parametros.codigo,
           
            numero_sigma = v_parametros.numero_sigma,
            tipo = v_parametros.tipo,
            id_institucion = v_parametros.id_institucion,
            id_usuario_mod = p_id_usuario,
            fecha_mod = now()
            where id_proveedor=v_parametros.id_proveedor;
           
        
            --10-04-2012: sincronizacion de UO entre BD
            v_respuesta_sinc:=param.f_sincroniza_proveedor_entre_bd(v_parametros.id_proveedor,'10.172.0.13','5432','db_link','db_link','dbendesis' ,'UPDATE');
                     
            if(v_respuesta_sinc!='si')  then
               raise exception 'Sincronizacion de proveedor en BD externa no realizada%',v_respuesta_sinc;
            end if;
            
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proveedores modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proveedor',v_parametros.id_proveedor::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end;

    /*********************************    
     #TRANSACCION:  'PM_PROVEE_ELI'
     #DESCRIPCION:    Eliminacion de registros
     #AUTOR:        mzm    
     #FECHA:        15-11-2011 10:44:58
    ***********************************/

    elsif(p_transaccion='PM_PROVEE_ELI')then

        begin
            --Sentencia de la eliminacion
            delete from param.tproveedor
            where id_proveedor=v_parametros.id_proveedor;
             
            --10-04-2012: sincronizacion de UO entre BD
            v_respuesta_sinc:=param.f_sincroniza_proveedor_entre_bd(v_parametros.id_proveedor,'10.172.0.13','5432','db_link','db_link','dbendesis','DELETE');
                     
            if(v_respuesta_sinc!='si')  then
               raise exception 'Sincronizacion de proveedor en BD externa no realizada%',v_respuesta_sinc;
            end if;
              
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proveedores eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proveedor',v_parametros.id_proveedor::varchar);
              
            --Devuelve la respuesta
            return v_resp;

        end;
         
    else
     
        raise exception 'Transaccion inexistente: %',p_transaccion;

    end if;

EXCEPTION
                
    WHEN OTHERS THEN
        v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
    raise exception '%',v_resp;
                        
END;
$$;


ALTER FUNCTION param.f_tproveedor_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1118 (class 1255 OID 1962914)
-- Dependencies: 2435 11
-- Name: f_tproveedor_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION f_tproveedor_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.f_tproveedor_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'param.tproveedor'
 AUTOR: 		 (mzm)
 FECHA:	        15-11-2011 10:44:58
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'param.f_tproveedor_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_PROVEE_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mzm	
 	#FECHA:		15-11-2011 10:44:58
	***********************************/

	if(p_transaccion='PM_PROVEE_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						provee.id_proveedor,
						provee.id_persona,
						provee.codigo,
					    provee.numero_sigma,
						provee.tipo,
						provee.estado_reg,
						provee.id_institucion,
						provee.id_usuario_reg,
						provee.fecha_reg,
						provee.id_usuario_mod,
						provee.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	,
                        person.nombre_completo1,
                        instit.nombre,
                        provee.nit
						from param.tproveedor provee
						inner join segu.tusuario usu1 on usu1.id_usuario = provee.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = provee.id_usuario_mod   
                        left join segu.vpersona person on person.id_persona=provee.id_persona
                        left join param.tinstitucion instit on instit.id_institucion=provee.id_institucion
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'PM_PROVEE_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mzm	
 	#FECHA:		15-11-2011 10:44:58
	***********************************/

	elsif(p_transaccion='PM_PROVEE_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_proveedor)
					    from param.tproveedor provee
					    inner join segu.tusuario usu1 on usu1.id_usuario = provee.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = provee.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
    
    /*********************************    
 	#TRANSACCION:  'PM_PROVEEV_SEL'
 	#DESCRIPCION:	Consulta de datos de proveedores a partir de una vista de base
                    de datos
 	#AUTOR:		rac	
 	#FECHA:		08-12-2011 10:44:58
	***********************************/    
        
					
	elseif(p_transaccion='PM_PROVEEV_SEL')then
     				
    	begin
        	
    		--Sentencia de la consulta
			v_consulta:='select
						id_proveedor,
                        id_persona,
                        codigo,
                        numero_sigma,
                        tipo,
                        id_institucion,
                        desc_proveedor,
                        nit
						from param.vproveedor provee
						where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'PM_PROVEEV_CONT'
 	#DESCRIPCION:	Conteo de registros de proveedores en la vista vproveedor
 	#AUTOR:		rac	
 	#FECHA:		09-12-2011 10:44:58
	***********************************/

	elsif(p_transaccion='PM_PROVEEV_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_proveedor)
					    from param.vproveedor provee
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION param.f_tproveedor_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1310 (class 1255 OID 2013519)
-- Dependencies: 2435 11
-- Name: ft_alarma_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION ft_alarma_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_alarma_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.talarma'
 AUTOR: 		 (fprudencio)
 FECHA:	        18-11-2011 11:59:10
 COMENTARIOS:	         
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_alarma	integer;  
    v_registros_config		record;
    v_registros_detalle		record;
    v_dif_dias				integer;
    v_id_funcionario		integer;
    v_id_subsistema			integer;
    v_consulta_config	    text;
    v_consulta_detalle		text;
    --Ids que se necesitan para  SAJ
    v_id_rpc				integer;
    v_id_sup    			integer;
    v_id_rep_legal			integer; 
    v_id_sup_boleta			integer;
			    
BEGIN            raise exception 'param.ft_alarma_ime';

    v_nombre_funcion = 'param.ft_alarma_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_ALARM_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	if(p_transaccion='PM_ALARM_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into param.talarma(
			acceso_directo,
			id_funcionario,
			fecha,
			estado_reg,
			descripcion,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.acceso_directo,
			v_parametros.id_funcionario,
			v_parametros.fecha,
			'activo',
			v_parametros.descripcion,
			p_id_usuario,
			now()::date,
			null,
			null
			)RETURNING id_alarma into v_id_alarma;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Alarmas almacenado(a) con exito (id_alarma'||v_id_alarma||')'); 
            v_resp = f_agrega_clave(v_resp,'id_alarma',v_id_alarma::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;
        
        	/*********************************    
 	#TRANSACCION:  'PM_ALARM_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	elsif(p_transaccion='PM_ALARM_MOD')then

		begin
			--Sentencia de la modificacion
			update param.talarma set
			acceso_directo = v_parametros.acceso_directo,
			id_funcionario = v_parametros.id_funcionario,
			fecha = v_parametros.fecha,
			descripcion = v_parametros.descripcion,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_alarma=v_parametros.id_alarma;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Alarmas modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_alarma',v_parametros.id_alarma::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;


	/*********************************    
 	#TRANSACCION:  'PM_DESCCOR_MOD'
 	#DESCRIPCION:	DEsactiva envio de correos
 	#AUTOR:		rarteaga	
 	#FECHA:		8-3-2012 11:59:10
	***********************************/

	elsif(p_transaccion='PM_DESCCOR_MOD')then

		begin
			--Sentencia de la modificacion
			 update param.talarma 
             set sw_correo = 1
             where sw_correo = 0;
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Desactiva envio de correo para alarmas'); 
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'PM_ALARM_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	elsif(p_transaccion='PM_ALARM_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from param.talarma
            where id_alarma=v_parametros.id_alarma;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Alarmas eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_alarma',v_parametros.id_alarma::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
        
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION param.ft_alarma_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1207 (class 1255 OID 2013518)
-- Dependencies: 11 2435
-- Name: ft_alarma_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION ft_alarma_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_alarma_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'param.talarma'
 AUTOR: 		 (fprudencio)
 FECHA:	        18-11-2011 11:59:10
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_id_funcionario integer;
    v_filtro varchar;
			    
BEGIN
                                                    
	v_nombre_funcion = 'param.ft_alarma_sel';
    v_parametros = f_get_record(p_tabla);
    
   -- v_filtro = '';
   
   /*********************************    
 	#TRANSACCION:  'PM_ALARMCOR_SEL'
 	#DESCRIPCION:	Consulta de alarmas pendientes de envio de correo no se utiliza con pagiancion
 	#AUTOR:		rarteaga	
 	#FECHA:		7-03-2012 11:59:10
	***********************************/

	if(p_transaccion='PM_ALARMCOR_SEL')then
     				
    	begin
            
            --Sentencia de la consulta
			v_consulta:='
                        select
						alarm.id_alarma,
                        funcio.email_empresa,
						alarm.fecha,
						alarm.descripcion,
					    alarm.clase,
                        alarm.titulo,
                        alarm.obs,
                        alarm.tipo,
                        (alarm.fecha-now()::date)::integer as dias
						from param.talarma alarm
						inner join rhum.tfuncionario funcio on funcio.id_funcionario=alarm.id_funcionario
                        where alarm.sw_correo = 0';
                        
             --modificar correpondencia
           /*  update param.talarma 
             set sw_correo = 1
             where sw_correo = 0;*/
			
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'PM_ALARM_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	elseif(p_transaccion='PM_ALARM_SEL')then
     				
    	begin
        
         
         
    		--Sentencia de la consulta
			v_consulta:='select
						alarm.id_alarma,
						alarm.acceso_directo,
						alarm.id_funcionario,
						alarm.fecha,
						alarm.estado_reg,
						alarm.descripcion,
						alarm.id_usuario_reg,
						alarm.fecha_reg,
						alarm.id_usuario_mod,
						alarm.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        person.nombre_completo1,
                        alarm.clase,
                        alarm.titulo,
                        alarm.parametros,
                        alarm.obs,
                        alarm.tipo,
                        (alarm.fecha-now()::date)::integer as dias
						from param.talarma alarm
						inner join segu.tusuario usu1 on usu1.id_usuario = alarm.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = alarm.id_usuario_mod
                        inner join rhum.tfuncionario funcio on funcio.id_funcionario=alarm.id_funcionario   
                        inner join segu.vpersona person on person.id_persona=funcio.id_persona
				        where  ';
				       
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'PM_ALARM_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	elsif(p_transaccion='PM_ALARM_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_alarma)
					    from param.talarma alarm
					    inner join segu.tusuario usu1 on usu1.id_usuario = alarm.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = alarm.id_usuario_mod
                        inner join rhum.tfuncionario funcio on funcio.id_funcionario=alarm.id_funcionario   
                        inner join segu.vpersona person on person.id_persona=funcio.id_persona
				        where  ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
	/*********************************    
 	#TRANSACCION:  'PM_ALARM_PEND'
 	#DESCRIPCION:	Cuenta cuantas alarmas tiene pendientes el funcionario
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	elsif(p_transaccion='PM_ALARM_PEND')then

		begin
          
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_alarma) as total
					    from param.talarma alarm
					    inner join segu.tusuario usu1 on usu1.id_usuario = alarm.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = alarm.id_usuario_mod
                        inner join rhum.tfuncionario funcio on funcio.id_funcionario=alarm.id_funcionario   
                        inner join segu.vpersona person on person.id_persona=funcio.id_persona
				        where  alarm.estado_reg=''activo'' AND alarm.id_funcionario in(Select fun.id_funcionario
            																	      from rhum.tfuncionario fun
            																		  inner join segu.tusuario usu on usu.id_persona=fun.id_persona
                                                                                      where usu.id_usuario='||p_id_usuario||') AND ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;				
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION param.ft_alarma_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1279 (class 1255 OID 2122015)
-- Dependencies: 11 2435
-- Name: ft_config_alarma_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: fprudencio
--

CREATE FUNCTION ft_config_alarma_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_config_alarma_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.tconfig_alarma'
 AUTOR: 		 (fprudencio)
 FECHA:	        18-11-2011 11:59:10
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_config_alarma	integer;  
   
			    
BEGIN       raise exception 'param.ft_config_alarma_ime';

    v_nombre_funcion = 'param.ft_config_alarma_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_CONALA_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	if(p_transaccion='PM_CONALA_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into param.tconfig_alarma(
			codigo,
			descripcion,
			dias,
            id_subsistema,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.codigo,
			v_parametros.descripcion,
			v_parametros.dias,
			v_parametros.id_subsistema,
			'activo',
			p_id_usuario,
			now()::date,
			null,
			null
			)RETURNING id_config_alarma into v_id_config_alarma;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Configuracion de Alarmas almacenado(a) con exito (id_config_alarma'||v_id_config_alarma||')'); 
            v_resp = f_agrega_clave(v_resp,'id_config_alarma',v_id_config_alarma::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'PM_CONALA_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	elsif(p_transaccion='PM_CONALA_MOD')then

		begin
			--Sentencia de la modificacion
			update param.tconfig_alarma set
			codigo = v_parametros.codigo,
			descripcion = v_parametros.descripcion,
			dias = v_parametros.dias,
			id_subsistema = v_parametros.id_subsistema,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_config_alarma=v_parametros.id_config_alarma;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Configuracion de Alarmas modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_config_alarma',v_parametros.id_config_alarma::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'PM_CONALA_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	elsif(p_transaccion='PM_CONALA_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from param.tconfig_alarma
            where id_config_alarma=v_parametros.id_config_alarma;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Configuracion de Alarmas eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_config_alarma',v_parametros.id_config_alarma::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;    
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION param.ft_config_alarma_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO fprudencio;

--
-- TOC entry 1296 (class 1255 OID 2118583)
-- Dependencies: 2435 11
-- Name: ft_config_alarma_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: fprudencio
--

CREATE FUNCTION ft_config_alarma_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 moneda: 		param.ft_config_alarma_sel
 DESCRIPCIÓN:  listado de la configuracion de alarmas
 AUTOR: 		fprudencio
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		25-11-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='param.ft_config_alarma_sel';


     if(par_transaccion='PM_CONALA_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            CONALA.id_config_alarma,
                            CONALA.codigo,
                            CONALA.descripcion,
                            CONALA.dias,
                            CONALA.id_subsistema,
                            (SUBSIS.codigo ||'' - ''|| SUBSIS.nombre) as desc_subsis,
                            CONALA.id_usuario_reg,
                            CONALA.estado_reg ,
                            CONALA.fecha_reg ,                            
                            CONALA.fecha_mod,
                            CONALA.id_usuario_mod,
                            PERSON.nombre_completo1 AS desc_usuario_reg,
                            PERMOD.nombre_completo1 AS desc_usuario_mod
                            FROM PARAM.tconfig_alarma CONALA
                            INNER JOIN SEGU.tusuario USUARI
                            ON USUARI.id_usuario=CONALA.id_usuario_reg
                            INNER JOIN segu.vpersona PERSON ON PERSON.id_persona=USUARI.id_persona
                            INNER JOIN segu.tsubsistema SUBSIS ON SUBSIS.id_subsistema=CONALA.id_subsistema
                            LEFT JOIN SEGU.tusuario USUMOD
                            ON USUMOD.id_usuario=CONALA.id_usuario_mod
                            LEFT JOIN segu.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE  ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               --raise notice'(%)',v_consulta   ;
               return v_consulta;


         END;


     elsif(par_transaccion='PM_CONALA_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                            count(CONALA.id_config_alarma)
                            FROM PARAM.tconfig_alarma CONALA
                            INNER JOIN SEGU.tusuario USUARI
                            ON USUARI.id_usuario=CONALA.id_usuario_reg
                            INNER JOIN segu.vpersona PERSON ON PERSON.id_persona=USUARI.id_persona
                            INNER JOIN segu.tsubsistema SUBSIS ON SUBSIS.id_subsistema=CONALA.id_subsistema
                            LEFT JOIN SEGU.tusuario USUMOD
                            ON USUMOD.id_usuario=CONALA.id_usuario_mod
                            LEFT JOIN segu.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     elsif(par_transaccion='PM_ALATABLA_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT table_schema::varchar,
                                   table_name::varchar 
                            FROM information_schema.columns
                            WHERE column_name = ''id_alarma'' AND ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               raise notice '%',v_consulta;
               return v_consulta;


         END;
     elsif(par_transaccion='PM_ALATABLA_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(table_name)                                  
                            FROM information_schema.columns
                            WHERE column_name = ''id_alarma'' AND ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro; 
               
               return v_consulta;


         END;        
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION param.ft_config_alarma_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO fprudencio;

--
-- TOC entry 1283 (class 1255 OID 1475527)
-- Dependencies: 2435 11
-- Name: ft_depto_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION ft_depto_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.ft_depto_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 		KPLIAN
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		06-06-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='param.ft_depto_ime';
     v_parametros:=f_get_record(par_tabla);


 /*******************************
 #TRANSACCION:   PM_DEPPTO_INS
 #DESCRIPCION:	Inserta deptos
 #AUTOR:		KPLIAN	
 #FECHA:		06-06-2011	
***********************************/
     if(par_transaccion='PM_DEPPTO_INS')then


          BEGIN

               --verificar unicidad de codigo
               if exists (select 1 from param.tdepto where upper(codigo)=upper(v_parametros.codigo) and estado_reg='activo' and id_subsistema=v_parametros.id_subsistema) then
                   raise exception 'Insercion no realizada. Codigo% en uso para subsistema%', upper(v_parametros.codigo),  (select nombre from segu.tsubsistema where id_subsistema=v_parametros.id_subsistema) ;
               end if;
               --insercion de nuevo depto
               INSERT INTO param.tdepto(codigo, id_subsistema, nombre, nombre_corto, estado_reg,fecha_reg, id_usuario_reg)
               values(v_parametros.codigo,v_parametros.id_subsistema, v_parametros.nombre, v_parametros.nombre_corto,'activo',now()::date, par_id_usuario);

               v_resp = f_agrega_clave(v_resp,'mensaje','depto insertado con exito '||v_parametros.nombre_corto || 'para Subsis.' || (select nombre from segu.tsubsistema where id_subsistema=v_parametros.id_subsistema));
               v_resp = f_agrega_clave(v_resp,'id_depto',v_id_funcion::varchar);


         END;
 /*******************************
 #TRANSACCION:  PM_DEPPTO_MOD
 #DESCRIPCION:	Modifica la depto seleccionada
 #AUTOR:		KPLIAN	
 #FECHA:		06-06-2011
***********************************/
     elsif(par_transaccion='PM_DEPPTO_MOD')then


          BEGIN
               --modificacion de depto
               update param.tdepto set
               codigo=v_parametros.codigo,
               nombre_corto=v_parametros.nombre_corto,
               nombre=v_parametros.nombre,
               id_subsistema=v_parametros.id_subsistema,
               id_usuario_mod=par_id_usuario,
               fecha_mod=now()
               where id_depto=v_parametros.id_depto;

               v_resp = f_agrega_clave(v_resp,'mensaje','depto modificado con exito '||v_parametros.codigo);
               v_resp = f_agrega_clave(v_resp,'id_depto',v_parametros.id_depto::varchar);


          END;

/*******************************
 #TRANSACCION:  PM_DEPPTO_ELI
 #DESCRIPCION:	Inactiva el depto selecionado
 #AUTOR:		KPLIAN	
 #FECHA:		06-06-2011
***********************************/

    elsif(par_transaccion='PM_DEPPTO_ELI')then
        BEGIN

         --inactivacion de la depto
               update param.tdepto set estado_reg='eliminado'
               where id_depto=v_parametros.id_depto;
               return 'depto eliminado con exito';

               v_resp = f_agrega_clave(v_resp,'mensaje','depto eliminado con exito '||v_parametros.id_depto);
               v_resp = f_agrega_clave(v_resp,'id_depto',v_parametros.id_depto::varchar);

        END;


    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;

 return v_resp;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION param.ft_depto_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1284 (class 1255 OID 1475528)
-- Dependencies: 11 2435
-- Name: ft_depto_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION ft_depto_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 documento: 	param.ft_depto_sel
 DESCRIPCIÓN:  listado de documento
 AUTOR: 	    KPLIAN	
 FECHA:	        06/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;
v_filadd varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='param.ft_depto_sel';
     
 /*******************************
 #TRANSACCION:  PM_DEPPTO_SEL
 #DESCRIPCION:	Listado de departamento
 #AUTOR:		MZM	
 #FECHA:		03-06-2011
 #AUTOR_MOD:     RAC
 #DESCRIPCION_MOD  se aumenta el filtro de id_subsistema cuando dea distinto de null	
 #FECHA:		15-10-2011
***********************************/


     if(par_transaccion='PM_DEPPTO_SEL')then

          --consulta:=';
          
          
          BEGIN
          v_filadd = '';
          IF (f_existe_parametro(par_tabla,'id_subsistema')) THEN
          v_filadd = ' (DEPPTO.id_subsistema = ' ||v_parametros.id_subsistema||') and ';
          
          END IF;
          
          IF (f_existe_parametro(par_tabla,'codigo_subsistema')) THEN
          v_filadd = ' (SUBSIS.codigo = ''' ||v_parametros.codigo_subsistema||''') and ';
          
          END IF;
          
          
          

               v_consulta:='SELECT 
                            DEPPTO.id_depto,
                            DEPPTO.codigo,
                            DEPPTO.nombre,
                            DEPPTO.nombre_corto,
                            DEPPTO.id_subsistema,
                            DEPPTO.estado_reg,
                            DEPPTO.fecha_reg,
                            DEPPTO.id_usuario_reg,
                            DEPPTO.fecha_mod,
                            DEPPTO.id_usuario_mod,
                            PERREG.nombre_completo1 as usureg,
                            PERMOD.nombre_completo1 as usumod,
                            SUBSIS.codigo||'' - ''||SUBSIS.nombre as desc_subsistema
                            FROM param.tdepto DEPPTO
                            INNER JOIN segu.tsubsistema SUBSIS on SUBSIS.id_subsistema=DEPPTO.id_subsistema
                            INNER JOIN segu.tusuario USUREG on USUREG.id_usuario=DEPPTO.id_usuario_reg
                            INNER JOIN segu.vpersona PERREG on PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN segu.tusuario USUMOD on USUMOD.id_usuario=DEPPTO.id_usuario_mod
                            LEFT JOIN segu.vpersona PERMOD on PERMOD.id_persona=USUMOD.id_persona
                            WHERE '||v_filadd;
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

 /*******************************
 #TRANSACCION:  PM_DEPPTO_CONT
 #DESCRIPCION:	cuenta la cantidad de departamentos
 #AUTOR:		MZM	
 #FECHA:		03-06-2011
 #AUTOR_MOD:     RAC
 #DESCRIPCION_MOD  se aumenta el filtro de id_subsistema cuando dea distinto de null	
 #FECHA:		15-10-2011
***********************************/

     elsif(par_transaccion='PM_DEPPTO_CONT')then
        BEGIN
          
          v_filadd = '';
          IF (f_existe_parametro(par_tabla,'id_subsistema')) THEN
             v_filadd = ' (DEPPTO.id_subsistema = ' ||v_parametros.id_subsistema||') and ';
          END IF;
          
          
               v_consulta:='SELECT
                                  count(DEPPTO.id_depto)
                            FROM param.tdepto DEPPTO
                            INNER JOIN segu.tsubsistema SUBSIS on SUBSIS.id_subsistema=DEPPTO.id_subsistema
                            INNER JOIN segu.tusuario USUREG on USUREG.id_usuario=DEPPTO.id_usuario_reg
                            INNER JOIN segu.vpersona PERREG on PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN segu.tusuario USUMOD on USUMOD.id_usuario=DEPPTO.id_usuario_mod
                            LEFT JOIN segu.vpersona PERMOD on PERMOD.id_persona=USUMOD.id_persona
                            WHERE '||v_filadd;
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION param.ft_depto_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1184 (class 1255 OID 2585568)
-- Dependencies: 2435 11
-- Name: ft_dispara_alarma_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: rac
--

CREATE FUNCTION ft_dispara_alarma_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_dispara_alarma_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.talarma'
 AUTOR: 		 (fprudencio)
 FECHA:	        18-11-2011 11:59:10
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_alarma	integer;  
    v_registros_config		record;
    v_registros_detalle		record;
    v_dif_dias				integer;
    v_id_funcionario		integer;
    v_id_subsistema			integer;
    v_consulta_config	    text;
    v_consulta_detalle		text;
    --Ids que se necesitan para  SAJ
    v_mensaje varchar;
			    
BEGIN   

    v_nombre_funcion = 'param.ft_dispara_alarma_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_ALARMASAJ_INS'
 	#DESCRIPCION:	Revisa alaramas del sistema SAJ
 	#AUTOR:		rarteaga	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	if(p_transaccion='PM_GENALA_INS')then
					
        begin    
        	
            IF(v_parametros.tipo='TODOS' or v_parametros.tipo='SAJ')THEN 
               v_mensaje:= saj.f_verifica_alarma(v_parametros.id_usuario);
            END IF;
            
            --ir introducion if que diparen la funcion segun sistema X
            IF(v_parametros.tipo='TODOS' or v_parametros.tipo='X')THEN 
            --   v_mensaje:= x.f_verifica_alarma(v_parametros.id_usuario);
            END IF;
 
           --Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Alarmas almacenado(a) con exito'); 
            v_resp = f_agrega_clave(v_resp,'respuesta',v_mensaje);

            --Devuelve la respuesta
            return v_resp;

		end;

	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION param.ft_dispara_alarma_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rac;

--
-- TOC entry 1181 (class 1255 OID 2585924)
-- Dependencies: 11 2435
-- Name: ft_dispara_alarma_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: rac
--

CREATE FUNCTION ft_dispara_alarma_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_dispara_alarma_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'param.talarma'
 AUTOR: 		 (fprudencio)
 FECHA:	        18-11-2011 11:59:10
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_id_funcionario integer;
    v_filtro varchar;
			    
BEGIN
                                                    
	v_nombre_funcion = 'param.ft_dispara_alarma_sel';
    v_parametros = f_get_record(p_tabla);
    
   -- v_filtro = '';

	/*********************************    
 	#TRANSACCION:  'PM_ALARM_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	if(p_transaccion='PM_ALARM_SEL')then
     				
    	begin
        --Sentencia de la consulta
			v_consulta:='select
						alarm.id_alarma,
						alarm.acceso_directo,
						alarm.id_funcionario,
						alarm.fecha,
						alarm.estado_reg,
						alarm.descripcion,
						alarm.id_usuario_reg,
						alarm.fecha_reg,
						alarm.id_usuario_mod,
						alarm.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        person.nombre_completo1,
                        alarm.clase,
                        alarm.titulo,
                        alarm.parametros,
                        alarm.obs,
                        alarm.tipo,
                        (alarm.fecha-now()::date)::integer as dias
						from param.talarma alarm
						inner join segu.tusuario usu1 on usu1.id_usuario = alarm.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = alarm.id_usuario_mod
                        inner join rhum.tfuncionario funcio on funcio.id_funcionario=alarm.id_funcionario   
                        inner join segu.vpersona person on person.id_persona=funcio.id_persona
				        where  ';
				       
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'PM_ALARM_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	elsif(p_transaccion='PM_ALARM_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_alarma)
					    from param.talarma alarm
					    inner join segu.tusuario usu1 on usu1.id_usuario = alarm.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = alarm.id_usuario_mod
                        inner join rhum.tfuncionario funcio on funcio.id_funcionario=alarm.id_funcionario   
                        inner join segu.vpersona person on person.id_persona=funcio.id_persona
				        where  ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION param.ft_dispara_alarma_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rac;

--
-- TOC entry 1178 (class 1255 OID 1475529)
-- Dependencies: 11 2435
-- Name: ft_documento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION ft_documento_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.ft_documento_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 		KPLIAN
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		03-06-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

v_id_uo           integer;
v_id_depto        integer;
v_id_depto_uo     integer;
v_formato 		varchar;

BEGIN

     v_nombre_funcion:='param.ft_documento_ime';
     v_parametros:=f_get_record(par_tabla);


 /*******************************
 #TRANSACCION:   PM_DOCUME_INS
 #DESCRIPCION:	Inserta Documentos
 #AUTOR:		KPLIAN	
 #FECHA:		03-06-2011	
***********************************/
     if(par_transaccion='PM_DOCUME_INS')then


          BEGIN
               --verificar unicidad de codigo
               if exists (select 1 from param.tdocumento where upper(codigo)=upper(v_parametros.codigo) and estado_reg='activo' and id_subsistema=v_parametros.id_subsistema) then
                   raise exception 'Insercion no realizada. Codigo% en uso para subsistema%', upper(v_parametros.codigo),  (select nombre from segu.tsubsistema where id_subsistema=v_parametros.id_subsistema) ;
               end if;
               --insercion de nuevo documento
              
              --evita formato en blanco
              v_formato = NULL;
              IF(v_parametros.formato is not NULL and trim(v_parametros.formato) <>'' )THEN
                v_formato =  v_parametros.formato;
              END IF;
               
               INSERT INTO param.tdocumento(
               		codigo, 
               		descripcion, 
                    id_subsistema, 
                    estado_reg,
 					fecha_reg, 
                    id_usuario_reg, 
                    periodo_gestion, 
                    tipo, 
                    tipo_numeracion, 
                    formato)
               values (
               		v_parametros.codigo, 
                    v_parametros.descripcion,
                    v_parametros.id_subsistema, 
                    'activo', 
                    now() ::date,
                 	par_id_usuario, 
                    v_parametros.periodo_gestion, 
                    v_parametros.tipo, 
                    v_parametros.tipo_numeracion, 
                    v_formato);


               v_resp = f_agrega_clave(v_resp,'mensaje','Documento insertado con exito '||v_parametros.codigo || 'para Subsis.' || (select nombre from segu.tsubsistema where id_subsistema=v_parametros.id_subsistema));
               v_resp = f_agrega_clave(v_resp,'id_documento',v_id_funcion::varchar);


         END;
 /*******************************
 #TRANSACCION:  PM_DOCUME_MOD
 #DESCRIPCION:	Modifica la documento seleccionada
 #AUTOR:		KPLIAN	
 #FECHA:		03-06-2011
***********************************/
     elsif(par_transaccion='PM_DOCUME_MOD')then


          BEGIN
          
          
               /*validar que si ya se tienen correlativos generados para este tipo de doc==> no se pueda modificar ni el tipo_numeracion, ni tipo*/
               if exists (select 1 from param.tcorrelativo where id_documento=v_parametros.id_documento) then
                  if exists (select 1 from param.tdocumento where id_documento=v_parametros.id_documento and (tipo!=v_parametros.tipo or tipo_numeracion!=v_parametros.tipo_numeracion or formato!=v_parametros.formato)) then
                     raise exception 'No es posible modificar la forma en la que se numera este documento. Tiene numeracion generada';
                  end if;                                                                                                             
               end if;
               
              --evita formato en blanco
              v_formato = NULL;
              IF(v_parametros.formato is not NULL and trim(v_parametros.formato) <>'' )THEN
                v_formato =  v_parametros.formato;
              END IF;
                    
               --modificacion de documento
               update param.tdocumento set
               codigo=v_parametros.codigo,
               descripcion=v_parametros.descripcion,
               id_subsistema=v_parametros.id_subsistema,
               id_usuario_mod=par_id_usuario,
               fecha_mod=now(),
               estado_reg=v_parametros.estado_reg,
               periodo_gestion=v_parametros.periodo_gestion,
               tipo=v_parametros.tipo,
               tipo_numeracion=v_parametros.tipo_numeracion  ,
               formato=v_parametros.formato
               where id_documento=v_parametros.id_documento;

               v_resp = f_agrega_clave(v_resp,'mensaje','documento modificado con exito '||v_parametros.codigo);
               v_resp = f_agrega_clave(v_resp,'id_documento',v_parametros.id_documento::varchar);


          END;

/*******************************
 #TRANSACCION:  PM_DOCUME_ELI
 #DESCRIPCION:	Inactiva el documento selecionado
 #AUTOR:		KPLIAN	
 #FECHA:		03-06-2011
***********************************/

    elsif(par_transaccion='PM_DOCUME_ELI')then
        BEGIN

         --inactivacion de la documento
               update param.tdocumento set estado_reg='eliminado'
               where id_documento=v_parametros.id_documento;
               return 'documento eliminado con exito';

               v_resp = f_agrega_clave(v_resp,'mensaje','documento eliminado con exito '||v_parametros.id_documento);
               v_resp = f_agrega_clave(v_resp,'id_documento',v_parametros.id_documento::varchar);

        END;


    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;

 return v_resp;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION param.ft_documento_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1175 (class 1255 OID 1475530)
-- Dependencies: 2435 11
-- Name: ft_documento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION ft_documento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 documento: 	param.ft_documento_sel
 DESCRIPCIÓN:  listado de documento
 AUTOR: 	    KPLIAN	(m)
 FECHA:	        04/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;
v_filadd varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='param.ft_documento_sel';
/*******************************
 #TRANSACCION:  PM_DOCUME_SEL
 #DESCRIPCION:	Listado de documentos
 #AUTOR:		KPLIAN(mzm)	
 #FECHA:		08/01/11	
 ******************************
 #DESCRIPCION_MOD:	aumenta filtro para tipo de documentos por el subsistema
                    se usa desde la interface de correspondencia
 #AUTOR_MOD:		KPLIAN(rac)	
 #FECHA_MOD:		27/10/11
***********************************/

     if(par_transaccion='PM_DOCUME_SEL')then

          --consulta:=';
          BEGIN
          
           v_filadd = '';
            IF (f_existe_parametro(par_tabla,'tipo')) THEN
               v_filadd = ' ( DOCUME.tipo = '''||v_parametros.tipo||''' and  DOCUME.estado_reg=''activo'' ) and ';
            END IF;

               v_consulta:='SELECT 
                                   DOCUME.id_documento,
                                   DOCUME.codigo,
                                   DOCUME.descripcion,
                                   DOCUME.estado_reg,
                                   DOCUME.fecha_mod,
                                   DOCUME.fecha_reg,
                                   DOCUME.id_subsistema,
                                   DOCUME.id_usuario_mod,
                                   DOCUME.id_usuario_reg,
                                   SUBSIS.codigo  ||''-''||SUBSIS.nombre as desc_subsis,
                                   SUBSIS.nombre as nombre_subsis,
                                   PERREG.nombre_completo1 as usureg,
                                   PERMOD.nombre_completo1 as usumod,
                                   DOCUME.tipo_numeracion,
                                   DOCUME.periodo_gestion,
                                   DOCUME.tipo,
                                   DOCUME.formato

                            FROM param.tdocumento DOCUME
                            INNER JOIN segu.tsubsistema SUBSIS on SUBSIS.id_subsistema=DOCUME.id_subsistema
                            INNER JOIN segu.tusuario USUREG on USUREG.id_usuario=DOCUME.id_usuario_reg
                            INNER JOIN segu.vpersona PERREG on PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN segu.tusuario USUMOD on USUMOD.id_usuario=DOCUME.id_usuario_mod
                            LEFT JOIN segu.vpersona PERMOD on PERMOD.id_persona=USUMOD.id_persona
                            
                            WHERE '||v_filadd;
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='PM_DOCUME_CONT')then

          --consulta:=';
          BEGIN
          
              v_filadd = '';
              IF (f_existe_parametro(par_tabla,'tipo')) THEN
               v_filadd = ' ( DOCUME.tipo = '''||v_parametros.tipo||''' and  DOCUME.estado_reg=''activo'' ) and ';
              END IF;

               v_consulta:='SELECT
                            count(DOCUME.id_documento)
                            FROM param.tdocumento DOCUME
                            INNER JOIN segu.tsubsistema SUBSIS on SUBSIS.id_subsistema=DOCUME.id_subsistema
                            INNER JOIN segu.tusuario USUREG on USUREG.id_usuario=DOCUME.id_usuario_reg
                            INNER JOIN segu.vpersona PERREG on PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN segu.tusuario USUMOD on USUMOD.id_usuario=DOCUME.id_usuario_mod
                            LEFT JOIN segu.vpersona PERMOD on PERMOD.id_persona=USUMOD.id_persona
                            
                            WHERE  '||v_filadd;
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION param.ft_documento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 116 (class 1255 OID 16533)
-- Dependencies: 11 2435
-- Name: ft_gestion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: rchumacero
--

CREATE FUNCTION ft_gestion_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.ft_gestion_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 		KPLIAN
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		07-01-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;
i                 integer;
BEGIN

     v_nombre_funcion:='segu.ft_funcion_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   PM_GESTIO_INS
 #DESCRIPCION:	Inserta Funciones
 #AUTOR:		KPLIAN	
 #FECHA:		07-01-2011	
***********************************/
     if(par_transaccion='PM_GESTIO_INS')then

        
          BEGIN
          
          --insercion de nueva funcion
               if exists (select 1 from param.tgestion where gestion=v_parametros.gestion and estado_reg!='eliminado') then
                  raise exception 'Insercion no realizada. Gestion existente';
               end if;
               INSERT INTO param.tgestion(gestion, estado_reg,fecha_reg, id_usuario_reg)
               values(v_parametros.gestion,'activo',now()::date, par_id_usuario);
              
              
               for i in 1..12 loop
                 insert into param.tperiodo(periodo, id_gestion, id_usuario_reg, fecha_reg, estado_reg)
                 values (i, (select id_gestion from param.tgestion where gestion=v_parametros.gestion and estado_reg='activo'), par_id_usuario, now()::date,'activo');
               end loop;

               v_resp = f_agrega_clave(v_resp,'mensaje','Gestion insertada con exito '||v_parametros.gestion);
               v_resp = f_agrega_clave(v_resp,'id_gestion',v_id_funcion::varchar);


         END;
 /*******************************    
 #TRANSACCION:  PM_GESTIO_MOD
 #DESCRIPCION:	Modifica la gestion seleccionada
 #AUTOR:		KPLIAN	
 #FECHA:		07-01-2011
***********************************/
     elsif(par_transaccion='PM_GESTIO_MOD')then

          
          BEGIN

               if exists (select 1 from param.tgestion where gestion=v_parametros.gestion and id_gestion!=v_parametros.id_gestion and estado_reg!='eliminado') then
                  raise exception 'Modificacion no realizada. Gestion existente';
               end if;
               --modificacion de gestion
               update param.tgestion set

                     gestion=v_parametros.gestion,
                     estado_reg=v_parametros.estado_reg

               where id_gestion=v_parametros.id_gestion;

               v_resp = f_agrega_clave(v_resp,'mensaje','Gestion modificada con exito '||v_parametros.gestion);
               v_resp = f_agrega_clave(v_resp,'id_gestion',v_parametros.id_gestion::varchar);

             
          END;
          
/*******************************    
 #TRANSACCION:   PM_GESTIO_ELI
 #DESCRIPCION:	Inactiva la gestion selecionada
 #AUTOR:		KPLIAN	
 #FECHA:		07-01-2011
***********************************/

    elsif(par_transaccion='PM_GESTIO_ELI')then
        BEGIN
        
               -- verificar que la gestion no tenga dependencias
               -- en esquema param con tcorrelativo
               --inactivacion de la gestion
               update param.tgestion set estado_reg='eliminado'
               where id_gestion=v_parametros.id_gestion;
               return 'Gestion eliminada con exito';

               -- si existen periodos para la gestion que se esta eliminando, eliminar tb los periodos
               if exists (select 1 from param.tperiodo where id_gestion=v_parametros.id_gestion and estado_reg!='eliminado') then
                  update param.tperiodo set estado_reg='eliminado'
                  where id_gestion=v_parametros.id_gestion;
               end if;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Gestion eliminada con exito '||v_parametros.id_gestion);
               v_resp = f_agrega_clave(v_resp,'id_gestion',v_parametros.id_gestion::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION param.ft_gestion_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 117 (class 1255 OID 16534)
-- Dependencies: 2435 11
-- Name: ft_gestion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: rchumacero
--

CREATE FUNCTION ft_gestion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 gestion: 		param.ft_gestion_sel
 DESCRIPCIÓN:  listado de gestion
 AUTOR: 		KPLIAN
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		07-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='param.ft_gestion_sel';


     if(par_transaccion='PM_GESTIO_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            GESTIO.id_gestion,
                            GESTIO.gestion,
                            GESTIO.estado_reg,
                            GESTIO.fecha_reg,
                            GESTIO.fecha_mod,
                            GESTIO.id_usuario_reg,
                            GESTIO.id_usuario_mod,
                            PERREG.nombre_completo1 as desc_usureg,
                            PERMOD.nombre_completo1 as desc_usumod
                            FROM param.tgestion GESTIO
                            inner join segu.tusuario USUREG on USUREG.id_usuario=GESTIO.id_usuario_reg
                            inner join segu.vpersona PERREG on PERREG.id_persona=USUREG.id_persona
                            left join segu.tusuario USUMOD on USUMOD.id_usuario=GESTIO.id_usuario_mod
                            left join segu.vpersona PERMOD on PERMOD.id_persona=USUMOD.id_persona
                            WHERE GESTIO.estado_reg!=''eliminado'' and ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;     
               
               if(public.f_existe_parametro(par_tabla,'estado')) then
                  v_consulta:=v_consulta || ' and GESTIO.estado_reg='''||v_parametros.estado||'''';
               end if;
               
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='PM_GESTIO_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(GESTIO.id_gestion)
                            FROM param.tgestion GESTIO
                            WHERE GESTIO.estado_reg!=''eliminado'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;  
               if(public.f_existe_parametro(par_tabla,'estado')) then
                  v_consulta:=v_consulta || ' and GESTIO.estado_reg='''||v_parametros.estado||'''';
               end if;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION param.ft_gestion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 313 (class 1255 OID 1513932)
-- Dependencies: 11 2435
-- Name: ft_institucion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION ft_institucion_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_institucion_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.tinstitucion'
 AUTOR: 		 (gvelasquez)
 FECHA:	        21-09-2011 10:50:03
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_institucion	integer;
			    
BEGIN

    v_nombre_funcion = 'param.ft_institucion_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_INSTIT_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		21-09-2011 10:50:03
	***********************************/

	if(p_transaccion='PM_INSTIT_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into param.tinstitucion(
			fax,
			estado_reg,
			
			casilla,
			direccion,
			doc_id,
			telefono2,
			id_persona,
			email2,
			celular1,
			email1,
			
			nombre,
			observaciones,
			telefono1,
			celular2,
			codigo_banco,
			pag_web,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod,
            codigo,
            es_banco,
            cargo_representante
          	) values(
			v_parametros.fax,
			'activo',
			v_parametros.casilla,
			v_parametros.direccion,
			v_parametros.doc_id,
			v_parametros.telefono2,
			v_parametros.id_persona,
			v_parametros.email2,
			v_parametros.celular1,
			v_parametros.email1,
			v_parametros.nombre,
			v_parametros.observaciones,
			v_parametros.telefono1,
			v_parametros.celular2,
			v_parametros.codigo_banco,
			v_parametros.pag_web,
			p_id_usuario,
			now(),
			null,
			null,
            v_parametros.codigo,
            v_parametros.es_banco,
            v_parametros.cargo_representante
            
			)RETURNING id_institucion into v_id_institucion;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Institución almacenado(a) con exito (id_institucion'||v_id_institucion||')'); 
            v_resp = f_agrega_clave(v_resp,'id_institucion',v_id_institucion::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'PM_INSTIT_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		21-09-2011 10:50:03
	***********************************/

	elsif(p_transaccion='PM_INSTIT_MOD')then

		begin
        
      --  raise exception 'ss  %',v_parametros.id_institucion;
			--Sentencia de la modificacion
			update param.tinstitucion set
			fax = v_parametros.fax,
			
			casilla = v_parametros.casilla,
			direccion = v_parametros.direccion,
			doc_id = v_parametros.doc_id,
			telefono2 = v_parametros.telefono2,
			id_persona = v_parametros.id_persona,
			email2 = v_parametros.email2,
			celular1 = v_parametros.celular1,
			email1 = v_parametros.email1,
			
			nombre = v_parametros.nombre,
			observaciones = v_parametros.observaciones,
			telefono1 = v_parametros.telefono1,
			celular2 = v_parametros.celular2,
			codigo_banco = v_parametros.codigo_banco,
			pag_web = v_parametros.pag_web,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now(),
            codigo = v_parametros.codigo,
            es_banco = v_parametros.es_banco,
            cargo_representante = v_parametros.cargo_representante
			where id_institucion=v_parametros.id_institucion;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Institución modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_institucion',v_parametros.id_institucion::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'PM_INSTIT_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		21-09-2011 10:50:03
	***********************************/

	elsif(p_transaccion='PM_INSTIT_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from param.tinstitucion
            where id_institucion=v_parametros.id_institucion;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Institución eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_institucion',v_parametros.id_institucion::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION param.ft_institucion_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1143 (class 1255 OID 1513933)
-- Dependencies: 11 2435
-- Name: ft_institucion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION ft_institucion_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_institucion_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'param.tinstitucion'
 AUTOR: 		 (gvelasquez)
 FECHA:	        21-09-2011 10:50:03
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_filadd			varchar;
			    
BEGIN

	v_nombre_funcion = 'param.ft_institucion_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_INSTIT_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		gvelasquez	
 	#FECHA:		21-09-2011 10:50:03
	***********************************/

	if(p_transaccion='PM_INSTIT_SEL')then
     				
    	begin
            v_filadd = ' 0=0 ';
            IF (f_existe_parametro(p_tabla,'es_banco')) THEN
               v_filadd = ' instit.es_banco = '''||v_parametros.es_banco||''' ';
            END IF;
        
        
    		--Sentencia de la consulta
			v_consulta:='select
						instit.id_institucion,
						instit.fax,
						instit.estado_reg,
                        instit.casilla,
						instit.direccion,
						instit.doc_id,
						instit.telefono2,
						instit.id_persona,
						instit.email2,
						instit.celular1,
						instit.email1,
					
						instit.nombre,
						instit.observaciones,
						instit.telefono1,
						instit.celular2,
						instit.codigo_banco,
						instit.pag_web,
						instit.id_usuario_reg,
						instit.fecha_reg,
						instit.id_usuario_mod,
						instit.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        instit.codigo,	
						instit.es_banco,
                        per.nombre_completo2 as desc_persona,
                        instit.cargo_representante
						from param.tinstitucion instit
						inner join segu.tusuario usu1 on usu1.id_usuario = instit.id_usuario_reg
                        LEFT JOIN segu.vpersona per on per.id_persona = instit.id_persona
						left join segu.tusuario usu2 on usu2.id_usuario = instit.id_usuario_mod
				        where  (instit.estado_reg=''activo'' and '||v_filadd||' ) and';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'PM_INSTIT_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		21-09-2011 10:50:03
	***********************************/

	elsif(p_transaccion='PM_INSTIT_CONT')then

		begin
          v_filadd = ' 0=0 ';
            IF (f_existe_parametro(p_tabla,'es_banco')) THEN
               v_filadd = ' instit.es_banco = '''||v_parametros.es_banco||''' and  instit.estado_reg=''activo'' ';
            END IF;
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_institucion)
					    from param.tinstitucion instit
                        WHERE  '||v_filadd;
			
			--Definicion de la respuesta		    
			--v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION param.ft_institucion_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 254 (class 1255 OID 1370084)
-- Dependencies: 2435 11
-- Name: ft_lugar_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION ft_lugar_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.f_tlugar_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.tlugar'
 AUTOR: 		 (rac)
 FECHA:	        29-08-2011 09:19:28
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_lugar	integer;
    v_codigo_largo varchar;
			    
BEGIN

    v_nombre_funcion = 'param.f_tlugar_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_lug_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		29-08-2011 09:19:28
	***********************************/

	if(p_transaccion='PM_LUG_INS')then
					
        begin
        
           --obtiene codigo recursivamente
            IF v_parametros.id_lugar_fk is null THEN
               v_codigo_largo = v_parametros.codigo;
            ELSE
            
             WITH RECURSIVE t(id,id_fk,cod,n) AS (
               SELECT l.id_lugar,l.id_lugar_fk, l.codigo,1 
               FROM param.tlugar l 
               WHERE l.id_lugar = v_parametros.id_lugar_fk
              UNION ALL
               SELECT l.id_lugar,l.id_lugar_fk, l.codigo , n+1
               FROM param.tlugar l, t
               WHERE l.id_lugar = t.id_fk
            )
            SELECT textcat_all(a.cod||'.')
             into  
             v_codigo_largo
            FROM (SELECT  cod
                  FROM t 
                 order by n desc)  a;
                 
                 
               v_codigo_largo = v_codigo_largo||v_parametros.codigo;
            END IF;
            
            
        	--Sentencia de la insercion
        	insert into param.tlugar(
			codigo,
			estado_reg,
			id_lugar_fk,
			nombre,
			sw_impuesto,
			sw_municipio,
			tipo,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod,
            codigo_largo
          	) values(
			v_parametros.codigo,
			'activo',
			v_parametros.id_lugar_fk,
			v_parametros.nombre,
			v_parametros.sw_impuesto,
			v_parametros.sw_municipio,
			v_parametros.tipo,
			now(),
			p_id_usuario,
			null,
			null,
            v_codigo_largo
			)RETURNING id_lugar into v_id_lugar;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Lugar almacenado(a) con exito (id_lugar'||v_id_lugar||')'); 
            v_resp = f_agrega_clave(v_resp,'id_lugar',v_id_lugar::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'PM_lug_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		29-08-2011 09:19:28
	***********************************/

	elsif(p_transaccion='PM_LUG_MOD')then

		begin
            --obtiene codigo recursivamente
            IF v_parametros.id_lugar_fk is null THEN
               v_codigo_largo = v_parametros.codigo;
            ELSE
            
             WITH RECURSIVE t(id,id_fk,cod,n) AS (
               SELECT l.id_lugar,l.id_lugar_fk, l.codigo,1 
               FROM param.tlugar l 
               WHERE l.id_lugar = v_parametros.id_lugar_fk
              UNION ALL
               SELECT l.id_lugar,l.id_lugar_fk, l.codigo , n+1
               FROM param.tlugar l, t
               WHERE l.id_lugar = t.id_fk
            )
            SELECT textcat_all(a.cod||'.')
             into  
             v_codigo_largo
            FROM (SELECT  cod
                  FROM t 
                 order by n desc)  a;
                 
                 
               v_codigo_largo = v_codigo_largo||v_parametros.codigo;
            END IF;
        
			--Sentencia de la modificacion
			update param.tlugar set
			codigo = v_parametros.codigo,
			id_lugar_fk = v_parametros.id_lugar_fk,
			nombre = v_parametros.nombre,
			sw_impuesto = v_parametros.sw_impuesto,
			sw_municipio = v_parametros.sw_municipio,
			tipo = v_parametros.tipo,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario,
            codigo_largo=v_codigo_largo
			where id_lugar=v_parametros.id_lugar;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Lugar modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_lugar',v_parametros.id_lugar::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'PM_lug_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		29-08-2011 09:19:28
	***********************************/

	elsif(p_transaccion='PM_LUG_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from param.tlugar
            where id_lugar=v_parametros.id_lugar;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Lugar eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_lugar',v_parametros.id_lugar::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION param.ft_lugar_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 255 (class 1255 OID 1370083)
-- Dependencies: 11 2435
-- Name: ft_lugar_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION ft_lugar_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.f_tlugar_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'param.tlugar'
 AUTOR: 		 (rac)
 FECHA:	        29-08-2011 09:19:28
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_where varchar;
    v_join varchar;
			    
BEGIN

	v_nombre_funcion = 'param.f_tlugar_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_LUG_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		29-08-2011 09:19:28
	***********************************/

	if(p_transaccion='PM_LUG_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						lug.id_lugar,
						lug.codigo,
						lug.estado_reg,
						lug.id_lugar_fk,
						lug.nombre,
						lug.sw_impuesto,
						lug.sw_municipio,
						lug.tipo,
						lug.fecha_reg,
						lug.id_usuario_reg,
						lug.fecha_mod,
						lug.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from param.tlugar lug
						inner join segu.tusuario usu1 on usu1.id_usuario = lug.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = lug.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;
        
     /*********************************    
 	#TRANSACCION:  'PM_LUG_ARB_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		29-08-2011 09:19:28
	***********************************/

	elseif(p_transaccion='PM_LUG_ARB_SEL')then
     				
    	begin
        
              if(v_parametros.id_padre = '%') then
                v_where := ' lug.id_lugar_fk is NULL';
                 v_join:= 'LEFT';      
                      
              else
                v_where := ' lug.id_lugar_fk = '||v_parametros.id_padre;
                v_join := 'INNER';
              end if;
        
        
    		--Sentencia de la consulta
			v_consulta:='select
						lug.id_lugar,
						lug.codigo,
						lug.estado_reg,
						lug.id_lugar_fk,
						lug.nombre,
						lug.sw_impuesto,
						lug.sw_municipio,
						lug.tipo,
						lug.fecha_reg,
						lug.id_usuario_reg,
						lug.fecha_mod,
						lug.id_usuario_mod,
						usu1.cuenta as usr_reg,
                        case
                          when (lug.id_lugar_fk is null )then
                               ''raiz''::varchar
                          ELSE
                              ''hijo''::varchar
                          END as tipo_nodo,
                         codigo_largo
						from param.tlugar lug
						inner join segu.tusuario usu1 
                        on usu1.id_usuario = lug.id_usuario_reg
					    where  '||v_where|| '  
                        ORDER BY lug.id_lugar';
			
			
			--Devuelve la respuesta
			return v_consulta;
						
		end;   

	/*********************************    
 	#TRANSACCION:  'PM_LUG_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		29-08-2011 09:19:28
	***********************************/

	elsif(p_transaccion='PM_LUG_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_lugar)
					    from param.tlugar lug
					    inner join segu.tusuario usu1 on usu1.id_usuario = lug.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = lug.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION param.ft_lugar_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 260 (class 1255 OID 16535)
-- Dependencies: 11 2435
-- Name: ft_moneda_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: rchumacero
--

CREATE FUNCTION ft_moneda_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.ft_moneda_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 		KPLIAN
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		18-01-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='param.ft_moneda_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   PM_MONEDA_INS
 #DESCRIPCION:	Inserta Funciones
 #AUTOR:		KPLIAN	
 #FECHA:		18-01-2011	
***********************************/
     if(par_transaccion='PM_MONEDA_INS')then

        
          BEGIN
          
          --insercion de nueva funcion
               INSERT INTO param.tmoneda(codigo,moneda, estado_reg,fecha_reg, id_usuario_reg)
               values(v_parametros.codigo,v_parametros.moneda,'activo',now()::date, par_id_usuario);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','moneda insertada con exito '||v_parametros.moneda);
               v_resp = f_agrega_clave(v_resp,'id_moneda',v_id_funcion::varchar);


         END;
 /*******************************    
 #TRANSACCION:  PM_MONEDA_MOD
 #DESCRIPCION:	Modifica la moneda seleccionada
 #AUTOR:		KPLIAN	
 #FECHA:		18-01-2011
***********************************/
     elsif(par_transaccion='PM_MONEDA_MOD')then

          
          BEGIN

          
               if exists (select 1 from param.tmoneda where estado_reg='activo' and tipo_moneda='base' and id_moneda!=v_parametros.id_moneda and v_parametros.tipo_moneda='on') then
                  raise exception 'Modificacion no realizada. Ya existe una moneda base';
               end if;
               --modificacion de moneda
               update param.tmoneda set
               codigo=v_parametros.codigo,
               moneda=v_parametros.moneda,
               fecha_mod=now()::date,
               id_usuario_mod=par_id_usuario,
               tipo_moneda=f_iif(v_parametros.tipo_moneda='on','base', null)
               
               where id_moneda=v_parametros.id_moneda;

               v_resp = f_agrega_clave(v_resp,'mensaje','moneda modificada con exito '||v_parametros.id_moneda);
               v_resp = f_agrega_clave(v_resp,'id_moneda',v_parametros.id_moneda::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  PM_MONEDA_ELI
 #DESCRIPCION:	Inactiva la moneda selecionada
 #AUTOR:		KPLIAN	
 #FECHA:		18-01-2011
***********************************/

    elsif(par_transaccion='PM_MONEDA_ELI')then
        BEGIN
        
         --inactivacion de la moneda
               update param.tmoneda set estado_reg='eliminado'
               where id_moneda=v_parametros.id_moneda;
               return 'moneda eliminado con exito';
               
               v_resp = f_agrega_clave(v_resp,'mensaje','moneda eliminada con exito '||v_parametros.id_moneda);
               v_resp = f_agrega_clave(v_resp,'id_moneda',v_parametros.id_moneda::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION param.ft_moneda_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1192 (class 1255 OID 16536)
-- Dependencies: 11 2435
-- Name: ft_moneda_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: rchumacero
--

CREATE FUNCTION ft_moneda_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 moneda: 		param.ft_moneda_sel
 DESCRIPCIÓN:  listado de moneda
 AUTOR: 		KPLIAN
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		18-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='param.ft_moneda_sel';


     if(par_transaccion='PM_MONEDA_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            MONEDA.id_moneda,
                            MONEDA.codigo ,
                            MONEDA.moneda,
                            MONEDA.estado_reg ,
                            MONEDA.fecha_reg ,
                            MONEDA.id_usuario_reg,
                            MONEDA.fecha_mod,
                            MONEDA.id_usuario_mod,
                            PERSON.nombre_completo1 AS desc_usuario_reg,
                            PERMOD.nombre_completo1 AS desc_usuario_mod,
                            f_iif(MONEDA.tipo_moneda=''base'',''true'',''false'') as tipo_moneda
                            FROM PARAM.tmoneda MONEDA
                            INNER JOIN SEGU.tusuario USUARI
                            ON USUARI.id_usuario=MONEDA.id_usuario_reg
                            INNER JOIN segu.vpersona PERSON ON PERSON.id_persona=USUARI.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD
                            ON USUMOD.id_usuario=MONEDA.id_usuario_mod
                            LEFT JOIN segu.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE MONEDA.estado_reg!=''eliminado'' and ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='PM_MONEDA_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                            count(MONEDA.id_moneda)
                            FROM PARAM.tmoneda MONEDA
                            INNER JOIN SEGU.tusuario USUARI
                            ON USUARI.id_usuario=MONEDA.id_usuario_reg
                            LEFT JOIN SEGU.tusuario USUMOD
                            ON USUMOD.id_usuario=MONEDA.id_moneda
                            WHERE MONEDA.estado_reg!=''eliminado'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION param.ft_moneda_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 121 (class 1255 OID 16537)
-- Dependencies: 11 2435
-- Name: ft_periodo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: rchumacero
--

CREATE FUNCTION ft_periodo_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.ft_periodo_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 		KPLIAN
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		12-01-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='segu.ft_periodo_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   PM_PERIOD_INS
 #DESCRIPCION:	Inserta Funciones
 #AUTOR:		KPLIAN	
 #FECHA:		07-01-2011	
***********************************/
     if(par_transaccion='PM_PERIOD_INS')then

        
          BEGIN
          
          if exists (select 1 from param.tperiodo where periodo=v_parametros.periodo and estado_reg!='eliminado' and id_gestion=v_parametros.id_gestion) then
            raise exception 'Insercion no realizada. Periodo existente';
          end if;
          --insercion de nueva funcion
               INSERT INTO param.tperiodo(periodo, estado_reg,fecha_reg, id_gestion, id_usuario_reg)
               values(v_parametros.periodo,'activo',now()::date, v_parametros.id_gestion, par_id_usuario);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','periodo insertada con exito '||v_parametros.periodo);
               v_resp = f_agrega_clave(v_resp,'id_periodo',v_id_funcion::varchar);


         END;
 /*******************************    
 #TRANSACCION:  PM_PERIOD_MOD
 #DESCRIPCION:	Modifica la periodo seleccionada
 #AUTOR:		KPLIAN	
 #FECHA:		12-01-2011
***********************************/
     elsif(par_transaccion='PM_PERIOD_MOD')then

          
          BEGIN
          
               if exists (select 1 from param.tperiodo where periodo=v_parametros.periodo and id_periodo!=v_parametros.id_periodo and estado_reg!='eliminado' and id_gestion=v_parametros.id_gestion) then
                  raise exception 'Modificacion no realizada. Periodo existente';
               end if;
               --modificacion de periodo
               update param.tperiodo set
               periodo=v_parametros.periodo,
               estado_reg=v_parametros.estado_reg
               where id_periodo=v_parametros.id_periodo;

               v_resp = f_agrega_clave(v_resp,'mensaje','periodo modificada con exito '||v_parametros.id_periodo);
               v_resp = f_agrega_clave(v_resp,'id_periodo',v_parametros.id_periodo::varchar);

             
          END;
          
/*******************************    
 #TRANSACCION:  PM_PERIOD_ELI
 #DESCRIPCION:	Inactiva la periodo selecionada
 #AUTOR:		KPLIAN	
 #FECHA:		12-01-2011
***********************************/

    elsif(par_transaccion='PM_PERIOD_ELI')then
        BEGIN
        
         --inactivacion de la periodo
               update param.tperiodo set estado_reg='eliminado'
               where id_periodo=v_parametros.id_periodo;
               return 'periodo eliminado con exito';
               
               v_resp = f_agrega_clave(v_resp,'mensaje','periodo eliminada con exito '||v_parametros.id_periodo);
               v_resp = f_agrega_clave(v_resp,'id_periodo',v_parametros.id_periodo::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION param.ft_periodo_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 122 (class 1255 OID 16538)
-- Dependencies: 11 2435
-- Name: ft_periodo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: rchumacero
--

CREATE FUNCTION ft_periodo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 periodo: 		param.ft_periodo_sel
 DESCRIPCIÓN:  listado de periodo
 AUTOR: 		KPLIAN
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		12-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='param.ft_periodo_sel';


     if(par_transaccion='PM_PERIOD_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            PERIOD.id_periodo,
                            public.f_obtener_literal_periodo(PERIOD.periodo, 10),
                            PERIOD.estado_reg,
                            PERIOD.fecha_reg,
                            GESTIO.id_gestion,
                            GESTIO.gestion,
                            PERIOD.id_usuario_reg,
                            PERIOD.id_usuario_mod,
                            perreg.nombre_completo1 as usureg,
                            permod.nombre_completo1 as usumod,
                            PERIOD.fecha_mod
                            FROM param.tperiodo PERIOD
                            INNER JOIN param.tgestion GESTIO
                            ON GESTIO.id_gestion=PERIOD.id_gestion
                            inner join segu.tusuario usureg on usureg.id_usuario=PERIOD.id_usuario_reg
                            inner join segu.vpersona perreg on perreg.id_persona=usureg.id_persona
                            left join segu.tusuario usumod on usumod.id_usuario=PERIOD.id_usuario_mod
                            left join segu.vpersona permod on permod.id_persona=usumod.id_persona
                            WHERE PERIOD.estado_reg!=''eliminado'' and ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;

               --if (v_parametros.id_gestion!=null) then
               --raise exception 'id_gestion no null';
                 v_consulta:=v_consulta|| ' AND PERIOD.id_gestion='||coalesce(v_parametros.id_gestion,0);
             --  else
               --  raise exception 'entra aqui';
               --end if;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='PM_PERIOD_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(PERIOD.id_periodo)
                            FROM param.tperiodo PERIOD
                            INNER JOIN param.tgestion GESTIO
                            ON GESTIO.id_gestion=PERIOD.id_gestion
                            WHERE PERIOD.estado_reg!=''eliminado'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
                 if (v_parametros.id_gestion is not null) then
                 v_consulta:=v_consulta|| ' AND PERIOD.id_gestion='||v_parametros.id_gestion;
               end if;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION param.ft_periodo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1280 (class 1255 OID 2131343)
-- Dependencies: 11 2435
-- Name: ft_usuario_uo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION ft_usuario_uo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_usuario_uo_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.tusuario_uo'
 AUTOR: 		 (rac)
 FECHA:	        13-12-2011 11:14:34
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_usuario_uo	integer;
			    
BEGIN

    v_nombre_funcion = 'param.ft_usuario_uo_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_uuo_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		13-12-2011 11:14:34
	***********************************/

	if(p_transaccion='PM_uuo_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into param.tusuario_uo(
			estado_reg,
			id_uo,
			id_usuario,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			'activo',
			v_parametros.id_uo,
			v_parametros.id_usuario,
			now(),
			p_id_usuario,
			null,
			null
			)RETURNING id_usuario_uo into v_id_usuario_uo;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','usuario_uo almacenado(a) con exito (id_usuario_uo'||v_id_usuario_uo||')'); 
            v_resp = f_agrega_clave(v_resp,'id_usuario_uo',v_id_usuario_uo::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'PM_uuo_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		13-12-2011 11:14:34
	***********************************/

	elsif(p_transaccion='PM_uuo_MOD')then

		begin
			--Sentencia de la modificacion
			update param.tusuario_uo set
			id_uo = v_parametros.id_uo,
			id_usuario = v_parametros.id_usuario,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_usuario_uo=v_parametros.id_usuario_uo;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','usuario_uo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_usuario_uo',v_parametros.id_usuario_uo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'PM_uuo_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		13-12-2011 11:14:34
	***********************************/

	elsif(p_transaccion='PM_uuo_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from param.tusuario_uo
            where id_usuario_uo=v_parametros.id_usuario_uo;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','usuario_uo eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_usuario_uo',v_parametros.id_usuario_uo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION param.ft_usuario_uo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1281 (class 1255 OID 2131344)
-- Dependencies: 11 2435
-- Name: ft_usuario_uo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: postgres
--

CREATE FUNCTION ft_usuario_uo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_usuario_uo_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'param.tusuario_uo'
 AUTOR: 		 (rac)
 FECHA:	        13-12-2011 11:14:34
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'param.ft_usuario_uo_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_UUO_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		13-12-2011 11:14:34
	***********************************/

	if(p_transaccion='PM_UUO_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						uuo.id_usuario_uo,
						uuo.estado_reg,
						uuo.id_uo,
						uuo.id_usuario,
						uuo.fecha_reg,
						uuo.id_usuario_reg,
						uuo.fecha_mod,
						uuo.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        PERSON.nombre_completo2 as desc_usuario,
                        uo.nombre_unidad
                       
						from param.tusuario_uo uuo
                         INNER JOIN rhum.tuo uo on uo.id_uo = uuo.id_uo
                         INNER JOIN segu.tusuario usupri on usupri.id_usuario=uuo.id_usuario
                       INNER JOIN segu.vpersona PERSON on PERSON.id_persona = usupri.id_persona
						inner join segu.tusuario usu1 on usu1.id_usuario = uuo.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = uuo.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'PM_UUO_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		13-12-2011 11:14:34
	***********************************/

	elsif(p_transaccion='PM_UUO_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_usuario_uo)
					    from param.tusuario_uo uuo
                        INNER JOIN rhum.tuo uo on uo.id_uo = uuo.id_uo
                         INNER JOIN segu.tusuario usupri on usupri.id_usuario=uuo.id_usuario
                       INNER JOIN segu.vpersona PERSON on PERSON.id_persona = usupri.id_persona
						inner join segu.tusuario usu1 on usu1.id_usuario = uuo.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = uuo.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION param.ft_usuario_uo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- TOC entry 1226 (class 1255 OID 2964527)
-- Dependencies: 5
-- Name: _int_contained(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _int_contained(integer[], integer[]) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_int_contained';


ALTER FUNCTION public._int_contained(integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 5966 (class 0 OID 0)
-- Dependencies: 1226
-- Name: FUNCTION _int_contained(integer[], integer[]); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION _int_contained(integer[], integer[]) IS 'contained in';


--
-- TOC entry 1225 (class 1255 OID 2964526)
-- Dependencies: 5
-- Name: _int_contains(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _int_contains(integer[], integer[]) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_int_contains';


ALTER FUNCTION public._int_contains(integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 5967 (class 0 OID 0)
-- Dependencies: 1225
-- Name: FUNCTION _int_contains(integer[], integer[]); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION _int_contains(integer[], integer[]) IS 'contains';


--
-- TOC entry 1229 (class 1255 OID 2964530)
-- Dependencies: 5
-- Name: _int_different(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _int_different(integer[], integer[]) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_int_different';


ALTER FUNCTION public._int_different(integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 5968 (class 0 OID 0)
-- Dependencies: 1229
-- Name: FUNCTION _int_different(integer[], integer[]); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION _int_different(integer[], integer[]) IS 'different';


--
-- TOC entry 1231 (class 1255 OID 2964532)
-- Dependencies: 5
-- Name: _int_inter(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _int_inter(integer[], integer[]) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_int_inter';


ALTER FUNCTION public._int_inter(integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 1227 (class 1255 OID 2964528)
-- Dependencies: 5
-- Name: _int_overlap(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _int_overlap(integer[], integer[]) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_int_overlap';


ALTER FUNCTION public._int_overlap(integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 5969 (class 0 OID 0)
-- Dependencies: 1227
-- Name: FUNCTION _int_overlap(integer[], integer[]); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION _int_overlap(integer[], integer[]) IS 'overlaps';


--
-- TOC entry 1228 (class 1255 OID 2964529)
-- Dependencies: 5
-- Name: _int_same(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _int_same(integer[], integer[]) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_int_same';


ALTER FUNCTION public._int_same(integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 5970 (class 0 OID 0)
-- Dependencies: 1228
-- Name: FUNCTION _int_same(integer[], integer[]); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION _int_same(integer[], integer[]) IS 'same as';


--
-- TOC entry 1230 (class 1255 OID 2964531)
-- Dependencies: 5
-- Name: _int_union(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _int_union(integer[], integer[]) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_int_union';


ALTER FUNCTION public._int_union(integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 480 (class 1255 OID 1898657)
-- Dependencies: 5 2104
-- Name: _st_asgeojson(integer, geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_asgeojson(integer, geometry, integer, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asGeoJson';


ALTER FUNCTION public._st_asgeojson(integer, geometry, integer, integer) OWNER TO postgres;

--
-- TOC entry 735 (class 1255 OID 1898946)
-- Dependencies: 5 2131
-- Name: _st_asgeojson(integer, geography, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_asgeojson(integer, geography, integer, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_as_geojson';


ALTER FUNCTION public._st_asgeojson(integer, geography, integer, integer) OWNER TO postgres;

--
-- TOC entry 463 (class 1255 OID 1898640)
-- Dependencies: 5 2104
-- Name: _st_asgml(integer, geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_asgml(integer, geometry, integer, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asGML';


ALTER FUNCTION public._st_asgml(integer, geometry, integer, integer) OWNER TO postgres;

--
-- TOC entry 727 (class 1255 OID 1898932)
-- Dependencies: 5 2131
-- Name: _st_asgml(integer, geography, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_asgml(integer, geography, integer, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_as_gml';


ALTER FUNCTION public._st_asgml(integer, geography, integer, integer) OWNER TO postgres;

--
-- TOC entry 472 (class 1255 OID 1898649)
-- Dependencies: 5 2104
-- Name: _st_askml(integer, geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_askml(integer, geometry, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asKML';


ALTER FUNCTION public._st_askml(integer, geometry, integer) OWNER TO postgres;

--
-- TOC entry 704 (class 1255 OID 1898940)
-- Dependencies: 5 2131
-- Name: _st_askml(integer, geography, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_askml(integer, geography, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_as_kml';


ALTER FUNCTION public._st_askml(integer, geography, integer) OWNER TO postgres;

--
-- TOC entry 767 (class 1255 OID 1898978)
-- Dependencies: 5 2131
-- Name: _st_bestsrid(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_bestsrid(geography) RETURNS integer
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_BestSRID($1,$1)$_$;


ALTER FUNCTION public._st_bestsrid(geography) OWNER TO postgres;

--
-- TOC entry 766 (class 1255 OID 1898977)
-- Dependencies: 5 2131 2131
-- Name: _st_bestsrid(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_bestsrid(geography, geography) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_bestsrid';


ALTER FUNCTION public._st_bestsrid(geography, geography) OWNER TO postgres;

--
-- TOC entry 366 (class 1255 OID 1898534)
-- Dependencies: 5 2104 2104
-- Name: _st_buffer(geometry, double precision, cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_buffer(geometry, double precision, cstring) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'buffer';


ALTER FUNCTION public._st_buffer(geometry, double precision, cstring) OWNER TO postgres;

--
-- TOC entry 427 (class 1255 OID 1898607)
-- Dependencies: 5 2104 2104
-- Name: _st_contains(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_contains(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'contains';


ALTER FUNCTION public._st_contains(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 433 (class 1255 OID 1898613)
-- Dependencies: 5 2104 2104
-- Name: _st_containsproperly(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_containsproperly(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'containsproperly';


ALTER FUNCTION public._st_containsproperly(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 429 (class 1255 OID 1898609)
-- Dependencies: 5 2104 2104
-- Name: _st_coveredby(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_coveredby(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'coveredby';


ALTER FUNCTION public._st_coveredby(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 431 (class 1255 OID 1898611)
-- Dependencies: 5 2104 2104
-- Name: _st_covers(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_covers(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'covers';


ALTER FUNCTION public._st_covers(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 759 (class 1255 OID 1898970)
-- Dependencies: 5 2131 2131
-- Name: _st_covers(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_covers(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'geography_covers';


ALTER FUNCTION public._st_covers(geography, geography) OWNER TO postgres;

--
-- TOC entry 421 (class 1255 OID 1898601)
-- Dependencies: 5 2104 2104
-- Name: _st_crosses(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_crosses(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'crosses';


ALTER FUNCTION public._st_crosses(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 646 (class 1255 OID 1898823)
-- Dependencies: 5 2104 2104
-- Name: _st_dfullywithin(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_dfullywithin(geometry, geometry, double precision) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dfullywithin';


ALTER FUNCTION public._st_dfullywithin(geometry, geometry, double precision) OWNER TO postgres;

--
-- TOC entry 741 (class 1255 OID 1898954)
-- Dependencies: 2131 5 2131
-- Name: _st_distance(geography, geography, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_distance(geography, geography, double precision, boolean) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'geography_distance';


ALTER FUNCTION public._st_distance(geography, geography, double precision, boolean) OWNER TO postgres;

--
-- TOC entry 1048 (class 1255 OID 1898391)
-- Dependencies: 5 2435 2120 2104
-- Name: _st_dumppoints(geometry, integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_dumppoints(the_geom geometry, cur_path integer[]) RETURNS SETOF geometry_dump
    LANGUAGE plpgsql
    AS $$
DECLARE
  tmp geometry_dump;
  tmp2 geometry_dump;
  nb_points integer;
  nb_geom integer;
  i integer;
  j integer;
  g geometry;
  
BEGIN
  
  RAISE DEBUG '%,%', cur_path, ST_GeometryType(the_geom);

  -- Special case (MULTI* OR GEOMETRYCOLLECTION) : iterate and return the DumpPoints of the geometries
  SELECT ST_NumGeometries(the_geom) INTO nb_geom;

  IF (nb_geom IS NOT NULL) THEN
    
    i = 1;
    FOR tmp2 IN SELECT (ST_Dump(the_geom)).* LOOP

      FOR tmp IN SELECT * FROM _ST_DumpPoints(tmp2.geom, cur_path || tmp2.path) LOOP
	    RETURN NEXT tmp;
      END LOOP;
      i = i + 1;
      
    END LOOP;

    RETURN;
  END IF;
  

  -- Special case (POLYGON) : return the points of the rings of a polygon
  IF (ST_GeometryType(the_geom) = 'ST_Polygon') THEN

    FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_ExteriorRing(the_geom), cur_path || ARRAY[1]) LOOP
      RETURN NEXT tmp;
    END LOOP;
    
    j := ST_NumInteriorRings(the_geom);
    FOR i IN 1..j LOOP
        FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_InteriorRingN(the_geom, i), cur_path || ARRAY[i+1]) LOOP
          RETURN NEXT tmp;
        END LOOP;
    END LOOP;
    
    RETURN;
  END IF;

    
  -- Special case (POINT) : return the point
  IF (ST_GeometryType(the_geom) = 'ST_Point') THEN

    tmp.path = cur_path || ARRAY[1];
    tmp.geom = the_geom;

    RETURN NEXT tmp;
    RETURN;

  END IF;


  -- Use ST_NumPoints rather than ST_NPoints to have a NULL value if the_geom isn't
  -- a LINESTRING or CIRCULARSTRING.
  SELECT ST_NumPoints(the_geom) INTO nb_points;

  -- This should never happen
  IF (nb_points IS NULL) THEN
    RAISE EXCEPTION 'Unexpected error while dumping geometry %', ST_AsText(the_geom);
  END IF;

  FOR i IN 1..nb_points LOOP
    tmp.path = cur_path || ARRAY[i];
    tmp.geom := ST_PointN(the_geom, i);
    RETURN NEXT tmp;
  END LOOP;
   
END
$$;


ALTER FUNCTION public._st_dumppoints(the_geom geometry, cur_path integer[]) OWNER TO postgres;

--
-- TOC entry 415 (class 1255 OID 1898595)
-- Dependencies: 5 2104 2104
-- Name: _st_dwithin(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_dwithin(geometry, geometry, double precision) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_dwithin';


ALTER FUNCTION public._st_dwithin(geometry, geometry, double precision) OWNER TO postgres;

--
-- TOC entry 742 (class 1255 OID 1898955)
-- Dependencies: 5 2131 2131
-- Name: _st_dwithin(geography, geography, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_dwithin(geography, geography, double precision, boolean) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'geography_dwithin';


ALTER FUNCTION public._st_dwithin(geography, geography, double precision, boolean) OWNER TO postgres;

--
-- TOC entry 452 (class 1255 OID 1898629)
-- Dependencies: 5 2104 2104
-- Name: _st_equals(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_equals(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'geomequals';


ALTER FUNCTION public._st_equals(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 748 (class 1255 OID 1898959)
-- Dependencies: 5 2131 2131
-- Name: _st_expand(geography, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_expand(geography, double precision) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_expand';


ALTER FUNCTION public._st_expand(geography, double precision) OWNER TO postgres;

--
-- TOC entry 418 (class 1255 OID 1898598)
-- Dependencies: 5 2104 2104
-- Name: _st_intersects(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_intersects(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'intersects';


ALTER FUNCTION public._st_intersects(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 372 (class 1255 OID 1898540)
-- Dependencies: 5 2104 2104
-- Name: _st_linecrossingdirection(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_linecrossingdirection(geometry, geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'ST_LineCrossingDirection';


ALTER FUNCTION public._st_linecrossingdirection(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 644 (class 1255 OID 1898821)
-- Dependencies: 5 2104 2104 2104
-- Name: _st_longestline(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_longestline(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_longestline2d';


ALTER FUNCTION public._st_longestline(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 640 (class 1255 OID 1898817)
-- Dependencies: 5 2104 2104
-- Name: _st_maxdistance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_maxdistance(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_maxdistance2d_linestring';


ALTER FUNCTION public._st_maxdistance(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 671 (class 1255 OID 1898845)
-- Dependencies: 2104 5 2104
-- Name: _st_orderingequals(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_orderingequals(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_same';


ALTER FUNCTION public._st_orderingequals(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 438 (class 1255 OID 1898616)
-- Dependencies: 5 2104 2104
-- Name: _st_overlaps(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_overlaps(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'overlaps';


ALTER FUNCTION public._st_overlaps(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 758 (class 1255 OID 1898969)
-- Dependencies: 5 2131 2131
-- Name: _st_pointoutside(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_pointoutside(geography) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_point_outside';


ALTER FUNCTION public._st_pointoutside(geography) OWNER TO postgres;

--
-- TOC entry 413 (class 1255 OID 1898593)
-- Dependencies: 5 2104 2104
-- Name: _st_touches(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_touches(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'touches';


ALTER FUNCTION public._st_touches(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 424 (class 1255 OID 1898604)
-- Dependencies: 5 2104 2104
-- Name: _st_within(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION _st_within(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'within';


ALTER FUNCTION public._st_within(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 657 (class 1255 OID 1898834)
-- Dependencies: 5 2435
-- Name: addauth(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addauth(text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$ 
DECLARE
	lockid alias for $1;
	okay boolean;
	myrec record;
BEGIN
	-- check to see if table exists
	--  if not, CREATE TEMP TABLE mylock (transid xid, lockcode text)
	okay := 'f';
	FOR myrec IN SELECT * FROM pg_class WHERE relname = 'temp_lock_have_table' LOOP
		okay := 't';
	END LOOP; 
	IF (okay <> 't') THEN 
		CREATE TEMP TABLE temp_lock_have_table (transid xid, lockcode text);
			-- this will only work from pgsql7.4 up
			-- ON COMMIT DELETE ROWS;
	END IF;

	--  INSERT INTO mylock VALUES ( $1)
--	EXECUTE 'INSERT INTO temp_lock_have_table VALUES ( '||
--		quote_literal(getTransactionID()) || ',' ||
--		quote_literal(lockid) ||')';

	INSERT INTO temp_lock_have_table VALUES (getTransactionID(), lockid);

	RETURN true::boolean;
END;
$_$;


ALTER FUNCTION public.addauth(text) OWNER TO postgres;

--
-- TOC entry 892 (class 1255 OID 1898233)
-- Dependencies: 5 2104 2104
-- Name: addbbox(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addbbox(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_addBBOX';


ALTER FUNCTION public.addbbox(geometry) OWNER TO postgres;

--
-- TOC entry 1089 (class 1255 OID 1898435)
-- Dependencies: 5 2435
-- Name: addgeometrycolumn(character varying, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;


ALTER FUNCTION public.addgeometrycolumn(character varying, character varying, integer, character varying, integer) OWNER TO postgres;

--
-- TOC entry 1088 (class 1255 OID 1898434)
-- Dependencies: 5 2435
-- Name: addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;


ALTER FUNCTION public.addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) OWNER TO postgres;

--
-- TOC entry 1087 (class 1255 OID 1898433)
-- Dependencies: 5 2435
-- Name: addgeometrycolumn(character varying, character varying, character varying, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	catalog_name alias for $1;
	schema_name alias for $2;
	table_name alias for $3;
	column_name alias for $4;
	new_srid alias for $5;
	new_type alias for $6;
	new_dim alias for $7;
	rec RECORD;
	sr varchar;
	real_schema name;
	sql text;

BEGIN

	-- Verify geometry type
	IF ( NOT ( (new_type = 'GEOMETRY') OR
			   (new_type = 'GEOMETRYCOLLECTION') OR
			   (new_type = 'POINT') OR
			   (new_type = 'MULTIPOINT') OR
			   (new_type = 'POLYGON') OR
			   (new_type = 'MULTIPOLYGON') OR
			   (new_type = 'LINESTRING') OR
			   (new_type = 'MULTILINESTRING') OR
			   (new_type = 'GEOMETRYCOLLECTIONM') OR
			   (new_type = 'POINTM') OR
			   (new_type = 'MULTIPOINTM') OR
			   (new_type = 'POLYGONM') OR
			   (new_type = 'MULTIPOLYGONM') OR
			   (new_type = 'LINESTRINGM') OR
			   (new_type = 'MULTILINESTRINGM') OR
			   (new_type = 'CIRCULARSTRING') OR
			   (new_type = 'CIRCULARSTRINGM') OR
			   (new_type = 'COMPOUNDCURVE') OR
			   (new_type = 'COMPOUNDCURVEM') OR
			   (new_type = 'CURVEPOLYGON') OR
			   (new_type = 'CURVEPOLYGONM') OR
			   (new_type = 'MULTICURVE') OR
			   (new_type = 'MULTICURVEM') OR
			   (new_type = 'MULTISURFACE') OR
			   (new_type = 'MULTISURFACEM')) )
	THEN
		RAISE EXCEPTION 'Invalid type name - valid ones are:
	POINT, MULTIPOINT,
	LINESTRING, MULTILINESTRING,
	POLYGON, MULTIPOLYGON,
	CIRCULARSTRING, COMPOUNDCURVE, MULTICURVE,
	CURVEPOLYGON, MULTISURFACE,
	GEOMETRY, GEOMETRYCOLLECTION,
	POINTM, MULTIPOINTM,
	LINESTRINGM, MULTILINESTRINGM,
	POLYGONM, MULTIPOLYGONM,
	CIRCULARSTRINGM, COMPOUNDCURVEM, MULTICURVEM
	CURVEPOLYGONM, MULTISURFACEM,
	or GEOMETRYCOLLECTIONM';
		RETURN 'fail';
	END IF;


	-- Verify dimension
	IF ( (new_dim >4) OR (new_dim <0) ) THEN
		RAISE EXCEPTION 'invalid dimension';
		RETURN 'fail';
	END IF;

	IF ( (new_type LIKE '%M') AND (new_dim!=3) ) THEN
		RAISE EXCEPTION 'TypeM needs 3 dimensions';
		RETURN 'fail';
	END IF;


	-- Verify SRID
	IF ( new_srid != -1 ) THEN
		SELECT SRID INTO sr FROM spatial_ref_sys WHERE SRID = new_srid;
		IF NOT FOUND THEN
			RAISE EXCEPTION 'AddGeometryColumns() - invalid SRID';
			RETURN 'fail';
		END IF;
	END IF;


	-- Verify schema
	IF ( schema_name IS NOT NULL AND schema_name != '' ) THEN
		sql := 'SELECT nspname FROM pg_namespace ' ||
			'WHERE text(nspname) = ' || quote_literal(schema_name) ||
			'LIMIT 1';
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Schema % is not a valid schemaname', quote_literal(schema_name);
			RETURN 'fail';
		END IF;
	END IF;

	IF ( real_schema IS NULL ) THEN
		RAISE DEBUG 'Detecting schema';
		sql := 'SELECT n.nspname AS schemaname ' ||
			'FROM pg_catalog.pg_class c ' ||
			  'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace ' ||
			'WHERE c.relkind = ' || quote_literal('r') ||
			' AND n.nspname NOT IN (' || quote_literal('pg_catalog') || ', ' || quote_literal('pg_toast') || ')' ||
			' AND pg_catalog.pg_table_is_visible(c.oid)' ||
			' AND c.relname = ' || quote_literal(table_name);
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Table % does not occur in the search_path', quote_literal(table_name);
			RETURN 'fail';
		END IF;
	END IF;


	-- Add geometry column to table
	sql := 'ALTER TABLE ' ||
		quote_ident(real_schema) || '.' || quote_ident(table_name)
		|| ' ADD COLUMN ' || quote_ident(column_name) ||
		' geometry ';
	RAISE DEBUG '%', sql;
	EXECUTE sql;


	-- Delete stale record in geometry_columns (if any)
	sql := 'DELETE FROM geometry_columns WHERE
		f_table_catalog = ' || quote_literal('') ||
		' AND f_table_schema = ' ||
		quote_literal(real_schema) ||
		' AND f_table_name = ' || quote_literal(table_name) ||
		' AND f_geometry_column = ' || quote_literal(column_name);
	RAISE DEBUG '%', sql;
	EXECUTE sql;


	-- Add record in geometry_columns
	sql := 'INSERT INTO geometry_columns (f_table_catalog,f_table_schema,f_table_name,' ||
										  'f_geometry_column,coord_dimension,srid,type)' ||
		' VALUES (' ||
		quote_literal('') || ',' ||
		quote_literal(real_schema) || ',' ||
		quote_literal(table_name) || ',' ||
		quote_literal(column_name) || ',' ||
		new_dim::text || ',' ||
		new_srid::text || ',' ||
		quote_literal(new_type) || ')';
	RAISE DEBUG '%', sql;
	EXECUTE sql;


	-- Add table CHECKs
	sql := 'ALTER TABLE ' ||
		quote_ident(real_schema) || '.' || quote_ident(table_name)
		|| ' ADD CONSTRAINT '
		|| quote_ident('enforce_srid_' || column_name)
		|| ' CHECK (ST_SRID(' || quote_ident(column_name) ||
		') = ' || new_srid::text || ')' ;
	RAISE DEBUG '%', sql;
	EXECUTE sql;

	sql := 'ALTER TABLE ' ||
		quote_ident(real_schema) || '.' || quote_ident(table_name)
		|| ' ADD CONSTRAINT '
		|| quote_ident('enforce_dims_' || column_name)
		|| ' CHECK (ST_NDims(' || quote_ident(column_name) ||
		') = ' || new_dim::text || ')' ;
	RAISE DEBUG '%', sql;
	EXECUTE sql;

	IF ( NOT (new_type = 'GEOMETRY')) THEN
		sql := 'ALTER TABLE ' ||
			quote_ident(real_schema) || '.' || quote_ident(table_name) || ' ADD CONSTRAINT ' ||
			quote_ident('enforce_geotype_' || column_name) ||
			' CHECK (GeometryType(' ||
			quote_ident(column_name) || ')=' ||
			quote_literal(new_type) || ' OR (' ||
			quote_ident(column_name) || ') is null)';
		RAISE DEBUG '%', sql;
		EXECUTE sql;
	END IF;

	RETURN
		real_schema || '.' ||
		table_name || '.' || column_name ||
		' SRID:' || new_srid::text ||
		' TYPE:' || new_type ||
		' DIMS:' || new_dim::text || ' ';
END;
$_$;


ALTER FUNCTION public.addgeometrycolumn(character varying, character varying, character varying, character varying, integer, character varying, integer) OWNER TO postgres;

--
-- TOC entry 1024 (class 1255 OID 1898364)
-- Dependencies: 5 2104 2104 2104
-- Name: addpoint(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addpoint(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_addpoint';


ALTER FUNCTION public.addpoint(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1026 (class 1255 OID 1898366)
-- Dependencies: 5 2104 2104 2104
-- Name: addpoint(geometry, geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION addpoint(geometry, geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_addpoint';


ALTER FUNCTION public.addpoint(geometry, geometry, integer) OWNER TO postgres;

--
-- TOC entry 791 (class 1255 OID 1898078)
-- Dependencies: 5 2104 2104
-- Name: affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  $2, $3, 0,  $4, $5, 0,  0, 0, 1,  $6, $7, 0)$_$;


ALTER FUNCTION public.affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 789 (class 1255 OID 1898076)
-- Dependencies: 5 2104 2104
-- Name: affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_affine';


ALTER FUNCTION public.affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 118 (class 1255 OID 16539)
-- Dependencies: 5
-- Name: aggregate_array(anyarray, anyelement); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION aggregate_array(anyarray, anyelement) RETURNS anyarray
    LANGUAGE sql
    AS $_$
SELECT
CASE
WHEN $1 IS NULL
THEN ARRAY[$2]
WHEN $2 IS NULL
THEN $1
ELSE array_append($1,$2)
END;
$_$;


ALTER FUNCTION public.aggregate_array(anyarray, anyelement) OWNER TO rchumacero;

--
-- TOC entry 944 (class 1255 OID 1898285)
-- Dependencies: 5 2104
-- Name: area(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION area(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_area_polygon';


ALTER FUNCTION public.area(geometry) OWNER TO postgres;

--
-- TOC entry 942 (class 1255 OID 1898283)
-- Dependencies: 5 2104
-- Name: area2d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION area2d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_area_polygon';


ALTER FUNCTION public.area2d(geometry) OWNER TO postgres;

--
-- TOC entry 529 (class 1255 OID 1898706)
-- Dependencies: 5 2104
-- Name: asbinary(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION asbinary(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asBinary';


ALTER FUNCTION public.asbinary(geometry) OWNER TO postgres;

--
-- TOC entry 531 (class 1255 OID 1898708)
-- Dependencies: 5 2104
-- Name: asbinary(geometry, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION asbinary(geometry, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asBinary';


ALTER FUNCTION public.asbinary(geometry, text) OWNER TO postgres;

--
-- TOC entry 990 (class 1255 OID 1898332)
-- Dependencies: 5 2104
-- Name: asewkb(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION asewkb(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'WKBFromLWGEOM';


ALTER FUNCTION public.asewkb(geometry) OWNER TO postgres;

--
-- TOC entry 998 (class 1255 OID 1898338)
-- Dependencies: 5 2104
-- Name: asewkb(geometry, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION asewkb(geometry, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'WKBFromLWGEOM';


ALTER FUNCTION public.asewkb(geometry, text) OWNER TO postgres;

--
-- TOC entry 987 (class 1255 OID 1898330)
-- Dependencies: 5 2104
-- Name: asewkt(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION asewkt(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asEWKT';


ALTER FUNCTION public.asewkt(geometry) OWNER TO postgres;

--
-- TOC entry 466 (class 1255 OID 1898643)
-- Dependencies: 5 2104
-- Name: asgml(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION asgml(geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, 15, 0)$_$;


ALTER FUNCTION public.asgml(geometry) OWNER TO postgres;

--
-- TOC entry 464 (class 1255 OID 1898641)
-- Dependencies: 5 2104
-- Name: asgml(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION asgml(geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, $2, 0)$_$;


ALTER FUNCTION public.asgml(geometry, integer) OWNER TO postgres;

--
-- TOC entry 994 (class 1255 OID 1898334)
-- Dependencies: 5 2104
-- Name: ashexewkb(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ashexewkb(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asHEXEWKB';


ALTER FUNCTION public.ashexewkb(geometry) OWNER TO postgres;

--
-- TOC entry 996 (class 1255 OID 1898336)
-- Dependencies: 5 2104
-- Name: ashexewkb(geometry, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ashexewkb(geometry, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asHEXEWKB';


ALTER FUNCTION public.ashexewkb(geometry, text) OWNER TO postgres;

--
-- TOC entry 475 (class 1255 OID 1898652)
-- Dependencies: 5 2104
-- Name: askml(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION askml(geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML(2, transform($1,4326), 15)$_$;


ALTER FUNCTION public.askml(geometry) OWNER TO postgres;

--
-- TOC entry 473 (class 1255 OID 1898650)
-- Dependencies: 5 2104
-- Name: askml(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION askml(geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML(2, transform($1,4326), $2)$_$;


ALTER FUNCTION public.askml(geometry, integer) OWNER TO postgres;

--
-- TOC entry 476 (class 1255 OID 1898653)
-- Dependencies: 5 2104
-- Name: askml(integer, geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION askml(integer, geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML($1, transform($2,4326), $3)$_$;


ALTER FUNCTION public.askml(integer, geometry, integer) OWNER TO postgres;

--
-- TOC entry 461 (class 1255 OID 1898638)
-- Dependencies: 5 2104
-- Name: assvg(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION assvg(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'assvg_geometry';


ALTER FUNCTION public.assvg(geometry) OWNER TO postgres;

--
-- TOC entry 459 (class 1255 OID 1898636)
-- Dependencies: 5 2104
-- Name: assvg(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION assvg(geometry, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'assvg_geometry';


ALTER FUNCTION public.assvg(geometry, integer) OWNER TO postgres;

--
-- TOC entry 457 (class 1255 OID 1898634)
-- Dependencies: 5 2104
-- Name: assvg(geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION assvg(geometry, integer, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'assvg_geometry';


ALTER FUNCTION public.assvg(geometry, integer, integer) OWNER TO postgres;

--
-- TOC entry 533 (class 1255 OID 1898710)
-- Dependencies: 5 2104
-- Name: astext(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION astext(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asText';


ALTER FUNCTION public.astext(geometry) OWNER TO postgres;

--
-- TOC entry 954 (class 1255 OID 1898295)
-- Dependencies: 5 2104 2104
-- Name: azimuth(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION azimuth(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_azimuth';


ALTER FUNCTION public.azimuth(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 649 (class 1255 OID 1898827)
-- Dependencies: 2435 5 2104
-- Name: bdmpolyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(BuildArea(mline));

	RETURN geom;
END;
$_$;


ALTER FUNCTION public.bdmpolyfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 648 (class 1255 OID 1898825)
-- Dependencies: 5 2435 2104
-- Name: bdpolyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;


ALTER FUNCTION public.bdpolyfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 1223 (class 1255 OID 2964522)
-- Dependencies: 2009 5
-- Name: boolop(integer[], query_int); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION boolop(integer[], query_int) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'boolop';


ALTER FUNCTION public.boolop(integer[], query_int) OWNER TO postgres;

--
-- TOC entry 5971 (class 0 OID 0)
-- Dependencies: 1223
-- Name: FUNCTION boolop(integer[], query_int); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION boolop(integer[], query_int) IS 'boolean operation with array';


--
-- TOC entry 382 (class 1255 OID 1898549)
-- Dependencies: 5 2104 2104
-- Name: boundary(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION boundary(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'boundary';


ALTER FUNCTION public.boundary(geometry) OWNER TO postgres;

--
-- TOC entry 327 (class 1255 OID 1898479)
-- Dependencies: 5 2104
-- Name: box(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box(geometry) RETURNS box
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_BOX';


ALTER FUNCTION public.box(geometry) OWNER TO postgres;

--
-- TOC entry 330 (class 1255 OID 1898482)
-- Dependencies: 5 2107
-- Name: box(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box(box3d) RETURNS box
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_BOX';


ALTER FUNCTION public.box(box3d) OWNER TO postgres;

--
-- TOC entry 820 (class 1255 OID 1898112)
-- Dependencies: 5 2117 2111
-- Name: box2d(box3d_extent); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box2d(box3d_extent) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_BOX2DFLOAT4';


ALTER FUNCTION public.box2d(box3d_extent) OWNER TO postgres;

--
-- TOC entry 325 (class 1255 OID 1898477)
-- Dependencies: 5 2117 2104
-- Name: box2d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box2d(geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_BOX2DFLOAT4';


ALTER FUNCTION public.box2d(geometry) OWNER TO postgres;

--
-- TOC entry 328 (class 1255 OID 1898480)
-- Dependencies: 5 2117 2107
-- Name: box2d(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box2d(box3d) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_BOX2DFLOAT4';


ALTER FUNCTION public.box2d(box3d) OWNER TO postgres;

--
-- TOC entry 326 (class 1255 OID 1898478)
-- Dependencies: 5 2107 2104
-- Name: box3d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box3d(geometry) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_BOX3D';


ALTER FUNCTION public.box3d(geometry) OWNER TO postgres;

--
-- TOC entry 329 (class 1255 OID 1898481)
-- Dependencies: 5 2107 2117
-- Name: box3d(box2d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box3d(box2d) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_to_BOX3D';


ALTER FUNCTION public.box3d(box2d) OWNER TO postgres;

--
-- TOC entry 819 (class 1255 OID 1898110)
-- Dependencies: 5 2107 2111
-- Name: box3d_extent(box3d_extent); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box3d_extent(box3d_extent) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_extent_to_BOX3D';


ALTER FUNCTION public.box3d_extent(box3d_extent) OWNER TO postgres;

--
-- TOC entry 332 (class 1255 OID 1898484)
-- Dependencies: 5 2107
-- Name: box3dtobox(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION box3dtobox(box3d) RETURNS box
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT box($1)$_$;


ALTER FUNCTION public.box3dtobox(box3d) OWNER TO postgres;

--
-- TOC entry 364 (class 1255 OID 1898532)
-- Dependencies: 5 2104 2104
-- Name: buffer(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION buffer(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'buffer';


ALTER FUNCTION public.buffer(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 369 (class 1255 OID 1898537)
-- Dependencies: 5 2104 2104
-- Name: buffer(geometry, double precision, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION buffer(geometry, double precision, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_Buffer($1, $2, $3)$_$;


ALTER FUNCTION public.buffer(geometry, double precision, integer) OWNER TO postgres;

--
-- TOC entry 1037 (class 1255 OID 1898377)
-- Dependencies: 5 2104 2104
-- Name: buildarea(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION buildarea(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_buildarea';


ALTER FUNCTION public.buildarea(geometry) OWNER TO postgres;

--
-- TOC entry 338 (class 1255 OID 1898490)
-- Dependencies: 5 2104
-- Name: bytea(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION bytea(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_bytea';


ALTER FUNCTION public.bytea(geometry) OWNER TO postgres;

--
-- TOC entry 435 (class 1255 OID 1615823)
-- Dependencies: 5 2435
-- Name: cast_bytea_oid(bytea); Type: FUNCTION; Schema: public; Owner: mflores
--

CREATE FUNCTION cast_bytea_oid(archivo bytea) RETURNS oid
    LANGUAGE plpgsql
    AS $$
   declare
      loid oid;
      lfd integer;
      lsize integer;
begin

   if(archivo is null) then
      return null;
   end if;
   loid := lo_create(0);
   lfd := lo_open(loid,131072);
   lsize := lowrite(lfd,archivo);
   perform lo_close(lfd);
   return loid;
end;
$$;


ALTER FUNCTION public.cast_bytea_oid(archivo bytea) OWNER TO mflores;

--
-- TOC entry 442 (class 1255 OID 1898620)
-- Dependencies: 5 2104 2104
-- Name: centroid(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION centroid(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'centroid';


ALTER FUNCTION public.centroid(geometry) OWNER TO postgres;

--
-- TOC entry 659 (class 1255 OID 1898836)
-- Dependencies: 5
-- Name: checkauth(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION checkauth(text, text) RETURNS integer
    LANGUAGE sql
    AS $_$ SELECT CheckAuth('', $1, $2) $_$;


ALTER FUNCTION public.checkauth(text, text) OWNER TO postgres;

--
-- TOC entry 658 (class 1255 OID 1898835)
-- Dependencies: 5 2435
-- Name: checkauth(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION checkauth(text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
DECLARE
	schema text;
BEGIN
	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	if ( $1 != '' ) THEN
		schema = $1;
	ELSE
		SELECT current_schema() into schema;
	END IF;

	-- TODO: check for an already existing trigger ?

	EXECUTE 'CREATE TRIGGER check_auth BEFORE UPDATE OR DELETE ON ' 
		|| quote_ident(schema) || '.' || quote_ident($2)
		||' FOR EACH ROW EXECUTE PROCEDURE CheckAuthTrigger('
		|| quote_literal($3) || ')';

	RETURN 0;
END;
$_$;


ALTER FUNCTION public.checkauth(text, text, text) OWNER TO postgres;

--
-- TOC entry 660 (class 1255 OID 1898837)
-- Dependencies: 5
-- Name: checkauthtrigger(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION checkauthtrigger() RETURNS trigger
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'check_authorization';


ALTER FUNCTION public.checkauthtrigger() OWNER TO postgres;

--
-- TOC entry 390 (class 1255 OID 1898557)
-- Dependencies: 5 2104 2104 2104
-- Name: collect(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION collect(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'LWGEOM_collect';


ALTER FUNCTION public.collect(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1050 (class 1255 OID 1898393)
-- Dependencies: 5 2117 2117 2104
-- Name: combine_bbox(box2d, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION combine_bbox(box2d, geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_combine';


ALTER FUNCTION public.combine_bbox(box2d, geometry) OWNER TO postgres;

--
-- TOC entry 1052 (class 1255 OID 1898395)
-- Dependencies: 5 2111 2111 2104
-- Name: combine_bbox(box3d_extent, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION combine_bbox(box3d_extent, geometry) RETURNS box3d_extent
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'BOX3D_combine';


ALTER FUNCTION public.combine_bbox(box3d_extent, geometry) OWNER TO postgres;

--
-- TOC entry 1055 (class 1255 OID 1898399)
-- Dependencies: 5 2107 2107 2104
-- Name: combine_bbox(box3d, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION combine_bbox(box3d, geometry) RETURNS box3d
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'BOX3D_combine';


ALTER FUNCTION public.combine_bbox(box3d, geometry) OWNER TO postgres;

--
-- TOC entry 1218 (class 1255 OID 2958985)
-- Dependencies: 5
-- Name: comma_cat(text, text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION comma_cat(text, text) RETURNS text
    LANGUAGE sql
    AS $_$
select case
 WHEN $2 is null or $2 = '' THEN $1
 WHEN $1 is null or $1 = '' THEN $2
 ELSE $1 || ',' || $2
 END
$_$;


ALTER FUNCTION public.comma_cat(text, text) OWNER TO rchumacero;

--
-- TOC entry 911 (class 1255 OID 1898252)
-- Dependencies: 5 2114
-- Name: compression(chip); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION compression(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getCompression';


ALTER FUNCTION public.compression(chip) OWNER TO postgres;

--
-- TOC entry 302 (class 1255 OID 1475670)
-- Dependencies: 5 2435
-- Name: concat(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION concat(text, text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
begin
  if $1 is null then
    return $2;
  end if;
  if $2 is null then
    return $1;
  end if;
  return $1 || ',' || $2;
end
$_$;


ALTER FUNCTION public.concat(text, text) OWNER TO postgres;

--
-- TOC entry 426 (class 1255 OID 1898606)
-- Dependencies: 5 2104 2104
-- Name: contains(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION contains(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'contains';


ALTER FUNCTION public.contains(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 370 (class 1255 OID 1898538)
-- Dependencies: 5 2104 2104
-- Name: convexhull(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION convexhull(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'convexhull';


ALTER FUNCTION public.convexhull(geometry) OWNER TO postgres;

--
-- TOC entry 420 (class 1255 OID 1898600)
-- Dependencies: 5 2104 2104
-- Name: crosses(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION crosses(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'crosses';


ALTER FUNCTION public.crosses(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 909 (class 1255 OID 1898250)
-- Dependencies: 5 2114
-- Name: datatype(chip); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION datatype(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getDatatype';


ALTER FUNCTION public.datatype(chip) OWNER TO postgres;

--
-- TOC entry 236 (class 1255 OID 16540)
-- Dependencies: 5
-- Name: dblink(text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink(text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


ALTER FUNCTION public.dblink(text) OWNER TO rchumacero;

--
-- TOC entry 234 (class 1255 OID 16541)
-- Dependencies: 5
-- Name: dblink(text, text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink(text, text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


ALTER FUNCTION public.dblink(text, text) OWNER TO rchumacero;

--
-- TOC entry 237 (class 1255 OID 16542)
-- Dependencies: 5
-- Name: dblink(text, boolean); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink(text, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


ALTER FUNCTION public.dblink(text, boolean) OWNER TO rchumacero;

--
-- TOC entry 235 (class 1255 OID 16543)
-- Dependencies: 5
-- Name: dblink(text, text, boolean); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink(text, text, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


ALTER FUNCTION public.dblink(text, text, boolean) OWNER TO rchumacero;

--
-- TOC entry 199 (class 1255 OID 16544)
-- Dependencies: 5
-- Name: dblink_build_sql_delete(text, int2vector, integer, text[]); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_build_sql_delete(text, int2vector, integer, text[]) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_build_sql_delete';


ALTER FUNCTION public.dblink_build_sql_delete(text, int2vector, integer, text[]) OWNER TO rchumacero;

--
-- TOC entry 243 (class 1255 OID 16545)
-- Dependencies: 5
-- Name: dblink_build_sql_insert(text, int2vector, integer, text[], text[]); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_build_sql_insert(text, int2vector, integer, text[], text[]) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_build_sql_insert';


ALTER FUNCTION public.dblink_build_sql_insert(text, int2vector, integer, text[], text[]) OWNER TO rchumacero;

--
-- TOC entry 200 (class 1255 OID 16546)
-- Dependencies: 5
-- Name: dblink_build_sql_update(text, int2vector, integer, text[], text[]); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_build_sql_update(text, int2vector, integer, text[], text[]) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_build_sql_update';


ALTER FUNCTION public.dblink_build_sql_update(text, int2vector, integer, text[], text[]) OWNER TO rchumacero;

--
-- TOC entry 119 (class 1255 OID 16547)
-- Dependencies: 5
-- Name: dblink_cancel_query(text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_cancel_query(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_cancel_query';


ALTER FUNCTION public.dblink_cancel_query(text) OWNER TO rchumacero;

--
-- TOC entry 230 (class 1255 OID 16548)
-- Dependencies: 5
-- Name: dblink_close(text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_close(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


ALTER FUNCTION public.dblink_close(text) OWNER TO rchumacero;

--
-- TOC entry 231 (class 1255 OID 16549)
-- Dependencies: 5
-- Name: dblink_close(text, boolean); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_close(text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


ALTER FUNCTION public.dblink_close(text, boolean) OWNER TO rchumacero;

--
-- TOC entry 232 (class 1255 OID 16550)
-- Dependencies: 5
-- Name: dblink_close(text, text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_close(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


ALTER FUNCTION public.dblink_close(text, text) OWNER TO rchumacero;

--
-- TOC entry 233 (class 1255 OID 16551)
-- Dependencies: 5
-- Name: dblink_close(text, text, boolean); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_close(text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


ALTER FUNCTION public.dblink_close(text, text, boolean) OWNER TO rchumacero;

--
-- TOC entry 215 (class 1255 OID 16552)
-- Dependencies: 5
-- Name: dblink_connect(text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_connect(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_connect';


ALTER FUNCTION public.dblink_connect(text) OWNER TO rchumacero;

--
-- TOC entry 216 (class 1255 OID 16553)
-- Dependencies: 5
-- Name: dblink_connect(text, text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_connect(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_connect';


ALTER FUNCTION public.dblink_connect(text, text) OWNER TO rchumacero;

--
-- TOC entry 217 (class 1255 OID 16554)
-- Dependencies: 5
-- Name: dblink_connect_u(text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_connect_u(text) RETURNS text
    LANGUAGE c STRICT SECURITY DEFINER
    AS '$libdir/dblink', 'dblink_connect';


ALTER FUNCTION public.dblink_connect_u(text) OWNER TO rchumacero;

--
-- TOC entry 218 (class 1255 OID 16555)
-- Dependencies: 5
-- Name: dblink_connect_u(text, text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_connect_u(text, text) RETURNS text
    LANGUAGE c STRICT SECURITY DEFINER
    AS '$libdir/dblink', 'dblink_connect';


ALTER FUNCTION public.dblink_connect_u(text, text) OWNER TO rchumacero;

--
-- TOC entry 201 (class 1255 OID 16556)
-- Dependencies: 5
-- Name: dblink_current_query(); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_current_query() RETURNS text
    LANGUAGE c
    AS '$libdir/dblink', 'dblink_current_query';


ALTER FUNCTION public.dblink_current_query() OWNER TO rchumacero;

--
-- TOC entry 219 (class 1255 OID 16557)
-- Dependencies: 5
-- Name: dblink_disconnect(); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_disconnect() RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_disconnect';


ALTER FUNCTION public.dblink_disconnect() OWNER TO rchumacero;

--
-- TOC entry 220 (class 1255 OID 16558)
-- Dependencies: 5
-- Name: dblink_disconnect(text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_disconnect(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_disconnect';


ALTER FUNCTION public.dblink_disconnect(text) OWNER TO rchumacero;

--
-- TOC entry 120 (class 1255 OID 16559)
-- Dependencies: 5
-- Name: dblink_error_message(text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_error_message(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_error_message';


ALTER FUNCTION public.dblink_error_message(text) OWNER TO rchumacero;

--
-- TOC entry 240 (class 1255 OID 16560)
-- Dependencies: 5
-- Name: dblink_exec(text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_exec(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


ALTER FUNCTION public.dblink_exec(text) OWNER TO rchumacero;

--
-- TOC entry 238 (class 1255 OID 16561)
-- Dependencies: 5
-- Name: dblink_exec(text, text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_exec(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


ALTER FUNCTION public.dblink_exec(text, text) OWNER TO rchumacero;

--
-- TOC entry 241 (class 1255 OID 16562)
-- Dependencies: 5
-- Name: dblink_exec(text, boolean); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_exec(text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


ALTER FUNCTION public.dblink_exec(text, boolean) OWNER TO rchumacero;

--
-- TOC entry 239 (class 1255 OID 16563)
-- Dependencies: 5
-- Name: dblink_exec(text, text, boolean); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_exec(text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


ALTER FUNCTION public.dblink_exec(text, text, boolean) OWNER TO rchumacero;

--
-- TOC entry 226 (class 1255 OID 16564)
-- Dependencies: 5
-- Name: dblink_fetch(text, integer); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_fetch(text, integer) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


ALTER FUNCTION public.dblink_fetch(text, integer) OWNER TO rchumacero;

--
-- TOC entry 227 (class 1255 OID 16565)
-- Dependencies: 5
-- Name: dblink_fetch(text, integer, boolean); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_fetch(text, integer, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


ALTER FUNCTION public.dblink_fetch(text, integer, boolean) OWNER TO rchumacero;

--
-- TOC entry 228 (class 1255 OID 16566)
-- Dependencies: 5
-- Name: dblink_fetch(text, text, integer); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_fetch(text, text, integer) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


ALTER FUNCTION public.dblink_fetch(text, text, integer) OWNER TO rchumacero;

--
-- TOC entry 229 (class 1255 OID 16567)
-- Dependencies: 5
-- Name: dblink_fetch(text, text, integer, boolean); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_fetch(text, text, integer, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


ALTER FUNCTION public.dblink_fetch(text, text, integer, boolean) OWNER TO rchumacero;

--
-- TOC entry 115 (class 1255 OID 16568)
-- Dependencies: 5
-- Name: dblink_get_connections(); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_get_connections() RETURNS text[]
    LANGUAGE c
    AS '$libdir/dblink', 'dblink_get_connections';


ALTER FUNCTION public.dblink_get_connections() OWNER TO rchumacero;

--
-- TOC entry 110 (class 1255 OID 16569)
-- Dependencies: 5
-- Name: dblink_get_notify(); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_get_notify(OUT notify_name text, OUT be_pid integer, OUT extra text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_notify';


ALTER FUNCTION public.dblink_get_notify(OUT notify_name text, OUT be_pid integer, OUT extra text) OWNER TO rchumacero;

--
-- TOC entry 111 (class 1255 OID 16570)
-- Dependencies: 5
-- Name: dblink_get_notify(text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_get_notify(conname text, OUT notify_name text, OUT be_pid integer, OUT extra text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_notify';


ALTER FUNCTION public.dblink_get_notify(conname text, OUT notify_name text, OUT be_pid integer, OUT extra text) OWNER TO rchumacero;

--
-- TOC entry 242 (class 1255 OID 16571)
-- Dependencies: 5 1606
-- Name: dblink_get_pkey(text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_get_pkey(text) RETURNS SETOF dblink_pkey_results
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_pkey';


ALTER FUNCTION public.dblink_get_pkey(text) OWNER TO rchumacero;

--
-- TOC entry 123 (class 1255 OID 16572)
-- Dependencies: 5
-- Name: dblink_get_result(text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_get_result(text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_result';


ALTER FUNCTION public.dblink_get_result(text) OWNER TO rchumacero;

--
-- TOC entry 124 (class 1255 OID 16573)
-- Dependencies: 5
-- Name: dblink_get_result(text, boolean); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_get_result(text, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_result';


ALTER FUNCTION public.dblink_get_result(text, boolean) OWNER TO rchumacero;

--
-- TOC entry 125 (class 1255 OID 16574)
-- Dependencies: 5
-- Name: dblink_is_busy(text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_is_busy(text) RETURNS integer
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_is_busy';


ALTER FUNCTION public.dblink_is_busy(text) OWNER TO rchumacero;

--
-- TOC entry 221 (class 1255 OID 16575)
-- Dependencies: 5
-- Name: dblink_open(text, text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_open(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


ALTER FUNCTION public.dblink_open(text, text) OWNER TO rchumacero;

--
-- TOC entry 222 (class 1255 OID 16576)
-- Dependencies: 5
-- Name: dblink_open(text, text, boolean); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_open(text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


ALTER FUNCTION public.dblink_open(text, text, boolean) OWNER TO rchumacero;

--
-- TOC entry 223 (class 1255 OID 16577)
-- Dependencies: 5
-- Name: dblink_open(text, text, text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_open(text, text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


ALTER FUNCTION public.dblink_open(text, text, text) OWNER TO rchumacero;

--
-- TOC entry 224 (class 1255 OID 16578)
-- Dependencies: 5
-- Name: dblink_open(text, text, text, boolean); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_open(text, text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


ALTER FUNCTION public.dblink_open(text, text, text, boolean) OWNER TO rchumacero;

--
-- TOC entry 126 (class 1255 OID 16579)
-- Dependencies: 5
-- Name: dblink_send_query(text, text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION dblink_send_query(text, text) RETURNS integer
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_send_query';


ALTER FUNCTION public.dblink_send_query(text, text) OWNER TO rchumacero;

--
-- TOC entry 380 (class 1255 OID 1898547)
-- Dependencies: 5 2104 2104 2104
-- Name: difference(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION difference(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'difference';


ALTER FUNCTION public.difference(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 495 (class 1255 OID 1898672)
-- Dependencies: 5 2104
-- Name: dimension(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dimension(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dimension';


ALTER FUNCTION public.dimension(geometry) OWNER TO postgres;

--
-- TOC entry 666 (class 1255 OID 1898841)
-- Dependencies: 2435 5
-- Name: disablelongtransactions(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION disablelongtransactions() RETURNS text
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;

BEGIN

	--
	-- Drop all triggers applied by CheckAuth()
	--
	FOR rec IN
		SELECT c.relname, t.tgname, t.tgargs FROM pg_trigger t, pg_class c, pg_proc p
		WHERE p.proname = 'checkauthtrigger' and t.tgfoid = p.oid and t.tgrelid = c.oid
	LOOP
		EXECUTE 'DROP TRIGGER ' || quote_ident(rec.tgname) ||
			' ON ' || quote_ident(rec.relname);
	END LOOP;

	--
	-- Drop the authorization_table table
	--
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table' LOOP
		DROP TABLE authorization_table;
	END LOOP;

	--
	-- Drop the authorized_tables view
	--
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables' LOOP
		DROP VIEW authorized_tables;
	END LOOP;

	RETURN 'Long transactions support disabled';
END;
$$;


ALTER FUNCTION public.disablelongtransactions() OWNER TO postgres;

--
-- TOC entry 410 (class 1255 OID 1898590)
-- Dependencies: 5 2104 2104
-- Name: disjoint(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION disjoint(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'disjoint';


ALTER FUNCTION public.disjoint(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 950 (class 1255 OID 1898291)
-- Dependencies: 5 2104 2104
-- Name: distance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION distance(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_mindistance2d';


ALTER FUNCTION public.distance(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 948 (class 1255 OID 1898289)
-- Dependencies: 5 2104 2104
-- Name: distance_sphere(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION distance_sphere(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_distance_sphere';


ALTER FUNCTION public.distance_sphere(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 946 (class 1255 OID 1898287)
-- Dependencies: 5 2104 2104 2101
-- Name: distance_spheroid(geometry, geometry, spheroid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION distance_spheroid(geometry, geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_distance_ellipsoid';


ALTER FUNCTION public.distance_spheroid(geometry, geometry, spheroid) OWNER TO postgres;

--
-- TOC entry 894 (class 1255 OID 1898235)
-- Dependencies: 5 2104 2104
-- Name: dropbbox(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dropbbox(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dropBBOX';


ALTER FUNCTION public.dropbbox(geometry) OWNER TO postgres;

--
-- TOC entry 1099 (class 1255 OID 1898438)
-- Dependencies: 5 2435
-- Name: dropgeometrycolumn(character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dropgeometrycolumn(character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$;


ALTER FUNCTION public.dropgeometrycolumn(character varying, character varying) OWNER TO postgres;

--
-- TOC entry 1098 (class 1255 OID 1898437)
-- Dependencies: 5 2435
-- Name: dropgeometrycolumn(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dropgeometrycolumn(character varying, character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;


ALTER FUNCTION public.dropgeometrycolumn(character varying, character varying, character varying) OWNER TO postgres;

--
-- TOC entry 1097 (class 1255 OID 1898436)
-- Dependencies: 5 2435
-- Name: dropgeometrycolumn(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dropgeometrycolumn(character varying, character varying, character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	catalog_name alias for $1;
	schema_name alias for $2;
	table_name alias for $3;
	column_name alias for $4;
	myrec RECORD;
	okay boolean;
	real_schema name;

BEGIN


	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = 'f';

		FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := 't';
		END LOOP;

		IF ( okay <> 't' ) THEN
			RAISE NOTICE 'Invalid schema name - using current_schema()';
			SELECT current_schema() into real_schema;
		ELSE
			real_schema = schema_name;
		END IF;
	ELSE
		SELECT current_schema() into real_schema;
	END IF;

	-- Find out if the column is in the geometry_columns table
	okay = 'f';
	FOR myrec IN SELECT * from geometry_columns where f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := 't';
	END LOOP;
	IF (okay <> 't') THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
		RETURN 'f';
	END IF;

	-- Remove ref from geometry_columns table
	EXECUTE 'delete from geometry_columns where f_table_schema = ' ||
		quote_literal(real_schema) || ' and f_table_name = ' ||
		quote_literal(table_name)  || ' and f_geometry_column = ' ||
		quote_literal(column_name);

	-- Remove table column
	EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) || '.' ||
		quote_ident(table_name) || ' DROP COLUMN ' ||
		quote_ident(column_name);

	RETURN real_schema || '.' || table_name || '.' || column_name ||' effectively removed.';

END;
$_$;


ALTER FUNCTION public.dropgeometrycolumn(character varying, character varying, character varying, character varying) OWNER TO postgres;

--
-- TOC entry 1102 (class 1255 OID 1898441)
-- Dependencies: 5
-- Name: dropgeometrytable(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dropgeometrytable(character varying) RETURNS text
    LANGUAGE sql STRICT
    AS $_$ SELECT DropGeometryTable('','',$1) $_$;


ALTER FUNCTION public.dropgeometrytable(character varying) OWNER TO postgres;

--
-- TOC entry 1101 (class 1255 OID 1898440)
-- Dependencies: 5
-- Name: dropgeometrytable(character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dropgeometrytable(character varying, character varying) RETURNS text
    LANGUAGE sql STRICT
    AS $_$ SELECT DropGeometryTable('',$1,$2) $_$;


ALTER FUNCTION public.dropgeometrytable(character varying, character varying) OWNER TO postgres;

--
-- TOC entry 1100 (class 1255 OID 1898439)
-- Dependencies: 5 2435
-- Name: dropgeometrytable(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dropgeometrytable(character varying, character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	catalog_name alias for $1;
	schema_name alias for $2;
	table_name alias for $3;
	real_schema name;

BEGIN

	IF ( schema_name = '' ) THEN
		SELECT current_schema() into real_schema;
	ELSE
		real_schema = schema_name;
	END IF;

	-- Remove refs from geometry_columns table
	EXECUTE 'DELETE FROM geometry_columns WHERE ' ||
		'f_table_schema = ' || quote_literal(real_schema) ||
		' AND ' ||
		' f_table_name = ' || quote_literal(table_name);

	-- Remove table
	EXECUTE 'DROP TABLE '
		|| quote_ident(real_schema) || '.' ||
		quote_ident(table_name);

	RETURN
		real_schema || '.' ||
		table_name ||' dropped.';

END;
$_$;


ALTER FUNCTION public.dropgeometrytable(character varying, character varying, character varying) OWNER TO postgres;

--
-- TOC entry 1044 (class 1255 OID 1898387)
-- Dependencies: 5 2120 2104
-- Name: dump(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dump(geometry) RETURNS SETOF geometry_dump
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dump';


ALTER FUNCTION public.dump(geometry) OWNER TO postgres;

--
-- TOC entry 1046 (class 1255 OID 1898389)
-- Dependencies: 5 2120 2104
-- Name: dumprings(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dumprings(geometry) RETURNS SETOF geometry_dump
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dump_rings';


ALTER FUNCTION public.dumprings(geometry) OWNER TO postgres;

--
-- TOC entry 662 (class 1255 OID 1898839)
-- Dependencies: 5 2435
-- Name: enablelongtransactions(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION enablelongtransactions() RETURNS text
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	"query" text;
	exists bool;
	rec RECORD;

BEGIN

	exists = 'f';
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table'
	LOOP
		exists = 't';
	END LOOP;

	IF NOT exists
	THEN
		"query" = 'CREATE TABLE authorization_table (
			toid oid, -- table oid
			rid text, -- row id
			expires timestamp,
			authid text
		)';
		EXECUTE "query";
	END IF;

	exists = 'f';
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		exists = 't';
	END LOOP;

	IF NOT exists THEN
		"query" = 'CREATE VIEW authorized_tables AS ' ||
			'SELECT ' ||
			'n.nspname as schema, ' ||
			'c.relname as table, trim(' ||
			quote_literal(chr(92) || '000') ||
			' from t.tgargs) as id_column ' ||
			'FROM pg_trigger t, pg_class c, pg_proc p ' ||
			', pg_namespace n ' ||
			'WHERE p.proname = ' || quote_literal('checkauthtrigger') ||
			' AND c.relnamespace = n.oid' ||
			' AND t.tgfoid = p.oid and t.tgrelid = c.oid';
		EXECUTE "query";
	END IF;

	RETURN 'Long transactions support enabled';
END;
$$;


ALTER FUNCTION public.enablelongtransactions() OWNER TO postgres;

--
-- TOC entry 519 (class 1255 OID 1898696)
-- Dependencies: 5 2104 2104
-- Name: endpoint(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION endpoint(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_endpoint_linestring';


ALTER FUNCTION public.endpoint(geometry) OWNER TO postgres;

--
-- TOC entry 977 (class 1255 OID 1898318)
-- Dependencies: 5 2104 2104
-- Name: envelope(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION envelope(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_envelope';


ALTER FUNCTION public.envelope(geometry) OWNER TO postgres;

--
-- TOC entry 451 (class 1255 OID 1898628)
-- Dependencies: 5 2104 2104
-- Name: equals(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION equals(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geomequals';


ALTER FUNCTION public.equals(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1058 (class 1255 OID 1898405)
-- Dependencies: 5 2117
-- Name: estimated_extent(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION estimated_extent(text, text) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT SECURITY DEFINER
    AS '$libdir/postgis-1.5', 'LWGEOM_estimated_extent';


ALTER FUNCTION public.estimated_extent(text, text) OWNER TO postgres;

--
-- TOC entry 1056 (class 1255 OID 1898403)
-- Dependencies: 5 2117
-- Name: estimated_extent(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION estimated_extent(text, text, text) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT SECURITY DEFINER
    AS '$libdir/postgis-1.5', 'LWGEOM_estimated_extent';


ALTER FUNCTION public.estimated_extent(text, text, text) OWNER TO postgres;

--
-- TOC entry 127 (class 1255 OID 16580)
-- Dependencies: 5 2436
-- Name: existe_archivo(text); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION existe_archivo(archivo text) RETURNS boolean
    LANGUAGE plpythonu
    AS $$
    import os
    return os.path.exists(archivo)
$$;


ALTER FUNCTION public.existe_archivo(archivo text) OWNER TO rchumacero;

--
-- TOC entry 971 (class 1255 OID 1898312)
-- Dependencies: 5 2107 2107
-- Name: expand(box3d, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION expand(box3d, double precision) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_expand';


ALTER FUNCTION public.expand(box3d, double precision) OWNER TO postgres;

--
-- TOC entry 973 (class 1255 OID 1898314)
-- Dependencies: 5 2117 2117
-- Name: expand(box2d, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION expand(box2d, double precision) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_expand';


ALTER FUNCTION public.expand(box2d, double precision) OWNER TO postgres;

--
-- TOC entry 975 (class 1255 OID 1898316)
-- Dependencies: 5 2104 2104
-- Name: expand(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION expand(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_expand';


ALTER FUNCTION public.expand(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 497 (class 1255 OID 1898674)
-- Dependencies: 5 2104 2104
-- Name: exteriorring(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION exteriorring(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_exteriorring_polygon';


ALTER FUNCTION public.exteriorring(geometry) OWNER TO postgres;

--
-- TOC entry 128 (class 1255 OID 16581)
-- Dependencies: 5 2435
-- Name: f1(); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f1() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
a integer;
v_mensaje_error text;
v_resp varchar[];
v_nombre_funcion varchar;
v_msg varchar;
BEGIN
v_nombre_funcion='public.f1';
raise exception 'error forzado';
  a= 5/0;
  return a::varchar;
EXCEPTION
WHEN OTHERS THEN
	v_msg = f_agrega_clave(v_msg,'mensaje',SQLERRM);	
  	v_msg = f_agrega_clave(v_msg,'codigo_error',SQLSTATE);
  	v_msg = f_agrega_clave(v_msg,'procedimientos',v_nombre_funcion);
  	raise exception '%',v_msg; 
END;
$$;


ALTER FUNCTION public.f1() OWNER TO rchumacero;

--
-- TOC entry 1266 (class 1255 OID 16582)
-- Dependencies: 5 2435
-- Name: f_agrega_clave(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_agrega_clave(p_cad character varying, p_clave character varying, p_valor character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_agrega_clave
 DESCRIPCION:   Anade un parametro de respuesta a la cadena que se va a devolver al servidor
                Web
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE
v_cad_ini varchar;
    v_cad_fin varchar;
    v_cad_ini_fin varchar;
    v_cad_fin_fin varchar;
    v_resp varchar;
    v_cadena varchar;
    v_aux varchar;
    v_clave varchar;
    v_valor varchar;
BEGIN

--RCM: 22/03/2011 Verifica los parámetros para prevenir que vengan nulos. Si es así se hace un coalesce para evitar problemas en concatenación
    v_clave = COALESCE(p_clave,'indefinido');
    v_valor = COALESCE(p_valor,'');
    
    --Para hacer el trim se verifica que no sea cadena vacía porque hay un bug que al aplicar trim sobre la cadena vacía aparentemente lo vuelve null
    if v_valor != '' then
        v_valor = trim(p_valor);
    end if;


--Inicialización de constantes
v_cad_ini = '<';
    v_cad_fin = '>';
    v_cad_ini_fin = '</'||v_clave;
    v_cad_fin_fin = '>';
    
    /*v_cad_ini = '';
    v_cad_fin = ':';
    v_cad_ini_fin = '';
    v_cad_fin_fin = ',';*/
    
    --Se vacía la cadena en variables locales
    v_cadena=COALESCE(p_cad,'');

    --Verifica si la clave es mensaje y si ya fue serializada para no volver a serializar
    if v_clave = 'mensaje' then
    --raise notice 'substr: %     v_cad_ini: %  v_valor: %',substr(ltrim(v_cadena),1,1),v_cad_ini,v_valor;
     if substr(ltrim(v_valor),1,1) = v_cad_ini then
         return v_valor;
        end if;
    end if;
    
    --Verifica si ya esta registrado el 'codigo_error'
    if v_clave = 'codigo_error' then
     if f_obtiene_clave_valor(v_cadena,v_clave,'','','valor') <> '' then
         return p_cad;
        end if;
    end if;
    
    --Verifica si ya se registro el codigo procedimiento
    if v_clave = 'procedimientos' then
     if f_obtiene_clave_valor(v_cadena,v_clave,'','','valor') <> '' then
         v_aux =f_obtiene_clave_valor(v_cadena,v_clave,v_valor,'unir','');
         return v_aux;
        end if;
    end if;
    
    --Arma la rama
    v_aux = v_cad_ini || v_clave ||v_cad_fin || replace(v_valor,'"','') || v_cad_ini_fin || v_cad_fin_fin;
    
    --Agregar la rama
    v_cadena = v_cadena || v_aux;
    --Devolver respuesta    
    return v_cadena;
  
END;
$$;


ALTER FUNCTION public.f_agrega_clave(p_cad character varying, p_clave character varying, p_valor character varying) OWNER TO rchumacero;

--
-- TOC entry 130 (class 1255 OID 16583)
-- Dependencies: 5 2435
-- Name: f_agrega_clave_multiple(character varying, character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_agrega_clave_multiple(p_cad character varying, p_claves character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_agrega_clave_multiple
 DESCRIPCION:   Anade varios parametros de respuesta a la cadena que se va a devolver al servidor
                Web
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE
	v_cad_ini varchar;
    v_cad_fin varchar;
    v_cad_ini_fin varchar;
    v_cad_fin_fin varchar;
    v_resp varchar;
    v_cadena varchar;
    v_aux varchar;
    v_claves varchar;
    v_sw boolean;
    v_pos_ini integer;
    v_pos_fin integer;
    v_clave varchar;
    v_pos_aux integer;
BEGIN
	--Inicializa variables
	v_cad_ini = '<';
	v_cad_fin = '>';
	v_cad_ini_fin = '</';
	v_cad_fin_fin = '>';
	v_sw=true;

	--Inicializa la cadena
	v_cadena = p_cad;
	v_claves = p_claves;
	--raise exception 'HOLA: %',v_claves;

	--Recorre todas las claves 
	LOOP
		if substr(ltrim(v_claves),1,1) = v_cad_ini then
			v_pos_ini=1;
			--Ubica el primer v_cad_fin
			v_pos_fin=position(v_cad_fin in v_claves);
			--Obtiene la cadena entre v_cad_ini y v_cad_fin
			v_clave = substr(v_claves,v_pos_ini+1,v_pos_fin-v_pos_ini-1);
			--raise exception 'FFF:%',v_clave;
			--Obtiene el valor de la clave
			v_cadena = f_agrega_clave(v_cadena,v_clave,f_obtiene_clave_valor(p_claves,v_clave,'','','valor'));
			--Corta la cadena de claves
			v_aux=v_cad_ini_fin||v_clave||v_cad_fin_fin;
			v_pos_aux = position(v_aux in v_claves);
			--raise exception '%',v_pos_aux;
			
			v_claves = substr(v_claves,v_pos_aux+length(v_aux),length(v_claves));
			--raise exception '%',v_claves;
		else
			exit;
		end if;

	END LOOP;
    --Devolver respuesta    
    return v_cadena;
  
END;
$$;


ALTER FUNCTION public.f_agrega_clave_multiple(p_cad character varying, p_claves character varying) OWNER TO rchumacero;

--
-- TOC entry 129 (class 1255 OID 16584)
-- Dependencies: 5 2435
-- Name: f_array_p(character varying[]); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_array_p(p_array character varying[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

	i integer;
    j integer;

BEGIN
--j=array_length(p_array);
 for i in 1..array_upper(p_array,1) loop
 	raise notice '%', p_array[i];
 end loop;
return 'bien';
END;
$$;


ALTER FUNCTION public.f_array_p(p_array character varying[]) OWNER TO rchumacero;

--
-- TOC entry 286 (class 1255 OID 16585)
-- Dependencies: 5 2435
-- Name: f_array_ubicar_clave(character varying[], character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_array_ubicar_clave(p_array character varying[], p_clave character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_ubicar_clave
 DESCRIPCION:   
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE
	i integer;
  	v_valor varchar;
  	v_array varchar[];
    v_tam integer;
BEGIN
	v_valor='_false';
    v_array=p_array;
    v_tam=COALESCE(array_upper(p_array,1),0);
    
	for i in 1..v_tam loop
       	if p_array[i][1]=p_clave then
        	v_valor=p_array[i][2];
            return v_valor;
        end if;
    end loop;
	return v_valor;
/*EXCEPTION
WHEN OTHERS THEN
  return '_false';*/
END;
$$;


ALTER FUNCTION public.f_array_ubicar_clave(p_array character varying[], p_clave character varying) OWNER TO rchumacero;

--
-- TOC entry 131 (class 1255 OID 16586)
-- Dependencies: 5 2435
-- Name: f_array_ubicar_clave_posicion(character varying[], character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_array_ubicar_clave_posicion(p_array character varying[], p_clave character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_ubicar_clave_posicion
 DESCRIPCION:
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE
	i integer;
  	v_valor integer;
  	v_array varchar[];
    v_tam integer;
BEGIN
	v_valor=-1;
    v_array=p_array;
    v_tam=COALESCE(array_upper(p_array,1),0);
    
	for i in 1..v_tam loop
       	if p_array[i][1]=p_clave then
        	v_valor=i;
            return v_valor;
        end if;
    end loop;
	return v_valor;
/*EXCEPTION
WHEN OTHERS THEN
  return '_false';*/
END;
$$;


ALTER FUNCTION public.f_array_ubicar_clave_posicion(p_array character varying[], p_clave character varying) OWNER TO rchumacero;

--
-- TOC entry 244 (class 1255 OID 22709)
-- Dependencies: 5 2435
-- Name: f_campo_constraint(text, integer); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_campo_constraint(descripcion text, tipo integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
  inicio	integer;
  fin 		integer;
  cadena	text;
BEGIN
  if(tipo=1)then	
  inicio=strpos(descripcion,'REFERENCES');
  cadena=SUBSTRING(descripcion,inicio);
  inicio=strpos(cadena,'(');
  fin=strpos(cadena,')');
  cadena=SUBSTRING(cadena,inicio+1,fin-inicio-1);
  return cadena;
  elsif(tipo=0)then
  inicio=strpos(descripcion,'REFERENCES');
  cadena=SUBSTRING(descripcion,inicio);
  inicio=strpos(cadena,'.');
  fin=strpos(cadena,'(');
  cadena=SUBSTRING(cadena,inicio+1,fin-inicio-1);
  return cadena;
  else
  inicio=strpos(descripcion,'(');
  fin=strpos(descripcion,')');
  cadena=SUBSTRING(descripcion,inicio+1,fin-inicio-1);
  --raise notice '%',descripcion;
  return cadena;
  end if;
END;
$$;


ALTER FUNCTION public.f_campo_constraint(descripcion text, tipo integer) OWNER TO rchumacero;

--
-- TOC entry 274 (class 1255 OID 1475434)
-- Dependencies: 5 2435
-- Name: f_convertir_num_a_letra(numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION f_convertir_num_a_letra(par_numero numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 documento: 	public.f_convertir_num_a_letra
 DESCRIPCION:   Funcion que convierte un numero a letra
 AUTOR: 	    KPLIAN	
 FECHA:	        06/06/2011
 COMENTARIOS:	
***************************************************************************/

declare

       ptotal  numeric;

       total numeric;
       total1 numeric;
       cent2  numeric;
       cent   numeric;
       cent1  char(2);
       mil    numeric;
       millon numeric;
       millones numeric;
       sav    numeric;
       unit   numeric;
       deci   numeric;
       centi  numeric;
       factor numeric;
       sav1   numeric;
       depesos numeric;
       lletra  varchar;
       letras varchar;

       begin
            ptotal:=par_numero;
            total := ptotal;

            total1:= total;
            total := trunc(total);
            cent2 := total1 - total;
            cent  := cent2*100;
            cent1 := '0';

                  if (total=0) then
                     lletra := 'CERO';
                     cent1:=cast(cent as char(2));
                     return 'CERO  ,'||cent1||'/100 ';
                  end if;

                  mil:=0;
                  millon:=0;
                  millones:=0;
                  depesos:=0;
                  sav:=1;
                  unit:=1;
                  deci:=1;
                  centi:=1;
                  factor:=1;
                  sav1:=1;
                  letras:='';

                            while (total > 0) loop
                                if (total > 1999999) then
                                   depesos  := 1;
                                   factor   := 1000000;
                                   millones := 1;
                                   millon   := 0;
                                else
                                   if (total > 999999) then
                                      depesos := 1;
                                      factor  := 1000000;
                                      millon  := 1;
                                   else
                                       if (total > 999) then
                                          factor := 1000;
                                          mil    := 1;
                                       else
                                          factor := 1;
                                          mil := 0;
                                       end if;
                                   end if;
                                end if;

                                sav := total;

                                total := trunc(total/factor);
                                sav  := sav-(total*factor);
                                if (sav=0) then
                                   depesos := 0;
                                end if;

                                centi:=TRUNC(total/100);

                                if centi = 0 then
                                   letras := rtrim(letras)||'';
                                end if;
                                if centi = 1 then
                                   if total = 100 then
                                      letras := rtrim(letras)|| ' CIEN';
                                   else
                                       letras := rtrim(letras)||' CIENTO';
                                   end if;
                                end if;
                                if centi = 2 then
                                   letras := rtrim(letras)||' DOSCIENTOS';
                                end if;
                                if centi = 3 then
                                   letras := rtrim(letras)||' TRESCIENTOS';
                                end if;
                                if centi = 4 then
                                   letras := rtrim(letras)||' CUATROCIENTOS';
                                end if;
                                if centi = 5 then
                                   letras := rtrim(letras)||' QUINIENTOS';
                                end if;
                                if centi = 6 then
                                   letras := rtrim(letras)||' SEISCIENTOS';
                                end if;
                                if centi = 7 then
                                   letras := rtrim(letras)||' SETECIENTOS';
                                end if;
                                if centi = 8 then
                                   letras := rtrim(letras)||' OCHOCIENTOS';
                                end if;
                                if centi = 9 then
                                   letras := rtrim(letras)||' NOVECIENTOS';
                                end if;

                                total:=total - (centi*100);
                                deci :=trunc(total/10);
                                unit :=total-(deci*10);

                                if total >= 30 then
                                   if deci = 3 then
                                      letras := rtrim(letras)||' TREINTA';
                                   end if;
                                   if deci = 4 then
                                      letras := rtrim(letras)||' CUARENTA';
                                   end if;
                                   if deci = 5 then
                                      letras := rtrim(letras)||' CINCUENTA';
                                   end if;
                                   if deci = 6 then
                                      letras := rtrim(letras)||' SESENTA';
                                   end if;
                                   if deci = 7 then
                                      letras := rtrim(letras)||' SETENTA';
                                   end if;
                                   if deci = 8 then
                                      letras := rtrim(letras)||' OCHENTA';
                                   end if;
                                   if deci = 9 then
                                      letras := rtrim(letras)||' NOVENTA';
                                   end if;
                                   if unit > 0 then
                                      letras := rtrim(letras)||' Y';
                                   end if;
                                else
                                    unit := total;
                                end if;

                                if unit = 0 then
                                   letras := rtrim(letras)||'';
                                end if;
                                if unit = 1 then
                                   letras := rtrim(letras)||' UN';
                                end if;
                                if unit = 2 then
                                   letras := rtrim(letras)||' DOS';
                                end if;
                                if unit = 3 then
                                   letras := rtrim(letras)||' TRES';
                                end if;
                                if unit = 4 then
                                   letras := rtrim(letras)||' CUATRO';
                                end if;
                                if unit = 5 then
                                   letras := rtrim(letras)||' CINCO';
                                end if;
                                if unit = 6 then
                                   letras := rtrim(letras)||' SEIS';
                                end if;
                                if unit = 7 then
                                   letras := rtrim(letras)||' SIETE';
                                end if;
                                if unit = 8 then
                                   letras := rtrim(letras)||' OCHO';
                                end if;
                                if unit = 9 then
                                   letras := rtrim(letras)||' NUEVE';
                                end if;
                                if unit = 10 then
                                   letras := rtrim(letras)||' DIEZ';
                                end if;
                                if unit = 11 then
                                   letras := rtrim(letras)||' ONCE';
                                end if;
                                if unit = 12 then
                                   letras := rtrim(letras)||' DOCE';
                                end if;
                                if unit = 13 then
                                   letras := rtrim(letras)||' TRECE';
                                end if;
                                if unit = 14 then
                                   letras := rtrim(letras)||' CATORCE';
                                end if;
                                if unit = 15 then
                                   letras := rtrim(letras)||' QUINCE';
                                end if;
                                if unit = 16 then
                                   letras := rtrim(letras)||' DIECISEIS';
                                end if;
                                if unit = 17 then
                                   letras := rtrim(letras)||' DIECISIETE';
                                end if;
                                if unit = 18 then
                                   letras := rtrim(letras)||' DIECIOCHO';
                                end if;
                                if unit = 19 then
                                   letras := rtrim(letras)||' DIECINUEVE';
                                end if;
                                if unit = 20 then
                                   letras := rtrim(letras)||' VEINTE';
                                end if;
                                if unit = 21 then
                                   letras := rtrim(letras)||' VEINTIUNO';
                                end if;
                                if unit = 22 then
                                   letras := rtrim(letras)||' VEINTIDOS';
                                end if;
                                if unit = 23 then
                                   letras := rtrim(letras)||' VEINTITRES';
                                end if;
                                if unit = 24 then
                                   letras := rtrim(letras)||' VEINTICUATRO';
                                end if;
                                if unit = 25 then
                                   letras := rtrim(letras)||' VEINTICINCO';
                                end if;
                                if unit = 26 then
                                   letras := rtrim(letras)||' VEINTISEIS';
                                end if;
                                if unit = 27 then
                                   letras := rtrim(letras)||' VEINTISIETE';
                                end if;
                                if unit = 28 then
                                   letras := rtrim(letras)||' VEINTIOCHO';
                                end if;
                                if unit = 29 then
                                   letras := rtrim(letras)||' VEINTINUEVE';
                                end if;
                                if millones=1 then
                                   letras := rtrim(letras)||' MILLONES';
                                   millones := 0;
                                else
                                    if millon=1 then
                                       letras := rtrim(letras)||' MILLON';
                                       millon := 0;
                                    else
                                        if mil=1 then
                                           letras := rtrim(letras)||' MIL';
                                           mil := 0;
                                        end if;
                                    end if;
                                end if;
                                total:=sav;
  end loop;

  if cent=0 then
     cent1:='00';
  else
     if cent <10
     THEN
     raise notice '%',cent;
     cent1:= '0'||cast(cent as char(1));
	ELSE
     cent1:=cast(cent as char(2));
     END IF;
  end if;
  if depesos=1 then
     letras := rtrim(letras)||' ,'||cent1||'/100 ';
  else
     letras := rtrim(letras)||' ,'||cent1||'/100 ';
  end if;

--  lletra := '('||ltrim(letras)||')';
    lletra := ltrim(letras);

return lletra;
end
$$;


ALTER FUNCTION public.f_convertir_num_a_letra(par_numero numeric) OWNER TO postgres;

--
-- TOC entry 434 (class 1255 OID 1603896)
-- Dependencies: 5 2435
-- Name: f_copy(character varying, character varying); Type: FUNCTION; Schema: public; Owner: mflores
--

CREATE FUNCTION f_copy(pm_nombre_tabla character varying, pm_ruta_archivo character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  g_respuesta	varchar;
BEGIN
     EXECUTE ('COPY '||pm_nombre_tabla||' FROM '''||pm_ruta_archivo||''' DELIMITER '','';'); 
     g_respuesta='si';
     RETURN g_respuesta;
END;
$$;


ALTER FUNCTION public.f_copy(pm_nombre_tabla character varying, pm_ruta_archivo character varying) OWNER TO mflores;

--
-- TOC entry 1306 (class 1255 OID 3327008)
-- Dependencies: 5 2435
-- Name: f_dblink(character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: mzambrana
--

CREATE FUNCTION f_dblink(p_host character varying, p_puerto character varying, p_dbname character varying, p_user character varying, p_password character varying, p_sql character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA ENDESIS 
***************************************************************************
 SCRIPT: 		f_dblink
 DESCRIPCIÓN: 	Permite ejecutar una instrucción sql en otro servidor de base de datos con dblink
 AUTOR: 		RCM
 FECHA:			23/03/2012
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/
--------------------------
-- CUERPO DE LA FUNCIÓN --
--------------------------


--**** DECLARACION DE VARIABLES DE LA FUNCIÓN (LOCALES) ****---
DECLARE

	v_respuesta varchar;
    v_cadena_cnx varchar;

BEGIN

	--Verifica que los parámetros enviados ninguno sea nulo
    if coalesce(p_host,'')='' or coalesce(p_puerto,'')='' or coalesce(p_dbname,'')='' or coalesce(p_password,'')='' or coalesce(p_sql,'')='' then
    	raise exception 'No se puede realizar la conexión con el host destino: parámetros inválidos, ningún parámetro debe ser nulo o vacío';
    end if;
    
	--Forma la cadena de conexión
    v_cadena_cnx = 'hostaddr='||p_host||' port='||p_puerto||' dbname='||p_dbname||' user='||p_user||' password='||p_password;
      -- raise exception 'cadena%',p_sql;
    --Ejecuta el dblink
    v_respuesta = dblink_exec(v_cadena_cnx,p_sql);
     
	--Devuelve la respuesta
    return v_respuesta;    

END;
$$;


ALTER FUNCTION public.f_dblink(p_host character varying, p_puerto character varying, p_dbname character varying, p_user character varying, p_password character varying, p_sql character varying) OWNER TO mzambrana;

--
-- TOC entry 1176 (class 1255 OID 16587)
-- Dependencies: 5 2435
-- Name: f_ejecutar_dblink(character varying, character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_ejecutar_dblink(p_cadena character varying, p_opcion character varying) RETURNS record
    LANGUAGE plpgsql STRICT SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: public.f_ejecutar_dblink
 DESCRIPCIÓN: Guarda la sesion o el log mediante un dblink, la cadena
                indica los parametros que se van a guardar
 AUTOR:         KPLIAN(jrr)
 FECHA:
 COMENTARIOS:


***************************************************************************
 HISTORIA DE MODIFICACIONES:
 DESCRIPCION: se vuelve dinámico el usuario de base de datos con el que se conecta el dblink (linea 31 a la 34)
 AUTOR: KPLIAN(rcm)
 FECHA: 24-03-2011
***************************************************************************
*/

DECLARE
    v_resp      record;
    v_res_cone  varchar;
    v_database  varchar;
    v_respuesta varchar;
    v_nombre_funcion   text;
    v_mensaje_error    text;
    v_usr_bd 		varchar;
BEGIN
    v_nombre_funcion='f_ejecutar_dblink';
    v_database=current_database();
    v_usr_bd=v_database||'_conexion';
    --RCM 24-03-2011: modificación a usuario de bd dinámico
    --v_res_cone=(select dblink_connect('user=bdweb_conexion dbname='||v_database));
    v_res_cone=(select dblink_connect('user=' || v_usr_bd ||' dbname='||v_database));
    --FIN RCM

    if(p_opcion='log')then
        SELECT * FROM
            dblink(
                'select * from f_registrar_log'||p_cadena,true)
            AS t1(id_log integer)
            into v_resp;
         
        v_res_cone=(select dblink_disconnect());
    elsif(p_opcion='sesion')then
        SELECT * FROM
            dblink(
                'select * from segu.f_actualizar_sesion'||p_cadena,true)
            AS t1(res varchar)
            into v_resp;
        
        v_res_cone=(select dblink_disconnect());
    end if;
    return v_resp;
EXCEPTION

      WHEN OTHERS THEN
      
    	v_respuesta = '';
		v_respuesta = f_agrega_clave(v_respuesta,'mensaje',SQLERRM);
    	v_respuesta = f_agrega_clave(v_respuesta,'codigo_error',SQLSTATE);
  		v_respuesta = f_agrega_clave(v_respuesta,'tipo_respuesta','ERROR'::varchar);
        v_respuesta = f_agrega_clave(v_respuesta,'procedimientos',v_nombre_funcion);

        --raise exception '%',v_respuesta;
        
        --RCM 31/01/2012: Cuando la llamada a esta funcion devuelve error, el manejador de excepciones de esa función da el resultado,
        --por lo que se modifica para que devuelva un json direcamente
		raise exception '%',f_resp_to_json(v_respuesta);
      
END;
$$;


ALTER FUNCTION public.f_ejecutar_dblink(p_cadena character varying, p_opcion character varying) OWNER TO rchumacero;

--
-- TOC entry 988 (class 1255 OID 1687923)
-- Dependencies: 5 2435
-- Name: f_excel(bytea, character varying, character varying[]); Type: FUNCTION; Schema: public; Owner: rac
--

CREATE FUNCTION f_excel(archivo bytea, tabla character varying, titulo character varying[]) RETURNS SETOF text[]
    LANGUAGE plpgsql
    AS $$
DECLARE
  cant_filas	integer; 	--la cantidad de filas del Excel original
  cant_cols		integer; 	--la cantidad de columnas del Excel original
  filas_titulo	integer;
  cols_titulo	integer;
  vector		text[]; 	--contiene las filas del excel
  registros		text[]; 	--contiene una fila de excel separada por comas
  fila			text[];
  i				numeric;	--indice del for para las filas
  j				numeric;	--indice del for para las columnas
  k				numeric;
  aux			text;		-- bytea sin codificacion
  v_consulta	varchar;	--consulta insert
  
BEGIN
 	
    aux := (select decode(archivo::text,'base64')); --se obtiene el bytea y se quita la codificación
        
    vector := string_to_array(aux,'\\015\\012'); --descomponer el bytea en un vector que contenga una fila del CSV cada uno
    											 --\\015\\012 --> ENTER o salto de linea/retorno de carro en el bytea	
	
    fila := string_to_array(vector[1],';');
    select array_upper(fila,1) into cols_titulo;
    
    for k in 1..cols_titulo loop
    	if(titulo[k] <> fila[k]) then
        	raise exception 'El orden de las columnas en el archivo CSV es incorrecto, utilice la Plantilla por favor';
        end if;
    end loop;
    
    select array_upper(vector,1) into cant_filas; --cantidad de registros del CSV
    
    for i in 2..(cant_filas-1) loop
      	
        v_consulta := 'insert into '||tabla||' values ('; --inicio de la consulta del insert

        registros := string_to_array(vector[i],';'); --descomponer cada fila para obtener las columnas del CSV
        select array_upper(registros,1) into cant_cols; --cantidad de columnas del CSV
        
        for j in 1..(cant_cols-1) loop
                        
            registros[j] := (select replace(registros[j]::text,',','.')); --reemplazar las comas por puntos
            v_consulta := v_consulta ||''''|| registros[j] || ''','; --continuar con la insercion hasta la columna N-1
                 	
        end loop;  
        
        v_consulta := v_consulta ||''''||  registros[cant_cols] || ''');'; --insertar la ultima columna 
        execute v_consulta; --ejecutar el insert
        
    end loop;
    
    return;
        
END;
$$;


ALTER FUNCTION public.f_excel(archivo bytea, tabla character varying, titulo character varying[]) OWNER TO rac;

--
-- TOC entry 1189 (class 1255 OID 1475435)
-- Dependencies: 5 2435
-- Name: f_existe_parametro(character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION f_existe_parametro(p_tabla character varying, p_parametro character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_existe_parametro
 DESCRIPCION:   devuelve true si existe el parametro en la tabla indicada y false si no existe
                Web
 AUTOR: 	    KPLIAN (jrr)	
 FECHA:	        09/08/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
 
 
 DECLARE
    v_nombre_funcion   	text;
    v_resp              varchar;
    v_respuesta         boolean;
 BEGIN
    v_nombre_funcion:='public.f_existe_parametro';
    v_respuesta=false;
    
    if(exists ( select 1
                from pg_class c
                inner join pg_catalog.pg_attribute a
                    on c.oid = a.attrelid
                where c.relname=p_tabla and a.attname ilike p_parametro))then
                
        v_respuesta=true;
    end if;
    
    return v_respuesta;
    
 EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION public.f_existe_parametro(p_tabla character varying, p_parametro character varying) OWNER TO postgres;

--
-- TOC entry 133 (class 1255 OID 16588)
-- Dependencies: 5 2435
-- Name: f_get_mensaje_err(character varying, text, text, character varying, character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_get_mensaje_err(par_codigo_sql character varying, par_mensaje text, par_funcion text, par_transaccion character varying, par_linea character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_get_mensaje_err
 DESCRIPCION:
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
declare
       v_separador_error     varchar;
       v_separador_inicial   varchar;
       v_separador_funcion   varchar;
       v_mensaje_nuevo       text;

begin

     select valor into v_separador_inicial from public.variable_global vg where vg.variable='separador_inicial';
     select valor into v_separador_error from public.variable_global vg where vg.variable='separador_error';
     
     select valor into v_separador_funcion from public.variable_global vg where vg.variable='separador_funcion';

     if(split_part(par_mensaje,v_separador_error,3) ='')then

         v_mensaje_nuevo:=(v_separador_inicial||'f'||v_separador_error||par_codigo_sql||v_separador_error||coalesce(par_mensaje,' ')||v_separador_error||par_funcion)::text;
         --raise exception 'entra%',par_funcion;
         if(par_transaccion is not null)then
            v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_transaccion)::text;
         end if;
         if(par_linea is not null)then
            v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_linea)::text;
         end if;
     
     else
         v_mensaje_nuevo:=(coalesce(par_mensaje,'')||v_separador_funcion||par_funcion)::text;
         if(par_transaccion is not null)then
            v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_transaccion)::text;
         end if;
         if(par_linea is not null)then
            v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_linea)::text;
         end if;
     end if;

     return v_mensaje_nuevo;



end;
$$;


ALTER FUNCTION public.f_get_mensaje_err(par_codigo_sql character varying, par_mensaje text, par_funcion text, par_transaccion character varying, par_linea character varying) OWNER TO rchumacero;

--
-- TOC entry 134 (class 1255 OID 16589)
-- Dependencies: 5 2435
-- Name: f_get_mensaje_err2(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_get_mensaje_err2(p_procedimientos character varying, p_codigo_error character varying, p_mensaje_error character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_get_mensaje_err2
 DESCRIPCION:
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
declare
       v_separador_error     varchar;
       v_separador_inicial   varchar;
       v_separador_funcion   varchar;
       v_mensaje_nuevo       text;

begin

     select valor into v_separador_inicial from public.variable_global vg where vg.variable='separador_inicial';
     select valor into v_separador_error from public.variable_global vg where vg.variable='separador_error';
     
     select valor into v_separador_funcion from public.variable_global vg where vg.variable='separador_funcion';

     /*if(split_part(par_mensaje,v_separador_error,3) ='')then

         v_mensaje_nuevo:=(v_separador_inicial||'f'||v_separador_error||par_codigo_sql||v_separador_error||coalesce(par_mensaje,' ')||v_separador_error||par_funcion)::text;
         --raise exception 'entra%',par_funcion;
         if(par_transaccion is not null)then
            v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_transaccion)::text;
         end if;
         if(par_linea is not null)then
            v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_linea)::text;
         end if;
     
     else
         v_mensaje_nuevo:=(coalesce(par_mensaje,'')||v_separador_funcion||par_funcion)::text;
         if(par_transaccion is not null)then
            v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_transaccion)::text;
         end if;
         if(par_linea is not null)then
            v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_linea)::text;
         end if;
     end if;*/
     
     
     v_mensaje_nuevo = p_procedimientos || v_separador_error || p_codigo_error || v_separador_error || p_mensaje_error;

     return v_mensaje_nuevo;



end;
$$;


ALTER FUNCTION public.f_get_mensaje_err2(p_procedimientos character varying, p_codigo_error character varying, p_mensaje_error character varying) OWNER TO rchumacero;

--
-- TOC entry 287 (class 1255 OID 16590)
-- Dependencies: 5 2435
-- Name: f_get_mensaje_exi(text, text, character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_get_mensaje_exi(par_mensaje text, par_funcion text, par_transaccion character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_get_mensaje_exi
 DESCRIPCION:
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
declare
       v_separador_error     varchar;
       v_separador_inicial   varchar;
       v_separador_funcion   varchar;
       v_mensaje_nuevo       text;

begin
     select valor into v_separador_inicial from public.variable_global vg where vg.variable='separador_inicial';
     select valor into v_separador_error from public.variable_global vg where vg.variable='separador_error';

     select valor into v_separador_funcion from public.variable_global vg where vg.variable='separador_funcion';

     v_mensaje_nuevo:=(v_separador_inicial||'t'||v_separador_error||'0'||v_separador_error||coalesce(par_mensaje,'')||v_separador_error||par_funcion)::text;
     if(par_transaccion is not null)then
         v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_transaccion)::text;
     end if;
     
    return v_mensaje_nuevo;



end;
$$;


ALTER FUNCTION public.f_get_mensaje_exi(par_mensaje text, par_funcion text, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1216 (class 1255 OID 3273723)
-- Dependencies: 5 2435
-- Name: f_get_parametro(character varying, character varying); Type: FUNCTION; Schema: public; Owner: rac
--

CREATE FUNCTION f_get_parametro(p_tabla character varying, p_parametro character varying) RETURNS character varying
    LANGUAGE plpgsql COST 16
    AS $$
/**************************************************************************
 FUNCION: 		public.f_get_parametro
 DESCRIPCION:   devuelve el en varchar del parametros si existe
 				
                Web
 AUTOR: 	    KPLIAN (rac)	
 FECHA:	        09/08/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
 
 
 DECLARE
    v_nombre_funcion   	text;
    v_resp              varchar;
    v_respuesta         varchar;
    v_record record;
    v_consulta varchar;
 BEGIN
    v_nombre_funcion:='public.f_get_parametro';
    v_respuesta='NULL';
    
  v_consulta='select ('||p_parametro||')::varchar as resp  from '||p_tabla||' limit 1';
  
  raise notice 'get_parametro %',v_consulta;
                
      FOR  v_record in execute(v_consulta) LOOP
        
        v_respuesta = (v_record.resp);
        
      END LOOP;

   
    
    return coalesce(v_respuesta,'NULL');
    
    
 EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION public.f_get_parametro(p_tabla character varying, p_parametro character varying) OWNER TO rac;

--
-- TOC entry 1137 (class 1255 OID 3280921)
-- Dependencies: 2435 5
-- Name: f_get_parametro_by_id(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: rac
--

CREATE FUNCTION f_get_parametro_by_id(p_tabla character varying, p_parametro character varying, p_id character varying) RETURNS character varying
    LANGUAGE plpgsql COST 16
    AS $$
/**************************************************************************
 FUNCION: 		public.f_get_parametro_by_id
 DESCRIPCION:   devuelve el en varchar del parametros si existe
 				
                Web
 AUTOR: 	    KPLIAN (rac)	
 FECHA:	        09/08/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
 
 
 DECLARE
    v_nombre_funcion   	text;
    v_resp              varchar;
    v_respuesta         varchar;
    v_record record;
    v_consulta varchar;
 BEGIN
    v_nombre_funcion:='public.f_get_parametro_by_id';
    v_respuesta='NULL';
    
  v_consulta='select ('||p_parametro||')::varchar as resp  from '||p_tabla||' WHERE '||p_id;
  
  raise notice 'get_parametro %',v_consulta;
                
      FOR  v_record in execute(v_consulta) LOOP
        
        v_respuesta = (v_record.resp);
        
      END LOOP;

   
    
    return coalesce(v_respuesta,'NULL');
    
    
 EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION public.f_get_parametro_by_id(p_tabla character varying, p_parametro character varying, p_id character varying) OWNER TO rac;

--
-- TOC entry 135 (class 1255 OID 16591)
-- Dependencies: 5 2435
-- Name: f_get_record(character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_get_record(tabla character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_get_record
 DESCRIPCION:   Obtiene el record de la tabla temporal insertada en la funcion
                DBIntermediario
 AUTOR: 	    KPLIAN (jrr)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE

v_parametros                record;
v_consulta                  varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

BEGIN
     v_nombre_funcion:='public.f_get_record';

    v_consulta:= 'select * from '||tabla||' limit 1';
    
    execute v_consulta into v_parametros;
    return v_parametros;
    
EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;

END;
$$;


ALTER FUNCTION public.f_get_record(tabla character varying) OWNER TO rchumacero;

--
-- TOC entry 1314 (class 1255 OID 3477056)
-- Dependencies: 5 2435
-- Name: f_get_variable_global(character varying); Type: FUNCTION; Schema: public; Owner: rac
--

CREATE FUNCTION f_get_variable_global(p_parametro character varying) RETURNS character varying
    LANGUAGE plpgsql COST 16
    AS $$
/**************************************************************************
 FUNCION: 		public.f_get_variable_global
 DESCRIPCION:   devuelve el en varchar de la variable señalada 
 				en la tabla de varialbes globales
 				
                Web
 AUTOR: 	    KPLIAN (rac)	
 FECHA:	        09/08/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
 
 
 DECLARE
    v_nombre_funcion   	text;
    v_resp              varchar;
    v_respuesta         varchar;
    v_record record;
    v_consulta varchar;
 BEGIN
    v_nombre_funcion:='public.f_get_variable_global';
    v_respuesta='NULL';
    
  v_consulta='select valor as resp from public.variable_global v where v.variable='''||p_parametro||''' limit 1';
  
   raise notice 'get_parametro %',v_consulta;
                
      FOR  v_record in execute(v_consulta) LOOP
        
        v_respuesta = (v_record.resp);
        
      END LOOP;
      
     IF  v_respuesta is NULL THEN
      
      raise exception  'NO EXISTE UN VALOR PARA LA VARIABLE GLOBAL %',p_parametro;
     
     END IF;

   
    
    return coalesce(v_respuesta,'NULL');
    
    
 EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION public.f_get_variable_global(p_parametro character varying) OWNER TO rac;

--
-- TOC entry 136 (class 1255 OID 16592)
-- Dependencies: 5 2435
-- Name: f_iif(boolean, character varying, character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_iif(condicion boolean, op1 character varying, op2 character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_iif
 DESCRIPCION:   Si la condicion es verdadera devuelve laop1 sino devuelve op2
 AUTOR: 	    KPLIAN (jrr)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
BEGIN
if(condicion) then
return op1;
else
return op2;
end if;
END;
$$;


ALTER FUNCTION public.f_iif(condicion boolean, op1 character varying, op2 character varying) OWNER TO rchumacero;

--
-- TOC entry 1286 (class 1255 OID 1546556)
-- Dependencies: 5 2435
-- Name: f_intermediario_ime(integer, character varying, integer, character varying, macaddr, character varying, character varying, integer, character varying, character varying[], character varying[], character varying[], character varying[], character varying, bytea, character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_intermediario_ime(par_id_usuario integer, par_sid_web character varying, par_pid_web integer, par_ip character varying, par_mac macaddr, par_procedimiento character varying, par_transaccion character varying, par_id_categoria integer, es_matriz character varying, ip_admin character varying[], variables character varying[], valores character varying[], tipos character varying[], par_consulta character varying, par_files bytea, variable_files character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_intermediario_ime
 DESCRIPCIÃ“N: 	Recibe las peticiones del servidor web y las encamina 
  				hacia el procedimiento almacenado correspondiente
 AUTOR: 		KPLIAN(jrr)
 FECHA:			26/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:
 DESCRIPCION:	Revison y documentacion
 AUTOR:			 KPLIAN(rac)
 FECHA:			 26-11-10
***************************************************************************
 DESCRIPCION:	Valida si el usuario tiene permiso para ejecutar la transaccion
 AUTOR:			 KPLIAN(rac)
 FECHA:			 29-11-10
***************************************************************************
 DESCRIPCION:	Agregar array de direcciones IP para uso administrativo
 AUTOR:			 KPLIAN(rac)
 FECHA:			 25-12-10
**************************************************************************
DESCRIPCION:	Cuando campo tipo date viene vacio lo convierte en null
 AUTOR:			 KPLIAN(rac)
 FECHA:			 12/09/2011
***************************************************************************
DESCRIPCION:	Se introduce funcion  f_get_id_usuario  para aginarle persmisos de ejecucion
				del dueño de la funciona para no asginar permisos directos sobre la tabal
                tusuario por motivos de seguridad
 AUTOR:			 KPLIAN(rac)
 FECHA:			 29/02/2012
***************************************************************************
 */


DECLARE
 
    v_consulta          varchar;
    v_secuencia         integer;
    v_tamano            integer;
    v_retorno           varchar;
    v_mensaje           text;
    v_nombre_funcion    text;
    v_id_log       		integer;
    v_administrador     integer;
    v_valores_array     varchar[];
    v_tamano_matriz     integer;
    v_linea             varchar;
    v_resp				varchar;
    v_tiene_permisos    boolean;
    v_habilitar_log     integer;
    v_administrador_bool boolean;
    v_hora_ini          timestamp;
    v_hora_fin          timestamp;
    v_nivel_error        integer;
    v_tipo_error        varchar;
    v_id_usuario        integer;
    v_id_subsistema     integer;
    v_resp_error        record;
    v_upload_file        boolean;
    v_uf_count integer;
    
    --1 tipo: ERROR|EXITO
    --2 codigo_error: P0001
    --3 procedimientos: funciones
    --4 id_log
    --5 mensaje
    --6 ...
    --7 ..
    
    
    --TODO: falta concatenar procedimientos y eliminar los codigos de procedimientos

BEGIN

 --raise exception 'aaa  ';
    
    v_nombre_funcion:='public.f_intermediario_ime';
    v_nivel_error=2;
    v_hora_ini = clock_timestamp();
    
    v_linea=null;
    v_secuencia:=(nextval('parametro'));
    v_resp=f_runtime_config('LOG_STATEMENT','LOCAL','none');
    
    v_resp_error=f_ejecutar_dblink('('||pg_backend_pid()::varchar||',
            '''||par_sid_web||''','||par_pid_web||','''||par_transaccion||''','''||par_procedimiento||''')'
            ,'sesion');
       
    if(par_transaccion='SEG_VALUSU_SEG')then
       
        v_id_usuario:= segu.f_get_id_usuario(valores[6]);

    else
           
        v_id_usuario=par_id_usuario;
    
    end if;
    
    
   
    
    --1) verifica si es administrador, si tiene permisos y si habilita el log
       v_administrador = 0;
       
       v_nivel_error=0;
       v_resp=f_validar_bloqueos(v_id_usuario,par_ip);
       v_nivel_error=1;
      SELECT po_administrador,po_habilitar_log,po_tiene_permisos,po_id_subsistema
           into v_administrador_bool,v_habilitar_log,v_tiene_permisos,v_id_subsistema
       FROM f_verifica_permisos(par_id_usuario, par_transaccion, ''::varchar,ip_admin,par_ip::varchar);
       v_nivel_error=2;
      if(v_administrador_bool) THEN
        v_administrador = 1;
      END IF;
          
    -- 2) crea una tabla temportal con los parametros, valores y tipo de datos 
    -- 	  que seran direcciionado al procedimiento almacenado 
    --    concatena con el numero de secuencia para generar nombre de tabla unicos

    v_consulta:='create temporary table tt_parametros_'||v_secuencia||'(';
    v_tamano:=array_upper(tipos,1);
             --   raise exception 'aa%',variable_files;          

    for i in 1..(v_tamano-1) loop
        v_consulta:=v_consulta || variables[i] || ' ' || tipos[i] || ',';
    end loop;  
    --verifica si recibe archivos tipo bytea
    if( variable_files !='') THEN
      v_upload_file=true;
      v_consulta:=v_consulta || variables[v_tamano] || ' ' || tipos[v_tamano] || ','||variable_files||' bytea) on commit drop';
    ELSE
    v_upload_file=false;
      v_consulta:=v_consulta || variables[v_tamano] || ' ' || tipos[v_tamano] || ') on commit drop';
    END IF;
   -- raise exception 'aa%',v_consulta;
   
       RAISE NOTICE 'LLEGAAAAAAAA  2222';
    execute(v_consulta);
    
        RAISE NOTICE 'LLEGAAAAAAAA 333333333';
         
    
	-- 3) IF verifica si los resultados a ser enviados deben estar en formato de matriz o no
    --    Si no es formato de matriz es una llamada sencilla con un unico regisotr en la tabla temporal
    if(es_matriz='no') then
         
         -- 3.1)  prepara una cadena con un insert para la tabla temporal con los valores recibidos
        v_consulta:='insert into tt_parametros_'||v_secuencia||' values(';

        -- 3.2) FOR  recorre el array de  valores armando la cadena de insercion 
        
        for i in 1..(v_tamano-1) loop
            -- 3.2.1)IF si los valores son del tipo numeric o integer los espacios se insertan con valores nulos
            IF(tipos[i]='numeric' or tipos[i]='integer' or tipos[i]='int4')then
                if(valores[i]='')THEN
                    v_consulta:=v_consulta || 'null' || ',';
                else
                    v_consulta:=v_consulta || valores[i] || ',';
                end if;
            ELSE
                --RAC 12/09/2011 validacion para campo date vacio 
                if((tipos[i]='date' or tipos[i]='timestamp' or tipos[i]='time') and  valores[i]='')THEN
                     v_consulta:=v_consulta || 'null' || ',';
                else
                    v_consulta:=v_consulta ||''''|| valores[i] || ''',';
                end if;
            

            END IF;

        end loop; -- END FOOR 3.2)
        
        --   raise exception 'cons%',v_consulta;
         -- 3.3) introduce el final de la cadena de insercion
         
 --        raise exception '11111  %',par_files;
        
         --encode(par_files,'escape')
        if(tipos[v_tamano]='numeric' or tipos[v_tamano]='integer' or tipos[v_tamano]='int4')then
            
             if(v_upload_file)THEN
                 if(valores[v_tamano]='')THEN
               -- raise exception '222';
--                    v_consulta:=v_consulta || 'null' || ','''||par_files::text||''')';
--                    v_consulta:=v_consulta || 'null' || ','||decode('{'||par_files||'}','hex')||')';
--                    v_consulta:=v_consulta || 'null' || ','''||encode('{'||par_files||'}','hex')||''')';
--                      v_consulta:=v_consulta || 'null' || ',encode('''||par_files||'''::bytea,''hex''))';
                    --  v_consulta:=v_consulta || 'null' || ','''||encode(par_files,'escape')||''')';
                     v_consulta:=v_consulta || 'null' || ','''||par_files||'''::bytea)';
                      
                      
--                      v_consulta:=v_consulta || 'null' || ','''||par_files||'''::bytea)';
                else
                    v_consulta:=v_consulta || valores[v_tamano]|| ','''||par_files||'''::bytea)';
                end if;
             
             ELSE
                  
                if(valores[v_tamano]='')THEN
                    v_consulta:=v_consulta || 'null' || ')';
                else
                    v_consulta:=v_consulta || valores[v_tamano] || ')';
                end if;
            END IF;
          
        else
           --RAC 12/09/2011 validacion para campo date vacio 
           if(v_upload_file)THEN
              if((tipos[v_tamano]='date' or tipos[v_tamano]='timestamp' or tipos[v_tamano]='time') and  valores[v_tamano]='')THEN
                  v_consulta:=v_consulta || 'null' || ','''||par_files||'''::bytea)';
              else
                 v_consulta:=v_consulta ||''''|| valores[v_tamano] || ''','''||par_files||'''::bytea)';
              end if;
           
           ELSE
              if((tipos[v_tamano]='date' or tipos[v_tamano]='timestamp' or tipos[v_tamano]='time') and  valores[v_tamano]='')THEN
                  v_consulta:=v_consulta || 'null' || ')';
              else
                  v_consulta:=v_consulta ||''''|| valores[v_tamano] || ''')';
              end if;
            
           END IF;
        
        end if;
      -- 3.4  Ejecuta la cadena de insercion  en la tabla temporal con los datos recibidos del servidor
      -- raise exception 'aa%', v_consulta;
         raise notice '%', v_consulta;       
        execute v_consulta;
        
       --3.5) Arma en una cadena  la llamada al  procedimiento almacenado destino, le envia
       --     como parametro el nombre de la tabla temporal, el id_usuario,si es administrador 
       --     y la transaccion que se quiere ejecutar   

        v_consulta:='select ' || par_procedimiento || '('||v_administrador||','||coalesce(par_id_usuario,0)||',''tt_parametros_'||v_secuencia||''','''||par_transaccion||''')';
        raise notice '%',v_consulta;
   
        -- 3.6)ejecuta la cadena de llamada al procedimiento almacenado el valor de respuesta lo introduce
        --     en la variable tipo varchar v_retorno en formato JSON (o XML)
        execute v_consulta into v_retorno;
        
    
    -- 4) ELSE Si  es formato de matriz,   un for recorre la misma haciendo por cada vuelta
      --  un llamada al procedimiento almacenado con esto logramamos,  por ejemplo varias inserciones en una misma tabla
      -- y dentro de una misma transaccion, si tenemos algun error se corre un rollback para todo 
    else
    
    
          
    
     
        --4.1) calcula el tamano de la matriz
        v_tamano_matriz:=array_upper(valores,1);
        
        --4.2) recorre las filas de la matriz 
       for j in 1..(v_tamano_matriz) loop
            -- 4.2.1) prepara una cadena de insercion para la tabla temporal
            
            v_consulta='insert into tt_parametros_'||v_secuencia||' values(';
            
            --4.2.2)  FOR  recorre el array  de  valores (para la fila [j] de la matriz) armando la cadena de insercion con 
                  --  los valores  correpondientes a la fila [j]
        
          for i in 1..(v_tamano-1) loop
            
                --4.2.2.1) botiene el numero de fila por si acaso ocurriera un error tenerla identificada
                if(variables[i]='_fila')then
                    v_linea='Ocurrido en la linea # '||valores[j][i];
                end if;
                
               -- 4.2.2.2)IF si los valores son del tipo numeric o integer los espacios se insertan con valores nulos
                 
                if(tipos[i]='numeric' or tipos[i]='integer' or tipos[i]='int4')then
                    if(valores[j][i]='')THEN
                        v_consulta:=v_consulta || 'null' || ',';
                    else
                        v_consulta:=v_consulta || valores[j][i] || ',';
                    end if;
                ELSE
                
                --RAC 12/09/2011 validacion para campo date vacio 
                  if((tipos[i]='date' or tipos[i]='timestamp' or tipos[i]='time') and  valores[j][i]='')THEN
                       v_consulta:=v_consulta || 'null' || ',';
                  else
                    v_consulta:=v_consulta ||''''|| valores[j][i] || ''',';
                  end if;
                
                
                    
                end if;

            end loop;
            
            --4.2.3) inserta el ultimo valor en la cadena de insercion para la tabla temporal

            if(tipos[v_tamano]='numeric' or tipos[v_tamano]='integer' or tipos[v_tamano]='int4')then
                if(valores[j][v_tamano]='')THEN
                    v_consulta:=v_consulta || 'null' || ')';
                else
                    v_consulta:=v_consulta || valores[j][v_tamano] || ')';
                end if;

            ELSE
            
                --RAC 12/09/2011 validacion para campo date vacio 
                  if((tipos[v_tamano]='date' or tipos[v_tamano]='timestamp' or tipos[v_tamano]='time') and  valores[j][v_tamano]='')THEN
                      v_consulta:=v_consulta || 'null' || ')';
                  else
                    v_consulta:=v_consulta ||''''|| valores[j][v_tamano] || ''')';
                  end if;
                
            end if;
            --raise exception '%',v_consulta;
            
          -- 4.2.4  Ejecuta la cadena de insercion  en la tabla temporal con los datos recibidos del servidor

      
            execute v_consulta;
        
           --4.2.5) Arma en una cadena  la llamada al  procedimiento almacenado destino, le envia
           --     como parametro el nombre de la tabla temporal, el id_usuario,si es administrador 
           --     y la transaccion que se quiere ejecutar   
      
            v_consulta:='select ' || par_procedimiento || '('||v_administrador||','||coalesce(par_id_usuario,0)||',''tt_parametros_'||v_secuencia||''','''||par_transaccion||''')';

     
          -- 4.2.6) ejecuta la cadena de llamada al procedimiento almacenado el valor de respuesta lo introduce
          --     en la variable tipo varchar v_retorno en formato JSON (o XML)
            
              v_consulta:='select ' || par_procedimiento || '('||v_administrador||','||coalesce(par_id_usuario,0)||',''tt_parametros_'||v_secuencia||''','''||par_transaccion||''')';

            execute v_consulta into v_retorno;
          -- 4.2.7) vacia la tabla temporal para prepararla para la proxima fila de la matriz  
            execute('truncate table tt_parametros_'||v_secuencia);
            
            
        end loop; -- END FOR 4.2.2)
        
        
    end if;
    
    
    --Procesamiento de la respuesta de la funciÃ³n ejecutada
    --rcm
    --raise exception '%',v_retorno[1];
    
    --5) REgistra en LOG las trasacciones ejecutadas como exitosas
    
    v_id_log=0;
 -- v_habilitar_log = TRUE;
    
  RAISE NOTICE 'LLEGAAAAAAAA 444444444';
          
        
      v_hora_fin=clock_timestamp();
      v_id_log:=f_registrar_log(par_id_usuario,
    							par_ip,
                                par_mac::varchar,
                                'LOG_TRANSACCION',
                                f_obtiene_clave_valor(v_retorno,'mensaje','','','valor')::text,
                                par_procedimiento,
                                par_transaccion,
                                par_consulta,
                                to_char((v_hora_fin-v_hora_ini),'MS')::integer,
                                getpgusername()::varchar,
                                NULL,
                                pg_backend_pid(),
                                par_sid_web,
                                par_pid_web,
                                v_id_subsistema,
                                v_habilitar_log);
    
    v_resp='';
    v_resp = f_agrega_clave(v_resp,'tipo_respuesta','EXITO');
    v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
    v_resp = f_agrega_clave(v_resp,'id_log',v_id_log::varchar);
    
    v_resp = f_agrega_clave_multiple(v_resp,v_retorno);
    
    return f_resp_to_json(v_resp);

EXCEPTION
	WHEN OTHERS THEN
    
		v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'tipo_respuesta','ERROR'::varchar);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
  		--raise exception '%',v_resp;
        v_tipo_error='ERROR_TRANSACCION_BD';
        
         if(v_nivel_error=0)then
            v_tipo_error='ERROR_BLOQUEO';
         elsif(v_nivel_error=1)then
            v_tipo_error='ERROR_PERMISOS';
         elsif(par_transaccion='SEG_VALUSU_SEG')then
            v_tipo_error='ERROR_ACCESO';
         elsif (SQLSTATE='P0001')THEN
            v_tipo_error='ERROR_CONTROLADO_BD';
         end if;
        --Registro en el log
        v_id_log:=f_registrar_log(v_id_usuario,
        						par_ip,
                                par_mac::varchar,
                                v_tipo_error,
                                f_obtiene_clave_valor(v_resp,'mensaje','','','valor'),
                                f_obtiene_clave_valor(v_resp,'procedimientos','','','valor'),
                                par_transaccion,
                                par_consulta,
                                NULL,
                                getpgusername()::varchar,
                                SQLSTATE::varchar,
                                pg_backend_pid(),
                                par_sid_web,
                                par_pid_web,
                                v_id_subsistema,
                                1);
                                
        v_resp = f_agrega_clave(v_resp,'id_log',v_id_log::varchar);
        
  		return f_resp_to_json(v_resp);
END;
$$;


ALTER FUNCTION public.f_intermediario_ime(par_id_usuario integer, par_sid_web character varying, par_pid_web integer, par_ip character varying, par_mac macaddr, par_procedimiento character varying, par_transaccion character varying, par_id_categoria integer, es_matriz character varying, ip_admin character varying[], variables character varying[], valores character varying[], tipos character varying[], par_consulta character varying, par_files bytea, variable_files character varying) OWNER TO rchumacero;

--
-- TOC entry 137 (class 1255 OID 16595)
-- Dependencies: 5 2435
-- Name: f_intermediario_ime_orig(integer, character varying, macaddr, character varying, character varying, integer, character varying, character varying[], character varying[], character varying[], character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_intermediario_ime_orig(par_id_usuario integer, par_ip character varying, par_mac macaddr, par_procedimiento character varying, par_transaccion character varying, par_id_categoria integer, es_matriz character varying, variables character varying[], valores character varying[], tipos character varying[], par_consulta character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 
v_consulta          varchar;
v_secuencia         integer;
v_tamano            integer;
v_retorno           varchar;
v_mensaje           text;
v_nombre_funcion    text;
v_mensaje_log       varchar;
v_administrador     integer;
v_valores_array     varchar[];
v_tamano_matriz     integer;
v_linea             varchar;

BEGIN

    v_nombre_funcion:='public.f_intermediario_ime';
    v_linea=null;
    v_secuencia:=(nextval('parametro'));
    v_administrador:=0;
    if exists(select 1 from segu.usuario_rol ur where id_usuario=par_id_usuario and id_rol=1 and estado_reg='activo')then
       v_administrador:=1;
    end if;
    
    v_consulta:='create temporary table tt_parametros_'||v_secuencia||'(';
    v_tamano:=array_upper(tipos,1);
    for i in 1..(v_tamano-1) loop
        v_consulta:=v_consulta || variables[i] || ' ' || tipos[i] || ',';
    end loop;

    v_consulta:=v_consulta || variables[v_tamano] || ' ' || tipos[v_tamano] || ') on commit drop';

    execute(v_consulta);

    if(es_matriz='no')then

        v_consulta:='insert into tt_parametros_'||v_secuencia||' values(';

        for i in 1..(v_tamano-1) loop
            if(tipos[i]='numeric' or tipos[i]='integer')then
                if(valores[i]='')THEN
                    v_consulta:=v_consulta || 'null' || ',';
                else
                    v_consulta:=v_consulta || valores[i] || ',';
                end if;
            ELSE
                v_consulta:=v_consulta ||''''|| valores[i] || ''',';
            end if;

        end loop;

        if(tipos[v_tamano]='numeric' or tipos[v_tamano]='integer')then
            if(valores[v_tamano]='')THEN
                v_consulta:=v_consulta || 'null' || ')';
            else
                v_consulta:=v_consulta || valores[v_tamano] || ')';
            end if;
          
        ELSE
            v_consulta:=v_consulta ||''''|| valores[v_tamano] || ''')';
        end if;
        
        execute v_consulta;
   
        v_consulta:='select ' || par_procedimiento || '('||v_administrador||','||coalesce(par_id_usuario,0)||',''tt_parametros_'||v_secuencia||''','''||par_transaccion||''')';
        
        execute v_consulta into v_retorno;
    else
        
        v_tamano_matriz:=array_upper(valores,1);
        
        for j in 1..(v_tamano_matriz) loop
            v_consulta='insert into tt_parametros_'||v_secuencia||' values(';
            for i in 1..(v_tamano-1) loop
                if(variables[i]='_fila')then
                    v_linea='Ocurrido en la linea # '||valores[j][i];
                end if;
                if(tipos[i]='numeric' or tipos[i]='integer')then
                    if(valores[j][i]='')THEN
                        v_consulta:=v_consulta || 'null' || ',';
                    else
                        v_consulta:=v_consulta || valores[j][i] || ',';
                    end if;
                ELSE
                    v_consulta:=v_consulta ||''''|| valores[j][i] || ''',';
                end if;

            end loop;

            if(tipos[v_tamano]='numeric' or tipos[v_tamano]='integer')then
                if(valores[j][v_tamano]='')THEN
                    v_consulta:=v_consulta || 'null' || ')';
                else
                    v_consulta:=v_consulta || valores[j][v_tamano] || ')';
                end if;

            ELSE
                v_consulta:=v_consulta ||''''|| valores[j][v_tamano] || ''')';
            end if;
            --raise exception '%',v_consulta;
            execute v_consulta;

            v_consulta:='select ' || par_procedimiento || '('||v_administrador||','||coalesce(par_id_usuario,0)||',''tt_parametros_'||v_secuencia||''','''||par_transaccion||''')';

            execute v_consulta into v_retorno;
            execute('truncate table tt_parametros_'||v_secuencia);
        end loop;
        
        
    end if;
    v_mensaje:=f_get_mensaje_exi(v_retorno,v_nombre_funcion,par_transaccion);
    v_mensaje_log:=f_registrar_log(par_id_usuario,par_ip,par_mac::varchar,v_mensaje,par_consulta);
    return v_mensaje;
    
    EXCEPTION

       WHEN OTHERS THEN
--raise exception '%',par_consulta;
         v_mensaje:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM,v_nombre_funcion,par_transaccion,v_linea);
         
         v_mensaje_log:=f_registrar_log(par_id_usuario,par_ip,par_mac::varchar,v_mensaje,par_consulta);
         return v_mensaje::varchar;


END;
$$;


ALTER FUNCTION public.f_intermediario_ime_orig(par_id_usuario integer, par_ip character varying, par_mac macaddr, par_procedimiento character varying, par_transaccion character varying, par_id_categoria integer, es_matriz character varying, variables character varying[], valores character varying[], tipos character varying[], par_consulta character varying) OWNER TO rchumacero;

--
-- TOC entry 212 (class 1255 OID 3240859)
-- Dependencies: 2435 5
-- Name: f_intermediario_sel(integer, character varying, integer, character varying, macaddr, character varying, character varying, integer, character varying[], character varying[], character varying[], character varying[], character varying, character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_intermediario_sel(par_id_usuario integer, par_sid_web character varying, par_pid_web integer, par_ip character varying, par_mac macaddr, par_procedimiento character varying, par_transaccion character varying, par_id_categoria integer, ip_admin character varying[], variables character varying[], valores character varying[], tipos character varying[], tipo_retorno character varying DEFAULT 'varchar'::character varying, datos_retorno character varying DEFAULT NULL::character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_intermediario_sel
 DESCRIPCIÓN: 	Recibe las peticiones del servidor web y las encamina 
  				hacia el procedimiento almacenado correspondiente
 AUTOR: 		KPLIAN (jrr)
 FECHA:			26/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	Revison y documentacion
 AUTOR:			 KPLIAN (rac)
 FECHA:			 26-11-10
***************************************************************************
 DESCRIPCION:	Valida si el usuario tiene permiso para ejecutar la transaccion
 AUTOR:			 KPLIAN (rac)
 FECHA:			 29-11-10
****************************************************************************
 DESCRIPCION:	Agregar array de direcciones IP para uso administrativo
 AUTOR:			 KPLIAN (rac)
 FECHA:			 25-12-10
 ****************************************************************************
 DESCRIPCION:	Aumenta variable tipo retorno para definir se 
 				la funcion regresa su resultado como consulta o como record
                los record se utilizan cuando tenemos tablas temporales
 AUTOR:			 KPLIAN (rac)
 FECHA:			 19-03-12
***************************************************************************/

DECLARE
 
v_consulta    varchar;
v_secuencia   integer;
v_tamano      integer;
v_retorno     varchar;
v_mensaje    text;
v_mensaje_log   varchar;
v_nombre_funcion    text;
v_administrador     integer;

v_id_log integer;
v_resp_error record;
v_administrador_bool boolean;
v_tiene_permisos    boolean;
v_habilitar_log     integer;
v_database          varchar;
v_resp				varchar;
v_hora_ini          timestamp;
v_hora_fin          timestamp;
v_nivel_error    integer;
v_tipo_error        varchar;
v_id_subsistema     integer;
v_id_subsistema_cade varchar;
v_cadena_log        varchar;
v_retorno_record record;



BEGIN
    v_nombre_funcion:='public.f_intermediario_sel';
    v_resp=f_runtime_config('LOG_STATEMENT','LOCAL','none');
    v_nivel_error=2;
    v_hora_ini = clock_timestamp();
    v_retorno='';
    v_resp_error=f_ejecutar_dblink('('||pg_backend_pid()::varchar||',
            '''||par_sid_web||''','||par_pid_web||','''||par_transaccion||''','''||par_procedimiento||''')'
            ,'sesion');
    
    
    --1) verifica si es administrador, si tiene permisos y si habilita el log
       
       
       v_administrador = 0;
       v_nivel_error=0;
       v_resp=f_validar_bloqueos(par_id_usuario,par_ip);
       v_nivel_error=1;
       SELECT po_administrador,po_habilitar_log,po_tiene_permisos,po_id_subsistema
           into v_administrador_bool,v_habilitar_log,v_tiene_permisos,v_id_subsistema
       FROM f_verifica_permisos( par_id_usuario, par_transaccion, ''::varchar,ip_admin,par_ip::varchar);
       v_nivel_error=2;
       --raise exception 'permisos ->  %,%,%',v_tiene_permisos,v_habilitar_log,v_administrador_bool;
    
     
      if(v_administrador_bool) THEN
        v_administrador = 1;
      END IF;
       
       
      
    
       
    v_secuencia:=(nextval('parametro'));
    
    v_consulta:='create temporary table tt_parametros_'||v_secuencia||'(';
    v_tamano:=array_upper(variables,1);
    for i in 1..(v_tamano-1) loop
        v_consulta:=v_consulta || variables[i] || ' ' || tipos[i] || ',';

    end loop;
     
    v_consulta:=v_consulta || variables[v_tamano] || ' ' || tipos[v_tamano] || ') on commit drop';
    
    execute(v_consulta);
    
    v_consulta:='insert into tt_parametros_'||v_secuencia||' values(';
    
    for i in 1..(v_tamano-1) loop
        if(tipos[i]='numeric' or tipos[i]='integer')then
            if(valores[i]='')then
                v_consulta:=v_consulta || 'null' || ',';
            else
                v_consulta:=v_consulta || valores[i] || ',';
            end if;
        ELSE
            v_consulta:=v_consulta ||''''|| replace(valores[i],'''','''''') || ''',';
        end if;

    end loop;

    if(tipos[v_tamano]='numeric' or tipos[v_tamano]='integer')then
        if(valores[v_tamano]='')then
            v_consulta:=v_consulta || 'null'|| ')';
        else
            v_consulta:=v_consulta || valores[v_tamano] || ')';
        end if;
    ELSE
          v_consulta:=v_consulta ||''''|| replace(valores[v_tamano],'''','''''') || ''')';
    end if;
    --raise exception 'prueba:%',v_consulta;
    execute v_consulta;
    
  
    -- raise notice 'pasa';
    
   
    --raise exception '%',v_retorno;
    
    --raise exception 'aaaaaa: %',v_consulta;
   
    -- raise exception 'ES  SEL ';
     
     v_id_log=0;
     
  	 v_mensaje:=f_get_mensaje_exi('Exito en la consulta',v_nombre_funcion,par_transaccion);
    
   /*
   RAC 19032012
   aumentamos el tipo de dato de retorno
   para poder ejecutar consultar que retornan un tipo record
   */ 
    
   
   if(tipo_retorno='varchar')THEN
   
     v_consulta:='select ' || par_procedimiento || '('||v_administrador||','||coalesce(par_id_usuario,0)||',''tt_parametros_'||v_secuencia||''','''||par_transaccion||''')';
    
   
    execute v_consulta into v_retorno;
    
    return query execute (v_retorno);
    
    --RAC  >>>> OJO me parece que este registro de LOG nunca se EJECUTA
    v_hora_fin=clock_timestamp();
    --raise exception 'gfdsgfsd: %',v_habilitar_log;
        v_id_log:=f_registrar_log(par_id_usuario,
    							par_ip,
                                par_mac::varchar,
                                'LOG_TRANSACCION',
                                v_mensaje,
                                par_procedimiento,
                                par_transaccion,
                                v_retorno,
                                to_char((v_hora_fin-v_hora_ini),'MS')::integer,
                                getpgusername()::varchar,
                                NULL,
                                pg_backend_pid(),
                                par_sid_web,
                                par_pid_web,
                                v_id_subsistema,
                                v_habilitar_log);
                                
                                
     ELSE
     
     --en caso que el tipo de retorno sea un record
     
   -- execute v_consulta into v_retorno_record;
   
     v_consulta:='select * from ' || par_procedimiento || '('||v_administrador||','||coalesce(par_id_usuario,0)||',''tt_parametros_'||v_secuencia||''','''||par_transaccion||''') '||datos_retorno;
    
    raise notice 'CONSULTA %  ',v_consulta;
     
      for v_retorno_record in execute (v_consulta) LOOP
          RETURN NEXT v_retorno_record;
      END LOOP;
     
    
     END IF;


    EXCEPTION

       WHEN OTHERS THEN
       
        v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'tipo_respuesta','ERROR'::varchar);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);

        
         v_retorno:=replace(v_retorno,'''','''''');
         
         v_tipo_error='ERROR_TRANSACCION_BD';
         if(v_nivel_error=0)then
            v_tipo_error='ERROR_BLOQUEO';
         elsif(v_nivel_error=1)then
            v_tipo_error='ERROR_PERMISOS';
         elsif (SQLSTATE='P0001')THEN
            v_tipo_error='ERROR_CONTROLADO_BD';
         end if;
         
         if(v_id_subsistema is null)then
            v_id_subsistema_cade='null';
         else
            v_id_subsistema_cade=v_id_subsistema::varchar;
         end if;

         v_cadena_log='('||
         		coalesce(par_id_usuario,0)||',''' ||
                par_ip::varchar||''','''||
             	par_mac::varchar||''','''||
             	v_tipo_error ||''','''||
                f_obtiene_clave_valor(v_resp,'mensaje','','','valor')||''','''||
             	f_obtiene_clave_valor(v_resp,'procedimientos','','','valor')||''','''||
                par_transaccion||''','''||
                coalesce (v_retorno,' ')||''',NULL,''' ||
                getpgusername()||''','''||
                SQLSTATE||''','||
                pg_backend_pid()||','''||
                par_sid_web||''','||
                par_pid_web||','||
                v_id_subsistema_cade||
                ',1)';

		--RCM 31/01/2012: Cuando la llamada a esta funcion devuelve error, el manejador de excepciones de esa función da el resultado,
        --por lo que se modifica para que devuelva un json direcamente
         v_resp_error=f_ejecutar_dblink(v_cadena_log,'log');
                
         v_resp = f_agrega_clave(v_resp,'id_log',v_resp_error.id_log::varchar);
         


         raise exception '%',f_resp_to_json(v_resp);


END;
$$;


ALTER FUNCTION public.f_intermediario_sel(par_id_usuario integer, par_sid_web character varying, par_pid_web integer, par_ip character varying, par_mac macaddr, par_procedimiento character varying, par_transaccion character varying, par_id_categoria integer, ip_admin character varying[], variables character varying[], valores character varying[], tipos character varying[], tipo_retorno character varying, datos_retorno character varying) OWNER TO rchumacero;

--
-- TOC entry 1145 (class 1255 OID 1974331)
-- Dependencies: 5 2435
-- Name: f_llenar_ceros(numeric, integer); Type: FUNCTION; Schema: public; Owner: mzambrana
--

CREATE FUNCTION f_llenar_ceros(numero numeric, digitos integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	largo_cad 		integer;
	cadena			text;
BEGIN
    cadena:=text(numero);
    largo_cad:=char_length(cadena);
    while (largo_cad<digitos) loop
        cadena:='0'||cadena;
        largo_cad:=char_length(cadena);
    end loop;
    return cadena;
END;
$$;


ALTER FUNCTION public.f_llenar_ceros(numero numeric, digitos integer) OWNER TO mzambrana;

--
-- TOC entry 276 (class 1255 OID 1475522)
-- Dependencies: 2435 5
-- Name: f_obtener_literal_periodo(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION f_obtener_literal_periodo(par_mes integer, par_nro integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 documento: 	public.f_obtener_literal_periodo
 DESCRIPCION:   Funcion que obtiene el literal de un periodo (mes)
 AUTOR: 	    KPLIAN	
 FECHA:	        06/06/2011
 COMENTARIOS:	
***************************************************************************/
DECLARE
  g_mes_lite varchar;
BEGIN
    IF par_mes = 1 THEN
        g_mes_lite := 'Enero';
    ELSIF par_mes = 2 THEN
    	g_mes_lite := 'Febrero';
    ELSIF par_mes = 3 THEN
    	g_mes_lite := 'Marzo';
    ELSIF par_mes = 4 THEN
    	g_mes_lite := 'Abril';
    ELSIF par_mes = 5 THEN
    	g_mes_lite := 'Mayo';
    ELSIF par_mes = 6 THEN
    	g_mes_lite := 'Junio';
	ELSIF par_mes = 7 THEN
    	g_mes_lite := 'Julio';
	ELSIF par_mes = 8 THEN
    	g_mes_lite := 'Agosto';
    ELSIF par_mes = 9 THEN
    	g_mes_lite := 'Septiembre';
    ELSIF par_mes = 10 THEN
    	g_mes_lite := 'Octubre';
    ELSIF par_mes = 11 THEN
    	g_mes_lite := 'Noviembre';
   ELSIF par_mes = 12 THEN
    	g_mes_lite := 'Diciembre';
   END IF;

   IF par_nro > 0 THEN
        g_mes_lite := substr(g_mes_lite, 1, par_nro);
   END IF;

   return g_mes_lite;
END;
$$;


ALTER FUNCTION public.f_obtener_literal_periodo(par_mes integer, par_nro integer) OWNER TO postgres;

--
-- TOC entry 268 (class 1255 OID 1475523)
-- Dependencies: 5 2435
-- Name: f_obtener_primer_dia_mes(numeric, numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION f_obtener_primer_dia_mes(par_mes numeric, par_anio numeric) RETURNS date
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 documento: 	public.f_obtener_primer_dia_mes
 DESCRIPCION:   Funcion que obtiene el primer dia de un mes y anio especifico
 AUTOR: 	    KPLIAN	
 FECHA:	        06/06/2011
 COMENTARIOS:	
***************************************************************************/
DECLARE

g_mes      numeric;
g_fecha    date;

BEGIN
    g_mes:=par_mes;
    if (g_mes<10)then
        g_fecha:=(select cast(par_anio || '-0' || g_mes || '-01' as date));

    ELSE
        g_fecha:=(select cast(par_anio || '-' || g_mes || '-01' as date));
    end if;
    raise notice '%',g_fecha;
    return g_fecha;

END;
$$;


ALTER FUNCTION public.f_obtener_primer_dia_mes(par_mes numeric, par_anio numeric) OWNER TO postgres;

--
-- TOC entry 269 (class 1255 OID 1475524)
-- Dependencies: 5 2435
-- Name: f_obtener_ultimo_dia_mes(numeric, numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION f_obtener_ultimo_dia_mes(par_mes numeric, par_anio numeric) RETURNS date
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 documento: 	public.f_obtener_ultimo_dia_mes
 DESCRIPCION:   Funcion que obtiene el ultimo dia de un mes y anio especifico
 AUTOR: 	    KPLIAN	
 FECHA:	        06/06/2011
 COMENTARIOS:	
***************************************************************************/

DECLARE

g_mes      integer;
g_fecha    date;

BEGIN
    g_mes:=par_mes+1;
    if (g_mes<10)then
        g_fecha:=(select cast(par_anio || '-0' || g_mes || '-01' as date)-1);
    elsif(g_mes=13)THEN
        g_fecha:=(select cast(par_anio || '-12-31' as date));
    ELSE
        g_fecha:=(select cast(par_anio || '-' || g_mes || '-01' as date)-1);
    end if;
    return g_fecha;

END;
$$;


ALTER FUNCTION public.f_obtener_ultimo_dia_mes(par_mes numeric, par_anio numeric) OWNER TO postgres;

--
-- TOC entry 1250 (class 1255 OID 16598)
-- Dependencies: 5 2435
-- Name: f_obtiene_clave_valor(character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_obtiene_clave_valor(p_cad character varying, p_clave character varying, p_valor character varying, p_accion character varying, p_respuesta character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_obtiene_clave_valor
 DESCRIPCION:
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE

	v_cad_ini varchar; --SEPARADOR INICIAL DE LA CLAVE
    v_cad_fin varchar; --SEPARADOR FINAL DE LA CLAVE
    v_cad_ini_fin varchar; --SEPARADOR INICIAL DEL CIERRE DE LA CLAVE
    v_cad_fin_fin varchar; --SEPARADOR FINAL DEL CIERRE DE LA CLAVE

	v_ini integer; --POSICION INICIAL DE LA CLAVE INICIAL
    v_fin integer; --POSICION INICIAL DE LA CLAVE FINAL
    
    v_clave_ini varchar; --CLAVE INICIAL CON LOS SEPARADORES INCLUIDOS
    v_clave_fin varchar; --CLAVE FINAL CON LOS SEPARADORES INCLUIDOS
    v_tam integer; --TAMAÑO DE LA CLAVE BUSCADA
    v_valor varchar; --VALOR ACTUAL DE LA CLAVE UBICADA
    
    v_valor_nuevo varchar;
    v_cad_ant varchar;
    v_cad_post varchar;
    v_cadena_accion varchar;
    
BEGIN
	--Inicialización de constantes
	v_cad_ini = '<';
    v_cad_fin = '>';
    v_cad_ini_fin = '</'||p_clave;
    v_cad_fin_fin = '>';
    
    /*v_cad_ini = '[';
    v_cad_fin = ':';
    v_cad_ini_fin = '';
    v_cad_fin_fin = '],';*/
    
	--Forma claves de busqueda
    v_clave_ini = v_cad_ini || p_clave || v_cad_fin;
    v_clave_fin = v_cad_ini_fin || v_cad_fin_fin;
    
	--Ubica la posicion inicial de la clave
	v_ini = strpos(p_cad,v_clave_ini);
    --raise notice 'clave_ini %  v_clave_fin %  ini %',v_clave_ini,v_clave_fin,v_ini;
    
    --Si no se ubica la clave
    if v_ini=0 then
    	return '';
    end if;
    
    --Obtiene el tamaño de la clave
    v_tam = length(v_clave_ini);
    
    --Suma al inicio el tamaño de la clave
    v_ini = v_tam + v_ini;
    
    --Ubica la posicion del cierre de clave
    v_fin = strpos(p_cad,v_clave_fin); --25=B
    --raise notice 'tam %  ini %  fin %',v_tam,v_ini,v_fin;
    
    if v_fin = 0 then
    	return '';
    end if;
    
    --Se obtiene el valor de la clave ubicada
    v_valor = substr(p_cad,v_ini,v_fin-v_ini);
    v_cadena_accion = p_cad;
    
    --Obtiene toda la cadena anterior
    v_cad_ant=substr(p_cad,1,v_ini-1);
    
    --Obtiene toda la cadena posterior
	v_cad_post=substr(p_cad,v_fin,length(p_cad)-v_fin+1);
    
    -- Verfica si la accion es cambiar, unir o nada
    if p_accion = 'cambiar' then
    	v_valor = p_valor;
    	v_cadena_accion = v_cad_ant || p_valor ||v_cad_post;	
    elsif p_accion = 'unir' then
    	v_valor = p_valor || ' - ' || v_valor;
    	v_cadena_accion = v_cad_ant || v_valor ||v_cad_post;	
    end if;

	if p_respuesta = 'valor' then
    	return v_valor;
    elsif p_respuesta = 'cadena' then
    	return v_cadena_accion;
    else
    	return v_cadena_accion;
    end if;

END;
$$;


ALTER FUNCTION public.f_obtiene_clave_valor(p_cad character varying, p_clave character varying, p_valor character varying, p_accion character varying, p_respuesta character varying) OWNER TO rchumacero;

--
-- TOC entry 138 (class 1255 OID 16599)
-- Dependencies: 5 2435
-- Name: f_registrar_log(integer, character varying, character varying, character varying, text, text, character varying, character varying, integer, character varying, character varying, integer, character varying, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_registrar_log(par_id_usuario integer, par_ip character varying, par_mac character varying, par_tipo_log character varying, par_descripcion text, par_procedimientos text, par_transaccion character varying, par_consulta character varying, par_tiempo_ejecucion integer, par_usuario_base character varying, par_codigo_error character varying, par_pid_db integer, par_sid_web character varying, par_pid_web integer, par_id_subsistema integer, par_log integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: 		public.f_intermediario_ime
 DESCRIPCIÓN: 	Inserta registro de bitacora
 AUTOR: 		KPLIAN(jrr)
 FECHA:			26/07/2010

***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	 returning id_log
 AUTOR:			 KPLIAN(rac)
 FECHA:			 29-11-10
***************************************************************************
HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	 se anade el parametro par_log si es 1 se muestra en el
                log sino(0) solo en el monitor
 AUTOR:			 KPLIAN(jrr)
 FECHA:			 03-03-2011
***************************************************************************/

declare
       g_separador_error     varchar;
       g_separador_inicial   varchar;
       g_separador_funcion   varchar;
       g_mensaje_nuevo       text;
       g_descripcion         text;
       g_procedimientos      text;
       g_transaccion         varchar;
       g_tipo_log            varchar;
       v_id_log				 integer;
       v_resp                varchar;
       v_pid_db             integer;
       v_cuenta             varchar;
       v_subsistema         varchar;
       v_desc_transaccion   varchar;
       v_registro           record;
       v_interval           interval;

begin
    v_resp=f_runtime_config('LOG_STATEMENT','LOCAL','none');
    
     select valor into g_separador_inicial from public.variable_global vg where vg.variable='separador_inicial';
     select valor into g_separador_error from public.variable_global vg where vg.variable='separador_error';
    if(par_pid_db is null)then
        v_pid_db=pg_backend_pid();
    else
        v_pid_db=par_pid_db;
    end if;
    if(par_id_subsistema is not null)then
        select codigo
        into v_subsistema
        from segu.tsubsistema
        where id_subsistema=par_id_subsistema;
    end if;
    if(par_id_usuario is not null) then
        select cuenta
        into v_cuenta
        from segu.tusuario
        where id_usuario=par_id_usuario;
    end if;
    
    if(par_transaccion is not null)then
        select descripcion
        into v_desc_transaccion
        from segu.tprocedimiento
        where codigo=par_transaccion;
    end if;
    
    
    v_id_log=(select nextval('segu.log_id_log_seq'));
     --RAC, RCM: cambios para qe devuelva el id_log
     insert into segu.tlog(
     id_log,
     id_usuario,mac_maquina,ip_maquina,tipo_log,descripcion,fecha_reg,
     estado_reg,procedimientos,transaccion,consulta,tiempo_ejecucion,
     usuario_base,codigo_error,dia_semana,pid_db,pid_web,sid_web,cuenta_usuario,
     descripcion_transaccion,codigo_subsistema,id_subsistema,si_log
     ) values(
     v_id_log,
     par_id_usuario,par_mac,par_ip,par_tipo_log,par_descripcion,now(),'activo',
     par_procedimientos,par_transaccion,par_consulta,par_tiempo_ejecucion,
     par_usuario_base,par_codigo_error,to_char(now(),'D')::integer,
     v_pid_db,par_pid_web,par_sid_web,v_cuenta,
     v_desc_transaccion,v_subsistema,par_id_subsistema,par_log
     ) ;
     
    IF(par_tipo_log in('ERROR_WEB','ERROR_CONTROLADO_PHP','INYECCION','SESION',
                        'ERROR_TRANSACCION_BD','ERROR_CONTROLADO_BD',
                        'ERROR_PERMISOS','ERROR_BLOQUEO','ERROR_ACCESO'))THEN
                        
        for v_registro in
            (   select * from segu.tpatron_evento
                where estado_reg='activo' and tipo_evento=par_tipo_log)loop
            
            if((select count(*)
                from segu.vlog
                where tipo_log=par_tipo_log and
                    fecha_reg>(now() - (v_registro.periodo_intentos||' minutes')::interval) AND
                    ((v_registro.aplicacion='ip' and ip_maquina=par_ip) or (v_registro.aplicacion='usuario' and id_usuario=par_id_usuario)))
                    >=v_registro.cantidad_intentos)then
                

                if(not exists ( select 1
                                from segu.tbloqueo_notificacion
                                where id_patron_evento=v_registro.id_patron_evento and
                                        estado_reg='activo' and
                                        fecha_hora_fin > now() and
                                   ((aplicacion='ip' and ip=par_ip) or
                                   (aplicacion='usuario' and id_usuario=par_id_usuario))))THEN
                                   
                       insert into segu.tbloqueo_notificacion
                       (id_patron_evento,           nombre_patron,              fecha_hora_ini,
                       fecha_hora_fin,              estado_reg,                 id_usuario,
                       usuario,                     ip,                         tipo,
                       aplicacion,                  tipo_evento)
                       values(
                       v_registro.id_patron_evento, v_registro.nombre_patron,   now(),
                       (now()+ (v_registro.tiempo_bloqueo||' minutes')::interval),'activo',par_id_usuario,
                       v_cuenta,                    par_ip,                     v_registro.operacion,
                       v_registro.aplicacion,       v_registro.tipo_evento
                       );
                       
                end if;
                    
            end if;
        end loop;

    END IF;

     return v_id_log;
     
     

end;
$$;


ALTER FUNCTION public.f_registrar_log(par_id_usuario integer, par_ip character varying, par_mac character varying, par_tipo_log character varying, par_descripcion text, par_procedimientos text, par_transaccion character varying, par_consulta character varying, par_tiempo_ejecucion integer, par_usuario_base character varying, par_codigo_error character varying, par_pid_db integer, par_sid_web character varying, par_pid_web integer, par_id_subsistema integer, par_log integer) OWNER TO rchumacero;

--
-- TOC entry 139 (class 1255 OID 16601)
-- Dependencies: 5 2435
-- Name: f_resp_array(character varying[], character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_resp_array(p_array character varying[], p_clave character varying, p_valor character varying, p_accion character varying) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$
/*
Autor: KPLIAN(rcm)
Fecha: 19/08/2010
Propósito: FOrmar la respuesta en forma de array en formato clave-valor
Dominio: p_accion: 'unico','unir',otros
*/
DECLARE

	v_ini varchar;
    v_fin varchar;
    v_cad varchar;
    v_array varchar[];
    v_valor varchar;
    v_procede boolean;
    v_fila integer;

BEGIN

	--Definición de constantes para el formato del arrray
	v_ini='{';
    v_fin='}';
    v_procede=false;
        
    --Verifica la acción a realizar con el array
    --return '{claveZZ,'||p_clave||'}';
    v_valor = f_array_ubicar_clave(p_array,p_clave);
    if p_accion = 'unico' then
    	--Verifica si en el array enviado ya existe registrada la clave enviada. Si no existe la crea. Si existe no hace nada
        if v_valor = '_false' then
        	--No Existe, entonces crea la clave valor
            v_valor = p_valor;
            v_procede=true;
        end if;
    elsif p_accion = 'unir' then
    	--Verifica si ya existe la clave enviada. Si hay concatena por delante el valor. Si no existe lo crea.
        if v_valor = '_false' then
        	--Crea
            v_valor = p_valor;
            v_procede=true;
        else
        	--Concatena el valor con lo obtenido
            v_valor = p_valor||'|'||v_valor;
            v_fila = f_array_ubicar_clave_posicion(p_array);
            v_array = p_array;
            v_array[v_fila][2]=v_valor;
        end if;
    else
    	--Cualquier caso. Siempre crea la clave
        v_valor = p_valor;
        v_procede=true;
    end if;
    
    --Preparación de la cadena para agregar al array
    v_cad = v_ini||p_clave||','||v_valor||v_fin;
    
    --Append de la cadena procesada si la bandera esta encendida
    if v_procede then
    	v_array=array_append(p_array,v_cad);
    end if;
    
    --Envío de respuesta
	RETURN v_array;

END;
$$;


ALTER FUNCTION public.f_resp_array(p_array character varying[], p_clave character varying, p_valor character varying, p_accion character varying) OWNER TO rchumacero;

--
-- TOC entry 264 (class 1255 OID 16602)
-- Dependencies: 5 2435
-- Name: f_resp_to_json(character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_resp_to_json(p_xml character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_resp_to_json
 DESCRIPCION:   Convierte la cadena de respuesta a una cadena json
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE

	v_cad varchar;
    i integer;
    v_tam integer;
    v_array_claves varchar[];
    v_sub_cad varchar;
    v_pos_ini integer;
    v_pos_fin integer;
    v_clave varchar;
    v_cad_ini varchar;
    v_cad_fin varchar;
    v_cad_ini_fin varchar;
    v_cad_fin_fin varchar;
    v_nom_clave_ini varchar;
    v_nom_clave_fin varchar;
    v_aux varchar;
    v_resp varchar;

BEGIN
	--Inicialización de constantes
	v_cad_ini = '<';
    v_cad_fin = '>';
    v_cad_ini_fin = '</';
    v_cad_fin_fin = '>';

	v_cad=p_xml;
    v_tam=length(v_cad);
    
    loop
    	v_sub_cad='';
    	--Obtener la posicion del primer <
        v_pos_ini=strpos(v_cad,'<');
        --Obtener la posicion del primer >
        v_pos_fin=strpos(v_cad,'>');
        --Obtener la cadena siguiente del < hasta el >
        v_clave=substr(v_cad,v_pos_ini+1,v_pos_fin-2);
        --raise notice 'clave: %',v_clave;
        --Obtiene los nombres de las claves serializadas
        v_nom_clave_ini=v_cad_ini||v_clave||v_cad_fin;
        v_nom_clave_fin=v_cad_ini_fin||v_clave||v_cad_fin_fin;                
        --Obtiene el valor a partir de la clave
        v_sub_cad=f_obtiene_clave_valor(v_cad,v_clave,'','','valor');
        --Borrar de la cadena grande la cadena encontrada
        v_pos_fin=strpos(v_cad,v_nom_clave_fin);
        
        v_cad=substr(v_cad,v_pos_fin+length(v_nom_clave_fin),length(v_cad));
        --Guarda la subcadena en un array
        v_aux='"'||v_clave||'"'||':'||'"'||v_sub_cad||'"';
        v_array_claves=array_append(v_array_claves,v_aux);
        --raise exception '%',v_aux;
        exit when length(v_cad)=0;
    end loop;
    
    for i in 1..array_upper(v_array_claves,1) loop
    	--raise notice '%',v_array_claves[i];
        if i=1 then
        	v_resp = '{'||v_array_claves[i]||',';
        elsif i=array_upper(v_array_claves,1) then
        	v_resp = v_resp || v_array_claves[i] ||'}';
        else
        	v_resp = v_resp || v_array_claves[i]||',';
        end if;
    end loop;
    
    return v_resp;
    

END;
$$;


ALTER FUNCTION public.f_resp_to_json(p_xml character varying) OWNER TO rchumacero;

--
-- TOC entry 140 (class 1255 OID 16603)
-- Dependencies: 2435 5
-- Name: f_runtime_config(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_runtime_config(p_variable character varying, p_ambito character varying, p_valor character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: 		public.f_runtime_config
 DESCRIPCION:   Cambia el valor de una variable de configuracion de postgresql.conf
                en tiempo de ejecucion
 AUTOR: 	    KPLIAN (jrr)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE
    v_nombre_funcion    varchar;
    v_resp              varchar;
BEGIN
    v_nombre_funcion='public.f_runtime_config';
    if(p_variable is null or p_ambito is null or p_valor is null)then
        raise exception 'Error al realizar configuracion en tiempo de ejecucion uno de los parametros esta vacio';
    end if;
    execute('SET '||p_ambito||' '||p_variable||' = '||p_valor);
    return 'exito';

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION public.f_runtime_config(p_variable character varying, p_ambito character varying, p_valor character varying) OWNER TO rchumacero;

--
-- TOC entry 132 (class 1255 OID 16604)
-- Dependencies: 5 2435
-- Name: f_validar_bloqueos(integer, character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_validar_bloqueos(p_id_usuario integer, p_ip character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: 		public.f_validar_bloqueos
 DESCRIPCION:   Verifica si un usuario tiene un bloqueo activo al momento de ejecutar
                una transaccion
 AUTOR: 	    KPLIAN (jrr)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE

BEGIN
    if(exists(  select 1
                from segu.tbloqueo_notificacion
                where id_usuario=p_id_usuario
                and aplicacion='usuario'
                and tipo='bloqueo'
                and estado_reg='activo' and fecha_hora_fin>now()))then
        raise exception 'Su cuenta ha sido bloqueada. Comuniquese con el administrador';
    end if;
    if(exists(  select 1
                from segu.tbloqueo_notificacion
                where ip=p_ip
                and aplicacion='ip'
                and tipo='bloqueo'
                and estado_reg='activo' and fecha_hora_fin>now()))then

        raise exception 'Su equipo ha sido bloqueado. Comuniquese con el administrador';

    end if;
    
    return 'exito';
END;
$$;


ALTER FUNCTION public.f_validar_bloqueos(p_id_usuario integer, p_ip character varying) OWNER TO rchumacero;

--
-- TOC entry 1303 (class 1255 OID 16605)
-- Dependencies: 5 2435
-- Name: f_verifica_permisos(integer, character varying, character varying, character varying[], character varying); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION f_verifica_permisos(par_id_usuario integer, par_transaccion character varying, par_cod_gui character varying, par_ip_admin character varying[], par_ip character varying, OUT po_administrador boolean, OUT po_habilitar_log integer, OUT po_tiene_permisos boolean, OUT po_id_subsistema integer) RETURNS SETOF record
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/***************************************************************************
 DESCRIPCION:	Valida si el usuario tiene permiso para ejecutar la transaccion
 AUTOR:			 KPLIAN(jrr)
 FECHA:			 29-11-10
***************************************************************************/
declare
    v_descripcion   varchar;
begin


  -- 1) iniciamos los parametro
    
     po_administrador =FALSE; -- no es usuario administrador
     po_tiene_permisos = FALSE;  --los habilitado por defecto
     
     
     
     
  --2) verifica si es un usuario administrador, el administrador
  --   tiene permiso para ejecutar todas las transacciones 
  
   if exists(select 1 from segu.tusuario_rol ur where id_usuario=par_id_usuario and id_rol=1 and estado_reg='activo')then
       po_administrador:=true;
       po_tiene_permisos=true;
       
         --2.1) verificamos si la direccion IP del usuario administrador esta lista de los que pueden loguearse
        IF  not ( ARRAY[par_ip] <@ par_ip_admin ) THEN        
        	 raise exception 'El usuario no tiene autorizacion para conectarse  desde %',par_ip;
        END IF;
       
    end if;
    
   -- 3) verifica si la transaccion se almacena en log
   
    select CASE  
           WHEN p.habilita_log = 'no'THEN
              0
           ELSE
              1
           END,
           p.descripcion,
           f.id_subsistema
    into po_habilitar_log,v_descripcion,po_id_subsistema
    from segu.tprocedimiento p
    inner join segu.tfuncion f
        on(f.id_funcion=p.id_funcion)
    where p.codigo = par_transaccion;
    
    if(po_habilitar_log is null)then
        po_habilitar_log=1;
    end if;
   
     -- po_habilitar_log  = true;
  
    
    
    --  4) si no es administrador verificamos si no es una trasaccion basica
         -- (todos tienen permisos para ejecutar las basicas)
         IF ((not po_tiene_permisos) and  (par_transaccion in  ('SEG_SESION_INS','SEG_SESION_SEL','SEG_SESION_CONT','SEG_VALUSU_SEG','SEG_OBTEPRI_SEL','SEG_OBTEPRI_CONT','SEG_MENU_SEL','PM_GENALA_INS'))) THEN
         
            po_tiene_permisos = true;
         
         END IF; 
         
 
    
    --5)  verifica si el usuario tiene permiso para ejecutar la transaccion
   
    if (not po_tiene_permisos) THEN
     
     
     --5.1) si el usuario no es administrador verificamos 
     --     si tiene permisos para ejecutar la transaccion 
    
           IF(    
            		SELECT 1 
                    FROM segu.tusuario_rol ur
                    INNER JOIN  segu.trol_procedimiento_gui  rpg
                      ON rpg.id_rol = ur.id_rol  and rpg.estado_reg = 'activo'
                    INNER JOIN segu.tprocedimiento_gui pg
                     ON  rpg.id_procedimiento_gui = pg.id_procedimiento_gui and pg.estado_reg = 'activo'
                    INNER JOIN segu.tprocedimiento p 
                     ON    p.id_procedimiento  = pg.id_procedimiento   and p.estado_reg = 'activo'
                    WHERE ur.id_usuario=par_id_usuario 
                       and  ur.estado_reg='activo' and
                       p.codigo = par_transaccion LIMIT 1) THEN
                    
              
              po_tiene_permisos = true;
              
           ELSE   
           --en caso contrario arojamos el error de permiso denegado
           
              raise exception 'Permiso denegado para la transaccion :  %',par_transaccion;
              
           END IF;
           
   END IF;
   
   RETURN NEXT;
   --RETURN;

   
   
end;
$$;


ALTER FUNCTION public.f_verifica_permisos(par_id_usuario integer, par_transaccion character varying, par_cod_gui character varying, par_ip_admin character varying[], par_ip character varying, OUT po_administrador boolean, OUT po_habilitar_log integer, OUT po_tiene_permisos boolean, OUT po_id_subsistema integer) OWNER TO rchumacero;

--
-- TOC entry 905 (class 1255 OID 1898246)
-- Dependencies: 5 2114
-- Name: factor(chip); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION factor(chip) RETURNS real
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getFactor';


ALTER FUNCTION public.factor(chip) OWNER TO postgres;

--
-- TOC entry 1282 (class 1255 OID 2131427)
-- Dependencies: 5 2435
-- Name: fbytea(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION fbytea(b character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_agrega_clave_multiple
 DESCRIPCION:   Anade varios parametros de respuesta a la cadena que se va a devolver al servidor
                Web
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE
	v_cad_ini varchar;

BEGIN
	

  
    
    EXECUTE ('insert into tbytea(bb) values('''||b||''')');

    return 'exito';
  
END;
$$;


ALTER FUNCTION public.fbytea(b character varying) OWNER TO postgres;

--
-- TOC entry 1062 (class 1255 OID 1898409)
-- Dependencies: 5 2435 2117
-- Name: find_extent(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent("' || columnname || '") FROM "' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;


ALTER FUNCTION public.find_extent(text, text) OWNER TO postgres;

--
-- TOC entry 1060 (class 1255 OID 1898407)
-- Dependencies: 5 2435 2117
-- Name: find_extent(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent("' || columnname || '") FROM "' || schemaname || '"."' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;


ALTER FUNCTION public.find_extent(text, text, text) OWNER TO postgres;

--
-- TOC entry 1106 (class 1255 OID 1898445)
-- Dependencies: 5 2435
-- Name: find_srid(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schem text;
	tabl text;
	sr int4;
BEGIN
	IF $1 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - schema is NULL!';
	END IF;
	IF $2 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - table name is NULL!';
	END IF;
	IF $3 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - column name is NULL!';
	END IF;
	schem = $1;
	tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and tabl LIKE '%.%' ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	ELSE
	 schem = schem || '%';
	END IF;

	select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
	END IF;
	return sr;
END;
$_$;


ALTER FUNCTION public.find_srid(character varying, character varying, character varying) OWNER TO postgres;

--
-- TOC entry 1083 (class 1255 OID 1898428)
-- Dependencies: 5 2435
-- Name: fix_geometry_columns(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION fix_geometry_columns() RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	mislinked record;
	result text;
	linked integer;
	deleted integer;
	foundschema integer;
BEGIN

	-- Since 7.3 schema support has been added.
	-- Previous postgis versions used to put the database name in
	-- the schema column. This needs to be fixed, so we try to
	-- set the correct schema for each geometry_colums record
	-- looking at table, column, type and srid.
	UPDATE geometry_columns SET f_table_schema = n.nspname
		FROM pg_namespace n, pg_class c, pg_attribute a,
			pg_constraint sridcheck, pg_constraint typecheck
			WHERE ( f_table_schema is NULL
		OR f_table_schema = ''
			OR f_table_schema NOT IN (
					SELECT nspname::varchar
					FROM pg_namespace nn, pg_class cc, pg_attribute aa
					WHERE cc.relnamespace = nn.oid
					AND cc.relname = f_table_name::name
					AND aa.attrelid = cc.oid
					AND aa.attname = f_geometry_column::name))
			AND f_table_name::name = c.relname
			AND c.oid = a.attrelid
			AND c.relnamespace = n.oid
			AND f_geometry_column::name = a.attname

			AND sridcheck.conrelid = c.oid
		AND sridcheck.consrc LIKE '(srid(% = %)'
			AND sridcheck.consrc ~ textcat(' = ', srid::text)

			AND typecheck.conrelid = c.oid
		AND typecheck.consrc LIKE
		'((geometrytype(%) = ''%''::text) OR (% IS NULL))'
			AND typecheck.consrc ~ textcat(' = ''', type::text)

			AND NOT EXISTS (
					SELECT oid FROM geometry_columns gc
					WHERE c.relname::varchar = gc.f_table_name
					AND n.nspname::varchar = gc.f_table_schema
					AND a.attname::varchar = gc.f_geometry_column
			);

	GET DIAGNOSTICS foundschema = ROW_COUNT;

	-- no linkage to system table needed
	return 'fixed:'||foundschema::text;

END;
$$;


ALTER FUNCTION public.fix_geometry_columns() OWNER TO postgres;

--
-- TOC entry 956 (class 1255 OID 1898297)
-- Dependencies: 5 2104 2104
-- Name: force_2d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION force_2d(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_2d';


ALTER FUNCTION public.force_2d(geometry) OWNER TO postgres;

--
-- TOC entry 960 (class 1255 OID 1898301)
-- Dependencies: 5 2104 2104
-- Name: force_3d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION force_3d(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_3dz';


ALTER FUNCTION public.force_3d(geometry) OWNER TO postgres;

--
-- TOC entry 962 (class 1255 OID 1898303)
-- Dependencies: 5 2104 2104
-- Name: force_3dm(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION force_3dm(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_3dm';


ALTER FUNCTION public.force_3dm(geometry) OWNER TO postgres;

--
-- TOC entry 958 (class 1255 OID 1898299)
-- Dependencies: 5 2104 2104
-- Name: force_3dz(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION force_3dz(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_3dz';


ALTER FUNCTION public.force_3dz(geometry) OWNER TO postgres;

--
-- TOC entry 964 (class 1255 OID 1898305)
-- Dependencies: 5 2104 2104
-- Name: force_4d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION force_4d(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_4d';


ALTER FUNCTION public.force_4d(geometry) OWNER TO postgres;

--
-- TOC entry 966 (class 1255 OID 1898307)
-- Dependencies: 5 2104 2104
-- Name: force_collection(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION force_collection(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_collection';


ALTER FUNCTION public.force_collection(geometry) OWNER TO postgres;

--
-- TOC entry 981 (class 1255 OID 1898322)
-- Dependencies: 5 2104 2104
-- Name: forcerhr(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION forcerhr(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_forceRHR_poly';


ALTER FUNCTION public.forcerhr(geometry) OWNER TO postgres;

--
-- TOC entry 1247 (class 1255 OID 2964563)
-- Dependencies: 5
-- Name: g_int_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION g_int_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_int_compress';


ALTER FUNCTION public.g_int_compress(internal) OWNER TO postgres;

--
-- TOC entry 1246 (class 1255 OID 2964562)
-- Dependencies: 5
-- Name: g_int_consistent(internal, integer[], integer, oid, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION g_int_consistent(internal, integer[], integer, oid, internal) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_int_consistent';


ALTER FUNCTION public.g_int_consistent(internal, integer[], integer, oid, internal) OWNER TO postgres;

--
-- TOC entry 1248 (class 1255 OID 2964564)
-- Dependencies: 5
-- Name: g_int_decompress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION g_int_decompress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_int_decompress';


ALTER FUNCTION public.g_int_decompress(internal) OWNER TO postgres;

--
-- TOC entry 1249 (class 1255 OID 2964565)
-- Dependencies: 5
-- Name: g_int_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION g_int_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_int_penalty';


ALTER FUNCTION public.g_int_penalty(internal, internal, internal) OWNER TO postgres;

--
-- TOC entry 1251 (class 1255 OID 2964566)
-- Dependencies: 5
-- Name: g_int_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION g_int_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_int_picksplit';


ALTER FUNCTION public.g_int_picksplit(internal, internal) OWNER TO postgres;

--
-- TOC entry 1253 (class 1255 OID 2964568)
-- Dependencies: 5
-- Name: g_int_same(integer[], integer[], internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION g_int_same(integer[], integer[], internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_int_same';


ALTER FUNCTION public.g_int_same(integer[], integer[], internal) OWNER TO postgres;

--
-- TOC entry 1252 (class 1255 OID 2964567)
-- Dependencies: 5
-- Name: g_int_union(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION g_int_union(internal, internal) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_int_union';


ALTER FUNCTION public.g_int_union(internal, internal) OWNER TO postgres;

--
-- TOC entry 1257 (class 1255 OID 2964590)
-- Dependencies: 5
-- Name: g_intbig_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION g_intbig_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_intbig_compress';


ALTER FUNCTION public.g_intbig_compress(internal) OWNER TO postgres;

--
-- TOC entry 1256 (class 1255 OID 2964589)
-- Dependencies: 5
-- Name: g_intbig_consistent(internal, internal, integer, oid, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION g_intbig_consistent(internal, internal, integer, oid, internal) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_intbig_consistent';


ALTER FUNCTION public.g_intbig_consistent(internal, internal, integer, oid, internal) OWNER TO postgres;

--
-- TOC entry 1258 (class 1255 OID 2964591)
-- Dependencies: 5
-- Name: g_intbig_decompress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION g_intbig_decompress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_intbig_decompress';


ALTER FUNCTION public.g_intbig_decompress(internal) OWNER TO postgres;

--
-- TOC entry 1259 (class 1255 OID 2964592)
-- Dependencies: 5
-- Name: g_intbig_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION g_intbig_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_intbig_penalty';


ALTER FUNCTION public.g_intbig_penalty(internal, internal, internal) OWNER TO postgres;

--
-- TOC entry 1260 (class 1255 OID 2964593)
-- Dependencies: 5
-- Name: g_intbig_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION g_intbig_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_intbig_picksplit';


ALTER FUNCTION public.g_intbig_picksplit(internal, internal) OWNER TO postgres;

--
-- TOC entry 1262 (class 1255 OID 2964595)
-- Dependencies: 5
-- Name: g_intbig_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION g_intbig_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_intbig_same';


ALTER FUNCTION public.g_intbig_same(internal, internal, internal) OWNER TO postgres;

--
-- TOC entry 1261 (class 1255 OID 2964594)
-- Dependencies: 5
-- Name: g_intbig_union(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION g_intbig_union(internal, internal) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_intbig_union';


ALTER FUNCTION public.g_intbig_union(internal, internal) OWNER TO postgres;

--
-- TOC entry 699 (class 1255 OID 1898884)
-- Dependencies: 5 2131 2104
-- Name: geography(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography(geometry) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_from_geometry';


ALTER FUNCTION public.geography(geometry) OWNER TO postgres;

--
-- TOC entry 689 (class 1255 OID 1898867)
-- Dependencies: 5 2131 2131
-- Name: geography(geography, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography(geography, integer, boolean) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_enforce_typmod';


ALTER FUNCTION public.geography(geography, integer, boolean) OWNER TO postgres;

--
-- TOC entry 720 (class 1255 OID 1898914)
-- Dependencies: 5 2131 2131
-- Name: geography_cmp(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_cmp(geography, geography) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_cmp';


ALTER FUNCTION public.geography_cmp(geography, geography) OWNER TO postgres;

--
-- TOC entry 719 (class 1255 OID 1898913)
-- Dependencies: 5 2131 2131
-- Name: geography_eq(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_eq(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_eq';


ALTER FUNCTION public.geography_eq(geography, geography) OWNER TO postgres;

--
-- TOC entry 718 (class 1255 OID 1898912)
-- Dependencies: 2131 5 2131
-- Name: geography_ge(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_ge(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_ge';


ALTER FUNCTION public.geography_ge(geography, geography) OWNER TO postgres;

--
-- TOC entry 706 (class 1255 OID 1898889)
-- Dependencies: 5
-- Name: geography_gist_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gist_compress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_compress';


ALTER FUNCTION public.geography_gist_compress(internal) OWNER TO postgres;

--
-- TOC entry 705 (class 1255 OID 1898888)
-- Dependencies: 5 2104
-- Name: geography_gist_consistent(internal, geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gist_consistent(internal, geometry, integer) RETURNS boolean
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_consistent';


ALTER FUNCTION public.geography_gist_consistent(internal, geometry, integer) OWNER TO postgres;

--
-- TOC entry 711 (class 1255 OID 1898894)
-- Dependencies: 5
-- Name: geography_gist_decompress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gist_decompress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_decompress';


ALTER FUNCTION public.geography_gist_decompress(internal) OWNER TO postgres;

--
-- TOC entry 713 (class 1255 OID 1898896)
-- Dependencies: 5
-- Name: geography_gist_join_selectivity(internal, oid, internal, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gist_join_selectivity(internal, oid, internal, smallint) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_join_selectivity';


ALTER FUNCTION public.geography_gist_join_selectivity(internal, oid, internal, smallint) OWNER TO postgres;

--
-- TOC entry 707 (class 1255 OID 1898890)
-- Dependencies: 5
-- Name: geography_gist_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gist_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_penalty';


ALTER FUNCTION public.geography_gist_penalty(internal, internal, internal) OWNER TO postgres;

--
-- TOC entry 708 (class 1255 OID 1898891)
-- Dependencies: 5
-- Name: geography_gist_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gist_picksplit(internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_picksplit';


ALTER FUNCTION public.geography_gist_picksplit(internal, internal) OWNER TO postgres;

--
-- TOC entry 710 (class 1255 OID 1898893)
-- Dependencies: 5 2117 2117
-- Name: geography_gist_same(box2d, box2d, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gist_same(box2d, box2d, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_same';


ALTER FUNCTION public.geography_gist_same(box2d, box2d, internal) OWNER TO postgres;

--
-- TOC entry 712 (class 1255 OID 1898895)
-- Dependencies: 5
-- Name: geography_gist_selectivity(internal, oid, internal, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gist_selectivity(internal, oid, internal, integer) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_selectivity';


ALTER FUNCTION public.geography_gist_selectivity(internal, oid, internal, integer) OWNER TO postgres;

--
-- TOC entry 709 (class 1255 OID 1898892)
-- Dependencies: 5
-- Name: geography_gist_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gist_union(bytea, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_union';


ALTER FUNCTION public.geography_gist_union(bytea, internal) OWNER TO postgres;

--
-- TOC entry 717 (class 1255 OID 1898911)
-- Dependencies: 5 2131 2131
-- Name: geography_gt(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_gt(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_gt';


ALTER FUNCTION public.geography_gt(geography, geography) OWNER TO postgres;

--
-- TOC entry 716 (class 1255 OID 1898910)
-- Dependencies: 5 2131 2131
-- Name: geography_le(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_le(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_le';


ALTER FUNCTION public.geography_le(geography, geography) OWNER TO postgres;

--
-- TOC entry 715 (class 1255 OID 1898909)
-- Dependencies: 5 2131 2131
-- Name: geography_lt(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_lt(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_lt';


ALTER FUNCTION public.geography_lt(geography, geography) OWNER TO postgres;

--
-- TOC entry 714 (class 1255 OID 1898897)
-- Dependencies: 5 2131 2131
-- Name: geography_overlaps(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_overlaps(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_overlaps';


ALTER FUNCTION public.geography_overlaps(geography, geography) OWNER TO postgres;

--
-- TOC entry 696 (class 1255 OID 1898876)
-- Dependencies: 5
-- Name: geography_typmod_dims(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_typmod_dims(integer) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_typmod_dims';


ALTER FUNCTION public.geography_typmod_dims(integer) OWNER TO postgres;

--
-- TOC entry 697 (class 1255 OID 1898877)
-- Dependencies: 5
-- Name: geography_typmod_srid(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_typmod_srid(integer) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_typmod_srid';


ALTER FUNCTION public.geography_typmod_srid(integer) OWNER TO postgres;

--
-- TOC entry 698 (class 1255 OID 1898878)
-- Dependencies: 5
-- Name: geography_typmod_type(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geography_typmod_type(integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_typmod_type';


ALTER FUNCTION public.geography_typmod_type(integer) OWNER TO postgres;

--
-- TOC entry 586 (class 1255 OID 1898763)
-- Dependencies: 5 2104
-- Name: geomcollfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geomcollfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(GeomFromText($1)) = 'GEOMETRYCOLLECTION'
	THEN GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.geomcollfromtext(text) OWNER TO postgres;

--
-- TOC entry 584 (class 1255 OID 1898761)
-- Dependencies: 5 2104
-- Name: geomcollfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geomcollfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(GeomFromText($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.geomcollfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 637 (class 1255 OID 1898814)
-- Dependencies: 5 2104
-- Name: geomcollfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geomcollfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(GeomFromWKB($1)) = 'GEOMETRYCOLLECTION'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.geomcollfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 635 (class 1255 OID 1898812)
-- Dependencies: 5 2104
-- Name: geomcollfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geomcollfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(GeomFromWKB($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.geomcollfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 821 (class 1255 OID 1898113)
-- Dependencies: 5 2104 2111
-- Name: geometry(box3d_extent); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry(box3d_extent) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_LWGEOM';


ALTER FUNCTION public.geometry(box3d_extent) OWNER TO postgres;

--
-- TOC entry 333 (class 1255 OID 1898485)
-- Dependencies: 5 2104 2117
-- Name: geometry(box2d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry(box2d) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_to_LWGEOM';


ALTER FUNCTION public.geometry(box2d) OWNER TO postgres;

--
-- TOC entry 334 (class 1255 OID 1898486)
-- Dependencies: 5 2104 2107
-- Name: geometry(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry(box3d) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_LWGEOM';


ALTER FUNCTION public.geometry(box3d) OWNER TO postgres;

--
-- TOC entry 335 (class 1255 OID 1898487)
-- Dependencies: 5 2104
-- Name: geometry(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'parse_WKT_lwgeom';


ALTER FUNCTION public.geometry(text) OWNER TO postgres;

--
-- TOC entry 336 (class 1255 OID 1898488)
-- Dependencies: 5 2104 2114
-- Name: geometry(chip); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry(chip) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_to_LWGEOM';


ALTER FUNCTION public.geometry(chip) OWNER TO postgres;

--
-- TOC entry 337 (class 1255 OID 1898489)
-- Dependencies: 5 2104
-- Name: geometry(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_bytea';


ALTER FUNCTION public.geometry(bytea) OWNER TO postgres;

--
-- TOC entry 700 (class 1255 OID 1898886)
-- Dependencies: 5 2104 2131
-- Name: geometry(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry(geography) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geometry_from_geography';


ALTER FUNCTION public.geometry(geography) OWNER TO postgres;

--
-- TOC entry 879 (class 1255 OID 1898187)
-- Dependencies: 5 2104 2104
-- Name: geometry_above(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_above(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_above';


ALTER FUNCTION public.geometry_above(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 880 (class 1255 OID 1898188)
-- Dependencies: 5 2104 2104
-- Name: geometry_below(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_below(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_below';


ALTER FUNCTION public.geometry_below(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 853 (class 1255 OID 1898148)
-- Dependencies: 5 2104 2104
-- Name: geometry_cmp(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_cmp(geometry, geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_cmp';


ALTER FUNCTION public.geometry_cmp(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 881 (class 1255 OID 1898189)
-- Dependencies: 5 2104 2104
-- Name: geometry_contain(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_contain(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_contain';


ALTER FUNCTION public.geometry_contain(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 885 (class 1255 OID 1898190)
-- Dependencies: 5 2104 2104
-- Name: geometry_contained(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_contained(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_contained';


ALTER FUNCTION public.geometry_contained(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 852 (class 1255 OID 1898147)
-- Dependencies: 2104 5 2104
-- Name: geometry_eq(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_eq(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_eq';


ALTER FUNCTION public.geometry_eq(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 851 (class 1255 OID 1898146)
-- Dependencies: 5 2104 2104
-- Name: geometry_ge(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_ge(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_ge';


ALTER FUNCTION public.geometry_ge(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 872 (class 1255 OID 1898180)
-- Dependencies: 5
-- Name: geometry_gist_joinsel(internal, oid, internal, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_joinsel(internal, oid, internal, smallint) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_joinsel';


ALTER FUNCTION public.geometry_gist_joinsel(internal, oid, internal, smallint) OWNER TO postgres;

--
-- TOC entry 871 (class 1255 OID 1898179)
-- Dependencies: 5
-- Name: geometry_gist_sel(internal, oid, internal, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gist_sel(internal, oid, internal, integer) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_sel';


ALTER FUNCTION public.geometry_gist_sel(internal, oid, internal, integer) OWNER TO postgres;

--
-- TOC entry 850 (class 1255 OID 1898145)
-- Dependencies: 5 2104 2104
-- Name: geometry_gt(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_gt(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_gt';


ALTER FUNCTION public.geometry_gt(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 849 (class 1255 OID 1898144)
-- Dependencies: 5 2104 2104
-- Name: geometry_le(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_le(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_le';


ALTER FUNCTION public.geometry_le(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 877 (class 1255 OID 1898185)
-- Dependencies: 5 2104 2104
-- Name: geometry_left(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_left(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_left';


ALTER FUNCTION public.geometry_left(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 848 (class 1255 OID 1898143)
-- Dependencies: 5 2104 2104
-- Name: geometry_lt(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_lt(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_lt';


ALTER FUNCTION public.geometry_lt(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 875 (class 1255 OID 1898183)
-- Dependencies: 5 2104 2104
-- Name: geometry_overabove(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_overabove(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overabove';


ALTER FUNCTION public.geometry_overabove(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 876 (class 1255 OID 1898184)
-- Dependencies: 5 2104 2104
-- Name: geometry_overbelow(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_overbelow(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overbelow';


ALTER FUNCTION public.geometry_overbelow(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 882 (class 1255 OID 1898191)
-- Dependencies: 5 2104 2104
-- Name: geometry_overlap(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_overlap(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overlap';


ALTER FUNCTION public.geometry_overlap(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 873 (class 1255 OID 1898181)
-- Dependencies: 5 2104 2104
-- Name: geometry_overleft(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_overleft(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overleft';


ALTER FUNCTION public.geometry_overleft(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 874 (class 1255 OID 1898182)
-- Dependencies: 5 2104 2104
-- Name: geometry_overright(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_overright(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overright';


ALTER FUNCTION public.geometry_overright(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 878 (class 1255 OID 1898186)
-- Dependencies: 5 2104 2104
-- Name: geometry_right(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_right(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_right';


ALTER FUNCTION public.geometry_right(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 870 (class 1255 OID 1898178)
-- Dependencies: 5 2104 2104
-- Name: geometry_same(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_same(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_samebox';


ALTER FUNCTION public.geometry_same(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 883 (class 1255 OID 1898192)
-- Dependencies: 5 2104 2104
-- Name: geometry_samebox(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometry_samebox(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_samebox';


ALTER FUNCTION public.geometry_samebox(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 535 (class 1255 OID 1898712)
-- Dependencies: 5 2104
-- Name: geometryfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometryfromtext(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_text';


ALTER FUNCTION public.geometryfromtext(text) OWNER TO postgres;

--
-- TOC entry 537 (class 1255 OID 1898714)
-- Dependencies: 5 2104
-- Name: geometryfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometryfromtext(text, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_text';


ALTER FUNCTION public.geometryfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 493 (class 1255 OID 1898670)
-- Dependencies: 5 2104 2104
-- Name: geometryn(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometryn(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_geometryn_collection';


ALTER FUNCTION public.geometryn(geometry, integer) OWNER TO postgres;

--
-- TOC entry 505 (class 1255 OID 1898682)
-- Dependencies: 5 2104
-- Name: geometrytype(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geometrytype(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_getTYPE';


ALTER FUNCTION public.geometrytype(geometry) OWNER TO postgres;

--
-- TOC entry 1000 (class 1255 OID 1898340)
-- Dependencies: 5 2104
-- Name: geomfromewkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geomfromewkb(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOMFromWKB';


ALTER FUNCTION public.geomfromewkb(bytea) OWNER TO postgres;

--
-- TOC entry 1002 (class 1255 OID 1898342)
-- Dependencies: 5 2104
-- Name: geomfromewkt(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geomfromewkt(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'parse_WKT_lwgeom';


ALTER FUNCTION public.geomfromewkt(text) OWNER TO postgres;

--
-- TOC entry 539 (class 1255 OID 1898716)
-- Dependencies: 5 2104
-- Name: geomfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geomfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT geometryfromtext($1)$_$;


ALTER FUNCTION public.geomfromtext(text) OWNER TO postgres;

--
-- TOC entry 541 (class 1255 OID 1898718)
-- Dependencies: 5 2104
-- Name: geomfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geomfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT geometryfromtext($1, $2)$_$;


ALTER FUNCTION public.geomfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 588 (class 1255 OID 1898765)
-- Dependencies: 5 2104
-- Name: geomfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geomfromwkb(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_WKB';


ALTER FUNCTION public.geomfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 590 (class 1255 OID 1898767)
-- Dependencies: 5 2104
-- Name: geomfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geomfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT setSRID(GeomFromWKB($1), $2)$_$;


ALTER FUNCTION public.geomfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 388 (class 1255 OID 1898555)
-- Dependencies: 5 2104 2104 2104
-- Name: geomunion(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION geomunion(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geomunion';


ALTER FUNCTION public.geomunion(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1107 (class 1255 OID 1898446)
-- Dependencies: 5 2435
-- Name: get_proj4_from_srid(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;


ALTER FUNCTION public.get_proj4_from_srid(integer) OWNER TO postgres;

--
-- TOC entry 897 (class 1255 OID 1898238)
-- Dependencies: 5 2117 2104
-- Name: getbbox(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getbbox(geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_BOX2DFLOAT4';


ALTER FUNCTION public.getbbox(geometry) OWNER TO postgres;

--
-- TOC entry 896 (class 1255 OID 1898237)
-- Dependencies: 5 2104
-- Name: getsrid(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getsrid(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_getSRID';


ALTER FUNCTION public.getsrid(geometry) OWNER TO postgres;

--
-- TOC entry 661 (class 1255 OID 1898838)
-- Dependencies: 5
-- Name: gettransactionid(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gettransactionid() RETURNS xid
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'getTransactionID';


ALTER FUNCTION public.gettransactionid() OWNER TO postgres;

--
-- TOC entry 1264 (class 1255 OID 2964613)
-- Dependencies: 5
-- Name: ginint4_consistent(internal, smallint, internal, integer, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ginint4_consistent(internal, smallint, internal, integer, internal, internal) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'ginint4_consistent';


ALTER FUNCTION public.ginint4_consistent(internal, smallint, internal, integer, internal, internal) OWNER TO postgres;

--
-- TOC entry 1263 (class 1255 OID 2964612)
-- Dependencies: 5
-- Name: ginint4_queryextract(internal, internal, smallint, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ginint4_queryextract(internal, internal, smallint, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'ginint4_queryextract';


ALTER FUNCTION public.ginint4_queryextract(internal, internal, smallint, internal, internal) OWNER TO postgres;

--
-- TOC entry 899 (class 1255 OID 1898240)
-- Dependencies: 5 2104
-- Name: hasbbox(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION hasbbox(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_hasBBOX';


ALTER FUNCTION public.hasbbox(geometry) OWNER TO postgres;

--
-- TOC entry 903 (class 1255 OID 1898244)
-- Dependencies: 5 2114
-- Name: height(chip); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION height(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getHeight';


ALTER FUNCTION public.height(chip) OWNER TO postgres;

--
-- TOC entry 1219 (class 1255 OID 2964539)
-- Dependencies: 5
-- Name: icount(integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION icount(integer[]) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'icount';


ALTER FUNCTION public.icount(integer[]) OWNER TO postgres;

--
-- TOC entry 1238 (class 1255 OID 2964546)
-- Dependencies: 5
-- Name: idx(integer[], integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION idx(integer[], integer) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'idx';


ALTER FUNCTION public.idx(integer[], integer) OWNER TO postgres;

--
-- TOC entry 1243 (class 1255 OID 2964554)
-- Dependencies: 5
-- Name: intarray_del_elem(integer[], integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION intarray_del_elem(integer[], integer) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'intarray_del_elem';


ALTER FUNCTION public.intarray_del_elem(integer[], integer) OWNER TO postgres;

--
-- TOC entry 1242 (class 1255 OID 2964552)
-- Dependencies: 5
-- Name: intarray_push_array(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION intarray_push_array(integer[], integer[]) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'intarray_push_array';


ALTER FUNCTION public.intarray_push_array(integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 1241 (class 1255 OID 2964550)
-- Dependencies: 5
-- Name: intarray_push_elem(integer[], integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION intarray_push_elem(integer[], integer) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'intarray_push_elem';


ALTER FUNCTION public.intarray_push_elem(integer[], integer) OWNER TO postgres;

--
-- TOC entry 284 (class 1255 OID 1475538)
-- Dependencies: 5 2435
-- Name: intconcat(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION intconcat(integer, integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
begin
  if $1 is null then
    return $2;
  end if;
  if $2 is null then
    return $1;
  end if;
  return $1 || ',' || $2;
end
$_$;


ALTER FUNCTION public.intconcat(integer, integer) OWNER TO postgres;

--
-- TOC entry 503 (class 1255 OID 1898680)
-- Dependencies: 5 2104 2104
-- Name: interiorringn(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION interiorringn(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_interiorringn_polygon';


ALTER FUNCTION public.interiorringn(geometry, integer) OWNER TO postgres;

--
-- TOC entry 362 (class 1255 OID 1898530)
-- Dependencies: 5 2104 2104 2104
-- Name: intersection(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION intersection(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'intersection';


ALTER FUNCTION public.intersection(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 417 (class 1255 OID 1898597)
-- Dependencies: 5 2104 2104
-- Name: intersects(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION intersects(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'intersects';


ALTER FUNCTION public.intersects(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1232 (class 1255 OID 2964538)
-- Dependencies: 5
-- Name: intset(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION intset(integer) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'intset';


ALTER FUNCTION public.intset(integer) OWNER TO postgres;

--
-- TOC entry 1245 (class 1255 OID 2964559)
-- Dependencies: 5
-- Name: intset_subtract(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION intset_subtract(integer[], integer[]) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'intset_subtract';


ALTER FUNCTION public.intset_subtract(integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 1244 (class 1255 OID 2964556)
-- Dependencies: 5
-- Name: intset_union_elem(integer[], integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION intset_union_elem(integer[], integer) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'intset_union_elem';


ALTER FUNCTION public.intset_union_elem(integer[], integer) OWNER TO postgres;

--
-- TOC entry 521 (class 1255 OID 1898698)
-- Dependencies: 5 2104
-- Name: isclosed(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION isclosed(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_isclosed_linestring';


ALTER FUNCTION public.isclosed(geometry) OWNER TO postgres;

--
-- TOC entry 523 (class 1255 OID 1898700)
-- Dependencies: 5 2104
-- Name: isempty(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION isempty(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_isempty';


ALTER FUNCTION public.isempty(geometry) OWNER TO postgres;

--
-- TOC entry 444 (class 1255 OID 1898622)
-- Dependencies: 5 2104
-- Name: isring(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION isring(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'isring';


ALTER FUNCTION public.isring(geometry) OWNER TO postgres;

--
-- TOC entry 448 (class 1255 OID 1898626)
-- Dependencies: 5 2104
-- Name: issimple(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION issimple(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'issimple';


ALTER FUNCTION public.issimple(geometry) OWNER TO postgres;

--
-- TOC entry 440 (class 1255 OID 1898618)
-- Dependencies: 5 2104
-- Name: isvalid(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION isvalid(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'isvalid';


ALTER FUNCTION public.isvalid(geometry) OWNER TO postgres;

--
-- TOC entry 928 (class 1255 OID 1898269)
-- Dependencies: 5 2104
-- Name: length(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION length(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_length_linestring';


ALTER FUNCTION public.length(geometry) OWNER TO postgres;

--
-- TOC entry 926 (class 1255 OID 1898267)
-- Dependencies: 5 2104
-- Name: length2d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION length2d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_length2d_linestring';


ALTER FUNCTION public.length2d(geometry) OWNER TO postgres;

--
-- TOC entry 934 (class 1255 OID 1898275)
-- Dependencies: 5 2104 2101
-- Name: length2d_spheroid(geometry, spheroid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION length2d_spheroid(geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_length2d_ellipsoid';


ALTER FUNCTION public.length2d_spheroid(geometry, spheroid) OWNER TO postgres;

--
-- TOC entry 924 (class 1255 OID 1898265)
-- Dependencies: 5 2104
-- Name: length3d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION length3d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_length_linestring';


ALTER FUNCTION public.length3d(geometry) OWNER TO postgres;

--
-- TOC entry 930 (class 1255 OID 1898271)
-- Dependencies: 5 2104 2101
-- Name: length3d_spheroid(geometry, spheroid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION length3d_spheroid(geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_length_ellipsoid_linestring';


ALTER FUNCTION public.length3d_spheroid(geometry, spheroid) OWNER TO postgres;

--
-- TOC entry 932 (class 1255 OID 1898273)
-- Dependencies: 5 2104 2101
-- Name: length_spheroid(geometry, spheroid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION length_spheroid(geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_length_ellipsoid_linestring';


ALTER FUNCTION public.length_spheroid(geometry, spheroid) OWNER TO postgres;

--
-- TOC entry 353 (class 1255 OID 1898519)
-- Dependencies: 5 2104 2104
-- Name: line_interpolate_point(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION line_interpolate_point(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_interpolate_point';


ALTER FUNCTION public.line_interpolate_point(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 347 (class 1255 OID 1898523)
-- Dependencies: 5 2104 2104
-- Name: line_locate_point(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION line_locate_point(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_locate_point';


ALTER FUNCTION public.line_locate_point(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 355 (class 1255 OID 1898521)
-- Dependencies: 5 2104 2104
-- Name: line_substring(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION line_substring(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_substring';


ALTER FUNCTION public.line_substring(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 1020 (class 1255 OID 1898360)
-- Dependencies: 5 2104 2104
-- Name: linefrommultipoint(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION linefrommultipoint(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_from_mpoint';


ALTER FUNCTION public.linefrommultipoint(geometry) OWNER TO postgres;

--
-- TOC entry 547 (class 1255 OID 1898724)
-- Dependencies: 5 2104
-- Name: linefromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION linefromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'LINESTRING'
	THEN GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.linefromtext(text) OWNER TO postgres;

--
-- TOC entry 549 (class 1255 OID 1898726)
-- Dependencies: 5 2104
-- Name: linefromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION linefromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'LINESTRING'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.linefromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 598 (class 1255 OID 1898775)
-- Dependencies: 5 2104
-- Name: linefromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION linefromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'LINESTRING'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.linefromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 596 (class 1255 OID 1898773)
-- Dependencies: 5 2104
-- Name: linefromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION linefromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.linefromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 1042 (class 1255 OID 1898382)
-- Dependencies: 5 2104 2104
-- Name: linemerge(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION linemerge(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'linemerge';


ALTER FUNCTION public.linemerge(geometry) OWNER TO postgres;

--
-- TOC entry 551 (class 1255 OID 1898728)
-- Dependencies: 5 2104
-- Name: linestringfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION linestringfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT LineFromText($1)$_$;


ALTER FUNCTION public.linestringfromtext(text) OWNER TO postgres;

--
-- TOC entry 552 (class 1255 OID 1898729)
-- Dependencies: 5 2104
-- Name: linestringfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION linestringfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT LineFromText($1, $2)$_$;


ALTER FUNCTION public.linestringfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 602 (class 1255 OID 1898779)
-- Dependencies: 5 2104
-- Name: linestringfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION linestringfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'LINESTRING'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.linestringfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 600 (class 1255 OID 1898777)
-- Dependencies: 5 2104
-- Name: linestringfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION linestringfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.linestringfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 359 (class 1255 OID 1898527)
-- Dependencies: 5 2104 2104
-- Name: locate_along_measure(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION locate_along_measure(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT locate_between_measures($1, $2, $2) $_$;


ALTER FUNCTION public.locate_along_measure(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 357 (class 1255 OID 1898525)
-- Dependencies: 5 2104 2104
-- Name: locate_between_measures(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION locate_between_measures(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_locate_between_m';


ALTER FUNCTION public.locate_between_measures(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 655 (class 1255 OID 1898832)
-- Dependencies: 5
-- Name: lockrow(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lockrow(text, text, text) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT LockRow(current_schema(), $1, $2, $3, now()::timestamp+'1:00'); $_$;


ALTER FUNCTION public.lockrow(text, text, text) OWNER TO postgres;

--
-- TOC entry 654 (class 1255 OID 1898831)
-- Dependencies: 5
-- Name: lockrow(text, text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lockrow(text, text, text, text) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT LockRow($1, $2, $3, $4, now()::timestamp+'1:00'); $_$;


ALTER FUNCTION public.lockrow(text, text, text, text) OWNER TO postgres;

--
-- TOC entry 656 (class 1255 OID 1898833)
-- Dependencies: 5
-- Name: lockrow(text, text, text, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lockrow(text, text, text, timestamp without time zone) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT LockRow(current_schema(), $1, $2, $3, $4); $_$;


ALTER FUNCTION public.lockrow(text, text, text, timestamp without time zone) OWNER TO postgres;

--
-- TOC entry 652 (class 1255 OID 1898830)
-- Dependencies: 2435 5
-- Name: lockrow(text, text, text, text, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lockrow(text, text, text, text, timestamp without time zone) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $_$ 
DECLARE
	myschema alias for $1;
	mytable alias for $2;
	myrid   alias for $3;
	authid alias for $4;
	expires alias for $5;
	ret int;
	mytoid oid;
	myrec RECORD;
	
BEGIN

	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	EXECUTE 'DELETE FROM authorization_table WHERE expires < now()'; 

	SELECT c.oid INTO mytoid FROM pg_class c, pg_namespace n
		WHERE c.relname = mytable
		AND c.relnamespace = n.oid
		AND n.nspname = myschema;

	-- RAISE NOTICE 'toid: %', mytoid;

	FOR myrec IN SELECT * FROM authorization_table WHERE 
		toid = mytoid AND rid = myrid
	LOOP
		IF myrec.authid != authid THEN
			RETURN 0;
		ELSE
			RETURN 1;
		END IF;
	END LOOP;

	EXECUTE 'INSERT INTO authorization_table VALUES ('||
		quote_literal(mytoid::text)||','||quote_literal(myrid)||
		','||quote_literal(expires::text)||
		','||quote_literal(authid) ||')';

	GET DIAGNOSTICS ret = ROW_COUNT;

	RETURN ret;
END;
$_$;


ALTER FUNCTION public.lockrow(text, text, text, text, timestamp without time zone) OWNER TO postgres;

--
-- TOC entry 663 (class 1255 OID 1898840)
-- Dependencies: 5 2435
-- Name: longtransactionsenabled(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$;


ALTER FUNCTION public.longtransactionsenabled() OWNER TO postgres;

--
-- TOC entry 886 (class 1255 OID 1898206)
-- Dependencies: 5
-- Name: lwgeom_gist_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lwgeom_gist_compress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_compress';


ALTER FUNCTION public.lwgeom_gist_compress(internal) OWNER TO postgres;

--
-- TOC entry 884 (class 1255 OID 1898205)
-- Dependencies: 5 2104
-- Name: lwgeom_gist_consistent(internal, geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lwgeom_gist_consistent(internal, geometry, integer) RETURNS boolean
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_consistent';


ALTER FUNCTION public.lwgeom_gist_consistent(internal, geometry, integer) OWNER TO postgres;

--
-- TOC entry 891 (class 1255 OID 1898211)
-- Dependencies: 5
-- Name: lwgeom_gist_decompress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lwgeom_gist_decompress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_decompress';


ALTER FUNCTION public.lwgeom_gist_decompress(internal) OWNER TO postgres;

--
-- TOC entry 887 (class 1255 OID 1898207)
-- Dependencies: 5
-- Name: lwgeom_gist_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lwgeom_gist_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_penalty';


ALTER FUNCTION public.lwgeom_gist_penalty(internal, internal, internal) OWNER TO postgres;

--
-- TOC entry 888 (class 1255 OID 1898208)
-- Dependencies: 5
-- Name: lwgeom_gist_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lwgeom_gist_picksplit(internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_picksplit';


ALTER FUNCTION public.lwgeom_gist_picksplit(internal, internal) OWNER TO postgres;

--
-- TOC entry 890 (class 1255 OID 1898210)
-- Dependencies: 5 2117 2117
-- Name: lwgeom_gist_same(box2d, box2d, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lwgeom_gist_same(box2d, box2d, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_same';


ALTER FUNCTION public.lwgeom_gist_same(box2d, box2d, internal) OWNER TO postgres;

--
-- TOC entry 889 (class 1255 OID 1898209)
-- Dependencies: 5
-- Name: lwgeom_gist_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lwgeom_gist_union(bytea, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_union';


ALTER FUNCTION public.lwgeom_gist_union(bytea, internal) OWNER TO postgres;

--
-- TOC entry 515 (class 1255 OID 1898692)
-- Dependencies: 5 2104
-- Name: m(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION m(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_m_point';


ALTER FUNCTION public.m(geometry) OWNER TO postgres;

--
-- TOC entry 1013 (class 1255 OID 1898353)
-- Dependencies: 5 2117 2104 2104
-- Name: makebox2d(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION makebox2d(geometry, geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_construct';


ALTER FUNCTION public.makebox2d(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1015 (class 1255 OID 1898355)
-- Dependencies: 5 2107 2104 2104
-- Name: makebox3d(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION makebox3d(geometry, geometry) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_construct';


ALTER FUNCTION public.makebox3d(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1022 (class 1255 OID 1898362)
-- Dependencies: 5 2104 2104 2104
-- Name: makeline(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION makeline(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makeline';


ALTER FUNCTION public.makeline(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1017 (class 1255 OID 1898357)
-- Dependencies: 5 2104 2106
-- Name: makeline_garray(geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION makeline_garray(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makeline_garray';


ALTER FUNCTION public.makeline_garray(geometry[]) OWNER TO postgres;

--
-- TOC entry 1005 (class 1255 OID 1898345)
-- Dependencies: 5 2104
-- Name: makepoint(double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION makepoint(double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint';


ALTER FUNCTION public.makepoint(double precision, double precision) OWNER TO postgres;

--
-- TOC entry 1007 (class 1255 OID 1898347)
-- Dependencies: 5 2104
-- Name: makepoint(double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION makepoint(double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint';


ALTER FUNCTION public.makepoint(double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 1009 (class 1255 OID 1898349)
-- Dependencies: 5 2104
-- Name: makepoint(double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION makepoint(double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint';


ALTER FUNCTION public.makepoint(double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 1011 (class 1255 OID 1898351)
-- Dependencies: 5 2104
-- Name: makepointm(double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION makepointm(double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint3dm';


ALTER FUNCTION public.makepointm(double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 1035 (class 1255 OID 1898375)
-- Dependencies: 5 2104 2104
-- Name: makepolygon(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION makepolygon(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoly';


ALTER FUNCTION public.makepolygon(geometry) OWNER TO postgres;

--
-- TOC entry 1033 (class 1255 OID 1898373)
-- Dependencies: 5 2104 2104 2106
-- Name: makepolygon(geometry, geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION makepolygon(geometry, geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoly';


ALTER FUNCTION public.makepolygon(geometry, geometry[]) OWNER TO postgres;

--
-- TOC entry 639 (class 1255 OID 1898816)
-- Dependencies: 5 2104 2104
-- Name: max_distance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION max_distance(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_maxdistance2d_linestring';


ALTER FUNCTION public.max_distance(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 916 (class 1255 OID 1898257)
-- Dependencies: 5 2104
-- Name: mem_size(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION mem_size(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_mem_size';


ALTER FUNCTION public.mem_size(geometry) OWNER TO postgres;

--
-- TOC entry 563 (class 1255 OID 1898740)
-- Dependencies: 5 2104
-- Name: mlinefromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION mlinefromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'MULTILINESTRING'
	THEN GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.mlinefromtext(text) OWNER TO postgres;

--
-- TOC entry 561 (class 1255 OID 1898738)
-- Dependencies: 5 2104
-- Name: mlinefromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION mlinefromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(GeomFromText($1, $2)) = 'MULTILINESTRING'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.mlinefromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 625 (class 1255 OID 1898802)
-- Dependencies: 5 2104
-- Name: mlinefromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION mlinefromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.mlinefromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 623 (class 1255 OID 1898800)
-- Dependencies: 5 2104
-- Name: mlinefromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION mlinefromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'MULTILINESTRING'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.mlinefromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 141 (class 1255 OID 16606)
-- Dependencies: 5
-- Name: monitor_phx(integer); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION monitor_phx(integer) RETURNS integer
    LANGUAGE c STRICT
    AS '/usr/local/lib/phx.so', 'monitor_phx';


ALTER FUNCTION public.monitor_phx(integer) OWNER TO rchumacero;

--
-- TOC entry 571 (class 1255 OID 1898748)
-- Dependencies: 5 2104
-- Name: mpointfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION mpointfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'MULTIPOINT'
	THEN GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.mpointfromtext(text) OWNER TO postgres;

--
-- TOC entry 569 (class 1255 OID 1898746)
-- Dependencies: 5 2104
-- Name: mpointfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION mpointfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1,$2)) = 'MULTIPOINT'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.mpointfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 614 (class 1255 OID 1898791)
-- Dependencies: 5 2104
-- Name: mpointfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION mpointfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTIPOINT'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.mpointfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 612 (class 1255 OID 1898789)
-- Dependencies: 5 2104
-- Name: mpointfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION mpointfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1,$2)) = 'MULTIPOINT'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.mpointfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 578 (class 1255 OID 1898755)
-- Dependencies: 5 2104
-- Name: mpolyfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION mpolyfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'MULTIPOLYGON'
	THEN GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.mpolyfromtext(text) OWNER TO postgres;

--
-- TOC entry 576 (class 1255 OID 1898753)
-- Dependencies: 5 2104
-- Name: mpolyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION mpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'MULTIPOLYGON'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.mpolyfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 629 (class 1255 OID 1898806)
-- Dependencies: 5 2104
-- Name: mpolyfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION mpolyfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTIPOLYGON'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.mpolyfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 627 (class 1255 OID 1898804)
-- Dependencies: 5 2104
-- Name: mpolyfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION mpolyfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.mpolyfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 969 (class 1255 OID 1898310)
-- Dependencies: 5 2104 2104
-- Name: multi(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION multi(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_multi';


ALTER FUNCTION public.multi(geometry) OWNER TO postgres;

--
-- TOC entry 621 (class 1255 OID 1898798)
-- Dependencies: 5 2104
-- Name: multilinefromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION multilinefromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.multilinefromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 620 (class 1255 OID 1898797)
-- Dependencies: 5 2104
-- Name: multilinefromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION multilinefromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'MULTILINESTRING'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.multilinefromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 565 (class 1255 OID 1898742)
-- Dependencies: 5 2104
-- Name: multilinestringfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION multilinestringfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_MLineFromText($1)$_$;


ALTER FUNCTION public.multilinestringfromtext(text) OWNER TO postgres;

--
-- TOC entry 567 (class 1255 OID 1898744)
-- Dependencies: 5 2104
-- Name: multilinestringfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION multilinestringfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MLineFromText($1, $2)$_$;


ALTER FUNCTION public.multilinestringfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 574 (class 1255 OID 1898751)
-- Dependencies: 5 2104
-- Name: multipointfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION multipointfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MPointFromText($1)$_$;


ALTER FUNCTION public.multipointfromtext(text) OWNER TO postgres;

--
-- TOC entry 573 (class 1255 OID 1898750)
-- Dependencies: 5 2104
-- Name: multipointfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION multipointfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MPointFromText($1, $2)$_$;


ALTER FUNCTION public.multipointfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 618 (class 1255 OID 1898795)
-- Dependencies: 5 2104
-- Name: multipointfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION multipointfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTIPOINT'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.multipointfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 616 (class 1255 OID 1898793)
-- Dependencies: 5 2104
-- Name: multipointfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION multipointfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1,$2)) = 'MULTIPOINT'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.multipointfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 633 (class 1255 OID 1898810)
-- Dependencies: 5 2104
-- Name: multipolyfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION multipolyfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTIPOLYGON'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.multipolyfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 631 (class 1255 OID 1898808)
-- Dependencies: 5 2104
-- Name: multipolyfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION multipolyfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.multipolyfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 582 (class 1255 OID 1898759)
-- Dependencies: 5 2104
-- Name: multipolygonfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION multipolygonfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MPolyFromText($1)$_$;


ALTER FUNCTION public.multipolygonfromtext(text) OWNER TO postgres;

--
-- TOC entry 580 (class 1255 OID 1898757)
-- Dependencies: 5 2104
-- Name: multipolygonfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION multipolygonfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MPolyFromText($1, $2)$_$;


ALTER FUNCTION public.multipolygonfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 991 (class 1255 OID 1898328)
-- Dependencies: 5 2104
-- Name: ndims(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ndims(geometry) RETURNS smallint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_ndims';


ALTER FUNCTION public.ndims(geometry) OWNER TO postgres;

--
-- TOC entry 983 (class 1255 OID 1898324)
-- Dependencies: 5 2104 2104
-- Name: noop(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION noop(geometry) RETURNS geometry
    LANGUAGE c STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_noop';


ALTER FUNCTION public.noop(geometry) OWNER TO postgres;

--
-- TOC entry 920 (class 1255 OID 1898261)
-- Dependencies: 5 2104
-- Name: npoints(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION npoints(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_npoints';


ALTER FUNCTION public.npoints(geometry) OWNER TO postgres;

--
-- TOC entry 922 (class 1255 OID 1898263)
-- Dependencies: 5 2104
-- Name: nrings(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION nrings(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_nrings';


ALTER FUNCTION public.nrings(geometry) OWNER TO postgres;

--
-- TOC entry 491 (class 1255 OID 1898668)
-- Dependencies: 5 2104
-- Name: numgeometries(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION numgeometries(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_numgeometries_collection';


ALTER FUNCTION public.numgeometries(geometry) OWNER TO postgres;

--
-- TOC entry 501 (class 1255 OID 1898678)
-- Dependencies: 5 2104
-- Name: numinteriorring(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION numinteriorring(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_numinteriorrings_polygon';


ALTER FUNCTION public.numinteriorring(geometry) OWNER TO postgres;

--
-- TOC entry 499 (class 1255 OID 1898676)
-- Dependencies: 5 2104
-- Name: numinteriorrings(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION numinteriorrings(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_numinteriorrings_polygon';


ALTER FUNCTION public.numinteriorrings(geometry) OWNER TO postgres;

--
-- TOC entry 489 (class 1255 OID 1898666)
-- Dependencies: 5 2104
-- Name: numpoints(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION numpoints(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_numpoints_linestring';


ALTER FUNCTION public.numpoints(geometry) OWNER TO postgres;

--
-- TOC entry 437 (class 1255 OID 1898615)
-- Dependencies: 5 2104 2104
-- Name: overlaps(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION "overlaps"(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'overlaps';


ALTER FUNCTION public."overlaps"(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 940 (class 1255 OID 1898281)
-- Dependencies: 5 2104
-- Name: perimeter(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION perimeter(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_perimeter_poly';


ALTER FUNCTION public.perimeter(geometry) OWNER TO postgres;

--
-- TOC entry 938 (class 1255 OID 1898279)
-- Dependencies: 5 2104
-- Name: perimeter2d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION perimeter2d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_perimeter2d_poly';


ALTER FUNCTION public.perimeter2d(geometry) OWNER TO postgres;

--
-- TOC entry 936 (class 1255 OID 1898277)
-- Dependencies: 5 2104
-- Name: perimeter3d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION perimeter3d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_perimeter_poly';


ALTER FUNCTION public.perimeter3d(geometry) OWNER TO postgres;

--
-- TOC entry 396 (class 1255 OID 1898569)
-- Dependencies: 5 2106 2128
-- Name: pgis_geometry_accum_finalfn(pgis_abs); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pgis_geometry_accum_finalfn(pgis_abs) RETURNS geometry[]
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'pgis_geometry_accum_finalfn';


ALTER FUNCTION public.pgis_geometry_accum_finalfn(pgis_abs) OWNER TO postgres;

--
-- TOC entry 395 (class 1255 OID 1898568)
-- Dependencies: 5 2128 2128 2104
-- Name: pgis_geometry_accum_transfn(pgis_abs, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pgis_geometry_accum_transfn(pgis_abs, geometry) RETURNS pgis_abs
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'pgis_geometry_accum_transfn';


ALTER FUNCTION public.pgis_geometry_accum_transfn(pgis_abs, geometry) OWNER TO postgres;

--
-- TOC entry 398 (class 1255 OID 1898571)
-- Dependencies: 5 2104 2128
-- Name: pgis_geometry_collect_finalfn(pgis_abs); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pgis_geometry_collect_finalfn(pgis_abs) RETURNS geometry
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'pgis_geometry_collect_finalfn';


ALTER FUNCTION public.pgis_geometry_collect_finalfn(pgis_abs) OWNER TO postgres;

--
-- TOC entry 400 (class 1255 OID 1898573)
-- Dependencies: 5 2104 2128
-- Name: pgis_geometry_makeline_finalfn(pgis_abs); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pgis_geometry_makeline_finalfn(pgis_abs) RETURNS geometry
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'pgis_geometry_makeline_finalfn';


ALTER FUNCTION public.pgis_geometry_makeline_finalfn(pgis_abs) OWNER TO postgres;

--
-- TOC entry 399 (class 1255 OID 1898572)
-- Dependencies: 5 2104 2128
-- Name: pgis_geometry_polygonize_finalfn(pgis_abs); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pgis_geometry_polygonize_finalfn(pgis_abs) RETURNS geometry
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'pgis_geometry_polygonize_finalfn';


ALTER FUNCTION public.pgis_geometry_polygonize_finalfn(pgis_abs) OWNER TO postgres;

--
-- TOC entry 397 (class 1255 OID 1898570)
-- Dependencies: 5 2104 2128
-- Name: pgis_geometry_union_finalfn(pgis_abs); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pgis_geometry_union_finalfn(pgis_abs) RETURNS geometry
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'pgis_geometry_union_finalfn';


ALTER FUNCTION public.pgis_geometry_union_finalfn(pgis_abs) OWNER TO postgres;

--
-- TOC entry 952 (class 1255 OID 1898293)
-- Dependencies: 5 2104
-- Name: point_inside_circle(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION point_inside_circle(geometry, double precision, double precision, double precision) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_inside_circle_point';


ALTER FUNCTION public.point_inside_circle(geometry, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 543 (class 1255 OID 1898720)
-- Dependencies: 5 2104
-- Name: pointfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pointfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'POINT'
	THEN GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.pointfromtext(text) OWNER TO postgres;

--
-- TOC entry 545 (class 1255 OID 1898722)
-- Dependencies: 5 2104
-- Name: pointfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pointfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'POINT'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.pointfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 594 (class 1255 OID 1898771)
-- Dependencies: 5 2104
-- Name: pointfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pointfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'POINT'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.pointfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 592 (class 1255 OID 1898769)
-- Dependencies: 5 2104
-- Name: pointfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pointfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'POINT'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.pointfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 507 (class 1255 OID 1898684)
-- Dependencies: 5 2104 2104
-- Name: pointn(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pointn(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_pointn_linestring';


ALTER FUNCTION public.pointn(geometry, integer) OWNER TO postgres;

--
-- TOC entry 446 (class 1255 OID 1898624)
-- Dependencies: 5 2104 2104
-- Name: pointonsurface(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pointonsurface(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'pointonsurface';


ALTER FUNCTION public.pointonsurface(geometry) OWNER TO postgres;

--
-- TOC entry 553 (class 1255 OID 1898730)
-- Dependencies: 5 2104
-- Name: polyfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION polyfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'POLYGON'
	THEN GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.polyfromtext(text) OWNER TO postgres;

--
-- TOC entry 555 (class 1255 OID 1898732)
-- Dependencies: 5 2104
-- Name: polyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION polyfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'POLYGON'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.polyfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 606 (class 1255 OID 1898783)
-- Dependencies: 5 2104
-- Name: polyfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION polyfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'POLYGON'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.polyfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 604 (class 1255 OID 1898781)
-- Dependencies: 5 2104
-- Name: polyfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION polyfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'POLYGON'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.polyfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 559 (class 1255 OID 1898736)
-- Dependencies: 5 2104
-- Name: polygonfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION polygonfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT PolyFromText($1)$_$;


ALTER FUNCTION public.polygonfromtext(text) OWNER TO postgres;

--
-- TOC entry 557 (class 1255 OID 1898734)
-- Dependencies: 5 2104
-- Name: polygonfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION polygonfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT PolyFromText($1, $2)$_$;


ALTER FUNCTION public.polygonfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 610 (class 1255 OID 1898787)
-- Dependencies: 5 2104
-- Name: polygonfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION polygonfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'POLYGON'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.polygonfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 608 (class 1255 OID 1898785)
-- Dependencies: 5 2104
-- Name: polygonfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION polygonfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1,$2)) = 'POLYGON'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.polygonfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 1039 (class 1255 OID 1898379)
-- Dependencies: 5 2104 2106
-- Name: polygonize_garray(geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION polygonize_garray(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'polygonize_garray';


ALTER FUNCTION public.polygonize_garray(geometry[]) OWNER TO postgres;

--
-- TOC entry 1084 (class 1255 OID 1898429)
-- Dependencies: 5 2435
-- Name: populate_geometry_columns(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION populate_geometry_columns() RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	inserted    integer;
	oldcount    integer;
	probed      integer;
	stale       integer;
	gcs         RECORD;
	gc          RECORD;
	gsrid       integer;
	gndims      integer;
	gtype       text;
	query       text;
	gc_is_valid boolean;

BEGIN
	SELECT count(*) INTO oldcount FROM geometry_columns;
	inserted := 0;

	EXECUTE 'TRUNCATE geometry_columns';

	-- Count the number of geometry columns in all tables and views
	SELECT count(DISTINCT c.oid) INTO probed
	FROM pg_class c,
		 pg_attribute a,
		 pg_type t,
		 pg_namespace n
	WHERE (c.relkind = 'r' OR c.relkind = 'v')
	AND t.typname = 'geometry'
	AND a.attisdropped = false
	AND a.atttypid = t.oid
	AND a.attrelid = c.oid
	AND c.relnamespace = n.oid
	AND n.nspname NOT ILIKE 'pg_temp%';

	-- Iterate through all non-dropped geometry columns
	RAISE DEBUG 'Processing Tables.....';

	FOR gcs IN
	SELECT DISTINCT ON (c.oid) c.oid, n.nspname, c.relname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'r'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%'
	LOOP

	inserted := inserted + populate_geometry_columns(gcs.oid);
	END LOOP;

	-- Add views to geometry columns table
	RAISE DEBUG 'Processing Views.....';
	FOR gcs IN
	SELECT DISTINCT ON (c.oid) c.oid, n.nspname, c.relname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'v'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
	LOOP

	inserted := inserted + populate_geometry_columns(gcs.oid);
	END LOOP;

	IF oldcount > inserted THEN
	stale = oldcount-inserted;
	ELSE
	stale = 0;
	END IF;

	RETURN 'probed:' ||probed|| ' inserted:'||inserted|| ' conflicts:'||probed-inserted|| ' deleted:'||stale;
END

$$;


ALTER FUNCTION public.populate_geometry_columns() OWNER TO postgres;

--
-- TOC entry 1085 (class 1255 OID 1898430)
-- Dependencies: 5 2435
-- Name: populate_geometry_columns(oid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION populate_geometry_columns(tbl_oid oid) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	gcs         RECORD;
	gc          RECORD;
	gsrid       integer;
	gndims      integer;
	gtype       text;
	query       text;
	gc_is_valid boolean;
	inserted    integer;

BEGIN
	inserted := 0;

	-- Iterate through all geometry columns in this table
	FOR gcs IN
	SELECT n.nspname, c.relname, a.attname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'r'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%'
		AND c.oid = tbl_oid
	LOOP

	RAISE DEBUG 'Processing table %.%.%', gcs.nspname, gcs.relname, gcs.attname;

	DELETE FROM geometry_columns
	  WHERE f_table_schema = gcs.nspname
	  AND f_table_name = gcs.relname
	  AND f_geometry_column = gcs.attname;

	gc_is_valid := true;

	-- Try to find srid check from system tables (pg_constraint)
	gsrid :=
		(SELECT replace(replace(split_part(s.consrc, ' = ', 2), ')', ''), '(', '')
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = gcs.nspname
		 AND c.relname = gcs.relname
		 AND a.attname = gcs.attname
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%srid(% = %');
	IF (gsrid IS NULL) THEN
		-- Try to find srid from the geometry itself
		EXECUTE 'SELECT srid(' || quote_ident(gcs.attname) || ')
				 FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gsrid := gc.srid;

		-- Try to apply srid check to column
		IF (gsrid IS NOT NULL) THEN
			BEGIN
				EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
						 ADD CONSTRAINT ' || quote_ident('enforce_srid_' || gcs.attname) || '
						 CHECK (srid(' || quote_ident(gcs.attname) || ') = ' || gsrid || ')';
			EXCEPTION
				WHEN check_violation THEN
					RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (srid(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gsrid;
					gc_is_valid := false;
			END;
		END IF;
	END IF;

	-- Try to find ndims check from system tables (pg_constraint)
	gndims :=
		(SELECT replace(split_part(s.consrc, ' = ', 2), ')', '')
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = gcs.nspname
		 AND c.relname = gcs.relname
		 AND a.attname = gcs.attname
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%ndims(% = %');
	IF (gndims IS NULL) THEN
		-- Try to find ndims from the geometry itself
		EXECUTE 'SELECT ndims(' || quote_ident(gcs.attname) || ')
				 FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gndims := gc.ndims;

		-- Try to apply ndims check to column
		IF (gndims IS NOT NULL) THEN
			BEGIN
				EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
						 ADD CONSTRAINT ' || quote_ident('enforce_dims_' || gcs.attname) || '
						 CHECK (ndims(' || quote_ident(gcs.attname) || ') = '||gndims||')';
			EXCEPTION
				WHEN check_violation THEN
					RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (ndims(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gndims;
					gc_is_valid := false;
			END;
		END IF;
	END IF;

	-- Try to find geotype check from system tables (pg_constraint)
	gtype :=
		(SELECT replace(split_part(s.consrc, '''', 2), ')', '')
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = gcs.nspname
		 AND c.relname = gcs.relname
		 AND a.attname = gcs.attname
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%geometrytype(% = %');
	IF (gtype IS NULL) THEN
		-- Try to find geotype from the geometry itself
		EXECUTE 'SELECT geometrytype(' || quote_ident(gcs.attname) || ')
				 FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gtype := gc.geometrytype;
		--IF (gtype IS NULL) THEN
		--    gtype := 'GEOMETRY';
		--END IF;

		-- Try to apply geometrytype check to column
		IF (gtype IS NOT NULL) THEN
			BEGIN
				EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				ADD CONSTRAINT ' || quote_ident('enforce_geotype_' || gcs.attname) || '
				CHECK ((geometrytype(' || quote_ident(gcs.attname) || ') = ' || quote_literal(gtype) || ') OR (' || quote_ident(gcs.attname) || ' IS NULL))';
			EXCEPTION
				WHEN check_violation THEN
					-- No geometry check can be applied. This column contains a number of geometry types.
					RAISE WARNING 'Could not add geometry type check (%) to table column: %.%.%', gtype, quote_ident(gcs.nspname),quote_ident(gcs.relname),quote_ident(gcs.attname);
			END;
		END IF;
	END IF;

	IF (gsrid IS NULL) THEN
		RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine the srid', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
	ELSIF (gndims IS NULL) THEN
		RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine the number of dimensions', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
	ELSIF (gtype IS NULL) THEN
		RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine the geometry type', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
	ELSE
		-- Only insert into geometry_columns if table constraints could be applied.
		IF (gc_is_valid) THEN
			INSERT INTO geometry_columns (f_table_catalog,f_table_schema, f_table_name, f_geometry_column, coord_dimension, srid, type)
			VALUES ('', gcs.nspname, gcs.relname, gcs.attname, gndims, gsrid, gtype);
			inserted := inserted + 1;
		END IF;
	END IF;
	END LOOP;

	-- Add views to geometry columns table
	FOR gcs IN
	SELECT n.nspname, c.relname, a.attname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'v'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%'
		AND c.oid = tbl_oid
	LOOP
		RAISE DEBUG 'Processing view %.%.%', gcs.nspname, gcs.relname, gcs.attname;

	DELETE FROM geometry_columns
	  WHERE f_table_schema = gcs.nspname
	  AND f_table_name = gcs.relname
	  AND f_geometry_column = gcs.attname;
	  
		EXECUTE 'SELECT ndims(' || quote_ident(gcs.attname) || ')
				 FROM ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gndims := gc.ndims;

		EXECUTE 'SELECT srid(' || quote_ident(gcs.attname) || ')
				 FROM ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gsrid := gc.srid;

		EXECUTE 'SELECT geometrytype(' || quote_ident(gcs.attname) || ')
				 FROM ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gtype := gc.geometrytype;

		IF (gndims IS NULL) THEN
			RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine ndims', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
		ELSIF (gsrid IS NULL) THEN
			RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine srid', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
		ELSIF (gtype IS NULL) THEN
			RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine gtype', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
		ELSE
			query := 'INSERT INTO geometry_columns (f_table_catalog,f_table_schema, f_table_name, f_geometry_column, coord_dimension, srid, type) ' ||
					 'VALUES ('''', ' || quote_literal(gcs.nspname) || ',' || quote_literal(gcs.relname) || ',' || quote_literal(gcs.attname) || ',' || gndims || ',' || gsrid || ',' || quote_literal(gtype) || ')';
			EXECUTE query;
			inserted := inserted + 1;
		END IF;
	END LOOP;

	RETURN inserted;
END

$$;


ALTER FUNCTION public.populate_geometry_columns(tbl_oid oid) OWNER TO postgres;

--
-- TOC entry 893 (class 1255 OID 1898234)
-- Dependencies: 5 2104 2104
-- Name: postgis_addbbox(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_addbbox(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_addBBOX';


ALTER FUNCTION public.postgis_addbbox(geometry) OWNER TO postgres;

--
-- TOC entry 1004 (class 1255 OID 1898344)
-- Dependencies: 5
-- Name: postgis_cache_bbox(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_cache_bbox() RETURNS trigger
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'cache_bbox';


ALTER FUNCTION public.postgis_cache_bbox() OWNER TO postgres;

--
-- TOC entry 895 (class 1255 OID 1898236)
-- Dependencies: 5 2104 2104
-- Name: postgis_dropbbox(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_dropbbox(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dropBBOX';


ALTER FUNCTION public.postgis_dropbbox(geometry) OWNER TO postgres;

--
-- TOC entry 774 (class 1255 OID 1898460)
-- Dependencies: 5 2435
-- Name: postgis_full_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	projver text;
	geosver text;
	libxmlver text;
	usestats bool;
	dbproc text;
	relproc text;
	fullver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_libxml_version() INTO libxmlver;
	SELECT postgis_uses_stats() INTO usestats;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;

	fullver = 'POSTGIS="' || libver || '"';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS="' || geosver || '"';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ="' || projver || '"';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML="' || libxmlver || '"';
	END IF;

	IF usestats THEN
		fullver = fullver || ' USE_STATS';
	END IF;

	-- fullver = fullver || ' DBPROC="' || dbproc || '"';
	-- fullver = fullver || ' RELPROC="' || relproc || '"';

	IF dbproc != relproc THEN
		fullver = fullver || ' (procs from ' || dbproc || ' need upgrade)';
	END IF;

	RETURN fullver;
END
$$;


ALTER FUNCTION public.postgis_full_version() OWNER TO postgres;

--
-- TOC entry 1092 (class 1255 OID 1898456)
-- Dependencies: 5
-- Name: postgis_geos_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_geos_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'postgis_geos_version';


ALTER FUNCTION public.postgis_geos_version() OWNER TO postgres;

--
-- TOC entry 898 (class 1255 OID 1898239)
-- Dependencies: 5 2117 2104
-- Name: postgis_getbbox(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_getbbox(geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_BOX2DFLOAT4';


ALTER FUNCTION public.postgis_getbbox(geometry) OWNER TO postgres;

--
-- TOC entry 855 (class 1255 OID 1898163)
-- Dependencies: 5
-- Name: postgis_gist_joinsel(internal, oid, internal, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_gist_joinsel(internal, oid, internal, smallint) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_joinsel';


ALTER FUNCTION public.postgis_gist_joinsel(internal, oid, internal, smallint) OWNER TO postgres;

--
-- TOC entry 854 (class 1255 OID 1898162)
-- Dependencies: 5
-- Name: postgis_gist_sel(internal, oid, internal, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_gist_sel(internal, oid, internal, integer) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_sel';


ALTER FUNCTION public.postgis_gist_sel(internal, oid, internal, integer) OWNER TO postgres;

--
-- TOC entry 900 (class 1255 OID 1898241)
-- Dependencies: 5 2104
-- Name: postgis_hasbbox(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_hasbbox(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_hasBBOX';


ALTER FUNCTION public.postgis_hasbbox(geometry) OWNER TO postgres;

--
-- TOC entry 1095 (class 1255 OID 1898459)
-- Dependencies: 5
-- Name: postgis_lib_build_date(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_lib_build_date() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'postgis_lib_build_date';


ALTER FUNCTION public.postgis_lib_build_date() OWNER TO postgres;

--
-- TOC entry 1114 (class 1255 OID 1898453)
-- Dependencies: 5
-- Name: postgis_lib_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_lib_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'postgis_lib_version';


ALTER FUNCTION public.postgis_lib_version() OWNER TO postgres;

--
-- TOC entry 1093 (class 1255 OID 1898457)
-- Dependencies: 5
-- Name: postgis_libxml_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_libxml_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'postgis_libxml_version';


ALTER FUNCTION public.postgis_libxml_version() OWNER TO postgres;

--
-- TOC entry 984 (class 1255 OID 1898325)
-- Dependencies: 5 2104 2104
-- Name: postgis_noop(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_noop(geometry) RETURNS geometry
    LANGUAGE c STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_noop';


ALTER FUNCTION public.postgis_noop(geometry) OWNER TO postgres;

--
-- TOC entry 1112 (class 1255 OID 1898451)
-- Dependencies: 5
-- Name: postgis_proj_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_proj_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'postgis_proj_version';


ALTER FUNCTION public.postgis_proj_version() OWNER TO postgres;

--
-- TOC entry 1094 (class 1255 OID 1898458)
-- Dependencies: 5
-- Name: postgis_scripts_build_date(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_scripts_build_date() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$SELECT '2011-09-12 18:37:35'::text AS version$$;


ALTER FUNCTION public.postgis_scripts_build_date() OWNER TO postgres;

--
-- TOC entry 1113 (class 1255 OID 1898452)
-- Dependencies: 5
-- Name: postgis_scripts_installed(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_scripts_installed() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$SELECT '1.5 r7360'::text AS version$$;


ALTER FUNCTION public.postgis_scripts_installed() OWNER TO postgres;

--
-- TOC entry 1090 (class 1255 OID 1898454)
-- Dependencies: 5
-- Name: postgis_scripts_released(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_scripts_released() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'postgis_scripts_released';


ALTER FUNCTION public.postgis_scripts_released() OWNER TO postgres;

--
-- TOC entry 1108 (class 1255 OID 1898447)
-- Dependencies: 5 2104 2104
-- Name: postgis_transform_geometry(geometry, text, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_transform_geometry(geometry, text, text, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'transform_geom';


ALTER FUNCTION public.postgis_transform_geometry(geometry, text, text, integer) OWNER TO postgres;

--
-- TOC entry 1091 (class 1255 OID 1898455)
-- Dependencies: 5
-- Name: postgis_uses_stats(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_uses_stats() RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'postgis_uses_stats';


ALTER FUNCTION public.postgis_uses_stats() OWNER TO postgres;

--
-- TOC entry 1111 (class 1255 OID 1898450)
-- Dependencies: 5
-- Name: postgis_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION postgis_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'postgis_version';


ALTER FUNCTION public.postgis_version() OWNER TO postgres;

--
-- TOC entry 1086 (class 1255 OID 1898432)
-- Dependencies: 5 2435
-- Name: probe_geometry_columns(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION probe_geometry_columns() RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	inserted integer;
	oldcount integer;
	probed integer;
	stale integer;
BEGIN

	SELECT count(*) INTO oldcount FROM geometry_columns;

	SELECT count(*) INTO probed
		FROM pg_class c, pg_attribute a, pg_type t,
			pg_namespace n,
			pg_constraint sridcheck, pg_constraint typecheck

		WHERE t.typname = 'geometry'
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND sridcheck.connamespace = n.oid
		AND typecheck.connamespace = n.oid
		AND sridcheck.conrelid = c.oid
		AND sridcheck.consrc LIKE '(srid('||a.attname||') = %)'
		AND typecheck.conrelid = c.oid
		AND typecheck.consrc LIKE
		'((geometrytype('||a.attname||') = ''%''::text) OR (% IS NULL))'
		;

	INSERT INTO geometry_columns SELECT
		''::varchar as f_table_catalogue,
		n.nspname::varchar as f_table_schema,
		c.relname::varchar as f_table_name,
		a.attname::varchar as f_geometry_column,
		2 as coord_dimension,
		trim(both  ' =)' from
			replace(replace(split_part(
				sridcheck.consrc, ' = ', 2), ')', ''), '(', ''))::integer AS srid,
		trim(both ' =)''' from substr(typecheck.consrc,
			strpos(typecheck.consrc, '='),
			strpos(typecheck.consrc, '::')-
			strpos(typecheck.consrc, '=')
			))::varchar as type
		FROM pg_class c, pg_attribute a, pg_type t,
			pg_namespace n,
			pg_constraint sridcheck, pg_constraint typecheck
		WHERE t.typname = 'geometry'
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND sridcheck.connamespace = n.oid
		AND typecheck.connamespace = n.oid
		AND sridcheck.conrelid = c.oid
		AND sridcheck.consrc LIKE '(st_srid('||a.attname||') = %)'
		AND typecheck.conrelid = c.oid
		AND typecheck.consrc LIKE
		'((geometrytype('||a.attname||') = ''%''::text) OR (% IS NULL))'

			AND NOT EXISTS (
					SELECT oid FROM geometry_columns gc
					WHERE c.relname::varchar = gc.f_table_name
					AND n.nspname::varchar = gc.f_table_schema
					AND a.attname::varchar = gc.f_geometry_column
			);

	GET DIAGNOSTICS inserted = ROW_COUNT;

	IF oldcount > probed THEN
		stale = oldcount-probed;
	ELSE
		stale = 0;
	END IF;

	RETURN 'probed:'||probed::text||
		' inserted:'||inserted::text||
		' conflicts:'||(probed-inserted)::text||
		' stale:'||stale::text;
END

$$;


ALTER FUNCTION public.probe_geometry_columns() OWNER TO postgres;

--
-- TOC entry 1222 (class 1255 OID 2964521)
-- Dependencies: 5 2009
-- Name: querytree(query_int); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION querytree(query_int) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'querytree';


ALTER FUNCTION public.querytree(query_int) OWNER TO postgres;

--
-- TOC entry 1224 (class 1255 OID 2964523)
-- Dependencies: 2009 5
-- Name: rboolop(query_int, integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION rboolop(query_int, integer[]) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'rboolop';


ALTER FUNCTION public.rboolop(query_int, integer[]) OWNER TO postgres;

--
-- TOC entry 5975 (class 0 OID 0)
-- Dependencies: 1224
-- Name: FUNCTION rboolop(query_int, integer[]); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION rboolop(query_int, integer[]) IS 'boolean operation with array';


--
-- TOC entry 405 (class 1255 OID 1898586)
-- Dependencies: 5 2104 2104
-- Name: relate(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION relate(geometry, geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'relate_full';


ALTER FUNCTION public.relate(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 407 (class 1255 OID 1898588)
-- Dependencies: 5 2104 2104
-- Name: relate(geometry, geometry, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION relate(geometry, geometry, text) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'relate_pattern';


ALTER FUNCTION public.relate(geometry, geometry, text) OWNER TO postgres;

--
-- TOC entry 1028 (class 1255 OID 1898368)
-- Dependencies: 5 2104 2104
-- Name: removepoint(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION removepoint(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_removepoint';


ALTER FUNCTION public.removepoint(geometry, integer) OWNER TO postgres;

--
-- TOC entry 1064 (class 1255 OID 1898427)
-- Dependencies: 5
-- Name: rename_geometry_table_constraints(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION rename_geometry_table_constraints() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$
SELECT 'rename_geometry_table_constraint() is obsoleted'::text
$$;


ALTER FUNCTION public.rename_geometry_table_constraints() OWNER TO postgres;

--
-- TOC entry 979 (class 1255 OID 1898320)
-- Dependencies: 5 2104 2104
-- Name: reverse(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION reverse(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_reverse';


ALTER FUNCTION public.reverse(geometry) OWNER TO postgres;

--
-- TOC entry 795 (class 1255 OID 1898082)
-- Dependencies: 5 2104 2104
-- Name: rotate(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION rotate(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT rotateZ($1, $2)$_$;


ALTER FUNCTION public.rotate(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 797 (class 1255 OID 1898084)
-- Dependencies: 5 2104 2104
-- Name: rotatex(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION rotatex(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1, 1, 0, 0, 0, cos($2), -sin($2), 0, sin($2), cos($2), 0, 0, 0)$_$;


ALTER FUNCTION public.rotatex(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 799 (class 1255 OID 1898086)
-- Dependencies: 5 2104 2104
-- Name: rotatey(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION rotatey(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  cos($2), 0, sin($2),  0, 1, 0,  -sin($2), 0, cos($2), 0,  0, 0)$_$;


ALTER FUNCTION public.rotatey(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 793 (class 1255 OID 1898080)
-- Dependencies: 5 2104 2104
-- Name: rotatez(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION rotatez(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  cos($2), -sin($2), 0,  sin($2), cos($2), 0,  0, 0, 1,  0, 0, 0)$_$;


ALTER FUNCTION public.rotatez(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 807 (class 1255 OID 1898094)
-- Dependencies: 5 2104 2104
-- Name: scale(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION scale(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT scale($1, $2, $3, 1)$_$;


ALTER FUNCTION public.scale(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 805 (class 1255 OID 1898092)
-- Dependencies: 5 2104 2104
-- Name: scale(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION scale(geometry, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  $2, 0, 0,  0, $3, 0,  0, 0, $4,  0, 0, 0)$_$;


ALTER FUNCTION public.scale(geometry, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 679 (class 1255 OID 1898853)
-- Dependencies: 5 2104 2104
-- Name: se_envelopesintersect(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION se_envelopesintersect(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ 
	SELECT $1 && $2
	$_$;


ALTER FUNCTION public.se_envelopesintersect(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 673 (class 1255 OID 1898847)
-- Dependencies: 5 2104
-- Name: se_is3d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION se_is3d(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_hasz';


ALTER FUNCTION public.se_is3d(geometry) OWNER TO postgres;

--
-- TOC entry 674 (class 1255 OID 1898848)
-- Dependencies: 2104 5
-- Name: se_ismeasured(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION se_ismeasured(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_hasm';


ALTER FUNCTION public.se_ismeasured(geometry) OWNER TO postgres;

--
-- TOC entry 680 (class 1255 OID 1898854)
-- Dependencies: 5 2104 2104
-- Name: se_locatealong(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION se_locatealong(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT locate_between_measures($1, $2, $2) $_$;


ALTER FUNCTION public.se_locatealong(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 681 (class 1255 OID 1898855)
-- Dependencies: 5 2104 2104
-- Name: se_locatebetween(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION se_locatebetween(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_locate_between_m';


ALTER FUNCTION public.se_locatebetween(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 677 (class 1255 OID 1898851)
-- Dependencies: 5 2104
-- Name: se_m(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION se_m(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_m_point';


ALTER FUNCTION public.se_m(geometry) OWNER TO postgres;

--
-- TOC entry 676 (class 1255 OID 1898850)
-- Dependencies: 2104 5
-- Name: se_z(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION se_z(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_z_point';


ALTER FUNCTION public.se_z(geometry) OWNER TO postgres;

--
-- TOC entry 351 (class 1255 OID 1898517)
-- Dependencies: 5 2104 2104
-- Name: segmentize(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION segmentize(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_segmentize2d';


ALTER FUNCTION public.segmentize(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 914 (class 1255 OID 1898255)
-- Dependencies: 5 2114 2114
-- Name: setfactor(chip, real); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION setfactor(chip, real) RETURNS chip
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_setFactor';


ALTER FUNCTION public.setfactor(chip, real) OWNER TO postgres;

--
-- TOC entry 1030 (class 1255 OID 1898370)
-- Dependencies: 5 2104 2104 2104
-- Name: setpoint(geometry, integer, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION setpoint(geometry, integer, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_setpoint_linestring';


ALTER FUNCTION public.setpoint(geometry, integer, geometry) OWNER TO postgres;

--
-- TOC entry 913 (class 1255 OID 1898254)
-- Dependencies: 5 2114 2114
-- Name: setsrid(chip, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION setsrid(chip, integer) RETURNS chip
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_setSRID';


ALTER FUNCTION public.setsrid(chip, integer) OWNER TO postgres;

--
-- TOC entry 527 (class 1255 OID 1898704)
-- Dependencies: 5 2104 2104
-- Name: setsrid(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION setsrid(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_setSRID';


ALTER FUNCTION public.setsrid(geometry, integer) OWNER TO postgres;

--
-- TOC entry 811 (class 1255 OID 1898098)
-- Dependencies: 5 2104 2104
-- Name: shift_longitude(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION shift_longitude(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_longitude_shift';


ALTER FUNCTION public.shift_longitude(geometry) OWNER TO postgres;

--
-- TOC entry 339 (class 1255 OID 1898507)
-- Dependencies: 5 2104 2104
-- Name: simplify(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION simplify(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_simplify2d';


ALTER FUNCTION public.simplify(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 345 (class 1255 OID 1898513)
-- Dependencies: 5 2104 2104
-- Name: snaptogrid(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION snaptogrid(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT SnapToGrid($1, 0, 0, $2, $2)$_$;


ALTER FUNCTION public.snaptogrid(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 343 (class 1255 OID 1898511)
-- Dependencies: 5 2104 2104
-- Name: snaptogrid(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION snaptogrid(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT SnapToGrid($1, 0, 0, $2, $3)$_$;


ALTER FUNCTION public.snaptogrid(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 341 (class 1255 OID 1898509)
-- Dependencies: 5 2104 2104
-- Name: snaptogrid(geometry, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION snaptogrid(geometry, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_snaptogrid';


ALTER FUNCTION public.snaptogrid(geometry, double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 349 (class 1255 OID 1898515)
-- Dependencies: 5 2104 2104 2104
-- Name: snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_snaptogrid_pointoff';


ALTER FUNCTION public.snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 1234 (class 1255 OID 2964542)
-- Dependencies: 5
-- Name: sort(integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION sort(integer[]) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'sort';


ALTER FUNCTION public.sort(integer[]) OWNER TO postgres;

--
-- TOC entry 1233 (class 1255 OID 2964541)
-- Dependencies: 5
-- Name: sort(integer[], text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION sort(integer[], text) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'sort';


ALTER FUNCTION public.sort(integer[], text) OWNER TO postgres;

--
-- TOC entry 1235 (class 1255 OID 2964543)
-- Dependencies: 5
-- Name: sort_asc(integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION sort_asc(integer[]) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'sort_asc';


ALTER FUNCTION public.sort_asc(integer[]) OWNER TO postgres;

--
-- TOC entry 1236 (class 1255 OID 2964544)
-- Dependencies: 5
-- Name: sort_desc(integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION sort_desc(integer[]) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'sort_desc';


ALTER FUNCTION public.sort_desc(integer[]) OWNER TO postgres;

--
-- TOC entry 901 (class 1255 OID 1898242)
-- Dependencies: 5 2114
-- Name: srid(chip); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION srid(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getSRID';


ALTER FUNCTION public.srid(chip) OWNER TO postgres;

--
-- TOC entry 525 (class 1255 OID 1898702)
-- Dependencies: 5 2104
-- Name: srid(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION srid(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_getSRID';


ALTER FUNCTION public.srid(geometry) OWNER TO postgres;

--
-- TOC entry 361 (class 1255 OID 1898529)
-- Dependencies: 5 2104 2104
-- Name: st_addmeasure(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_addmeasure(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ST_AddMeasure';


ALTER FUNCTION public.st_addmeasure(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 1025 (class 1255 OID 1898365)
-- Dependencies: 5 2104 2104 2104
-- Name: st_addpoint(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_addpoint(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_addpoint';


ALTER FUNCTION public.st_addpoint(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1027 (class 1255 OID 1898367)
-- Dependencies: 5 2104 2104 2104
-- Name: st_addpoint(geometry, geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_addpoint(geometry, geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_addpoint';


ALTER FUNCTION public.st_addpoint(geometry, geometry, integer) OWNER TO postgres;

--
-- TOC entry 792 (class 1255 OID 1898079)
-- Dependencies: 5 2104 2104
-- Name: st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  $2, $3, 0,  $4, $5, 0,  0, 0, 1,  $6, $7, 0)$_$;


ALTER FUNCTION public.st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 790 (class 1255 OID 1898077)
-- Dependencies: 5 2104 2104
-- Name: st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_affine';


ALTER FUNCTION public.st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 945 (class 1255 OID 1898286)
-- Dependencies: 5 2104
-- Name: st_area(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_area(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_area_polygon';


ALTER FUNCTION public.st_area(geometry) OWNER TO postgres;

--
-- TOC entry 753 (class 1255 OID 1898964)
-- Dependencies: 5 2131
-- Name: st_area(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_area(geography) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_Area($1, true)$_$;


ALTER FUNCTION public.st_area(geography) OWNER TO postgres;

--
-- TOC entry 754 (class 1255 OID 1898965)
-- Dependencies: 5
-- Name: st_area(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_area(text) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Area($1::geometry);  $_$;


ALTER FUNCTION public.st_area(text) OWNER TO postgres;

--
-- TOC entry 752 (class 1255 OID 1898963)
-- Dependencies: 5 2131
-- Name: st_area(geography, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_area(geography, boolean) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'geography_area';


ALTER FUNCTION public.st_area(geography, boolean) OWNER TO postgres;

--
-- TOC entry 943 (class 1255 OID 1898284)
-- Dependencies: 5 2104
-- Name: st_area2d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_area2d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_area_polygon';


ALTER FUNCTION public.st_area2d(geometry) OWNER TO postgres;

--
-- TOC entry 530 (class 1255 OID 1898707)
-- Dependencies: 5 2104
-- Name: st_asbinary(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asbinary(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asBinary';


ALTER FUNCTION public.st_asbinary(geometry) OWNER TO postgres;

--
-- TOC entry 693 (class 1255 OID 1898873)
-- Dependencies: 5 2131
-- Name: st_asbinary(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asbinary(geography) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_as_binary';


ALTER FUNCTION public.st_asbinary(geography) OWNER TO postgres;

--
-- TOC entry 694 (class 1255 OID 1898874)
-- Dependencies: 5
-- Name: st_asbinary(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asbinary(text) RETURNS bytea
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsBinary($1::geometry);  $_$;


ALTER FUNCTION public.st_asbinary(text) OWNER TO postgres;

--
-- TOC entry 532 (class 1255 OID 1898709)
-- Dependencies: 5 2104
-- Name: st_asbinary(geometry, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asbinary(geometry, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asBinary';


ALTER FUNCTION public.st_asbinary(geometry, text) OWNER TO postgres;

--
-- TOC entry 993 (class 1255 OID 1898333)
-- Dependencies: 5 2104
-- Name: st_asewkb(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asewkb(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'WKBFromLWGEOM';


ALTER FUNCTION public.st_asewkb(geometry) OWNER TO postgres;

--
-- TOC entry 999 (class 1255 OID 1898339)
-- Dependencies: 5 2104
-- Name: st_asewkb(geometry, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asewkb(geometry, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'WKBFromLWGEOM';


ALTER FUNCTION public.st_asewkb(geometry, text) OWNER TO postgres;

--
-- TOC entry 989 (class 1255 OID 1898331)
-- Dependencies: 5 2104
-- Name: st_asewkt(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asewkt(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asEWKT';


ALTER FUNCTION public.st_asewkt(geometry) OWNER TO postgres;

--
-- TOC entry 482 (class 1255 OID 1898659)
-- Dependencies: 5 2104
-- Name: st_asgeojson(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson(1, $1, 15, 0)$_$;


ALTER FUNCTION public.st_asgeojson(geometry) OWNER TO postgres;

--
-- TOC entry 743 (class 1255 OID 1898948)
-- Dependencies: 5 2131
-- Name: st_asgeojson(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(geography) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson(1, $1, 15, 0)$_$;


ALTER FUNCTION public.st_asgeojson(geography) OWNER TO postgres;

--
-- TOC entry 744 (class 1255 OID 1898949)
-- Dependencies: 5
-- Name: st_asgeojson(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsGeoJson($1::geometry);  $_$;


ALTER FUNCTION public.st_asgeojson(text) OWNER TO postgres;

--
-- TOC entry 481 (class 1255 OID 1898658)
-- Dependencies: 5 2104
-- Name: st_asgeojson(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson(1, $1, $2, 0)$_$;


ALTER FUNCTION public.st_asgeojson(geometry, integer) OWNER TO postgres;

--
-- TOC entry 483 (class 1255 OID 1898660)
-- Dependencies: 5 2104
-- Name: st_asgeojson(integer, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(integer, geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson($1, $2, 15, 0)$_$;


ALTER FUNCTION public.st_asgeojson(integer, geometry) OWNER TO postgres;

--
-- TOC entry 736 (class 1255 OID 1898947)
-- Dependencies: 5 2131
-- Name: st_asgeojson(geography, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(geography, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson(1, $1, $2, 0)$_$;


ALTER FUNCTION public.st_asgeojson(geography, integer) OWNER TO postgres;

--
-- TOC entry 737 (class 1255 OID 1898950)
-- Dependencies: 5 2131
-- Name: st_asgeojson(integer, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(integer, geography) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson($1, $2, 15, 0)$_$;


ALTER FUNCTION public.st_asgeojson(integer, geography) OWNER TO postgres;

--
-- TOC entry 484 (class 1255 OID 1898661)
-- Dependencies: 5 2104
-- Name: st_asgeojson(integer, geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(integer, geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson($1, $2, $3, 0)$_$;


ALTER FUNCTION public.st_asgeojson(integer, geometry, integer) OWNER TO postgres;

--
-- TOC entry 485 (class 1255 OID 1898662)
-- Dependencies: 5 2104
-- Name: st_asgeojson(geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(geometry, integer, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson(1, $1, $2, $3)$_$;


ALTER FUNCTION public.st_asgeojson(geometry, integer, integer) OWNER TO postgres;

--
-- TOC entry 738 (class 1255 OID 1898951)
-- Dependencies: 2131 5
-- Name: st_asgeojson(integer, geography, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(integer, geography, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson($1, $2, $3, 0)$_$;


ALTER FUNCTION public.st_asgeojson(integer, geography, integer) OWNER TO postgres;

--
-- TOC entry 739 (class 1255 OID 1898952)
-- Dependencies: 5 2131
-- Name: st_asgeojson(geography, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(geography, integer, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson(1, $1, $2, $3)$_$;


ALTER FUNCTION public.st_asgeojson(geography, integer, integer) OWNER TO postgres;

--
-- TOC entry 486 (class 1255 OID 1898663)
-- Dependencies: 5 2104
-- Name: st_asgeojson(integer, geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(integer, geometry, integer, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson($1, $2, $3, $4)$_$;


ALTER FUNCTION public.st_asgeojson(integer, geometry, integer, integer) OWNER TO postgres;

--
-- TOC entry 740 (class 1255 OID 1898953)
-- Dependencies: 5 2131
-- Name: st_asgeojson(integer, geography, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgeojson(integer, geography, integer, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson($1, $2, $3, $4)$_$;


ALTER FUNCTION public.st_asgeojson(integer, geography, integer, integer) OWNER TO postgres;

--
-- TOC entry 467 (class 1255 OID 1898644)
-- Dependencies: 5 2104
-- Name: st_asgml(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, 15, 0)$_$;


ALTER FUNCTION public.st_asgml(geometry) OWNER TO postgres;

--
-- TOC entry 729 (class 1255 OID 1898934)
-- Dependencies: 5 2131
-- Name: st_asgml(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(geography) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, 15, 0)$_$;


ALTER FUNCTION public.st_asgml(geography) OWNER TO postgres;

--
-- TOC entry 730 (class 1255 OID 1898935)
-- Dependencies: 5
-- Name: st_asgml(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsGML($1::geometry);  $_$;


ALTER FUNCTION public.st_asgml(text) OWNER TO postgres;

--
-- TOC entry 465 (class 1255 OID 1898642)
-- Dependencies: 5 2104
-- Name: st_asgml(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, $2, 0)$_$;


ALTER FUNCTION public.st_asgml(geometry, integer) OWNER TO postgres;

--
-- TOC entry 468 (class 1255 OID 1898645)
-- Dependencies: 5 2104
-- Name: st_asgml(integer, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(integer, geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML($1, $2, 15, 0)$_$;


ALTER FUNCTION public.st_asgml(integer, geometry) OWNER TO postgres;

--
-- TOC entry 728 (class 1255 OID 1898933)
-- Dependencies: 5 2131
-- Name: st_asgml(geography, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(geography, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, $2, 0)$_$;


ALTER FUNCTION public.st_asgml(geography, integer) OWNER TO postgres;

--
-- TOC entry 731 (class 1255 OID 1898936)
-- Dependencies: 2131 5
-- Name: st_asgml(integer, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(integer, geography) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML($1, $2, 15, 0)$_$;


ALTER FUNCTION public.st_asgml(integer, geography) OWNER TO postgres;

--
-- TOC entry 469 (class 1255 OID 1898646)
-- Dependencies: 5 2104
-- Name: st_asgml(integer, geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(integer, geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML($1, $2, $3, 0)$_$;


ALTER FUNCTION public.st_asgml(integer, geometry, integer) OWNER TO postgres;

--
-- TOC entry 470 (class 1255 OID 1898647)
-- Dependencies: 5 2104
-- Name: st_asgml(geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(geometry, integer, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, $2, $3)$_$;


ALTER FUNCTION public.st_asgml(geometry, integer, integer) OWNER TO postgres;

--
-- TOC entry 701 (class 1255 OID 1898937)
-- Dependencies: 5 2131
-- Name: st_asgml(integer, geography, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(integer, geography, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML($1, $2, $3, 0)$_$;


ALTER FUNCTION public.st_asgml(integer, geography, integer) OWNER TO postgres;

--
-- TOC entry 702 (class 1255 OID 1898938)
-- Dependencies: 2131 5
-- Name: st_asgml(geography, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(geography, integer, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, $2, $3)$_$;


ALTER FUNCTION public.st_asgml(geography, integer, integer) OWNER TO postgres;

--
-- TOC entry 471 (class 1255 OID 1898648)
-- Dependencies: 5 2104
-- Name: st_asgml(integer, geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(integer, geometry, integer, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML($1, $2, $3, $4)$_$;


ALTER FUNCTION public.st_asgml(integer, geometry, integer, integer) OWNER TO postgres;

--
-- TOC entry 703 (class 1255 OID 1898939)
-- Dependencies: 5 2131
-- Name: st_asgml(integer, geography, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_asgml(integer, geography, integer, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML($1, $2, $3, $4)$_$;


ALTER FUNCTION public.st_asgml(integer, geography, integer, integer) OWNER TO postgres;

--
-- TOC entry 995 (class 1255 OID 1898335)
-- Dependencies: 5 2104
-- Name: st_ashexewkb(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_ashexewkb(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asHEXEWKB';


ALTER FUNCTION public.st_ashexewkb(geometry) OWNER TO postgres;

--
-- TOC entry 997 (class 1255 OID 1898337)
-- Dependencies: 5 2104
-- Name: st_ashexewkb(geometry, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_ashexewkb(geometry, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asHEXEWKB';


ALTER FUNCTION public.st_ashexewkb(geometry, text) OWNER TO postgres;

--
-- TOC entry 477 (class 1255 OID 1898654)
-- Dependencies: 5 2104
-- Name: st_askml(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_askml(geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML(2, ST_Transform($1,4326), 15)$_$;


ALTER FUNCTION public.st_askml(geometry) OWNER TO postgres;

--
-- TOC entry 723 (class 1255 OID 1898942)
-- Dependencies: 2131 5
-- Name: st_askml(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_askml(geography) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML(2, $1, 15)$_$;


ALTER FUNCTION public.st_askml(geography) OWNER TO postgres;

--
-- TOC entry 732 (class 1255 OID 1898943)
-- Dependencies: 5
-- Name: st_askml(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_askml(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsKML($1::geometry);  $_$;


ALTER FUNCTION public.st_askml(text) OWNER TO postgres;

--
-- TOC entry 474 (class 1255 OID 1898651)
-- Dependencies: 5 2104
-- Name: st_askml(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_askml(geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML(2, ST_Transform($1,4326), $2)$_$;


ALTER FUNCTION public.st_askml(geometry, integer) OWNER TO postgres;

--
-- TOC entry 478 (class 1255 OID 1898655)
-- Dependencies: 5 2104
-- Name: st_askml(integer, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_askml(integer, geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML($1, ST_Transform($2,4326), 15)$_$;


ALTER FUNCTION public.st_askml(integer, geometry) OWNER TO postgres;

--
-- TOC entry 721 (class 1255 OID 1898941)
-- Dependencies: 5 2131
-- Name: st_askml(geography, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_askml(geography, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML(2, $1, $2)$_$;


ALTER FUNCTION public.st_askml(geography, integer) OWNER TO postgres;

--
-- TOC entry 733 (class 1255 OID 1898944)
-- Dependencies: 5 2131
-- Name: st_askml(integer, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_askml(integer, geography) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML($1, $2, 15)$_$;


ALTER FUNCTION public.st_askml(integer, geography) OWNER TO postgres;

--
-- TOC entry 479 (class 1255 OID 1898656)
-- Dependencies: 5 2104
-- Name: st_askml(integer, geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_askml(integer, geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML($1, ST_Transform($2,4326), $3)$_$;


ALTER FUNCTION public.st_askml(integer, geometry, integer) OWNER TO postgres;

--
-- TOC entry 734 (class 1255 OID 1898945)
-- Dependencies: 5 2131
-- Name: st_askml(integer, geography, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_askml(integer, geography, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML($1, $2, $3)$_$;


ALTER FUNCTION public.st_askml(integer, geography, integer) OWNER TO postgres;

--
-- TOC entry 462 (class 1255 OID 1898639)
-- Dependencies: 5 2104
-- Name: st_assvg(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_assvg(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'assvg_geometry';


ALTER FUNCTION public.st_assvg(geometry) OWNER TO postgres;

--
-- TOC entry 725 (class 1255 OID 1898930)
-- Dependencies: 5 2131
-- Name: st_assvg(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_assvg(geography) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_as_svg';


ALTER FUNCTION public.st_assvg(geography) OWNER TO postgres;

--
-- TOC entry 726 (class 1255 OID 1898931)
-- Dependencies: 5
-- Name: st_assvg(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_assvg(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsSVG($1::geometry);  $_$;


ALTER FUNCTION public.st_assvg(text) OWNER TO postgres;

--
-- TOC entry 460 (class 1255 OID 1898637)
-- Dependencies: 5 2104
-- Name: st_assvg(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_assvg(geometry, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'assvg_geometry';


ALTER FUNCTION public.st_assvg(geometry, integer) OWNER TO postgres;

--
-- TOC entry 724 (class 1255 OID 1898929)
-- Dependencies: 5 2131
-- Name: st_assvg(geography, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_assvg(geography, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_as_svg';


ALTER FUNCTION public.st_assvg(geography, integer) OWNER TO postgres;

--
-- TOC entry 458 (class 1255 OID 1898635)
-- Dependencies: 5 2104
-- Name: st_assvg(geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_assvg(geometry, integer, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'assvg_geometry';


ALTER FUNCTION public.st_assvg(geometry, integer, integer) OWNER TO postgres;

--
-- TOC entry 722 (class 1255 OID 1898928)
-- Dependencies: 5 2131
-- Name: st_assvg(geography, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_assvg(geography, integer, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_as_svg';


ALTER FUNCTION public.st_assvg(geography, integer, integer) OWNER TO postgres;

--
-- TOC entry 534 (class 1255 OID 1898711)
-- Dependencies: 5 2104
-- Name: st_astext(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_astext(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asText';


ALTER FUNCTION public.st_astext(geometry) OWNER TO postgres;

--
-- TOC entry 690 (class 1255 OID 1898869)
-- Dependencies: 5 2131
-- Name: st_astext(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_astext(geography) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_as_text';


ALTER FUNCTION public.st_astext(geography) OWNER TO postgres;

--
-- TOC entry 691 (class 1255 OID 1898870)
-- Dependencies: 5
-- Name: st_astext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_astext(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsText($1::geometry);  $_$;


ALTER FUNCTION public.st_astext(text) OWNER TO postgres;

--
-- TOC entry 955 (class 1255 OID 1898296)
-- Dependencies: 5 2104 2104
-- Name: st_azimuth(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_azimuth(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_azimuth';


ALTER FUNCTION public.st_azimuth(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 650 (class 1255 OID 1898828)
-- Dependencies: 5 2435 2104
-- Name: st_bdmpolyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(ST_BuildArea(mline));

	RETURN geom;
END;
$_$;


ALTER FUNCTION public.st_bdmpolyfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 653 (class 1255 OID 1898826)
-- Dependencies: 5 2435 2104
-- Name: st_bdpolyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := ST_BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;


ALTER FUNCTION public.st_bdpolyfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 383 (class 1255 OID 1898550)
-- Dependencies: 5 2104 2104
-- Name: st_boundary(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_boundary(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'boundary';


ALTER FUNCTION public.st_boundary(geometry) OWNER TO postgres;

--
-- TOC entry 777 (class 1255 OID 1898463)
-- Dependencies: 5 2104
-- Name: st_box(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_box(geometry) RETURNS box
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_BOX';


ALTER FUNCTION public.st_box(geometry) OWNER TO postgres;

--
-- TOC entry 780 (class 1255 OID 1898466)
-- Dependencies: 5 2107
-- Name: st_box(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_box(box3d) RETURNS box
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_BOX';


ALTER FUNCTION public.st_box(box3d) OWNER TO postgres;

--
-- TOC entry 776 (class 1255 OID 1898461)
-- Dependencies: 5 2117 2104
-- Name: st_box2d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_box2d(geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_BOX2DFLOAT4';


ALTER FUNCTION public.st_box2d(geometry) OWNER TO postgres;

--
-- TOC entry 778 (class 1255 OID 1898464)
-- Dependencies: 5 2117 2107
-- Name: st_box2d(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_box2d(box3d) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_BOX2DFLOAT4';


ALTER FUNCTION public.st_box2d(box3d) OWNER TO postgres;

--
-- TOC entry 1096 (class 1255 OID 1898475)
-- Dependencies: 5 2117 2111
-- Name: st_box2d(box3d_extent); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_box2d(box3d_extent) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_BOX2DFLOAT4';


ALTER FUNCTION public.st_box2d(box3d_extent) OWNER TO postgres;

--
-- TOC entry 838 (class 1255 OID 1898132)
-- Dependencies: 5 2117
-- Name: st_box2d_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_box2d_in(cstring) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_in';


ALTER FUNCTION public.st_box2d_in(cstring) OWNER TO postgres;

--
-- TOC entry 839 (class 1255 OID 1898133)
-- Dependencies: 5 2117
-- Name: st_box2d_out(box2d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_box2d_out(box2d) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_out';


ALTER FUNCTION public.st_box2d_out(box2d) OWNER TO postgres;

--
-- TOC entry 775 (class 1255 OID 1898462)
-- Dependencies: 5 2107 2104
-- Name: st_box3d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_box3d(geometry) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_BOX3D';


ALTER FUNCTION public.st_box3d(geometry) OWNER TO postgres;

--
-- TOC entry 779 (class 1255 OID 1898465)
-- Dependencies: 5 2107 2117
-- Name: st_box3d(box2d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_box3d(box2d) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_to_BOX3D';


ALTER FUNCTION public.st_box3d(box2d) OWNER TO postgres;

--
-- TOC entry 1067 (class 1255 OID 1898474)
-- Dependencies: 5 2107 2111
-- Name: st_box3d_extent(box3d_extent); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_box3d_extent(box3d_extent) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_extent_to_BOX3D';


ALTER FUNCTION public.st_box3d_extent(box3d_extent) OWNER TO postgres;

--
-- TOC entry 813 (class 1255 OID 1898101)
-- Dependencies: 5 2107
-- Name: st_box3d_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_box3d_in(cstring) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_in';


ALTER FUNCTION public.st_box3d_in(cstring) OWNER TO postgres;

--
-- TOC entry 814 (class 1255 OID 1898102)
-- Dependencies: 5 2107
-- Name: st_box3d_out(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_box3d_out(box3d) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_out';


ALTER FUNCTION public.st_box3d_out(box3d) OWNER TO postgres;

--
-- TOC entry 365 (class 1255 OID 1898533)
-- Dependencies: 5 2104 2104
-- Name: st_buffer(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_buffer(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'buffer';


ALTER FUNCTION public.st_buffer(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 768 (class 1255 OID 1898979)
-- Dependencies: 2131 5 2131
-- Name: st_buffer(geography, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_buffer(geography, double precision) RETURNS geography
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT geography(ST_Transform(ST_Buffer(ST_Transform(geometry($1), _ST_BestSRID($1)), $2), 4326))$_$;


ALTER FUNCTION public.st_buffer(geography, double precision) OWNER TO postgres;

--
-- TOC entry 769 (class 1255 OID 1898980)
-- Dependencies: 5 2104
-- Name: st_buffer(text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_buffer(text, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Buffer($1::geometry, $2);  $_$;


ALTER FUNCTION public.st_buffer(text, double precision) OWNER TO postgres;

--
-- TOC entry 367 (class 1255 OID 1898535)
-- Dependencies: 5 2104 2104
-- Name: st_buffer(geometry, double precision, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_buffer(geometry, double precision, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_Buffer($1, $2,
		CAST('quad_segs='||CAST($3 AS text) as cstring))
	   $_$;


ALTER FUNCTION public.st_buffer(geometry, double precision, integer) OWNER TO postgres;

--
-- TOC entry 368 (class 1255 OID 1898536)
-- Dependencies: 5 2104 2104
-- Name: st_buffer(geometry, double precision, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_buffer(geometry, double precision, text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_Buffer($1, $2,
		CAST( regexp_replace($3, '^[0123456789]+$',
			'quad_segs='||$3) AS cstring)
		)
	   $_$;


ALTER FUNCTION public.st_buffer(geometry, double precision, text) OWNER TO postgres;

--
-- TOC entry 1038 (class 1255 OID 1898378)
-- Dependencies: 5 2104 2104
-- Name: st_buildarea(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_buildarea(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_buildarea';


ALTER FUNCTION public.st_buildarea(geometry) OWNER TO postgres;

--
-- TOC entry 1066 (class 1255 OID 1898473)
-- Dependencies: 5 2104
-- Name: st_bytea(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_bytea(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_bytea';


ALTER FUNCTION public.st_bytea(geometry) OWNER TO postgres;

--
-- TOC entry 443 (class 1255 OID 1898621)
-- Dependencies: 5 2104 2104
-- Name: st_centroid(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_centroid(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'centroid';


ALTER FUNCTION public.st_centroid(geometry) OWNER TO postgres;

--
-- TOC entry 836 (class 1255 OID 1898129)
-- Dependencies: 5 2114
-- Name: st_chip_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_chip_in(cstring) RETURNS chip
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_in';


ALTER FUNCTION public.st_chip_in(cstring) OWNER TO postgres;

--
-- TOC entry 837 (class 1255 OID 1898130)
-- Dependencies: 2114 5
-- Name: st_chip_out(chip); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_chip_out(chip) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_out';


ALTER FUNCTION public.st_chip_out(chip) OWNER TO postgres;

--
-- TOC entry 642 (class 1255 OID 1898819)
-- Dependencies: 5 2104 2104 2104
-- Name: st_closestpoint(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_closestpoint(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_closestpoint';


ALTER FUNCTION public.st_closestpoint(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 392 (class 1255 OID 1898561)
-- Dependencies: 5 2104 2106
-- Name: st_collect(geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_collect(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_collect_garray';


ALTER FUNCTION public.st_collect(geometry[]) OWNER TO postgres;

--
-- TOC entry 391 (class 1255 OID 1898558)
-- Dependencies: 5 2104 2104 2104
-- Name: st_collect(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_collect(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'LWGEOM_collect';


ALTER FUNCTION public.st_collect(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 968 (class 1255 OID 1898309)
-- Dependencies: 5 2104 2104
-- Name: st_collectionextract(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_collectionextract(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ST_CollectionExtract';


ALTER FUNCTION public.st_collectionextract(geometry, integer) OWNER TO postgres;

--
-- TOC entry 1051 (class 1255 OID 1898394)
-- Dependencies: 5 2117 2117 2104
-- Name: st_combine_bbox(box2d, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_combine_bbox(box2d, geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_combine';


ALTER FUNCTION public.st_combine_bbox(box2d, geometry) OWNER TO postgres;

--
-- TOC entry 1053 (class 1255 OID 1898396)
-- Dependencies: 5 2111 2111 2104
-- Name: st_combine_bbox(box3d_extent, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_combine_bbox(box3d_extent, geometry) RETURNS box3d_extent
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'BOX3D_combine';


ALTER FUNCTION public.st_combine_bbox(box3d_extent, geometry) OWNER TO postgres;

--
-- TOC entry 1054 (class 1255 OID 1898400)
-- Dependencies: 5 2107 2107 2104
-- Name: st_combine_bbox(box3d, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_combine_bbox(box3d, geometry) RETURNS box3d
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'BOX3D_combine';


ALTER FUNCTION public.st_combine_bbox(box3d, geometry) OWNER TO postgres;

--
-- TOC entry 912 (class 1255 OID 1898253)
-- Dependencies: 5 2114
-- Name: st_compression(chip); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_compression(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getCompression';


ALTER FUNCTION public.st_compression(chip) OWNER TO postgres;

--
-- TOC entry 428 (class 1255 OID 1898608)
-- Dependencies: 5 2104 2104
-- Name: st_contains(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_contains(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Contains($1,$2)$_$;


ALTER FUNCTION public.st_contains(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 436 (class 1255 OID 1898614)
-- Dependencies: 5 2104 2104
-- Name: st_containsproperly(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_containsproperly(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_ContainsProperly($1,$2)$_$;


ALTER FUNCTION public.st_containsproperly(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 371 (class 1255 OID 1898539)
-- Dependencies: 5 2104 2104
-- Name: st_convexhull(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_convexhull(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'convexhull';


ALTER FUNCTION public.st_convexhull(geometry) OWNER TO postgres;

--
-- TOC entry 670 (class 1255 OID 1898844)
-- Dependencies: 5 2104
-- Name: st_coorddim(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_coorddim(geometry) RETURNS smallint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_ndims';


ALTER FUNCTION public.st_coorddim(geometry) OWNER TO postgres;

--
-- TOC entry 430 (class 1255 OID 1898610)
-- Dependencies: 5 2104 2104
-- Name: st_coveredby(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_coveredby(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_CoveredBy($1,$2)$_$;


ALTER FUNCTION public.st_coveredby(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 762 (class 1255 OID 1898973)
-- Dependencies: 2131 5 2131
-- Name: st_coveredby(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_coveredby(geography, geography) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Covers($2, $1)$_$;


ALTER FUNCTION public.st_coveredby(geography, geography) OWNER TO postgres;

--
-- TOC entry 763 (class 1255 OID 1898974)
-- Dependencies: 5
-- Name: st_coveredby(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_coveredby(text, text) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_CoveredBy($1::geometry, $2::geometry);  $_$;


ALTER FUNCTION public.st_coveredby(text, text) OWNER TO postgres;

--
-- TOC entry 449 (class 1255 OID 1898612)
-- Dependencies: 5 2104 2104
-- Name: st_covers(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_covers(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Covers($1,$2)$_$;


ALTER FUNCTION public.st_covers(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 760 (class 1255 OID 1898971)
-- Dependencies: 2131 5 2131
-- Name: st_covers(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_covers(geography, geography) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT $1 && $2 AND _ST_Covers($1, $2)$_$;


ALTER FUNCTION public.st_covers(geography, geography) OWNER TO postgres;

--
-- TOC entry 761 (class 1255 OID 1898972)
-- Dependencies: 5
-- Name: st_covers(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_covers(text, text) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_Covers($1::geometry, $2::geometry);  $_$;


ALTER FUNCTION public.st_covers(text, text) OWNER TO postgres;

--
-- TOC entry 422 (class 1255 OID 1898602)
-- Dependencies: 5 2104 2104
-- Name: st_crosses(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_crosses(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Crosses($1,$2)$_$;


ALTER FUNCTION public.st_crosses(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 664 (class 1255 OID 1898984)
-- Dependencies: 5 2104 2104
-- Name: st_curvetoline(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_curvetoline(geometry) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_CurveToLine($1, 32)$_$;


ALTER FUNCTION public.st_curvetoline(geometry) OWNER TO postgres;

--
-- TOC entry 772 (class 1255 OID 1898983)
-- Dependencies: 5 2104 2104
-- Name: st_curvetoline(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_curvetoline(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_curve_segmentize';


ALTER FUNCTION public.st_curvetoline(geometry, integer) OWNER TO postgres;

--
-- TOC entry 910 (class 1255 OID 1898251)
-- Dependencies: 5 2114
-- Name: st_datatype(chip); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_datatype(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getDatatype';


ALTER FUNCTION public.st_datatype(chip) OWNER TO postgres;

--
-- TOC entry 647 (class 1255 OID 1898824)
-- Dependencies: 5 2104 2104
-- Name: st_dfullywithin(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dfullywithin(geometry, geometry, double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && ST_Expand($2,$3) AND $2 && ST_Expand($1,$3) AND _ST_DFullyWithin(ST_ConvexHull($1), ST_ConvexHull($2), $3)$_$;


ALTER FUNCTION public.st_dfullywithin(geometry, geometry, double precision) OWNER TO postgres;

--
-- TOC entry 381 (class 1255 OID 1898548)
-- Dependencies: 5 2104 2104 2104
-- Name: st_difference(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_difference(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'difference';


ALTER FUNCTION public.st_difference(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 496 (class 1255 OID 1898673)
-- Dependencies: 5 2104
-- Name: st_dimension(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dimension(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dimension';


ALTER FUNCTION public.st_dimension(geometry) OWNER TO postgres;

--
-- TOC entry 411 (class 1255 OID 1898591)
-- Dependencies: 5 2104 2104
-- Name: st_disjoint(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_disjoint(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'disjoint';


ALTER FUNCTION public.st_disjoint(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 951 (class 1255 OID 1898292)
-- Dependencies: 5 2104 2104
-- Name: st_distance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_distance(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_mindistance2d';


ALTER FUNCTION public.st_distance(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 746 (class 1255 OID 1898957)
-- Dependencies: 5 2131 2131
-- Name: st_distance(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_distance(geography, geography) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_Distance($1, $2, 0.0, true)$_$;


ALTER FUNCTION public.st_distance(geography, geography) OWNER TO postgres;

--
-- TOC entry 747 (class 1255 OID 1898958)
-- Dependencies: 5
-- Name: st_distance(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_distance(text, text) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Distance($1::geometry, $2::geometry);  $_$;


ALTER FUNCTION public.st_distance(text, text) OWNER TO postgres;

--
-- TOC entry 745 (class 1255 OID 1898956)
-- Dependencies: 5 2131 2131
-- Name: st_distance(geography, geography, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_distance(geography, geography, boolean) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_Distance($1, $2, 0.0, $3)$_$;


ALTER FUNCTION public.st_distance(geography, geography, boolean) OWNER TO postgres;

--
-- TOC entry 949 (class 1255 OID 1898290)
-- Dependencies: 5 2104 2104
-- Name: st_distance_sphere(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_distance_sphere(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_distance_sphere';


ALTER FUNCTION public.st_distance_sphere(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 947 (class 1255 OID 1898288)
-- Dependencies: 5 2104 2104 2101
-- Name: st_distance_spheroid(geometry, geometry, spheroid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_distance_spheroid(geometry, geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_distance_ellipsoid';


ALTER FUNCTION public.st_distance_spheroid(geometry, geometry, spheroid) OWNER TO postgres;

--
-- TOC entry 1045 (class 1255 OID 1898388)
-- Dependencies: 5 2120 2104
-- Name: st_dump(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dump(geometry) RETURNS SETOF geometry_dump
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dump';


ALTER FUNCTION public.st_dump(geometry) OWNER TO postgres;

--
-- TOC entry 1049 (class 1255 OID 1898392)
-- Dependencies: 5 2120 2104
-- Name: st_dumppoints(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dumppoints(geometry) RETURNS SETOF geometry_dump
    LANGUAGE sql STRICT
    AS $_$
  SELECT * FROM _ST_DumpPoints($1, NULL);
$_$;


ALTER FUNCTION public.st_dumppoints(geometry) OWNER TO postgres;

--
-- TOC entry 1047 (class 1255 OID 1898390)
-- Dependencies: 5 2120 2104
-- Name: st_dumprings(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dumprings(geometry) RETURNS SETOF geometry_dump
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dump_rings';


ALTER FUNCTION public.st_dumprings(geometry) OWNER TO postgres;

--
-- TOC entry 416 (class 1255 OID 1898596)
-- Dependencies: 5 2104 2104
-- Name: st_dwithin(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dwithin(geometry, geometry, double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && ST_Expand($2,$3) AND $2 && ST_Expand($1,$3) AND _ST_DWithin($1, $2, $3)$_$;


ALTER FUNCTION public.st_dwithin(geometry, geometry, double precision) OWNER TO postgres;

--
-- TOC entry 750 (class 1255 OID 1898961)
-- Dependencies: 5 2131 2131
-- Name: st_dwithin(geography, geography, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dwithin(geography, geography, double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && _ST_Expand($2,$3) AND $2 && _ST_Expand($1,$3) AND _ST_DWithin($1, $2, $3, true)$_$;


ALTER FUNCTION public.st_dwithin(geography, geography, double precision) OWNER TO postgres;

--
-- TOC entry 751 (class 1255 OID 1898962)
-- Dependencies: 5
-- Name: st_dwithin(text, text, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dwithin(text, text, double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_DWithin($1::geometry, $2::geometry, $3);  $_$;


ALTER FUNCTION public.st_dwithin(text, text, double precision) OWNER TO postgres;

--
-- TOC entry 749 (class 1255 OID 1898960)
-- Dependencies: 2131 5 2131
-- Name: st_dwithin(geography, geography, double precision, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_dwithin(geography, geography, double precision, boolean) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && _ST_Expand($2,$3) AND $2 && _ST_Expand($1,$3) AND _ST_DWithin($1, $2, $3, $4)$_$;


ALTER FUNCTION public.st_dwithin(geography, geography, double precision, boolean) OWNER TO postgres;

--
-- TOC entry 520 (class 1255 OID 1898697)
-- Dependencies: 5 2104 2104
-- Name: st_endpoint(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_endpoint(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_endpoint_linestring';


ALTER FUNCTION public.st_endpoint(geometry) OWNER TO postgres;

--
-- TOC entry 978 (class 1255 OID 1898319)
-- Dependencies: 5 2104 2104
-- Name: st_envelope(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_envelope(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_envelope';


ALTER FUNCTION public.st_envelope(geometry) OWNER TO postgres;

--
-- TOC entry 453 (class 1255 OID 1898630)
-- Dependencies: 5 2104 2104
-- Name: st_equals(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_equals(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Equals($1,$2)$_$;


ALTER FUNCTION public.st_equals(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1059 (class 1255 OID 1898406)
-- Dependencies: 5 2117
-- Name: st_estimated_extent(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_estimated_extent(text, text) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT SECURITY DEFINER
    AS '$libdir/postgis-1.5', 'LWGEOM_estimated_extent';


ALTER FUNCTION public.st_estimated_extent(text, text) OWNER TO postgres;

--
-- TOC entry 1057 (class 1255 OID 1898404)
-- Dependencies: 5 2117
-- Name: st_estimated_extent(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_estimated_extent(text, text, text) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT SECURITY DEFINER
    AS '$libdir/postgis-1.5', 'LWGEOM_estimated_extent';


ALTER FUNCTION public.st_estimated_extent(text, text, text) OWNER TO postgres;

--
-- TOC entry 972 (class 1255 OID 1898313)
-- Dependencies: 5 2107 2107
-- Name: st_expand(box3d, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_expand(box3d, double precision) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_expand';


ALTER FUNCTION public.st_expand(box3d, double precision) OWNER TO postgres;

--
-- TOC entry 974 (class 1255 OID 1898315)
-- Dependencies: 5 2117 2117
-- Name: st_expand(box2d, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_expand(box2d, double precision) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_expand';


ALTER FUNCTION public.st_expand(box2d, double precision) OWNER TO postgres;

--
-- TOC entry 976 (class 1255 OID 1898317)
-- Dependencies: 5 2104 2104
-- Name: st_expand(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_expand(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_expand';


ALTER FUNCTION public.st_expand(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 498 (class 1255 OID 1898675)
-- Dependencies: 5 2104 2104
-- Name: st_exteriorring(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_exteriorring(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_exteriorring_polygon';


ALTER FUNCTION public.st_exteriorring(geometry) OWNER TO postgres;

--
-- TOC entry 906 (class 1255 OID 1898247)
-- Dependencies: 5 2114
-- Name: st_factor(chip); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_factor(chip) RETURNS real
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getFactor';


ALTER FUNCTION public.st_factor(chip) OWNER TO postgres;

--
-- TOC entry 1063 (class 1255 OID 1898410)
-- Dependencies: 2435 5 2117
-- Name: st_find_extent(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent("' || columnname || '") FROM "' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;


ALTER FUNCTION public.st_find_extent(text, text) OWNER TO postgres;

--
-- TOC entry 1061 (class 1255 OID 1898408)
-- Dependencies: 5 2435 2117
-- Name: st_find_extent(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent("' || columnname || '") FROM "' || schemaname || '"."' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;


ALTER FUNCTION public.st_find_extent(text, text, text) OWNER TO postgres;

--
-- TOC entry 957 (class 1255 OID 1898298)
-- Dependencies: 5 2104 2104
-- Name: st_force_2d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force_2d(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_2d';


ALTER FUNCTION public.st_force_2d(geometry) OWNER TO postgres;

--
-- TOC entry 961 (class 1255 OID 1898302)
-- Dependencies: 5 2104 2104
-- Name: st_force_3d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force_3d(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_3dz';


ALTER FUNCTION public.st_force_3d(geometry) OWNER TO postgres;

--
-- TOC entry 963 (class 1255 OID 1898304)
-- Dependencies: 5 2104 2104
-- Name: st_force_3dm(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force_3dm(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_3dm';


ALTER FUNCTION public.st_force_3dm(geometry) OWNER TO postgres;

--
-- TOC entry 959 (class 1255 OID 1898300)
-- Dependencies: 5 2104 2104
-- Name: st_force_3dz(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force_3dz(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_3dz';


ALTER FUNCTION public.st_force_3dz(geometry) OWNER TO postgres;

--
-- TOC entry 965 (class 1255 OID 1898306)
-- Dependencies: 5 2104 2104
-- Name: st_force_4d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force_4d(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_4d';


ALTER FUNCTION public.st_force_4d(geometry) OWNER TO postgres;

--
-- TOC entry 967 (class 1255 OID 1898308)
-- Dependencies: 5 2104 2104
-- Name: st_force_collection(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_force_collection(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_collection';


ALTER FUNCTION public.st_force_collection(geometry) OWNER TO postgres;

--
-- TOC entry 982 (class 1255 OID 1898323)
-- Dependencies: 5 2104 2104
-- Name: st_forcerhr(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_forcerhr(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_forceRHR_poly';


ALTER FUNCTION public.st_forcerhr(geometry) OWNER TO postgres;

--
-- TOC entry 692 (class 1255 OID 1898872)
-- Dependencies: 5 2131
-- Name: st_geogfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geogfromtext(text) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_from_text';


ALTER FUNCTION public.st_geogfromtext(text) OWNER TO postgres;

--
-- TOC entry 695 (class 1255 OID 1898875)
-- Dependencies: 5 2131
-- Name: st_geogfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geogfromwkb(bytea) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_from_binary';


ALTER FUNCTION public.st_geogfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 667 (class 1255 OID 1898871)
-- Dependencies: 5 2131
-- Name: st_geographyfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geographyfromtext(text) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_from_text';


ALTER FUNCTION public.st_geographyfromtext(text) OWNER TO postgres;

--
-- TOC entry 488 (class 1255 OID 1898665)
-- Dependencies: 5 2104
-- Name: st_geohash(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geohash(geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_GeoHash($1, 0)$_$;


ALTER FUNCTION public.st_geohash(geometry) OWNER TO postgres;

--
-- TOC entry 487 (class 1255 OID 1898664)
-- Dependencies: 5 2104
-- Name: st_geohash(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geohash(geometry, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ST_GeoHash';


ALTER FUNCTION public.st_geohash(geometry, integer) OWNER TO postgres;

--
-- TOC entry 587 (class 1255 OID 1898764)
-- Dependencies: 5 2104
-- Name: st_geomcollfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomcollfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(ST_GeomFromText($1)) = 'GEOMETRYCOLLECTION'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_geomcollfromtext(text) OWNER TO postgres;

--
-- TOC entry 585 (class 1255 OID 1898762)
-- Dependencies: 5 2104
-- Name: st_geomcollfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomcollfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(ST_GeomFromText($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN ST_GeomFromText($1,$2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_geomcollfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 638 (class 1255 OID 1898815)
-- Dependencies: 5 2104
-- Name: st_geomcollfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomcollfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(ST_GeomFromWKB($1)) = 'GEOMETRYCOLLECTION'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_geomcollfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 636 (class 1255 OID 1898813)
-- Dependencies: 5 2104
-- Name: st_geomcollfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomcollfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(GeomFromWKB($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_geomcollfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 782 (class 1255 OID 1898468)
-- Dependencies: 5 2104 2117
-- Name: st_geometry(box2d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry(box2d) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_to_LWGEOM';


ALTER FUNCTION public.st_geometry(box2d) OWNER TO postgres;

--
-- TOC entry 783 (class 1255 OID 1898469)
-- Dependencies: 5 2104 2107
-- Name: st_geometry(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry(box3d) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_LWGEOM';


ALTER FUNCTION public.st_geometry(box3d) OWNER TO postgres;

--
-- TOC entry 784 (class 1255 OID 1898470)
-- Dependencies: 5 2104
-- Name: st_geometry(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'parse_WKT_lwgeom';


ALTER FUNCTION public.st_geometry(text) OWNER TO postgres;

--
-- TOC entry 785 (class 1255 OID 1898471)
-- Dependencies: 5 2104 2114
-- Name: st_geometry(chip); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry(chip) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_to_LWGEOM';


ALTER FUNCTION public.st_geometry(chip) OWNER TO postgres;

--
-- TOC entry 1065 (class 1255 OID 1898472)
-- Dependencies: 5 2104
-- Name: st_geometry(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_bytea';


ALTER FUNCTION public.st_geometry(bytea) OWNER TO postgres;

--
-- TOC entry 324 (class 1255 OID 1898476)
-- Dependencies: 5 2104 2111
-- Name: st_geometry(box3d_extent); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry(box3d_extent) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_LWGEOM';


ALTER FUNCTION public.st_geometry(box3d_extent) OWNER TO postgres;

--
-- TOC entry 864 (class 1255 OID 1898172)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_above(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_above(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_above';


ALTER FUNCTION public.st_geometry_above(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1077 (class 1255 OID 1898067)
-- Dependencies: 5
-- Name: st_geometry_analyze(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_analyze(internal) RETURNS boolean
    LANGUAGE c STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_analyze';


ALTER FUNCTION public.st_geometry_analyze(internal) OWNER TO postgres;

--
-- TOC entry 865 (class 1255 OID 1898173)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_below(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_below(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_below';


ALTER FUNCTION public.st_geometry_below(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 847 (class 1255 OID 1898142)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_cmp(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_cmp(geometry, geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_cmp';


ALTER FUNCTION public.st_geometry_cmp(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 866 (class 1255 OID 1898174)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_contain(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_contain(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_contain';


ALTER FUNCTION public.st_geometry_contain(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 867 (class 1255 OID 1898175)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_contained(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_contained(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_contained';


ALTER FUNCTION public.st_geometry_contained(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 846 (class 1255 OID 1898141)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_eq(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_eq(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_eq';


ALTER FUNCTION public.st_geometry_eq(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 845 (class 1255 OID 1898140)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_ge(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_ge(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_ge';


ALTER FUNCTION public.st_geometry_ge(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 844 (class 1255 OID 1898139)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_gt(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_gt(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_gt';


ALTER FUNCTION public.st_geometry_gt(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1075 (class 1255 OID 1898065)
-- Dependencies: 5 2104
-- Name: st_geometry_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_in(cstring) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_in';


ALTER FUNCTION public.st_geometry_in(cstring) OWNER TO postgres;

--
-- TOC entry 843 (class 1255 OID 1898138)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_le(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_le(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_le';


ALTER FUNCTION public.st_geometry_le(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 862 (class 1255 OID 1898170)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_left(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_left(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_left';


ALTER FUNCTION public.st_geometry_left(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 842 (class 1255 OID 1898137)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_lt(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_lt(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_lt';


ALTER FUNCTION public.st_geometry_lt(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1076 (class 1255 OID 1898066)
-- Dependencies: 5 2104
-- Name: st_geometry_out(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_out(geometry) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_out';


ALTER FUNCTION public.st_geometry_out(geometry) OWNER TO postgres;

--
-- TOC entry 860 (class 1255 OID 1898168)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_overabove(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_overabove(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overabove';


ALTER FUNCTION public.st_geometry_overabove(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 861 (class 1255 OID 1898169)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_overbelow(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_overbelow(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overbelow';


ALTER FUNCTION public.st_geometry_overbelow(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 868 (class 1255 OID 1898176)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_overlap(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_overlap(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overlap';


ALTER FUNCTION public.st_geometry_overlap(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 858 (class 1255 OID 1898166)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_overleft(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_overleft(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overleft';


ALTER FUNCTION public.st_geometry_overleft(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 859 (class 1255 OID 1898167)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_overright(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_overright(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overright';


ALTER FUNCTION public.st_geometry_overright(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1078 (class 1255 OID 1898068)
-- Dependencies: 5 2104
-- Name: st_geometry_recv(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_recv(internal) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_recv';


ALTER FUNCTION public.st_geometry_recv(internal) OWNER TO postgres;

--
-- TOC entry 863 (class 1255 OID 1898171)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_right(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_right(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_right';


ALTER FUNCTION public.st_geometry_right(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 869 (class 1255 OID 1898177)
-- Dependencies: 5 2104 2104
-- Name: st_geometry_same(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_same(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_samebox';


ALTER FUNCTION public.st_geometry_same(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1079 (class 1255 OID 1898069)
-- Dependencies: 5 2104
-- Name: st_geometry_send(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometry_send(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_send';


ALTER FUNCTION public.st_geometry_send(geometry) OWNER TO postgres;

--
-- TOC entry 536 (class 1255 OID 1898713)
-- Dependencies: 5 2104
-- Name: st_geometryfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometryfromtext(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_text';


ALTER FUNCTION public.st_geometryfromtext(text) OWNER TO postgres;

--
-- TOC entry 538 (class 1255 OID 1898715)
-- Dependencies: 5 2104
-- Name: st_geometryfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometryfromtext(text, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_text';


ALTER FUNCTION public.st_geometryfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 494 (class 1255 OID 1898671)
-- Dependencies: 5 2104 2104
-- Name: st_geometryn(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometryn(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_geometryn_collection';


ALTER FUNCTION public.st_geometryn(geometry, integer) OWNER TO postgres;

--
-- TOC entry 506 (class 1255 OID 1898683)
-- Dependencies: 5 2104
-- Name: st_geometrytype(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geometrytype(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geometry_geometrytype';


ALTER FUNCTION public.st_geometrytype(geometry) OWNER TO postgres;

--
-- TOC entry 1001 (class 1255 OID 1898341)
-- Dependencies: 5 2104
-- Name: st_geomfromewkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromewkb(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOMFromWKB';


ALTER FUNCTION public.st_geomfromewkb(bytea) OWNER TO postgres;

--
-- TOC entry 1003 (class 1255 OID 1898343)
-- Dependencies: 5 2104
-- Name: st_geomfromewkt(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromewkt(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'parse_WKT_lwgeom';


ALTER FUNCTION public.st_geomfromewkt(text) OWNER TO postgres;

--
-- TOC entry 454 (class 1255 OID 1898631)
-- Dependencies: 5 2104
-- Name: st_geomfromgml(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromgml(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geom_from_gml';


ALTER FUNCTION public.st_geomfromgml(text) OWNER TO postgres;

--
-- TOC entry 456 (class 1255 OID 1898633)
-- Dependencies: 5 2104
-- Name: st_geomfromkml(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromkml(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geom_from_kml';


ALTER FUNCTION public.st_geomfromkml(text) OWNER TO postgres;

--
-- TOC entry 540 (class 1255 OID 1898717)
-- Dependencies: 5 2104
-- Name: st_geomfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromtext(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_text';


ALTER FUNCTION public.st_geomfromtext(text) OWNER TO postgres;

--
-- TOC entry 542 (class 1255 OID 1898719)
-- Dependencies: 5 2104
-- Name: st_geomfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromtext(text, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_text';


ALTER FUNCTION public.st_geomfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 589 (class 1255 OID 1898766)
-- Dependencies: 5 2104
-- Name: st_geomfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromwkb(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_WKB';


ALTER FUNCTION public.st_geomfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 591 (class 1255 OID 1898768)
-- Dependencies: 5 2104
-- Name: st_geomfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_geomfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_SetSRID(ST_GeomFromWKB($1), $2)$_$;


ALTER FUNCTION public.st_geomfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 455 (class 1255 OID 1898632)
-- Dependencies: 5 2104
-- Name: st_gmltosql(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_gmltosql(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geom_from_gml';


ALTER FUNCTION public.st_gmltosql(text) OWNER TO postgres;

--
-- TOC entry 665 (class 1255 OID 1898985)
-- Dependencies: 5 2104
-- Name: st_hasarc(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_hasarc(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_has_arc';


ALTER FUNCTION public.st_hasarc(geometry) OWNER TO postgres;

--
-- TOC entry 378 (class 1255 OID 1898545)
-- Dependencies: 5 2104 2104
-- Name: st_hausdorffdistance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_hausdorffdistance(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'hausdorffdistance';


ALTER FUNCTION public.st_hausdorffdistance(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 379 (class 1255 OID 1898546)
-- Dependencies: 5 2104 2104
-- Name: st_hausdorffdistance(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_hausdorffdistance(geometry, geometry, double precision) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'hausdorffdistancedensify';


ALTER FUNCTION public.st_hausdorffdistance(geometry, geometry, double precision) OWNER TO postgres;

--
-- TOC entry 904 (class 1255 OID 1898245)
-- Dependencies: 5 2114
-- Name: st_height(chip); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_height(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getHeight';


ALTER FUNCTION public.st_height(chip) OWNER TO postgres;

--
-- TOC entry 504 (class 1255 OID 1898681)
-- Dependencies: 5 2104 2104
-- Name: st_interiorringn(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_interiorringn(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_interiorringn_polygon';


ALTER FUNCTION public.st_interiorringn(geometry, integer) OWNER TO postgres;

--
-- TOC entry 363 (class 1255 OID 1898531)
-- Dependencies: 5 2104 2104 2104
-- Name: st_intersection(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'intersection';


ALTER FUNCTION public.st_intersection(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 770 (class 1255 OID 1898981)
-- Dependencies: 5 2131 2131 2131
-- Name: st_intersection(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(geography, geography) RETURNS geography
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT geography(ST_Transform(ST_Intersection(ST_Transform(geometry($1), _ST_BestSRID($1, $2)), ST_Transform(geometry($2), _ST_BestSRID($1, $2))), 4326))$_$;


ALTER FUNCTION public.st_intersection(geography, geography) OWNER TO postgres;

--
-- TOC entry 771 (class 1255 OID 1898982)
-- Dependencies: 5 2104
-- Name: st_intersection(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersection(text, text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Intersection($1::geometry, $2::geometry);  $_$;


ALTER FUNCTION public.st_intersection(text, text) OWNER TO postgres;

--
-- TOC entry 419 (class 1255 OID 1898599)
-- Dependencies: 5 2104 2104
-- Name: st_intersects(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersects(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Intersects($1,$2)$_$;


ALTER FUNCTION public.st_intersects(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 764 (class 1255 OID 1898975)
-- Dependencies: 2131 5 2131
-- Name: st_intersects(geography, geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersects(geography, geography) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Distance($1, $2, 0.0, false) < 0.00001$_$;


ALTER FUNCTION public.st_intersects(geography, geography) OWNER TO postgres;

--
-- TOC entry 765 (class 1255 OID 1898976)
-- Dependencies: 5
-- Name: st_intersects(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_intersects(text, text) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_Intersects($1::geometry, $2::geometry);  $_$;


ALTER FUNCTION public.st_intersects(text, text) OWNER TO postgres;

--
-- TOC entry 522 (class 1255 OID 1898699)
-- Dependencies: 5 2104
-- Name: st_isclosed(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_isclosed(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_isclosed_linestring';


ALTER FUNCTION public.st_isclosed(geometry) OWNER TO postgres;

--
-- TOC entry 524 (class 1255 OID 1898701)
-- Dependencies: 5 2104
-- Name: st_isempty(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_isempty(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_isempty';


ALTER FUNCTION public.st_isempty(geometry) OWNER TO postgres;

--
-- TOC entry 445 (class 1255 OID 1898623)
-- Dependencies: 5 2104
-- Name: st_isring(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_isring(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'isring';


ALTER FUNCTION public.st_isring(geometry) OWNER TO postgres;

--
-- TOC entry 450 (class 1255 OID 1898627)
-- Dependencies: 5 2104
-- Name: st_issimple(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_issimple(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'issimple';


ALTER FUNCTION public.st_issimple(geometry) OWNER TO postgres;

--
-- TOC entry 441 (class 1255 OID 1898619)
-- Dependencies: 5 2104
-- Name: st_isvalid(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_isvalid(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'isvalid';


ALTER FUNCTION public.st_isvalid(geometry) OWNER TO postgres;

--
-- TOC entry 377 (class 1255 OID 1898544)
-- Dependencies: 5 2104
-- Name: st_isvalidreason(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_isvalidreason(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'isvalidreason';


ALTER FUNCTION public.st_isvalidreason(geometry) OWNER TO postgres;

--
-- TOC entry 929 (class 1255 OID 1898270)
-- Dependencies: 5 2104
-- Name: st_length(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_length(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_length2d_linestring';


ALTER FUNCTION public.st_length(geometry) OWNER TO postgres;

--
-- TOC entry 756 (class 1255 OID 1898967)
-- Dependencies: 5 2131
-- Name: st_length(geography); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_length(geography) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT ST_Length($1, true)$_$;


ALTER FUNCTION public.st_length(geography) OWNER TO postgres;

--
-- TOC entry 757 (class 1255 OID 1898968)
-- Dependencies: 5
-- Name: st_length(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_length(text) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Length($1::geometry);  $_$;


ALTER FUNCTION public.st_length(text) OWNER TO postgres;

--
-- TOC entry 755 (class 1255 OID 1898966)
-- Dependencies: 2131 5
-- Name: st_length(geography, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_length(geography, boolean) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'geography_length';


ALTER FUNCTION public.st_length(geography, boolean) OWNER TO postgres;

--
-- TOC entry 927 (class 1255 OID 1898268)
-- Dependencies: 5 2104
-- Name: st_length2d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_length2d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_length2d_linestring';


ALTER FUNCTION public.st_length2d(geometry) OWNER TO postgres;

--
-- TOC entry 935 (class 1255 OID 1898276)
-- Dependencies: 5 2104 2101
-- Name: st_length2d_spheroid(geometry, spheroid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_length2d_spheroid(geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_length2d_ellipsoid';


ALTER FUNCTION public.st_length2d_spheroid(geometry, spheroid) OWNER TO postgres;

--
-- TOC entry 925 (class 1255 OID 1898266)
-- Dependencies: 5 2104
-- Name: st_length3d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_length3d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_length_linestring';


ALTER FUNCTION public.st_length3d(geometry) OWNER TO postgres;

--
-- TOC entry 931 (class 1255 OID 1898272)
-- Dependencies: 5 2101 2104
-- Name: st_length3d_spheroid(geometry, spheroid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_length3d_spheroid(geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_length_ellipsoid_linestring';


ALTER FUNCTION public.st_length3d_spheroid(geometry, spheroid) OWNER TO postgres;

--
-- TOC entry 933 (class 1255 OID 1898274)
-- Dependencies: 5 2104 2101
-- Name: st_length_spheroid(geometry, spheroid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_length_spheroid(geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_length_ellipsoid_linestring';


ALTER FUNCTION public.st_length_spheroid(geometry, spheroid) OWNER TO postgres;

--
-- TOC entry 354 (class 1255 OID 1898520)
-- Dependencies: 5 2104 2104
-- Name: st_line_interpolate_point(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_line_interpolate_point(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_interpolate_point';


ALTER FUNCTION public.st_line_interpolate_point(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 348 (class 1255 OID 1898524)
-- Dependencies: 5 2104 2104
-- Name: st_line_locate_point(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_line_locate_point(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_locate_point';


ALTER FUNCTION public.st_line_locate_point(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 356 (class 1255 OID 1898522)
-- Dependencies: 5 2104 2104
-- Name: st_line_substring(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_line_substring(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_substring';


ALTER FUNCTION public.st_line_substring(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 373 (class 1255 OID 1898541)
-- Dependencies: 5 2104 2104
-- Name: st_linecrossingdirection(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linecrossingdirection(geometry, geometry) RETURNS integer
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT CASE WHEN NOT $1 && $2 THEN 0 ELSE _ST_LineCrossingDirection($1,$2) END $_$;


ALTER FUNCTION public.st_linecrossingdirection(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1021 (class 1255 OID 1898361)
-- Dependencies: 5 2104 2104
-- Name: st_linefrommultipoint(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linefrommultipoint(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_from_mpoint';


ALTER FUNCTION public.st_linefrommultipoint(geometry) OWNER TO postgres;

--
-- TOC entry 548 (class 1255 OID 1898725)
-- Dependencies: 5 2104
-- Name: st_linefromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linefromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'LINESTRING'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_linefromtext(text) OWNER TO postgres;

--
-- TOC entry 550 (class 1255 OID 1898727)
-- Dependencies: 5 2104
-- Name: st_linefromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linefromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'LINESTRING'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_linefromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 599 (class 1255 OID 1898776)
-- Dependencies: 5 2104
-- Name: st_linefromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linefromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'LINESTRING'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_linefromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 597 (class 1255 OID 1898774)
-- Dependencies: 5 2104
-- Name: st_linefromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linefromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_linefromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 1043 (class 1255 OID 1898383)
-- Dependencies: 5 2104 2104
-- Name: st_linemerge(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linemerge(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'linemerge';


ALTER FUNCTION public.st_linemerge(geometry) OWNER TO postgres;

--
-- TOC entry 603 (class 1255 OID 1898780)
-- Dependencies: 5 2104
-- Name: st_linestringfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linestringfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'LINESTRING'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_linestringfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 601 (class 1255 OID 1898778)
-- Dependencies: 5 2104
-- Name: st_linestringfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linestringfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_linestringfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 1115 (class 1255 OID 1898986)
-- Dependencies: 2104 5 2104
-- Name: st_linetocurve(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_linetocurve(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_desegmentize';


ALTER FUNCTION public.st_linetocurve(geometry) OWNER TO postgres;

--
-- TOC entry 360 (class 1255 OID 1898528)
-- Dependencies: 5 2104 2104
-- Name: st_locate_along_measure(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_locate_along_measure(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT locate_between_measures($1, $2, $2) $_$;


ALTER FUNCTION public.st_locate_along_measure(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 358 (class 1255 OID 1898526)
-- Dependencies: 5 2104 2104
-- Name: st_locate_between_measures(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_locate_between_measures(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_locate_between_m';


ALTER FUNCTION public.st_locate_between_measures(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 374 (class 1255 OID 1898542)
-- Dependencies: 5 2104 2104
-- Name: st_locatebetweenelevations(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_locatebetweenelevations(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ST_LocateBetweenElevations';


ALTER FUNCTION public.st_locatebetweenelevations(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 645 (class 1255 OID 1898822)
-- Dependencies: 5 2104 2104 2104
-- Name: st_longestline(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_longestline(geometry, geometry) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_LongestLine(ST_ConvexHull($1), ST_ConvexHull($2))$_$;


ALTER FUNCTION public.st_longestline(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 516 (class 1255 OID 1898693)
-- Dependencies: 5 2104
-- Name: st_m(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_m(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_m_point';


ALTER FUNCTION public.st_m(geometry) OWNER TO postgres;

--
-- TOC entry 1014 (class 1255 OID 1898354)
-- Dependencies: 5 2117 2104 2104
-- Name: st_makebox2d(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makebox2d(geometry, geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_construct';


ALTER FUNCTION public.st_makebox2d(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1016 (class 1255 OID 1898356)
-- Dependencies: 5 2107 2104 2104
-- Name: st_makebox3d(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makebox3d(geometry, geometry) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_construct';


ALTER FUNCTION public.st_makebox3d(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1032 (class 1255 OID 1898372)
-- Dependencies: 5 2104
-- Name: st_makeenvelope(double precision, double precision, double precision, double precision, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makeenvelope(double precision, double precision, double precision, double precision, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ST_MakeEnvelope';


ALTER FUNCTION public.st_makeenvelope(double precision, double precision, double precision, double precision, integer) OWNER TO postgres;

--
-- TOC entry 1019 (class 1255 OID 1898359)
-- Dependencies: 5 2104 2106
-- Name: st_makeline(geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makeline(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makeline_garray';


ALTER FUNCTION public.st_makeline(geometry[]) OWNER TO postgres;

--
-- TOC entry 1023 (class 1255 OID 1898363)
-- Dependencies: 5 2104 2104 2104
-- Name: st_makeline(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makeline(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makeline';


ALTER FUNCTION public.st_makeline(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1018 (class 1255 OID 1898358)
-- Dependencies: 5 2104 2106
-- Name: st_makeline_garray(geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makeline_garray(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makeline_garray';


ALTER FUNCTION public.st_makeline_garray(geometry[]) OWNER TO postgres;

--
-- TOC entry 1006 (class 1255 OID 1898346)
-- Dependencies: 5 2104
-- Name: st_makepoint(double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makepoint(double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint';


ALTER FUNCTION public.st_makepoint(double precision, double precision) OWNER TO postgres;

--
-- TOC entry 1008 (class 1255 OID 1898348)
-- Dependencies: 5 2104
-- Name: st_makepoint(double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makepoint(double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint';


ALTER FUNCTION public.st_makepoint(double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 1010 (class 1255 OID 1898350)
-- Dependencies: 5 2104
-- Name: st_makepoint(double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makepoint(double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint';


ALTER FUNCTION public.st_makepoint(double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 1012 (class 1255 OID 1898352)
-- Dependencies: 5 2104
-- Name: st_makepointm(double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makepointm(double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint3dm';


ALTER FUNCTION public.st_makepointm(double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 1036 (class 1255 OID 1898376)
-- Dependencies: 5 2104 2104
-- Name: st_makepolygon(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makepolygon(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoly';


ALTER FUNCTION public.st_makepolygon(geometry) OWNER TO postgres;

--
-- TOC entry 1034 (class 1255 OID 1898374)
-- Dependencies: 5 2104 2104 2106
-- Name: st_makepolygon(geometry, geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_makepolygon(geometry, geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoly';


ALTER FUNCTION public.st_makepolygon(geometry, geometry[]) OWNER TO postgres;

--
-- TOC entry 641 (class 1255 OID 1898818)
-- Dependencies: 5 2104 2104
-- Name: st_maxdistance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_maxdistance(geometry, geometry) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_MaxDistance(ST_ConvexHull($1), ST_ConvexHull($2))$_$;


ALTER FUNCTION public.st_maxdistance(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 917 (class 1255 OID 1898258)
-- Dependencies: 5 2104
-- Name: st_mem_size(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mem_size(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_mem_size';


ALTER FUNCTION public.st_mem_size(geometry) OWNER TO postgres;

--
-- TOC entry 1117 (class 1255 OID 1898989)
-- Dependencies: 5 2104 2104
-- Name: st_minimumboundingcircle(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_minimumboundingcircle(geometry) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_MinimumBoundingCircle($1, 48)$_$;


ALTER FUNCTION public.st_minimumboundingcircle(geometry) OWNER TO postgres;

--
-- TOC entry 1116 (class 1255 OID 1898987)
-- Dependencies: 2104 5 2435 2104
-- Name: st_minimumboundingcircle(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_minimumboundingcircle(inputgeom geometry, segs_per_quarter integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
	DECLARE
	hull GEOMETRY;
	ring GEOMETRY;
	center GEOMETRY;
	radius DOUBLE PRECISION;
	dist DOUBLE PRECISION;
	d DOUBLE PRECISION;
	idx1 integer;
	idx2 integer;
	l1 GEOMETRY;
	l2 GEOMETRY;
	p1 GEOMETRY;
	p2 GEOMETRY;
	a1 DOUBLE PRECISION;
	a2 DOUBLE PRECISION;


	BEGIN

	-- First compute the ConvexHull of the geometry
	hull = ST_ConvexHull(inputgeom);
	--A point really has no MBC
	IF ST_GeometryType(hull) = 'ST_Point' THEN
		RETURN hull;
	END IF;
	-- convert the hull perimeter to a linestring so we can manipulate individual points
	--If its already a linestring force it to a closed linestring
	ring = CASE WHEN ST_GeometryType(hull) = 'ST_LineString' THEN ST_AddPoint(hull, ST_StartPoint(hull)) ELSE ST_ExteriorRing(hull) END;

	dist = 0;
	-- Brute Force - check every pair
	FOR i in 1 .. (ST_NumPoints(ring)-2)
		LOOP
			FOR j in i .. (ST_NumPoints(ring)-1)
				LOOP
				d = ST_Distance(ST_PointN(ring,i),ST_PointN(ring,j));
				-- Check the distance and update if larger
				IF (d > dist) THEN
					dist = d;
					idx1 = i;
					idx2 = j;
				END IF;
			END LOOP;
		END LOOP;

	-- We now have the diameter of the convex hull.  The following line returns it if desired.
	-- RETURN MakeLine(PointN(ring,idx1),PointN(ring,idx2));

	-- Now for the Minimum Bounding Circle.  Since we know the two points furthest from each
	-- other, the MBC must go through those two points. Start with those points as a diameter of a circle.

	-- The radius is half the distance between them and the center is midway between them
	radius = ST_Distance(ST_PointN(ring,idx1),ST_PointN(ring,idx2)) / 2.0;
	center = ST_Line_interpolate_point(ST_MakeLine(ST_PointN(ring,idx1),ST_PointN(ring,idx2)),0.5);

	-- Loop through each vertex and check if the distance from the center to the point
	-- is greater than the current radius.
	FOR k in 1 .. (ST_NumPoints(ring)-1)
		LOOP
		IF(k <> idx1 and k <> idx2) THEN
			dist = ST_Distance(center,ST_PointN(ring,k));
			IF (dist > radius) THEN
				-- We have to expand the circle.  The new circle must pass trhough
				-- three points - the two original diameters and this point.

				-- Draw a line from the first diameter to this point
				l1 = ST_Makeline(ST_PointN(ring,idx1),ST_PointN(ring,k));
				-- Compute the midpoint
				p1 = ST_line_interpolate_point(l1,0.5);
				-- Rotate the line 90 degrees around the midpoint (perpendicular bisector)
				l1 = ST_Translate(ST_Rotate(ST_Translate(l1,-X(p1),-Y(p1)),pi()/2),X(p1),Y(p1));
				--  Compute the azimuth of the bisector
				a1 = ST_Azimuth(ST_PointN(l1,1),ST_PointN(l1,2));
				--  Extend the line in each direction the new computed distance to insure they will intersect
				l1 = ST_AddPoint(l1,ST_Makepoint(X(ST_PointN(l1,2))+sin(a1)*dist,Y(ST_PointN(l1,2))+cos(a1)*dist),-1);
				l1 = ST_AddPoint(l1,ST_Makepoint(X(ST_PointN(l1,1))-sin(a1)*dist,Y(ST_PointN(l1,1))-cos(a1)*dist),0);

				-- Repeat for the line from the point to the other diameter point
				l2 = ST_Makeline(ST_PointN(ring,idx2),ST_PointN(ring,k));
				p2 = ST_Line_interpolate_point(l2,0.5);
				l2 = ST_Translate(ST_Rotate(ST_Translate(l2,-X(p2),-Y(p2)),pi()/2),X(p2),Y(p2));
				a2 = ST_Azimuth(ST_PointN(l2,1),ST_PointN(l2,2));
				l2 = ST_AddPoint(l2,ST_Makepoint(X(ST_PointN(l2,2))+sin(a2)*dist,Y(ST_PointN(l2,2))+cos(a2)*dist),-1);
				l2 = ST_AddPoint(l2,ST_Makepoint(X(ST_PointN(l2,1))-sin(a2)*dist,Y(ST_PointN(l2,1))-cos(a2)*dist),0);

				-- The new center is the intersection of the two bisectors
				center = ST_Intersection(l1,l2);
				-- The new radius is the distance to any of the three points
				radius = ST_Distance(center,ST_PointN(ring,idx1));
			END IF;
		END IF;
		END LOOP;
	--DONE!!  Return the MBC via the buffer command
	RETURN ST_Buffer(center,radius,segs_per_quarter);

	END;
$$;


ALTER FUNCTION public.st_minimumboundingcircle(inputgeom geometry, segs_per_quarter integer) OWNER TO postgres;

--
-- TOC entry 564 (class 1255 OID 1898741)
-- Dependencies: 5 2104
-- Name: st_mlinefromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mlinefromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'MULTILINESTRING'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mlinefromtext(text) OWNER TO postgres;

--
-- TOC entry 562 (class 1255 OID 1898739)
-- Dependencies: 5 2104
-- Name: st_mlinefromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mlinefromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(GeomFromText($1, $2)) = 'MULTILINESTRING'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mlinefromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 626 (class 1255 OID 1898803)
-- Dependencies: 5 2104
-- Name: st_mlinefromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mlinefromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mlinefromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 624 (class 1255 OID 1898801)
-- Dependencies: 5 2104
-- Name: st_mlinefromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mlinefromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'MULTILINESTRING'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mlinefromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 572 (class 1255 OID 1898749)
-- Dependencies: 5 2104
-- Name: st_mpointfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mpointfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'MULTIPOINT'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mpointfromtext(text) OWNER TO postgres;

--
-- TOC entry 570 (class 1255 OID 1898747)
-- Dependencies: 5 2104
-- Name: st_mpointfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mpointfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'MULTIPOINT'
	THEN GeomFromText($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mpointfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 615 (class 1255 OID 1898792)
-- Dependencies: 5 2104
-- Name: st_mpointfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mpointfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTIPOINT'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mpointfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 613 (class 1255 OID 1898790)
-- Dependencies: 5 2104
-- Name: st_mpointfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mpointfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'MULTIPOINT'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mpointfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 579 (class 1255 OID 1898756)
-- Dependencies: 5 2104
-- Name: st_mpolyfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mpolyfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'MULTIPOLYGON'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mpolyfromtext(text) OWNER TO postgres;

--
-- TOC entry 577 (class 1255 OID 1898754)
-- Dependencies: 5 2104
-- Name: st_mpolyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1, $2)) = 'MULTIPOLYGON'
	THEN ST_GeomFromText($1,$2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mpolyfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 630 (class 1255 OID 1898807)
-- Dependencies: 5 2104
-- Name: st_mpolyfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mpolyfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTIPOLYGON'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mpolyfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 628 (class 1255 OID 1898805)
-- Dependencies: 5 2104
-- Name: st_mpolyfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_mpolyfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_mpolyfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 970 (class 1255 OID 1898311)
-- Dependencies: 5 2104 2104
-- Name: st_multi(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multi(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_multi';


ALTER FUNCTION public.st_multi(geometry) OWNER TO postgres;

--
-- TOC entry 622 (class 1255 OID 1898799)
-- Dependencies: 5 2104
-- Name: st_multilinefromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multilinefromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_multilinefromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 566 (class 1255 OID 1898743)
-- Dependencies: 5 2104
-- Name: st_multilinestringfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multilinestringfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_MLineFromText($1)$_$;


ALTER FUNCTION public.st_multilinestringfromtext(text) OWNER TO postgres;

--
-- TOC entry 568 (class 1255 OID 1898745)
-- Dependencies: 5 2104
-- Name: st_multilinestringfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multilinestringfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MLineFromText($1, $2)$_$;


ALTER FUNCTION public.st_multilinestringfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 575 (class 1255 OID 1898752)
-- Dependencies: 5 2104
-- Name: st_multipointfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multipointfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MPointFromText($1)$_$;


ALTER FUNCTION public.st_multipointfromtext(text) OWNER TO postgres;

--
-- TOC entry 619 (class 1255 OID 1898796)
-- Dependencies: 5 2104
-- Name: st_multipointfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multipointfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTIPOINT'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_multipointfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 617 (class 1255 OID 1898794)
-- Dependencies: 5 2104
-- Name: st_multipointfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multipointfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1,$2)) = 'MULTIPOINT'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_multipointfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 634 (class 1255 OID 1898811)
-- Dependencies: 5 2104
-- Name: st_multipolyfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multipolyfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTIPOLYGON'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_multipolyfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 632 (class 1255 OID 1898809)
-- Dependencies: 5 2104
-- Name: st_multipolyfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multipolyfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_multipolyfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 583 (class 1255 OID 1898760)
-- Dependencies: 5 2104
-- Name: st_multipolygonfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multipolygonfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MPolyFromText($1)$_$;


ALTER FUNCTION public.st_multipolygonfromtext(text) OWNER TO postgres;

--
-- TOC entry 581 (class 1255 OID 1898758)
-- Dependencies: 5 2104
-- Name: st_multipolygonfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_multipolygonfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MPolyFromText($1, $2)$_$;


ALTER FUNCTION public.st_multipolygonfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 992 (class 1255 OID 1898329)
-- Dependencies: 5 2104
-- Name: st_ndims(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_ndims(geometry) RETURNS smallint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_ndims';


ALTER FUNCTION public.st_ndims(geometry) OWNER TO postgres;

--
-- TOC entry 921 (class 1255 OID 1898262)
-- Dependencies: 5 2104
-- Name: st_npoints(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_npoints(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_npoints';


ALTER FUNCTION public.st_npoints(geometry) OWNER TO postgres;

--
-- TOC entry 923 (class 1255 OID 1898264)
-- Dependencies: 5 2104
-- Name: st_nrings(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_nrings(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_nrings';


ALTER FUNCTION public.st_nrings(geometry) OWNER TO postgres;

--
-- TOC entry 492 (class 1255 OID 1898669)
-- Dependencies: 5 2104
-- Name: st_numgeometries(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_numgeometries(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_numgeometries_collection';


ALTER FUNCTION public.st_numgeometries(geometry) OWNER TO postgres;

--
-- TOC entry 502 (class 1255 OID 1898679)
-- Dependencies: 5 2104
-- Name: st_numinteriorring(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_numinteriorring(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_numinteriorrings_polygon';


ALTER FUNCTION public.st_numinteriorring(geometry) OWNER TO postgres;

--
-- TOC entry 500 (class 1255 OID 1898677)
-- Dependencies: 5 2104
-- Name: st_numinteriorrings(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_numinteriorrings(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_numinteriorrings_polygon';


ALTER FUNCTION public.st_numinteriorrings(geometry) OWNER TO postgres;

--
-- TOC entry 490 (class 1255 OID 1898667)
-- Dependencies: 5 2104
-- Name: st_numpoints(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_numpoints(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_numpoints_linestring';


ALTER FUNCTION public.st_numpoints(geometry) OWNER TO postgres;

--
-- TOC entry 672 (class 1255 OID 1898846)
-- Dependencies: 5 2104 2104
-- Name: st_orderingequals(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_orderingequals(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ 
	SELECT $1 ~= $2 AND _ST_OrderingEquals($1, $2)
	$_$;


ALTER FUNCTION public.st_orderingequals(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 439 (class 1255 OID 1898617)
-- Dependencies: 5 2104 2104
-- Name: st_overlaps(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_overlaps(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Overlaps($1,$2)$_$;


ALTER FUNCTION public.st_overlaps(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 941 (class 1255 OID 1898282)
-- Dependencies: 5 2104
-- Name: st_perimeter(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_perimeter(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_perimeter2d_poly';


ALTER FUNCTION public.st_perimeter(geometry) OWNER TO postgres;

--
-- TOC entry 939 (class 1255 OID 1898280)
-- Dependencies: 5 2104
-- Name: st_perimeter2d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_perimeter2d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_perimeter2d_poly';


ALTER FUNCTION public.st_perimeter2d(geometry) OWNER TO postgres;

--
-- TOC entry 937 (class 1255 OID 1898278)
-- Dependencies: 5 2104
-- Name: st_perimeter3d(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_perimeter3d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_perimeter_poly';


ALTER FUNCTION public.st_perimeter3d(geometry) OWNER TO postgres;

--
-- TOC entry 675 (class 1255 OID 1898849)
-- Dependencies: 5 2104
-- Name: st_point(double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_point(double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint';


ALTER FUNCTION public.st_point(double precision, double precision) OWNER TO postgres;

--
-- TOC entry 953 (class 1255 OID 1898294)
-- Dependencies: 5 2104
-- Name: st_point_inside_circle(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_point_inside_circle(geometry, double precision, double precision, double precision) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_inside_circle_point';


ALTER FUNCTION public.st_point_inside_circle(geometry, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 544 (class 1255 OID 1898721)
-- Dependencies: 5 2104
-- Name: st_pointfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pointfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'POINT'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_pointfromtext(text) OWNER TO postgres;

--
-- TOC entry 546 (class 1255 OID 1898723)
-- Dependencies: 5 2104
-- Name: st_pointfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pointfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1, $2)) = 'POINT'
	THEN ST_GeomFromText($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_pointfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 595 (class 1255 OID 1898772)
-- Dependencies: 5 2104
-- Name: st_pointfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pointfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'POINT'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_pointfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 593 (class 1255 OID 1898770)
-- Dependencies: 5 2104
-- Name: st_pointfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pointfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'POINT'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_pointfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 508 (class 1255 OID 1898685)
-- Dependencies: 5 2104 2104
-- Name: st_pointn(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pointn(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_pointn_linestring';


ALTER FUNCTION public.st_pointn(geometry, integer) OWNER TO postgres;

--
-- TOC entry 447 (class 1255 OID 1898625)
-- Dependencies: 5 2104 2104
-- Name: st_pointonsurface(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_pointonsurface(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'pointonsurface';


ALTER FUNCTION public.st_pointonsurface(geometry) OWNER TO postgres;

--
-- TOC entry 554 (class 1255 OID 1898731)
-- Dependencies: 5 2104
-- Name: st_polyfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polyfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'POLYGON'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_polyfromtext(text) OWNER TO postgres;

--
-- TOC entry 556 (class 1255 OID 1898733)
-- Dependencies: 5 2104
-- Name: st_polyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polyfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1, $2)) = 'POLYGON'
	THEN ST_GeomFromText($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_polyfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 607 (class 1255 OID 1898784)
-- Dependencies: 5 2104
-- Name: st_polyfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polyfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'POLYGON'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_polyfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 605 (class 1255 OID 1898782)
-- Dependencies: 5 2104
-- Name: st_polyfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polyfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'POLYGON'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_polyfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 678 (class 1255 OID 1898852)
-- Dependencies: 2104 5 2104
-- Name: st_polygon(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polygon(geometry, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ 
	SELECT setSRID(makepolygon($1), $2)
	$_$;


ALTER FUNCTION public.st_polygon(geometry, integer) OWNER TO postgres;

--
-- TOC entry 560 (class 1255 OID 1898737)
-- Dependencies: 5 2104
-- Name: st_polygonfromtext(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polygonfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_PolyFromText($1)$_$;


ALTER FUNCTION public.st_polygonfromtext(text) OWNER TO postgres;

--
-- TOC entry 558 (class 1255 OID 1898735)
-- Dependencies: 5 2104
-- Name: st_polygonfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polygonfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT PolyFromText($1, $2)$_$;


ALTER FUNCTION public.st_polygonfromtext(text, integer) OWNER TO postgres;

--
-- TOC entry 611 (class 1255 OID 1898788)
-- Dependencies: 5 2104
-- Name: st_polygonfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polygonfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'POLYGON'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_polygonfromwkb(bytea) OWNER TO postgres;

--
-- TOC entry 609 (class 1255 OID 1898786)
-- Dependencies: 5 2104
-- Name: st_polygonfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polygonfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1,$2)) = 'POLYGON'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


ALTER FUNCTION public.st_polygonfromwkb(bytea, integer) OWNER TO postgres;

--
-- TOC entry 1041 (class 1255 OID 1898381)
-- Dependencies: 5 2104 2106
-- Name: st_polygonize(geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polygonize(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'polygonize_garray';


ALTER FUNCTION public.st_polygonize(geometry[]) OWNER TO postgres;

--
-- TOC entry 1040 (class 1255 OID 1898380)
-- Dependencies: 5 2104 2106
-- Name: st_polygonize_garray(geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_polygonize_garray(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'polygonize_garray';


ALTER FUNCTION public.st_polygonize_garray(geometry[]) OWNER TO postgres;

--
-- TOC entry 857 (class 1255 OID 1898165)
-- Dependencies: 5
-- Name: st_postgis_gist_joinsel(internal, oid, internal, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_postgis_gist_joinsel(internal, oid, internal, smallint) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_joinsel';


ALTER FUNCTION public.st_postgis_gist_joinsel(internal, oid, internal, smallint) OWNER TO postgres;

--
-- TOC entry 856 (class 1255 OID 1898164)
-- Dependencies: 5
-- Name: st_postgis_gist_sel(internal, oid, internal, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_postgis_gist_sel(internal, oid, internal, integer) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_sel';


ALTER FUNCTION public.st_postgis_gist_sel(internal, oid, internal, integer) OWNER TO postgres;

--
-- TOC entry 406 (class 1255 OID 1898587)
-- Dependencies: 5 2104 2104
-- Name: st_relate(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_relate(geometry, geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'relate_full';


ALTER FUNCTION public.st_relate(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 408 (class 1255 OID 1898589)
-- Dependencies: 5 2104 2104
-- Name: st_relate(geometry, geometry, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_relate(geometry, geometry, text) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'relate_pattern';


ALTER FUNCTION public.st_relate(geometry, geometry, text) OWNER TO postgres;

--
-- TOC entry 1029 (class 1255 OID 1898369)
-- Dependencies: 5 2104 2104
-- Name: st_removepoint(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_removepoint(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_removepoint';


ALTER FUNCTION public.st_removepoint(geometry, integer) OWNER TO postgres;

--
-- TOC entry 980 (class 1255 OID 1898321)
-- Dependencies: 5 2104 2104
-- Name: st_reverse(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_reverse(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_reverse';


ALTER FUNCTION public.st_reverse(geometry) OWNER TO postgres;

--
-- TOC entry 796 (class 1255 OID 1898083)
-- Dependencies: 5 2104 2104
-- Name: st_rotate(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rotate(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT rotateZ($1, $2)$_$;


ALTER FUNCTION public.st_rotate(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 798 (class 1255 OID 1898085)
-- Dependencies: 5 2104 2104
-- Name: st_rotatex(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rotatex(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1, 1, 0, 0, 0, cos($2), -sin($2), 0, sin($2), cos($2), 0, 0, 0)$_$;


ALTER FUNCTION public.st_rotatex(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 800 (class 1255 OID 1898087)
-- Dependencies: 5 2104 2104
-- Name: st_rotatey(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rotatey(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  cos($2), 0, sin($2),  0, 1, 0,  -sin($2), 0, cos($2), 0,  0, 0)$_$;


ALTER FUNCTION public.st_rotatey(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 794 (class 1255 OID 1898081)
-- Dependencies: 5 2104 2104
-- Name: st_rotatez(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_rotatez(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  cos($2), -sin($2), 0,  sin($2), cos($2), 0,  0, 0, 1,  0, 0, 0)$_$;


ALTER FUNCTION public.st_rotatez(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 808 (class 1255 OID 1898095)
-- Dependencies: 5 2104 2104
-- Name: st_scale(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_scale(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT scale($1, $2, $3, 1)$_$;


ALTER FUNCTION public.st_scale(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 806 (class 1255 OID 1898093)
-- Dependencies: 5 2104 2104
-- Name: st_scale(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_scale(geometry, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  $2, 0, 0,  0, $3, 0,  0, 0, $4,  0, 0, 0)$_$;


ALTER FUNCTION public.st_scale(geometry, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 352 (class 1255 OID 1898518)
-- Dependencies: 5 2104 2104
-- Name: st_segmentize(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_segmentize(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_segmentize2d';


ALTER FUNCTION public.st_segmentize(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 915 (class 1255 OID 1898256)
-- Dependencies: 5 2114 2114
-- Name: st_setfactor(chip, real); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setfactor(chip, real) RETURNS chip
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_setFactor';


ALTER FUNCTION public.st_setfactor(chip, real) OWNER TO postgres;

--
-- TOC entry 1031 (class 1255 OID 1898371)
-- Dependencies: 5 2104 2104 2104
-- Name: st_setpoint(geometry, integer, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setpoint(geometry, integer, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_setpoint_linestring';


ALTER FUNCTION public.st_setpoint(geometry, integer, geometry) OWNER TO postgres;

--
-- TOC entry 528 (class 1255 OID 1898705)
-- Dependencies: 5 2104 2104
-- Name: st_setsrid(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_setsrid(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_setSRID';


ALTER FUNCTION public.st_setsrid(geometry, integer) OWNER TO postgres;

--
-- TOC entry 812 (class 1255 OID 1898099)
-- Dependencies: 5 2104 2104
-- Name: st_shift_longitude(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_shift_longitude(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_longitude_shift';


ALTER FUNCTION public.st_shift_longitude(geometry) OWNER TO postgres;

--
-- TOC entry 643 (class 1255 OID 1898820)
-- Dependencies: 5 2104 2104 2104
-- Name: st_shortestline(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_shortestline(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_shortestline2d';


ALTER FUNCTION public.st_shortestline(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 340 (class 1255 OID 1898508)
-- Dependencies: 5 2104 2104
-- Name: st_simplify(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_simplify(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_simplify2d';


ALTER FUNCTION public.st_simplify(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 376 (class 1255 OID 1898543)
-- Dependencies: 5 2104 2104
-- Name: st_simplifypreservetopology(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_simplifypreservetopology(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'topologypreservesimplify';


ALTER FUNCTION public.st_simplifypreservetopology(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 346 (class 1255 OID 1898514)
-- Dependencies: 5 2104 2104
-- Name: st_snaptogrid(geometry, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_snaptogrid(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_SnapToGrid($1, 0, 0, $2, $2)$_$;


ALTER FUNCTION public.st_snaptogrid(geometry, double precision) OWNER TO postgres;

--
-- TOC entry 344 (class 1255 OID 1898512)
-- Dependencies: 5 2104 2104
-- Name: st_snaptogrid(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_snaptogrid(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_SnapToGrid($1, 0, 0, $2, $3)$_$;


ALTER FUNCTION public.st_snaptogrid(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 342 (class 1255 OID 1898510)
-- Dependencies: 5 2104 2104
-- Name: st_snaptogrid(geometry, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_snaptogrid(geometry, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_snaptogrid';


ALTER FUNCTION public.st_snaptogrid(geometry, double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 350 (class 1255 OID 1898516)
-- Dependencies: 5 2104 2104 2104
-- Name: st_snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_snaptogrid_pointoff';


ALTER FUNCTION public.st_snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 1071 (class 1255 OID 1898059)
-- Dependencies: 5 2101
-- Name: st_spheroid_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_spheroid_in(cstring) RETURNS spheroid
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ellipsoid_in';


ALTER FUNCTION public.st_spheroid_in(cstring) OWNER TO postgres;

--
-- TOC entry 1072 (class 1255 OID 1898060)
-- Dependencies: 2101 5
-- Name: st_spheroid_out(spheroid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_spheroid_out(spheroid) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ellipsoid_out';


ALTER FUNCTION public.st_spheroid_out(spheroid) OWNER TO postgres;

--
-- TOC entry 902 (class 1255 OID 1898243)
-- Dependencies: 5 2114
-- Name: st_srid(chip); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_srid(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getSRID';


ALTER FUNCTION public.st_srid(chip) OWNER TO postgres;

--
-- TOC entry 526 (class 1255 OID 1898703)
-- Dependencies: 5 2104
-- Name: st_srid(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_srid(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_getSRID';


ALTER FUNCTION public.st_srid(geometry) OWNER TO postgres;

--
-- TOC entry 518 (class 1255 OID 1898695)
-- Dependencies: 5 2104 2104
-- Name: st_startpoint(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_startpoint(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_startpoint_linestring';


ALTER FUNCTION public.st_startpoint(geometry) OWNER TO postgres;

--
-- TOC entry 919 (class 1255 OID 1898260)
-- Dependencies: 5 2104
-- Name: st_summary(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_summary(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_summary';


ALTER FUNCTION public.st_summary(geometry) OWNER TO postgres;

--
-- TOC entry 385 (class 1255 OID 1898552)
-- Dependencies: 5 2104 2104 2104
-- Name: st_symdifference(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_symdifference(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'symdifference';


ALTER FUNCTION public.st_symdifference(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 387 (class 1255 OID 1898554)
-- Dependencies: 5 2104 2104 2104
-- Name: st_symmetricdifference(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_symmetricdifference(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'symdifference';


ALTER FUNCTION public.st_symmetricdifference(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 781 (class 1255 OID 1898467)
-- Dependencies: 5 2104
-- Name: st_text(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_text(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_text';


ALTER FUNCTION public.st_text(geometry) OWNER TO postgres;

--
-- TOC entry 414 (class 1255 OID 1898594)
-- Dependencies: 5 2104 2104
-- Name: st_touches(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_touches(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Touches($1,$2)$_$;


ALTER FUNCTION public.st_touches(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1110 (class 1255 OID 1898449)
-- Dependencies: 5 2104 2104
-- Name: st_transform(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_transform(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'transform';


ALTER FUNCTION public.st_transform(geometry, integer) OWNER TO postgres;

--
-- TOC entry 804 (class 1255 OID 1898091)
-- Dependencies: 5 2104 2104
-- Name: st_translate(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_translate(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT translate($1, $2, $3, 0)$_$;


ALTER FUNCTION public.st_translate(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 802 (class 1255 OID 1898089)
-- Dependencies: 5 2104 2104
-- Name: st_translate(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_translate(geometry, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1, 1, 0, 0, 0, 1, 0, 0, 0, 1, $2, $3, $4)$_$;


ALTER FUNCTION public.st_translate(geometry, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 810 (class 1255 OID 1898097)
-- Dependencies: 5 2104 2104
-- Name: st_transscale(geometry, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_transscale(geometry, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  $4, 0, 0,  0, $5, 0,
		0, 0, 1,  $2 * $4, $3 * $5, 0)$_$;


ALTER FUNCTION public.st_transscale(geometry, double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 404 (class 1255 OID 1898578)
-- Dependencies: 5 2104 2106
-- Name: st_union(geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_union(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'pgis_union_geometry_array';


ALTER FUNCTION public.st_union(geometry[]) OWNER TO postgres;

--
-- TOC entry 389 (class 1255 OID 1898556)
-- Dependencies: 5 2104 2104 2104
-- Name: st_union(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_union(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geomunion';


ALTER FUNCTION public.st_union(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 403 (class 1255 OID 1898577)
-- Dependencies: 5 2104 2106
-- Name: st_unite_garray(geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_unite_garray(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'pgis_union_geometry_array';


ALTER FUNCTION public.st_unite_garray(geometry[]) OWNER TO postgres;

--
-- TOC entry 908 (class 1255 OID 1898249)
-- Dependencies: 5 2114
-- Name: st_width(chip); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_width(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getWidth';


ALTER FUNCTION public.st_width(chip) OWNER TO postgres;

--
-- TOC entry 425 (class 1255 OID 1898605)
-- Dependencies: 5 2104 2104
-- Name: st_within(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_within(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Within($1,$2)$_$;


ALTER FUNCTION public.st_within(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 669 (class 1255 OID 1898843)
-- Dependencies: 2104 5
-- Name: st_wkbtosql(bytea); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_wkbtosql(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_WKB';


ALTER FUNCTION public.st_wkbtosql(bytea) OWNER TO postgres;

--
-- TOC entry 668 (class 1255 OID 1898842)
-- Dependencies: 5 2104
-- Name: st_wkttosql(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_wkttosql(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_text';


ALTER FUNCTION public.st_wkttosql(text) OWNER TO postgres;

--
-- TOC entry 510 (class 1255 OID 1898687)
-- Dependencies: 5 2104
-- Name: st_x(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_x(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_x_point';


ALTER FUNCTION public.st_x(geometry) OWNER TO postgres;

--
-- TOC entry 829 (class 1255 OID 1898121)
-- Dependencies: 5 2107
-- Name: st_xmax(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_xmax(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_xmax';


ALTER FUNCTION public.st_xmax(box3d) OWNER TO postgres;

--
-- TOC entry 823 (class 1255 OID 1898115)
-- Dependencies: 5 2107
-- Name: st_xmin(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_xmin(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_xmin';


ALTER FUNCTION public.st_xmin(box3d) OWNER TO postgres;

--
-- TOC entry 512 (class 1255 OID 1898689)
-- Dependencies: 5 2104
-- Name: st_y(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_y(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_y_point';


ALTER FUNCTION public.st_y(geometry) OWNER TO postgres;

--
-- TOC entry 831 (class 1255 OID 1898123)
-- Dependencies: 5 2107
-- Name: st_ymax(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_ymax(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_ymax';


ALTER FUNCTION public.st_ymax(box3d) OWNER TO postgres;

--
-- TOC entry 825 (class 1255 OID 1898117)
-- Dependencies: 5 2107
-- Name: st_ymin(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_ymin(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_ymin';


ALTER FUNCTION public.st_ymin(box3d) OWNER TO postgres;

--
-- TOC entry 514 (class 1255 OID 1898691)
-- Dependencies: 5 2104
-- Name: st_z(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_z(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_z_point';


ALTER FUNCTION public.st_z(geometry) OWNER TO postgres;

--
-- TOC entry 833 (class 1255 OID 1898125)
-- Dependencies: 5 2107
-- Name: st_zmax(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_zmax(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_zmax';


ALTER FUNCTION public.st_zmax(box3d) OWNER TO postgres;

--
-- TOC entry 986 (class 1255 OID 1898327)
-- Dependencies: 5 2104
-- Name: st_zmflag(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_zmflag(geometry) RETURNS smallint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_zmflag';


ALTER FUNCTION public.st_zmflag(geometry) OWNER TO postgres;

--
-- TOC entry 827 (class 1255 OID 1898119)
-- Dependencies: 5 2107
-- Name: st_zmin(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION st_zmin(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_zmin';


ALTER FUNCTION public.st_zmin(box3d) OWNER TO postgres;

--
-- TOC entry 517 (class 1255 OID 1898694)
-- Dependencies: 5 2104 2104
-- Name: startpoint(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION startpoint(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_startpoint_linestring';


ALTER FUNCTION public.startpoint(geometry) OWNER TO postgres;

--
-- TOC entry 1240 (class 1255 OID 2964549)
-- Dependencies: 5
-- Name: subarray(integer[], integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION subarray(integer[], integer) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'subarray';


ALTER FUNCTION public.subarray(integer[], integer) OWNER TO postgres;

--
-- TOC entry 1239 (class 1255 OID 2964548)
-- Dependencies: 5
-- Name: subarray(integer[], integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION subarray(integer[], integer, integer) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'subarray';


ALTER FUNCTION public.subarray(integer[], integer, integer) OWNER TO postgres;

--
-- TOC entry 918 (class 1255 OID 1898259)
-- Dependencies: 5 2104
-- Name: summary(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION summary(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_summary';


ALTER FUNCTION public.summary(geometry) OWNER TO postgres;

--
-- TOC entry 384 (class 1255 OID 1898551)
-- Dependencies: 5 2104 2104 2104
-- Name: symdifference(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION symdifference(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'symdifference';


ALTER FUNCTION public.symdifference(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 386 (class 1255 OID 1898553)
-- Dependencies: 5 2104 2104 2104
-- Name: symmetricdifference(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION symmetricdifference(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'symdifference';


ALTER FUNCTION public.symmetricdifference(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 331 (class 1255 OID 1898483)
-- Dependencies: 5 2104
-- Name: text(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION text(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_text';


ALTER FUNCTION public.text(geometry) OWNER TO postgres;

--
-- TOC entry 412 (class 1255 OID 1898592)
-- Dependencies: 5 2104 2104
-- Name: touches(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION touches(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'touches';


ALTER FUNCTION public.touches(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 1109 (class 1255 OID 1898448)
-- Dependencies: 5 2104 2104
-- Name: transform(geometry, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION transform(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'transform';


ALTER FUNCTION public.transform(geometry, integer) OWNER TO postgres;

--
-- TOC entry 803 (class 1255 OID 1898090)
-- Dependencies: 5 2104 2104
-- Name: translate(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION translate(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT translate($1, $2, $3, 0)$_$;


ALTER FUNCTION public.translate(geometry, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 801 (class 1255 OID 1898088)
-- Dependencies: 5 2104 2104
-- Name: translate(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION translate(geometry, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1, 1, 0, 0, 0, 1, 0, 0, 0, 1, $2, $3, $4)$_$;


ALTER FUNCTION public.translate(geometry, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 809 (class 1255 OID 1898096)
-- Dependencies: 5 2104 2104
-- Name: transscale(geometry, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION transscale(geometry, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  $4, 0, 0,  0, $5, 0,
		0, 0, 1,  $2 * $4, $3 * $5, 0)$_$;


ALTER FUNCTION public.transscale(geometry, double precision, double precision, double precision, double precision) OWNER TO postgres;

--
-- TOC entry 1276 (class 1255 OID 16607)
-- Dependencies: 5 2435
-- Name: trigger_usuario(); Type: FUNCTION; Schema: public; Owner: rchumacero
--

CREATE FUNCTION trigger_usuario() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
/**************************************************************************
 SISTEMA ENDESIS - SISTEMA DE SEGURIDAD (SSS)
***************************************************************************
 SCRIPT: 		trisg_usuario
 DESCRIPCIÓN: 	Permite insertar, modificar y eliminar usuarios de la base
                de datos
 AUTOR: 		KPLIAN(rac)
 FECHA:			11-09-2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:
 
 DESCRIPCION:	cambio que permite crear nombre de usuario con .
 AUTOR:			KPLIAN (rac)
 FECHA:			26/11/2011

***************************************************************************/
--------------------------
-- CUERPO DE LA FUNCIÓN --
--------------------------

--**** DECLARACION DE VARIABLES DE LA FUNCIÓN (LOCALES) ****---


DECLARE

    --PARÁMETROS FIJOS

    g_consulta         text;    -- VARIABLE QUE CONTENDRÁ LA CONSULTA DINÁMICA PARA EL FILTRO
    g_new_login            text;
    g_old_login            text;
    y varchar;
    
    _SEMILLA varchar;
BEGIN

      --*** EJECUCIÓN DEL PROCEDIMIENTO ESPECÍFICO

  --procedimiento de creación de base de datos

_SEMILLA = '+_)(*&^%$#@!@TERPODO';


    IF TG_OP = 'INSERT' THEN

                BEGIN
                select (current_database()::text)||'_'||NEW.cuenta into g_new_login;
                     -- Creación Usuario
                     g_consulta := 'CREATE USER'||' "'||g_new_login||'"';
                     g_consulta := g_consulta||' '||'WITH ENCRYPTED PASSWORD '''||md5(_SEMILLA||NEW.contrasena)||'''';
                     g_consulta := g_consulta||' '||'VALID UNTIL '''||NEW.fecha_caducidad||'''';

                     EXECUTE(g_consulta);

                  
                     --ASGINACION DE ROLES
                     
                     y:='ALTER GROUP rol_usuario_'||current_database()::text||'
                     ADD USER  "'||g_new_login||'"';
                     EXECUTE (y); 
                     
         
                END;

          --procedimiento de modificacion de usuario

     
   ELSIF TG_OP = 'UPDATE' THEN

        BEGIN
        
            --raise exception  'llega';
            --Modificación de login
               select (current_database()::text)||'_'||NEW.cuenta into g_new_login;
               select (current_database()::text)||'_'||OLD.cuenta into g_old_login;
                 
                
           
                
             IF (OLD.cuenta != NEW.cuenta) THEN
               		 g_consulta := 'ALTER USER "'||g_old_login||'" RENAME TO "'||g_new_login||'"';
          
           		     EXECUTE(g_consulta);
                   
             END IF; 

             -- Modificación de la contraseña

            IF (OLD.contrasena != NEW.contrasena) THEN

                    g_consulta := NULL;
                    g_consulta := 'ALTER USER "'||g_new_login||'" ';
                    g_consulta := g_consulta||' '||'WITH ENCRYPTED PASSWORD '''||md5(_SEMILLA||NEW.contrasena)||'''';

                    EXECUTE(g_consulta);
                    
                   
                    
            END IF;

                 -- Modificación de la Fecha de Validez del usuario

            IF (OLD.fecha_caducidad != NEW.fecha_caducidad) THEN

                    g_consulta := NULL;
                    g_consulta := 'ALTER USER "'||g_new_login||'" ';
                    g_consulta := g_consulta||' '||'VALID UNTIL '''||NEW.fecha_caducidad||'''';

                    EXECUTE(g_consulta);

            END IF;
            
            
                   -- Modificación de la Fecha de Validez del usuario

           IF (NEW.estado_reg != OLD.estado_reg) THEN

                  IF (NEW.estado_reg = 'inactivo') THEN

                          g_consulta := NULL;
                          g_consulta := 'ALTER USER "'||g_new_login||'" ';
                          g_consulta := g_consulta||' '||'VALID UNTIL '''||now()||'''';
                          
                          EXECUTE(g_consulta);
                   ELSE      
                   
                          g_consulta := NULL;
                          g_consulta := 'ALTER USER "'||g_new_login||'"';
                          g_consulta := g_consulta||' '||'VALID UNTIL '''||NEW.fecha_caducidad||'''';

                          EXECUTE(g_consulta);
                   END IF;
            END IF;


        END;

  --procedimiento de eliminación de usuario

   ELSIF TG_OP = 'DELETE' THEN

        BEGIN
        select (current_database()::text)||'_'||OLD.cuenta into g_old_login;
             g_consulta := 'DROP USER "'||g_old_login||'"';
            
             EXECUTE(g_consulta);

        END;
        --*/

   END IF;

   RETURN NULL;

END;
$_$;


ALTER FUNCTION public.trigger_usuario() OWNER TO rchumacero;

--
-- TOC entry 1237 (class 1255 OID 2964545)
-- Dependencies: 5
-- Name: uniq(integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION uniq(integer[]) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'uniq';


ALTER FUNCTION public.uniq(integer[]) OWNER TO postgres;

--
-- TOC entry 402 (class 1255 OID 1898576)
-- Dependencies: 5 2104 2106
-- Name: unite_garray(geometry[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION unite_garray(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'pgis_union_geometry_array';


ALTER FUNCTION public.unite_garray(geometry[]) OWNER TO postgres;

--
-- TOC entry 651 (class 1255 OID 1898829)
-- Dependencies: 5 2435
-- Name: unlockrows(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION unlockrows(text) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $_$ 
DECLARE
	ret int;
BEGIN

	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	EXECUTE 'DELETE FROM authorization_table where authid = ' ||
		quote_literal($1);

	GET DIAGNOSTICS ret = ROW_COUNT;

	RETURN ret;
END;
$_$;


ALTER FUNCTION public.unlockrows(text) OWNER TO postgres;

--
-- TOC entry 1105 (class 1255 OID 1898444)
-- Dependencies: 5 2435
-- Name: updategeometrysrid(character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION updategeometrysrid(character varying, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT UpdateGeometrySRID('','',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;


ALTER FUNCTION public.updategeometrysrid(character varying, character varying, integer) OWNER TO postgres;

--
-- TOC entry 1104 (class 1255 OID 1898443)
-- Dependencies: 5 2435
-- Name: updategeometrysrid(character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION updategeometrysrid(character varying, character varying, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT UpdateGeometrySRID('',$1,$2,$3,$4) into ret;
	RETURN ret;
END;
$_$;


ALTER FUNCTION public.updategeometrysrid(character varying, character varying, character varying, integer) OWNER TO postgres;

--
-- TOC entry 1103 (class 1255 OID 1898442)
-- Dependencies: 5 2435
-- Name: updategeometrysrid(character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION updategeometrysrid(character varying, character varying, character varying, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	catalog_name alias for $1;
	schema_name alias for $2;
	table_name alias for $3;
	column_name alias for $4;
	new_srid alias for $5;
	myrec RECORD;
	okay boolean;
	cname varchar;
	real_schema name;

BEGIN


	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = 'f';

		FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := 't';
		END LOOP;

		IF ( okay <> 't' ) THEN
			RAISE EXCEPTION 'Invalid schema name';
		ELSE
			real_schema = schema_name;
		END IF;
	ELSE
		SELECT INTO real_schema current_schema()::text;
	END IF;

	-- Find out if the column is in the geometry_columns table
	okay = 'f';
	FOR myrec IN SELECT * from geometry_columns where f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := 't';
	END LOOP;
	IF (okay <> 't') THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
		RETURN 'f';
	END IF;

	-- Update ref from geometry_columns table
	EXECUTE 'UPDATE geometry_columns SET SRID = ' || new_srid::text ||
		' where f_table_schema = ' ||
		quote_literal(real_schema) || ' and f_table_name = ' ||
		quote_literal(table_name)  || ' and f_geometry_column = ' ||
		quote_literal(column_name);

	-- Make up constraint name
	cname = 'enforce_srid_'  || column_name;

	-- Drop enforce_srid constraint
	EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||
		'.' || quote_ident(table_name) ||
		' DROP constraint ' || quote_ident(cname);

	-- Update geometries SRID
	EXECUTE 'UPDATE ' || quote_ident(real_schema) ||
		'.' || quote_ident(table_name) ||
		' SET ' || quote_ident(column_name) ||
		' = setSRID(' || quote_ident(column_name) ||
		', ' || new_srid::text || ')';

	-- Reset enforce_srid constraint
	EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||
		'.' || quote_ident(table_name) ||
		' ADD constraint ' || quote_ident(cname) ||
		' CHECK (srid(' || quote_ident(column_name) ||
		') = ' || new_srid::text || ')';

	RETURN real_schema || '.' || table_name || '.' || column_name ||' SRID changed to ' || new_srid::text;

END;
$_$;


ALTER FUNCTION public.updategeometrysrid(character varying, character varying, character varying, character varying, integer) OWNER TO postgres;

--
-- TOC entry 907 (class 1255 OID 1898248)
-- Dependencies: 5 2114
-- Name: width(chip); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION width(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getWidth';


ALTER FUNCTION public.width(chip) OWNER TO postgres;

--
-- TOC entry 423 (class 1255 OID 1898603)
-- Dependencies: 5 2104 2104
-- Name: within(geometry, geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION within(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'within';


ALTER FUNCTION public.within(geometry, geometry) OWNER TO postgres;

--
-- TOC entry 509 (class 1255 OID 1898686)
-- Dependencies: 5 2104
-- Name: x(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION x(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_x_point';


ALTER FUNCTION public.x(geometry) OWNER TO postgres;

--
-- TOC entry 828 (class 1255 OID 1898120)
-- Dependencies: 5 2107
-- Name: xmax(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xmax(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_xmax';


ALTER FUNCTION public.xmax(box3d) OWNER TO postgres;

--
-- TOC entry 822 (class 1255 OID 1898114)
-- Dependencies: 5 2107
-- Name: xmin(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xmin(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_xmin';


ALTER FUNCTION public.xmin(box3d) OWNER TO postgres;

--
-- TOC entry 511 (class 1255 OID 1898688)
-- Dependencies: 5 2104
-- Name: y(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION y(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_y_point';


ALTER FUNCTION public.y(geometry) OWNER TO postgres;

--
-- TOC entry 830 (class 1255 OID 1898122)
-- Dependencies: 5 2107
-- Name: ymax(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ymax(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_ymax';


ALTER FUNCTION public.ymax(box3d) OWNER TO postgres;

--
-- TOC entry 824 (class 1255 OID 1898116)
-- Dependencies: 5 2107
-- Name: ymin(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ymin(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_ymin';


ALTER FUNCTION public.ymin(box3d) OWNER TO postgres;

--
-- TOC entry 513 (class 1255 OID 1898690)
-- Dependencies: 5 2104
-- Name: z(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION z(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_z_point';


ALTER FUNCTION public.z(geometry) OWNER TO postgres;

--
-- TOC entry 832 (class 1255 OID 1898124)
-- Dependencies: 5 2107
-- Name: zmax(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION zmax(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_zmax';


ALTER FUNCTION public.zmax(box3d) OWNER TO postgres;

--
-- TOC entry 985 (class 1255 OID 1898326)
-- Dependencies: 5 2104
-- Name: zmflag(geometry); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION zmflag(geometry) RETURNS smallint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_zmflag';


ALTER FUNCTION public.zmflag(geometry) OWNER TO postgres;

--
-- TOC entry 826 (class 1255 OID 1898118)
-- Dependencies: 5 2107
-- Name: zmin(box3d); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION zmin(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_zmin';


ALTER FUNCTION public.zmin(box3d) OWNER TO postgres;

SET search_path = rhum, pg_catalog;

--
-- TOC entry 281 (class 1255 OID 1475533)
-- Dependencies: 12 2435
-- Name: __24nov11_ft_estructura_uo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: postgres
--

CREATE FUNCTION __24nov11_ft_estructura_uo_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		rhum.ft_estructura_uo_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 	    KPLIAN (mzm)
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		23-05-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_uo  				integer;

BEGIN

     v_nombre_funcion:='rhum.ft_estructura_uo_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:  RH_ESTRUO_INS
 #DESCRIPCION:	Inserta estructura de uos
 #AUTOR:			
 #FECHA:		23-05-2011	
***********************************/
     if(par_transaccion='RH_ESTRUO_INS')then

        
          BEGIN
               -- validacion de un solo nodo_base
               if exists (select distinct 1 from rhum.tuo where nodo_base='si' and estado_reg='activo' and v_parametros.nodo_base='si') then
                  raise exception 'Insercion no realizada. Ya se definio alguna unidad como nodo base';
               end if;
               
               -- verificar duplicidad de codigo de uo
               if exists (select distinct 1 from rhum.tuo where lower(codigo)=lower(v_parametros.codigo) and estado_reg='activo') then
               end if;
               -- insercion de uo nueva
               select nextval('rhum.tuo_id_uo_seq')::regclass into v_id_uo;
               insert into rhum.tuo(id_uo,          codigo,      nombre_unidad,nombre_cargo,   descripcion, cargo_individual,presupuesta,    estado_reg,  fecha_reg,id_usuario_reg, nodo_base)
               values(v_id_uo, upper(v_parametros.codigo), upper(v_parametros.nombre_unidad), upper(v_parametros.nombre_cargo), v_parametros.descripcion, v_parametros.cargo_individual, v_parametros.presupuesta, 'activo', now()::date, par_id_usuario, v_parametros.nodo_base);

               -- relacion de uo_hijo a o_padre
               INSERT INTO rhum.testructura_uo(id_uo_hijo, id_uo_padre,estado_reg, id_usuario_reg, fecha_reg)
               values(v_id_uo, v_parametros.id_uo_padre,'activo',    par_id_usuario, now()::date);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','estructura uo '||v_parametros.nombre_unidad ||' insertado con exito a ' || v_parametros.id_uo_padre);
               v_resp = f_agrega_clave(v_resp,'id_uo',v_id_uo::varchar);
         END;
 /*******************************    
 #TRANSACCION:  RH_ESTRUO_MOD
 #DESCRIPCION:	Modifica la parametrizacion seleccionada
 #AUTOR:			
 #FECHA:		23-05-2011
***********************************/
     elsif(par_transaccion='RH_ESTRUO_MOD')then

          
          BEGIN
               -- validacion de un solo nodo_base
               if exists (select distinct 1 from rhum.tuo where nodo_base='si' and estado_reg='activo' and id_uo!=v_parametros.id_uo and v_parametros.nodo_base='si') then
                  raise exception 'Insercion no realizada. Ya se definio alguna unidad como nodo base';
               end if;
               
               update rhum.tuo
               set codigo=upper(v_parametros.codigo),
                   nombre_unidad= upper(v_parametros.nombre_unidad),
                   nombre_cargo=upper(v_parametros.nombre_cargo),
                   descripcion=v_parametros.descripcion,
                   cargo_individual=v_parametros.cargo_individual,
                   presupuesta=v_parametros.presupuesta,
                   nodo_base=v_parametros.nodo_base
                where id_uo=v_parametros.id_uo;
               
                v_resp = f_agrega_clave(v_resp,'mensaje','estructura uo modificado con exito '||v_parametros.id_uo);
                v_resp = f_agrega_clave(v_resp,'id_uo',v_parametros.id_uo::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  RH_ESTRUO_ELI
 #DESCRIPCION:	Inactiva la parametrizacion selecionada. Verifica dependencias hacia abajo
 #AUTOR:			
 #FECHA:		23-05-2011
***********************************/

    elsif(par_transaccion='RH_ESTRUO_ELI')then
        BEGIN
        
         --inactivacion de la estructura uo
              if exists (select distinct 1 from rhum.testructura_uo
                         where id_uo_hijo in (select id_uo_padre from rhum.testructura_uo where estado_reg='activo')) then
                         raise exception 'Eliminacion no realizada. La Unidad que se inactiva tiene dependencias';
              end if;
               update rhum.tuo
               set estado_reg='eliminado'
               where id_uo=v_parametros.id_uo;
              
               
               v_resp = f_agrega_clave(v_resp,'mensaje','estructura uo eliminada con exito '||v_parametros.id_uo);
               v_resp = f_agrega_clave(v_resp,'id_uo',v_parametros.id_uo::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.__24nov11_ft_estructura_uo_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1270 (class 1255 OID 1475535)
-- Dependencies: 12 2435
-- Name: __24nov11_ft_estructura_uo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: postgres
--

CREATE FUNCTION __24nov11_ft_estructura_uo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		RHUM.ft_uo_sel
 DESCRIPCIÓN:  listado de uo
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		21-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


v_condicion 		varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_estructura_uo_sel';

/*******************************
 #TRANSACCION:  RH_UO_SEL
 #DESCRIPCION:	Listado de uos
 #AUTOR:		
 #FECHA:		23/05/11	
***********************************/
     if(par_transaccion='RH_ESTRUO_SEL')then

          
          BEGIN

           if(v_parametros.id_padre = '%') then
               v_condicion:='uo.nodo_base=''si'' ';
           else
               v_condicion:='euo.id_uo_padre='||v_parametros.id_padre||' and uo.nodo_base=''no'' ';
           end if;
               v_condicion:=v_condicion ||' and euo.estado_reg=''activo'' and uo.estado_reg=''activo'' ';
               
               
               v_consulta:='SELECT
                                UO.id_uo,
                                UO.codigo,
                                UO.descripcion,
                                UO.cargo_individual,
                                UO.nombre_unidad,
                                UO.nombre_cargo,
                                UO.presupuesta,
                                UO.nodo_base,
                                UO.estado_reg,
                                UO.fecha_reg,
                                UO.id_usuario_reg,
                                UO.fecha_mod,
                                UO.id_usuario_mod,
                                PERREG.nombre_completo2 AS USUREG,
                                PERMOD.nombre_completo2 AS USUMOD,
                                euo.id_uo_padre,
                                euo.id_estructura_uo
                            FROM rhum.tuo UO
                            inner join rhum.testructura_uo euo
                            on UO.id_uo=euo.id_uo_hijo
                            INNER JOIN segu.tusuario USUREG ON  UO.id_usuario_reg=USUREG.id_usuario
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=UO.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE '|| v_condicion;
               
               
             --  v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by euo.id_uo_hijo,UO.nombre_unidad' ;

               return v_consulta;


         END;

/*******************************
 #TRANSACCION:  RH_ESTRUO_CONT
 #DESCRIPCION:	Conteo de estructura uos
 #AUTOR:		
 #FECHA:		24/05/11	
***********************************/
     elsif(par_transaccion='RH_ESTRUO_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(UO.id_uo)
                            FROM rhum.tuo UO
                            inner join rhum.testructura_uo euo
                            on UO.id_uo=euo.id_uo_hijo
                            INNER JOIN segu.tusuario USUREG ON  UO.id_usuario_reg=USUREG.id_usuario
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=UO.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE '|| v_condicion;
              -- v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.__24nov11_ft_estructura_uo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1268 (class 1255 OID 16609)
-- Dependencies: 12 2435
-- Name: __24nov11_ft_funcionario_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: rchumacero
--

CREATE FUNCTION __24nov11_ft_funcionario_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 funcionario: 		RHUM.ft_funcionario_sel
 DESCRIPCIÓN:  listado de funcionario
 AUTOR: 		
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		21-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_funcionario_sel';


     if(par_transaccion='RH_FUNCIO_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            FUNCIO.id_funcionario,
                            FUNCIO.codigo,
                            FUNCIO.estado_reg,
                            FUNCIO.fecha_reg,
                            FUNCIO.id_persona,
                            FUNCIO.id_usuario_reg,
                            FUNCIO.fecha_mod,
                            FUNCIO.id_usuario_mod,
                            PERSON.nombre_completo1 AS desc_person,
                            PERREG.nombre_completo1 AS desc_usureg,
                            PERSON.ci, PERSON.num_documento,
                            PERSON.telefono1, PERSON.celular1, PERSON.correo
                            FROM rhum.tfuncionario FUNCIO
                            INNER JOIN SEGU.vpersona PERSON ON PERSON.id_persona=FUNCIO.id_persona
                            INNER JOIN SEGU.tusuario USUARI ON USUARI.id_usuario=FUNCIO.id_usuario_reg
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUARI.id_persona
                            WHERE ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='RH_FUNCIO_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(FUNCIO.id_funcionario)
                            FROM rhum.tfuncionario FUNCIO
                            INNER JOIN SEGU.vpersona PERSON ON PERSON.id_persona=FUNCIO.id_persona
                            INNER JOIN SEGU.tusuario USUARI ON USUARI.id_usuario=FUNCIO.id_usuario_reg
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUARI.id_persona
                            WHERE ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.__24nov11_ft_funcionario_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1300 (class 1255 OID 3239135)
-- Dependencies: 12 2435
-- Name: f_obtener_funcionarios_x_uo(integer); Type: FUNCTION; Schema: rhum; Owner: rac
--

CREATE FUNCTION f_obtener_funcionarios_x_uo(kp_id_uo integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA ENDESIS - SISTEMA DE KARD
***************************************************************************
 SCRIPT:f_obtener_funcionarios_x_uo
 COMENTARIOS:
 AUTOR: MZM
 Fecha: 19-03-12

*/
DECLARE
v_respuesta varchar;
v_registros record;
v_id_uo     integer;
BEGIN

    for v_registros in (
    select e.desc_funcionario1 as nombre_completo
                         from rhum.vfuncionario e
                         inner join rhum.tuo_funcionario ha on ha.id_funcionario=e.id_funcionario
                         where ha.estado_reg='activo' and ha.id_uo=kp_id_uo) loop

               if(v_respuesta!='') then
                  v_respuesta:= COALESCE(v_respuesta,'')||'<br>-'||v_registros.nombre_completo;
               else
                  v_respuesta:=v_registros.nombre_completo;
               end if;

     end loop;
return v_respuesta;
END;
$$;


ALTER FUNCTION rhum.f_obtener_funcionarios_x_uo(kp_id_uo integer) OWNER TO rac;

--
-- TOC entry 277 (class 1255 OID 1475525)
-- Dependencies: 12 2435
-- Name: f_obtener_uo_x_funcionario(integer, character varying, date); Type: FUNCTION; Schema: rhum; Owner: postgres
--

CREATE FUNCTION f_obtener_uo_x_funcionario(par_id_funcionario integer, par_opcion character varying, par_fecha date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/************************************
FUNCION: f_obtener_uo_x_funcionario
AUTOR: 	    KPLIAN (mzm)
PARAMETROS: par_id_funcionario : Nodo a partir del cual se quiere obtener la uo (que presupuesta, que es gerencia, a la que pertenece en linea directa)
            par_opcion: presupuesto==> presupuesto, gerencia ==> gerencia, inmediato_superior==> superior, funcionario==> funcionario
            par_fecha: indica la fecha a la cual se quiere obtener la dependencia del funcionario, si se envia null, tomar la fecha actual
            Si no existe una asignacion activa para el funcionario a la fecha indicada ==> devolver -1
************************************/
DECLARE
    
    v_id_uo                              integer;
    v_registros                          record;
    v_mensaje_error                      varchar;
    v_uo_funcionario                     integer;
    v_gerencia                           varchar;
    v_presupuesta                        varchar;
    v_tope                               varchar;
    v_uo_padre                           integer;
    v_resp                               varchar;
    v_nombre_funcion                     text;
    

BEGIN

v_nombre_funcion:='rhum.f_obtener_uo_x_funcionario';
v_id_uo:=-1;
v_tope:='no';

    select  euo.id_uo_padre, UOFUNC.id_uo, UO.presupuesta, UO.gerencia, f_iif(UO.nodo_base='si','si','no')
    into v_uo_padre, v_uo_funcionario, v_presupuesta, v_gerencia, v_tope
    from rhum.tuo_funcionario UOFUNC
    inner join rhum.tuo UO on UO.id_uo=UOFUNC.id_uo
    inner join rhum.testructura_uo euo on euo.id_uo_hijo=UO.id_uo and UOFUNC.id_uo=euo.id_uo_hijo
    where
         ((UOFUNC.estado_reg='activo' and UOFUNC.fecha_asignacion<=coalesce(par_fecha,now()::date))
         or (UOFUNC.estado_reg='inactivo' and UOFUNC.fecha_finalizacion>=coalesce(par_fecha,now()::date)))
         and UOFUNC.id_funcionario=par_id_funcionario;
                              

    v_id_uo:= f_iif(((par_opcion='presupuesto' and v_presupuesta='si') or (par_opcion='gerencia' and v_gerencia='si') or (par_opcion='funcionario')), ''||v_uo_funcionario||'','-1')::integer;
 
   while (v_tope='no' and v_id_uo<1) loop

           select euo.id_uo_padre, UO.gerencia, UO.presupuesta, UO.id_uo, f_iif(UO.nodo_base='si','si','no') as nodo_base
           into v_uo_padre, v_gerencia, v_presupuesta, v_uo_funcionario, v_tope
           from rhum.testructura_uo euo
           inner join rhum.tuo UO on UO.id_uo=euo.id_uo_padre
           where euo.id_uo_hijo=v_uo_funcionario;
                 
                 if(par_opcion ='presupuesto') then
                        if(v_presupuesta='si') then
                                v_id_uo:=v_uo_funcionario;
                        else
                                v_uo_funcionario:=v_uo_padre;
                        end if;

                 elsif (par_opcion='gerencia') then
                 elsif (par_opcion='superior') then
                 else -- la uo a la que pertenece el usuario

                 end if;
   
    end loop;
    
    return v_id_uo;
    


EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.f_obtener_uo_x_funcionario(par_id_funcionario integer, par_opcion character varying, par_fecha date) OWNER TO postgres;

--
-- TOC entry 1308 (class 1255 OID 3340567)
-- Dependencies: 2435 12
-- Name: f_sincroniza_uo_empleado_entre_bd(integer, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: mzambrana
--

CREATE FUNCTION f_sincroniza_uo_empleado_entre_bd(p_id_uo_empleado integer, p_host_destino character varying, p_port_destino character varying, p_user_destino character varying, p_pwd_destino character varying, p_bd_destino character varying, p_opcion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    
v_consulta  varchar;
v_respuesta varchar;
v_registros record;

BEGIN
                           
   
       
        IF p_opcion = 'INSERT' THEN
            BEGIN   
            
               
              if not exists (select P.id_uo_empleado from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_historico_asignacion
                                               FROM kard.tkp_historico_asignacion where id_historico_asignacion='||p_id_uo_empleado) AS P(
                                                                                id_uo_empleado integer) ) then
                     
                  select * into v_registros from rhum.tuo_funcionario where id_uo_funcionario=p_id_uo_empleado;                                       
                     
                    
                    --raise exception 'nombre_unidad%,v_registros.nombre_cargo%,v_registros.cargo_individual%,v_registros.descripcion%,v_registros.sw_presto%',v_registros.nombre_unidad,v_registros.nombre_cargo,v_registros.cargo_individual,v_registros.descripcion,v_registros.sw_presto;
                    
                  v_consulta:='insert into kard.tkp_historico_asignacion (id_historico_asignacion, fecha_asignacion, estado, id_unidad_organizacional, id_empleado,fecha_registro, estado_reg, id_lugar, id_usuario_reg) 
                  values ('||p_id_uo_empleado||','''||v_registros.fecha_asignacion||''','''||v_registros.estado_reg||''',
                  '||v_registros.id_uo||','||v_registros.id_funcionario||','''||now()::date||''',''activo'','||2||','||1||'
                   );';
                  
                  v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                  
                  
                  return 'si';
             else 
                  raise exception 'ya existe';
             end if;                                   
            
          end;
        ELSEIF p_opcion='UPDATE' THEN
               BEGIN      
                       if exists (select P.id_uo_empleado from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_historico_asignacion
                                               FROM kard.tkp_historico_asignacion where id_historico_asignacion='||p_id_uo_empleado) AS P(
                                                                                id_uo_empleado integer) ) then 
                                                                                
                          select * into v_registros from rhum.tuo_funcionario where id_uo_funcionario=p_id_uo_empleado;                                       
                 
                          v_consulta:='update kard.tkp_historico_asignacion
                          set id_unidad_organizacional='||v_registros.id_uo||',
                          id_empleado='||v_registros.id_funcionario||',
                          fecha_asignacion='''||v_registros.fecha_asignacion||'''
                          estado='''||v_registros.estado_reg||''',
                          fecha_finalizacion='''||v_registros.fecha_finalizacion||'''
                          where id_historico_asignacion='||p_id_uo_empleado;   
                          
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);  
                           
                           /*----pendiente adicionar control para actualizacion de informacion de relacion entre uo's ----*/
                           
                            
                           return 'si';
                     else
                           return 'no';          
                     end if;
               END;
        ELSIF p_opcion='DELETE' THEN               
               BEGIN           
                      if exists (select P.id_uo_empleado from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_historico_asignacion
                                               FROM kard.tkp_historico_asignacion where id_historico_asignacion='||p_id_uo_empleado) AS P(
                                                                                id_uo_empleado integer) ) then 
                                                                                

                           --eliminamos la relacion en estructura_uo                                                                                
                           v_consulta:='delete from kard.tkp_historico_asignacion where id_historico_asignacion='||p_id_uo_empleado;
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   

                         
                           return 'si';                                                      
                     else
                       return 'no';
                     end if;
                   
               END;
        END IF;     
        
--RETURN NEW;
            
            
           
  RETURN NULL;
END;
$$;


ALTER FUNCTION rhum.f_sincroniza_uo_empleado_entre_bd(p_id_uo_empleado integer, p_host_destino character varying, p_port_destino character varying, p_user_destino character varying, p_pwd_destino character varying, p_bd_destino character varying, p_opcion character varying) OWNER TO mzambrana;

--
-- TOC entry 1307 (class 1255 OID 3337816)
-- Dependencies: 12 2435
-- Name: f_sincroniza_uo_entre_bd(integer, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: mzambrana
--

CREATE FUNCTION f_sincroniza_uo_entre_bd(p_id_uo integer, p_host_destino character varying, p_port_destino character varying, p_user_destino character varying, p_pwd_destino character varying, p_bd_destino character varying, p_opcion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    
v_consulta  varchar;
v_respuesta varchar;
v_registros record;

BEGIN
                           
   
       
        IF p_opcion = 'INSERT' THEN
            BEGIN   
            
                                                                                                        /*
              v_consulta:='SELECT id_persona
                                               FROM segu.tpersona where id_persona='||p_id_persona;   */
                  --raise exception 'aa%',coalesce(new.genero,'');          
              if not exists (select P.id_uo from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_unidad_organizacional
                                               FROM kard.tkp_unidad_organizacional where id_unidad_organizacional='||p_id_uo) AS P(
                                                                                id_uo integer) ) then
                     
                  select * into v_registros from rhum.tuo where id_uo=p_id_uo;                                       
                     
                  v_consulta:='insert into kard.tkp_unidad_organizacional(id_unidad_organizacional, nombre_unidad, nombre_cargo, 
                  cargo_individual, descripcion, sw_presto, codigo, gerencia, correspondencia, fecha_reg, id_nivel_organizacional,estado_reg) 
                  values ('||p_id_uo||','''||coalesce(v_registros.nombre_unidad,'-')||''','''||coalesce(v_registros.nombre_cargo,'-')||''',
                  '''||coalesce(v_registros.cargo_individual,'-')||''','''||coalesce(v_registros.descripcion,'-')||''','''||f_iif(v_registros.presupuesta='no','2','1')::numeric||''','''||coalesce(v_registros.codigo,'-')||''','''||coalesce(v_registros.gerencia,'-')||''','''||coalesce(v_registros.correspondencia,'-')||''',
                  '''||now()::date||''','||22||' ,''activo''
                   );';
                        
                  v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);       
                  
                  --insertamos en estructura_organizacional   
                  select * into v_registros from rhum.testructura_uo where id_uo_hijo=p_id_uo;
                  
                  v_consulta:='insert into kard.tkp_estructura_organizacional (relacion, fecha_reg, id_padre, id_hijo)
                  values (''dependiente'','''||now()::date||''','||v_registros.id_uo_padre||','||p_id_uo||');
                  ';
                  v_respuesta:= f_dblink(p_host_destino, p_port_destino, p_bd_destino, p_user_destino, p_pwd_destino, v_consulta);
                  
                  return 'si';
             else 
                  raise exception 'ya existe';
             end if;                                   
            
          end;
        ELSEIF p_opcion='UPDATE' THEN
               BEGIN                
                      if exists (select P.id_uo from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_unidad_organizacional
                                               FROM kard.tkp_unidad_organizacional where id_unidad_organizacional='||p_id_uo) AS P(
                                                                                id_uo integer) ) then   
                                                                                
                          select * into v_registros from rhum.tuo where id_uo=p_id_uo;                                       
                     
                          v_consulta:='update kard.tkp_unidad_organizacional
                          set 
                          nombre_unidad='''||coalesce(v_registros.nombre_unidad,'-')||''', 
                          nombre_cargo='''||coalesce(v_registros.nombre_cargo,'-')||''', 
                          cargo_individual='''||coalesce(v_registros.cargo_individual,'-')||''', 
                          descripcion='''||coalesce(v_registros.descripcion,'-')||''', 
                          sw_presto='||f_iif(v_registros.presupuesta='no','2','1')::numeric||', 
                          codigo='''||coalesce(v_registros.codigo,'-')||''', 
                          gerencia='''||coalesce(v_registros.gerencia,'-')||''', 
                          correspondencia='''||coalesce(v_registros.correspondencia,'-')||'''
                          where id_unidad_organizacional='||p_id_uo;   
                          
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                           return 'si';
                     else
                           return 'no';          
                     end if;
               END;
        ELSIF p_opcion='DELETE' THEN               
               BEGIN     
                     if exists (select P.id_uo from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_unidad_organizacional
                                               FROM kard.tkp_unidad_organizacional where id_unidad_organizacional='||p_id_uo) AS P(
                                                                                id_uo integer) ) then   
                           
                           v_consulta:='delete from kard.tkp_estructura_organizacional where id_hijo='||p_id_uo;
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);  
                                                                          
                           v_consulta:='delete from kard.tkp_unidad_organizacional where id_unidad_organizacional='||p_id_uo;
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                           return 'si';                                                      
                     else
                       return 'no';
                     end if;
                   
               END;
        END IF;     
        
--RETURN NEW;
            
            
           
  RETURN NULL;
END;
$$;


ALTER FUNCTION rhum.f_sincroniza_uo_entre_bd(p_id_uo integer, p_host_destino character varying, p_port_destino character varying, p_user_destino character varying, p_pwd_destino character varying, p_bd_destino character varying, p_opcion character varying) OWNER TO mzambrana;

--
-- TOC entry 1297 (class 1255 OID 3239679)
-- Dependencies: 12 2435
-- Name: f_uo_arb_inicia(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: rac
--

CREATE FUNCTION f_uo_arb_inicia(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA ENDESIS - SISTEMA DE ...
***************************************************************************
 SCRIPT: 		kard.f_uo_arb_inicia
 DESCRIPCIÓN: 	
 AUTOR: 		Rensi Arteaga Copari
 FECHA:			19/03/2012
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCIÓN:
 AUTOR:       
 FECHA:      

***************************************************************************/
--------------------------
-- CUERPO DE LA FUNCIÓN --
--------------------------

-- PARÁMETROS FIJOS
/*
pm_id_usuario                               integer (si))
pm_ip_origen                                varchar(40) (si)
pm_mac_maquina                              macaddr (si)
pm_log_error                                varchar -- log -- error //variable interna (si)
pm_codigo_procedimiento                     varchar  // valor que identifica el tipo
                                                        de operacion a realizar
                                                        insert  (insertar)
                                                        delete  (eliminar)
                                                        update  (actualizar)
                                                        select  (visualizar)
pm_proc_almacenado                          varchar  // para colocar el nombre del procedimiento en caso de ser llamado
                                                        por otro procedimiento
*/

/*
      0) Crea una tabla temporal con los datos que se utilizaran para generar el arbol JSON   
           v_tabla = organigrama_filtro;
      1) FOR Lista los registros en la tabla original que cumplen con el filtro 
         1.1) Listamos la tabla temporal vara verficar si el registro no este ya insertado
         1.2) IF  Si el  registro NO ESTA insertado 
            1.2.1) si el nodo buscasdo no es la raiz seguimos buscando padres
              1.2.1.1)  Inicia la llamada recursiva para obetener el nivel final 
                       (en el camino va insertando en la tabla temporal todos los padres del regisotro)
            1.2.2) inserta el registro con el nivel final ya obtenido
       END LOOP;
     2) lista la tabla temporal y devuelve el resultado
*/

DECLARE


	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;


v_sw integer;
v_sw2 integer;
v_count integer;
v_consulta varchar;
v_consulta2 varchar;
g_registros  record;  -- PARA ALMACENAR EL CONJUNTO DE DATOS RESULTADO DEL SELECT
v_tabla varchar;
v_valor_nivel varchar;
v_nivel varchar;
v_niveles_acsi varchar;

pm_criterio_filtro varchar;
v_id integer;

BEGIN


 -- 0) Crea una tabla temporal con los datos que se utilizaran para generar el arbol JSON   

    v_tabla = '"organigrama_filtro"';
--raise exception 'en mantenimeinto';

/*
  id_uo SERIAL, 
  nombre_unidad VARCHAR(100), 
  nombre_cargo VARCHAR(50), 
  cargo_individual VARCHAR(2), 
  descripcion VARCHAR(100), 
  presupuesta VARCHAR(2), 
  codigo VARCHAR(15), 
  nodo_base VARCHAR(2), 
  gerencia VARCHAR(2), 
  correspondencia VARCHAR(2), 
*/

raise notice '00000  RH_INIUOARB_SEL=%',p_transaccion;
 
  
  
    v_nombre_funcion = 'rhum.f_uo_arb_inicia';
    v_parametros = f_get_record(p_tabla);
    pm_criterio_filtro= v_parametros.criterio_filtro_arb;
    
raise notice '%',pm_criterio_filtro;
	/*********************************    
 	#TRANSACCION:  'RH_INIUOARB_SEL'
 	#DESCRIPCION:	Filtro en organigrama
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	IF(p_transaccion='RH_INIUOARB_SEL')then
raise notice '11111111';
                    
   CREATE TEMPORARY TABLE organigrama_filtro (
                                  "niveles" varchar,
                                  "id_uo" INTEGER, 
                                  "nombre_unidad" VARCHAR, 
                                  "nombre_cargo" VARCHAR, 
                                  "cargo_individual" VARCHAR, 
                                  "descripcion" VARCHAR, 
                                  "presupuesta" VARCHAR, 
                                  "codigo" VARCHAR, 
                                  "nodo_base" VARCHAR, 
                                  "gerencia" VARCHAR, 
                                  "id_estructura_uo" INTEGER, 
                                  "correspondencia" VARCHAR,
                                  estado_reg varchar,
                                  funcionarios varchar,
                                  resaltar varchar,
                                  id_uo_padre integer
                                 
                                  
                                ) ON COMMIT DROP;
                    

   --        0) Crea una tabla temporal con los datos que se utilizaran para generar el arbol JSON   

            v_consulta := 'SELECT * FROM (SELECT
                           UNIORG.id_uo,
                           UNIORG.nombre_unidad,
                           UNIORG.nombre_cargo,
                           UNIORG.cargo_individual,
                           UNIORG.descripcion,
                           ESTORG.id_estructura_uo,
                           ESTORG.id_uo_padre,
                           UNIORG.estado_reg,
                           (rhum.f_obtener_funcionarios_x_uo(UNIORG.id_uo)) as funcionarios,
                           UNIORG.presupuesta,
                           UNIORG.correspondencia,
                           UNIORG.codigo, 
                           UNIORG.nodo_base, 
                           UNIORG.gerencia
                           FROM rhum.testructura_uo ESTORG
                           INNER JOIN rhum.tuo UNIORG
                           ON UNIORG.id_uo = ESTORG.id_uo_hijo
                           WHERE UNIORG.estado_reg=''activo''  ORDER BY  UNIORG.id_uo asc) AS ORG WHERE  (codigo  ilike ''%'||pm_criterio_filtro||'%''  or funcionarios ilike ''%'||pm_criterio_filtro||'%'' or nombre_cargo ilike ''%'||pm_criterio_filtro||'%'' )  ';
                           
                        
   
     --    1) FOR Lista los registros en la t_uotabla original que cumplen con el filtro 
raise notice '2222222222';
      FOR g_registros in EXECUTE(v_consulta) LOOP
      
      raise notice 'FOR --->';


     
     
       --       1.1) Listamos la tabla temporal vara verficar si el registro no este ya insertado
         
               SELECT  
                id_uo                 
                INTO 
                v_count
             
           FROM organigrama_filtro
           WHERE id_uo =g_registros.id_uo;
          
      --   1.2) IF  Si el  registro NO ESTA insertado 
          
          IF v_count is NULL THEN
                -- 1.2.1) si el nodo buscasdo no es la raiz seguimos buscando padres
                  IF(g_registros.nodo_base <> 'si') THEN
                  
                   --   1.2.1.1) Inicia la llamada recursiva para obetener el nivel final 
              --     (en el camino va insertando en la tabla temporal todos los padres del regisotro)
                            
                   v_nivel=rhum.f_uo_arb_recursivo(g_registros.id_uo_padre);
                   
                   v_nivel=v_nivel||g_registros.id_uo||'a';
                   
                  -- v_niveles_acsi = v_nivel||'_'||ascii(g_registros.id_uo);
                   
                  ELSE
                
                    v_nivel = g_registros.id_uo||'a';
                  --  v_niveles_acsi = ascii(g_registros.id_uo);
                  
                  END IF; 
                  
                           
      --    1.2.2) inserta el registro con el nivel final ya obtenido
                 
            INSERT  INTO organigrama_filtro 
                     (  niveles,
                        id_uo, 
                        nombre_unidad, 
                        nombre_cargo, 
                        cargo_individual, 
                        descripcion, 
                        presupuesta, 
                        codigo, 
                        nodo_base, 
                        gerencia, 
                        id_estructura_uo, 
                        correspondencia,
                        estado_reg,
                        funcionarios,
                        resaltar,
                        id_uo_padre
                     )
                     VALUES
                     (  v_nivel::varchar,
                        g_registros.id_uo, 
                        g_registros.nombre_unidad, 
                        g_registros.nombre_cargo, 
                        g_registros.cargo_individual, 
                        g_registros.descripcion, 
                        g_registros.presupuesta, 
                        g_registros.codigo, 
                        g_registros.nodo_base, 
                        g_registros.gerencia, 
                        g_registros.id_estructura_uo, 
                        g_registros.correspondencia,
                        g_registros.estado_reg,
                        g_registros.funcionarios,
                        'si', --RESALTA LOS REGISTRO QUE COINCIDEN CON EL FILTRO DE LA BUSQUEDA
                        g_registros.id_uo_padre
                        );        
              END IF;        
       END LOOP;
       
       raise notice '33333333';

  --   2) lista la tabla temporal y devuelve el resultado
  
  FOR g_registros in (SELECT                                   
                        niveles,
                        id_uo, 
                        nombre_unidad, 
                        nombre_cargo, 
                        cargo_individual, 
                        descripcion, 
                        presupuesta, 
                        codigo, 
                        nodo_base, 
                        gerencia, 
                        id_estructura_uo, 
                        correspondencia,
                        estado_reg,
                        funcionarios,
                        resaltar,
                        id_uo_padre
                      FROM organigrama_filtro
                      ORDER BY niveles asc ) LOOP
     RETURN NEXT g_registros;
   END LOOP;
   
   
  /* g_registros =(SELECT                                   
                        niveles,
                        id_uo, 
                        nombre_unidad, 
                        nombre_cargo, 
                        cargo_individual, 
                        descripcion, 
                        presupuesta, 
                        codigo, 
                        nodo_base, 
                        gerencia, 
                        id_estructura_uo, 
                        correspondencia,
                        estado_reg,
                        funcionarios,
                        resaltar
                      FROM organigrama_filtro
                      ORDER BY niveles asc);
                       
    RETURN next g_registros;*/
    
    
 END IF;


EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION rhum.f_uo_arb_inicia(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rac;

--
-- TOC entry 1293 (class 1255 OID 3239131)
-- Dependencies: 2435 12
-- Name: f_uo_arb_recursivo(integer); Type: FUNCTION; Schema: rhum; Owner: rac
--

CREATE FUNCTION f_uo_arb_recursivo(v_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA ENDESIS - SISTEMA DE ...
***************************************************************************
 SCRIPT: 		rhum.f_uo_arb_recursivo
 DESCRIPCIÓN: 	
 AUTOR: 		Rensi Arteaga Copari
 FECHA:			2012
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCIÓN:
 AUTOR:       
 FECHA:      

***************************************************************************/
--------------------------
-- CUERPO DE LA FUNCIÓN --
--------------------------

-- PARÁMETROS FIJOS
/*
pm_id_usuario                               integer (si))
pm_ip_origen                                varchar(40) (si)
pm_mac_maquina                              macaddr (si)
pm_log_error                                varchar -- log -- error //variable interna (si)
pm_codigo_procedimiento                     varchar  // valor que identifica el tipo
                                                        de operacion a realizar
                                                        insert  (insertar)
                                                        delete  (eliminar)
                                                        update  (actualizar)
                                                        select  (visualizar)
pm_proc_almacenado                          varchar  // para colocar el nombre del procedimiento en caso de ser llamado
                                                        por otro procedimiento
*/


/*
  0) listamos el regisotr con el v_id en la tabla temporal
  1)IF  si no hay registros en la tabla temporal
  1.1) Listamos el registro  con el v_id  de la tabla orignal
  1.2) IF, el registro v_id  NO tiene padre
  1.2.0) insertamos el registro de v_id con niveles = v_id
  1.2.1)  return  v_id 
  1.3) ELSE, si el registro tiene padres  
  1.3.1) nivel = fun_red(v_id) RECURSIVAMENTE
  1.3.2) insertamos el registro de v_id con niveles = nivel+v_id
  1.3.3) return nivel||_||v_id
  2)ELSE  si  hay regisotr registros en la tabla temporal
  2.1) retornamos los niveles del registro existente

*/


DECLARE
v_sw integer;
v_sw2 integer;
v_count integer;
v_consulta varchar;
v_consulta2 text;
v_consulta_ins text;
g_registros                record;  -- PARA ALMACENAR EL CONJUNTO DE DATOS RESULTADO DEL SELECT
v_bool varchar;
v_bool2 varchar;
v_nivel varchar;
BEGIN


  --0) listamos el regisotr con el v_id en la tabla temporal
       
       raise notice '########  arb recursivo ';
       SELECT  
          id_uo,
          niveles 
       INTO 
          v_count,
          v_nivel
       FROM organigrama_filtro
       WHERE id_uo =v_id;
                      
   
  
  --1)IF  si no hay registros en la tabla temporal
   IF v_count is NULL THEN
        --1.1) Listamos el registro  con el v_id  de la tabla orignal
        
         v_consulta := 'SELECT
                           UNIORG.id_uo,
                           UNIORG.nombre_unidad,
                           UNIORG.nombre_cargo,
                           UNIORG.cargo_individual,
                           UNIORG.descripcion,
                           ESTORG.id_estructura_uo,
                           ESTORG.id_uo_padre,
                           UNIORG.estado_reg,
                           (rhum.f_obtener_funcionarios_x_uo(UNIORG.id_uo)) as funcionarios,
                           UNIORG.presupuesta,
                           UNIORG.correspondencia,
                           UNIORG.codigo, 
                           UNIORG.nodo_base, 
                           UNIORG.gerencia
                           FROM rhum.testructura_uo ESTORG
                           INNER JOIN rhum.tuo UNIORG
                           ON UNIORG.id_uo = ESTORG.id_uo_hijo
                           WHERE UNIORG.estado_reg= ''activo''  AND UNIORG.id_uo = '||COALESCE(v_id,'0');
        
      FOR g_registros in EXECUTE (v_consulta) LOOP
        
        --1.2) IF, el registro v_id  NO tiene padre
        IF g_registros.nodo_base = 'si' THEN
        RAISE NOTICE '>>>>>>>>>IF id_uo_padre = %',g_registros.id_uo_padre;
        
        --1.2.0) insertamos el registro de v_id con niveles = v_id
        
            INSERT  INTO organigrama_filtro 
                     (  niveles,
                        id_uo, 
                        nombre_unidad, 
                        nombre_cargo, 
                        cargo_individual, 
                        descripcion, 
                        presupuesta, 
                        codigo, 
                        nodo_base, 
                        gerencia, 
                        id_estructura_uo, 
                        correspondencia,
                        estado_reg,
                        funcionarios,
                        resaltar,
                        id_uo_padre
                     )
                     VALUES
                     (  v_id||'a'::varchar,
                        g_registros.id_uo, 
                        g_registros.nombre_unidad, 
                        g_registros.nombre_cargo, 
                        g_registros.cargo_individual, 
                        g_registros.descripcion, 
                        g_registros.presupuesta, 
                        g_registros.codigo, 
                        g_registros.nodo_base, 
                        g_registros.gerencia, 
                        g_registros.id_estructura_uo, 
                        g_registros.correspondencia,
                        g_registros.estado_reg,
                        g_registros.funcionarios,
                        'no',
                        g_registros.id_uo_padre
                     );
                     
        
        
        --1.2.1)  return  v_id 
        
       RETURN v_id||'a'::varchar;
        
        --1.3) ELSE, si el registro tiene padres  
        ELSE
        
        RAISE NOTICE '>>>>>>>>>ELSE ';
        
        --1.3.1) nivel = fun_red(v_id_padre) RECURSIVAMENTE
        
          v_nivel := rhum.f_uo_arb_recursivo(g_registros.id_uo_padre);
          
        --1.3.2) insertamos el registro de v_id con niveles = nivel+v_id
                     
                     INSERT  INTO organigrama_filtro 
                     (  niveles,
                        id_uo, 
                        nombre_unidad, 
                        nombre_cargo, 
                        cargo_individual, 
                        descripcion, 
                        presupuesta, 
                        codigo, 
                        nodo_base, 
                        gerencia, 
                        id_estructura_uo, 
                        correspondencia,
                        estado_reg,
                        funcionarios,
                        resaltar,
                        id_uo_padre

                     )
                     VALUES
                     (  (v_nivel||v_id||'a')::varchar,
                        g_registros.id_uo, 
                        g_registros.nombre_unidad, 
                        g_registros.nombre_cargo, 
                        g_registros.cargo_individual, 
                        g_registros.descripcion, 
                        g_registros.presupuesta, 
                        g_registros.codigo, 
                        g_registros.nodo_base, 
                        g_registros.gerencia, 
                        g_registros.id_estructura_uo, 
                        g_registros.correspondencia,
                        g_registros.estado_reg,
                        g_registros.funcionarios,
                        'no',
                        g_registros.id_uo_padre
                     );
                     
                     raise notice '<<<<<<< SALE DEL IF';
        
        END IF;
          --1.3.3) return nivel||_||v_id
        return v_nivel||v_id||'a';
        
        END LOOP;
      
      return v_nivel;
--2)ELSE  si  hay regisotr registros en la tabla temporal
  ELSE
   --2.1) retornamos los niveles del registro existente
   
    RETURN v_nivel;

  END IF;

END;
$$;


ALTER FUNCTION rhum.f_uo_arb_recursivo(v_id integer) OWNER TO rac;

--
-- TOC entry 1272 (class 1255 OID 2107593)
-- Dependencies: 12 2435
-- Name: ft_estructura_uo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: mzambrana
--

CREATE FUNCTION ft_estructura_uo_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		rhum.ft_estructura_uo_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 	    KPLIAN (mzm)
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		23-05-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_uo  				    integer;

--10-04-2012: sincronizacion de UO entre BD
v_respuesta_sinc            varchar;

BEGIN

     v_nombre_funcion:='rhum.ft_estructura_uo_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:  RH_ESTRUO_INS
 #DESCRIPCION:	Inserta estructura de uos
 #AUTOR:			
 #FECHA:		23-05-2011	
***********************************/
     if(par_transaccion='RH_ESTRUO_INS')then

        
          BEGIN                             
               -- validacion de un solo nodo_base
               if exists (select distinct 1 from rhum.tuo where nodo_base='si' and estado_reg='activo' and v_parametros.nodo_base='si') then
                  raise exception 'Insercion no realizada. Ya se definio alguna unidad como nodo base';
               end if;
               
               -- verificar duplicidad de codigo de uo
               if exists (select distinct 1 from rhum.tuo where lower(codigo)=lower(v_parametros.codigo) and estado_reg='activo') then
               end if;
               -- insercion de uo nueva
              
              
               insert into rhum.tuo( codigo,      nombre_unidad,nombre_cargo,   descripcion, cargo_individual,presupuesta,    estado_reg,  fecha_reg,id_usuario_reg, nodo_base, correspondencia, gerencia)
               values(upper(v_parametros.codigo), upper(v_parametros.nombre_unidad), upper(v_parametros.nombre_cargo), v_parametros.descripcion, v_parametros.cargo_individual, v_parametros.presupuesta, 'activo', now()::date, par_id_usuario, v_parametros.nodo_base, v_parametros.correspondencia, v_parametros.gerencia)
               RETURNING id_uo into v_id_uo;

               -- relacion de uo_hijo a o_padre
               INSERT INTO rhum.testructura_uo(id_uo_hijo, id_uo_padre,estado_reg, id_usuario_reg, fecha_reg)
               values(v_id_uo, v_parametros.id_uo_padre,'activo',    par_id_usuario, now()::date);
              
               
               --10-04-2012: sincronizacion de UO entre BD
               v_respuesta_sinc:=rhum.f_sincroniza_uo_entre_bd(v_id_uo,'10.172.0.13','5432','db_link','db_link','dbendesis' ,'INSERT');
      
               if(v_respuesta_sinc!='si')  then
                     raise exception 'Sincronizacion de UO en BD externa no realizada%',v_respuesta_sinc;
               end if;  
               
               v_resp = f_agrega_clave(v_resp,'mensaje','estructura uo '||v_parametros.nombre_unidad ||' insertado con exito a ' || v_parametros.id_uo_padre);
               v_resp = f_agrega_clave(v_resp,'id_uo',v_id_uo::varchar);
         END;
 /*******************************    
 #TRANSACCION:  RH_ESTRUO_MOD
 #DESCRIPCION:	Modifica la parametrizacion seleccionada
 #AUTOR:			
 #FECHA:		23-05-2011
***********************************/
     elsif(par_transaccion='RH_ESTRUO_MOD')then

          
          BEGIN            
               -- validacion de un solo nodo_base
               if exists (select distinct 1 from rhum.tuo where nodo_base='si' and estado_reg='activo' and id_uo!=v_parametros.id_uo and v_parametros.nodo_base='si') then
                  raise exception 'Insercion no realizada. Ya se definio alguna unidad como nodo base';
               end if;
               
               update rhum.tuo
               set codigo=upper(v_parametros.codigo),
                   nombre_unidad= upper(v_parametros.nombre_unidad),
                   nombre_cargo=upper(v_parametros.nombre_cargo),
                   descripcion=v_parametros.descripcion,
                   cargo_individual=v_parametros.cargo_individual,
                   presupuesta=v_parametros.presupuesta,
                   nodo_base=v_parametros.nodo_base,
                   correspondencia=v_parametros.correspondencia,
                   gerencia=v_parametros.gerencia
                where id_uo=v_parametros.id_uo;
                
                --10-04-2012: sincronizacion de UO entre BD
                v_respuesta_sinc:=rhum.f_sincroniza_uo_entre_bd(v_parametros.id_uo,'10.172.0.13','5432','db_link','db_link','dbendesis' ,'UPDATE');
      
                if(v_respuesta_sinc!='si')  then
                     raise exception 'Sincronizacion de UO en BD externa no realizada%',v_respuesta_sinc;
                end if; 
                
                v_resp = f_agrega_clave(v_resp,'mensaje','estructura uo modificado con exito '||v_parametros.id_uo);
                v_resp = f_agrega_clave(v_resp,'id_uo',v_parametros.id_uo::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  RH_ESTRUO_ELI
 #DESCRIPCION:	Inactiva la parametrizacion selecionada. Verifica dependencias hacia abajo
 #AUTOR:			
 #FECHA:		23-05-2011
 *********************************
 #AUTOR_MOD:	KPLIAN (rac)		
 #FECHA_MOD:	23-05-2011
 #DESC_MON:		Valida la eliminacion de nodos solo si sus hijos estan inactivos
***********************************/

    elsif(par_transaccion='RH_ESTRUO_ELI')then
        BEGIN
        
        
         
             
           --1) verificamos si tiene relaciones activas con sus hijos (asumimos que si tiene hijos tendra relaciones activas con ellos)
            
            if exists ( select DISTINCT 1 
                          from rhum.tuo uo
                          inner join  rhum.testructura_uo euo on uo.id_uo = euo.id_uo_padre and euo.estado_reg='activo' 
                          where uo.id_uo = v_parametros.id_uo) then
               
                        --NOTA) sera necesario adicionar  una trsaccion que realize una eliminacion recursiva
                        --      previa confirmacion del usuario despues de este error 
                             
                        raise exception 'Eliminacion no realizada.  La Unidad que se inactiva tiene dependencias  elimine primero los hijos';
              
              end if;
              
              --2) se fija que no tenga funcionarios en estado activo asignados a este uo 
              if exists ( select DISTINCT 1 
                          from rhum.tuo_funcionario uof
                          where uof.id_uo = v_parametros.id_uo and uof.estado_reg='activo') then
             
                             
                        raise exception 'Eliminacion no realizada. La Unidad que se intenta eliminar tiene relaciones vigentes con empleados';
              
              end if;
               
               --3) inactiva la unidad
               update rhum.tuo
               set estado_reg='inactivo'
               where id_uo=v_parametros.id_uo;
               
               
               -- 4) inactiva las relaciones con los padres (para que se cumpla siempre la regla en 1)
               update rhum.testructura_uo
               set estado_reg='inactivo'
               where id_uo_hijo=v_parametros.id_uo;
              
               --10-04-2012: sincronizacion de UO entre BD
                v_respuesta_sinc:=rhum.f_sincroniza_uo_entre_bd(v_parametros.id_uo,'10.172.0.13','5432','db_link','db_link','dbendesis' ,'DELETE');
      
                if(v_respuesta_sinc!='si')  then
                     raise exception 'Sincronizacion de UO en BD externa no realizada%',v_respuesta_sinc;
                end if;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','estructura uo eliminada con exito '||v_parametros.id_uo);
               v_resp = f_agrega_clave(v_resp,'id_uo',v_parametros.id_uo::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.ft_estructura_uo_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO mzambrana;

--
-- TOC entry 1271 (class 1255 OID 2106662)
-- Dependencies: 12 2435
-- Name: ft_estructura_uo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: mzambrana
--

CREATE FUNCTION ft_estructura_uo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		RHUM.ft_uo_sel
 DESCRIPCIÓN:  listado de uo
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		21-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


v_condicion 		varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_estructura_uo_sel';

/*******************************
 #TRANSACCION:  RH_UO_SEL
 #DESCRIPCION:	Listado de uos
 #AUTOR:		
 #FECHA:		23/05/11	
***********************************/
     if(par_transaccion='RH_ESTRUO_SEL')then

          
          BEGIN

           if(v_parametros.id_padre = '%') then
               v_condicion:='uo.nodo_base=''si'' ';
           else
               v_condicion:='euo.id_uo_padre='||v_parametros.id_padre||' and uo.nodo_base=''no'' ';
           end if;
               v_condicion:=v_condicion ||' and euo.estado_reg=''activo'' and uo.estado_reg=''activo'' ';
               
               
               v_consulta:='SELECT
                                UO.id_uo,
                                UO.codigo,
                                UO.descripcion,
                                UO.cargo_individual,
                                UO.nombre_unidad,
                                UO.nombre_cargo,
                                UO.presupuesta,
                                UO.nodo_base,
                                UO.estado_reg,
                                UO.fecha_reg,
                                UO.id_usuario_reg,
                                UO.fecha_mod,
                                UO.id_usuario_mod,
                                PERREG.nombre_completo2 AS USUREG,
                                PERMOD.nombre_completo2 AS USUMOD,
                                euo.id_uo_padre,
                                euo.id_estructura_uo,
                                UO.correspondencia,
                                UO.gerencia
                            FROM rhum.tuo UO
                            inner join rhum.testructura_uo euo
                            on UO.id_uo=euo.id_uo_hijo
                            INNER JOIN segu.tusuario USUREG ON  UO.id_usuario_reg=USUREG.id_usuario
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=UO.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE '|| v_condicion;
               
               
             --  v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by euo.id_uo_hijo,UO.nombre_unidad' ;

               return v_consulta;


         END;

/*******************************
 #TRANSACCION:  RH_ESTRUO_CONT
 #DESCRIPCION:	Conteo de estructura uos
 #AUTOR:		
 #FECHA:		24/05/11	
***********************************/
     elsif(par_transaccion='RH_ESTRUO_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(UO.id_uo)
                            FROM rhum.tuo UO
                            inner join rhum.testructura_uo euo
                            on UO.id_uo=euo.id_uo_hijo
                            INNER JOIN segu.tusuario USUREG ON  UO.id_usuario_reg=USUREG.id_usuario
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=UO.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE '|| v_condicion;
              -- v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.ft_estructura_uo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO mzambrana;

--
-- TOC entry 144 (class 1255 OID 16608)
-- Dependencies: 12 2435
-- Name: ft_funcionario_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: rchumacero
--

CREATE FUNCTION ft_funcionario_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		rhum.ft_funcionario_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		KPLIAN (rac)
 FECHA:		21-01-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='rhum.ft_funcionario_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   RH_FUNCIO_INS
 #DESCRIPCION:	Inserta Funcionarios
 #AUTOR:			
 #FECHA:		25-01-2011	
***********************************/
     if(par_transaccion='RH_FUNCIO_INS')then

        
          BEGIN


               --insercion de nuevo FUNCIONARIO
               if exists (select 1 from rhum.tfuncionario where codigo=v_parametros.codigo and estado_reg='activo') then
                  raise exception 'Insercion no realizada. CODIGO EN USO';
               end if;

               INSERT INTO rhum.tfuncionario(
               codigo, id_persona,
               estado_reg,
               fecha_reg,
               id_usuario_reg,
               email_empresa,
               interno,
               fecha_ingreso )
               values(
                      v_parametros.codigo,
                      v_parametros.id_persona, 
                      'activo',now()::date, 
                      par_id_usuario,
                      v_parametros.id_persona,
                      v_parametros.interno,
                      v_parametros.fecha_ingreso);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','funcionario '||v_parametros.codigo ||' insertado con exito ');
               v_resp = f_agrega_clave(v_resp,'id_funcionario',v_id_funcion::varchar);
         END;
 /*******************************    
 #TRANSACCION:      RH_FUNCIO_MOD
 #DESCRIPCION:	Modifica la parametrizacion seleccionada
 #AUTOR:			
 #FECHA:		25-01-2011
***********************************/
     elsif(par_transaccion='RH_FUNCIO_MOD')then

          
          BEGIN
        
          
                if exists (select 1 from rhum.tfuncionario where id_funcionario!=v_parametros.id_funcionario and codigo=v_parametros.codigo and estado_reg='activo') then
                  raise exception 'Modificacion no realizada. CODIGO EN USO';
                end if;
                
                update rhum.tfuncionario
                set codigo=v_parametros.codigo,
                    id_usuario_mod=par_id_usuario,
                    id_persona=v_parametros.id_persona,
                    estado_reg=v_parametros.estado_reg,
                   email_empresa=v_parametros.email_empresa,
                    interno=v_parametros.interno,
                    fecha_ingreso=v_parametros.fecha_ingreso,
                    fecha_mod=now()::date
                where id_funcionario=v_parametros.id_funcionario;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','Funcionario modificado con exito '||v_parametros.id_funcionario);
               v_resp = f_agrega_clave(v_resp,'id_funcionario',v_parametros.id_funcionario::varchar);
               
                
          END;
          
/*******************************    
 #TRANSACCION:  RH_FUNCIO_ELI
 #DESCRIPCION:	Inactiva la parametrizacion selecionada
 #AUTOR:			
 #FECHA:		25-01-2011
***********************************/

    elsif(par_transaccion='RH_FUNCIO_ELI')then
        BEGIN
        
         --inactivacion de la periodo
               update rhum.tfuncionario
               set estado_reg='inactivo'
               where id_funcionario=v_parametros.id_funcionario;
               return 'Funcionario eliminado con exito';
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Funcionario eliminado con exito '||v_parametros.id_funcionario);
               v_resp = f_agrega_clave(v_resp,'id_funcionario',v_parametros.id_funcionario::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.ft_funcionario_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1269 (class 1255 OID 2105271)
-- Dependencies: 12 2435
-- Name: ft_funcionario_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: mzambrana
--

CREATE FUNCTION ft_funcionario_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 funcionario: 		RHUM.ft_funcionario_sel
 DESCRIPCIÓN:  listado de funcionario
 AUTOR: 	    KPLIAN (mzm)
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		21-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;
v_filadd           varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_funcionario_sel';

/*******************************
 #TRANSACCION:  RH_FUNCIO_SEL
 #DESCRIPCION:	Listado de funcionarios
 #AUTOR:		
 #FECHA:		23/05/11	
***********************************/
     if(par_transaccion='RH_FUNCIO_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            FUNCIO.id_funcionario,
                            FUNCIO.codigo,
                            FUNCIO.estado_reg,
                            FUNCIO.fecha_reg,
                            FUNCIO.id_persona,
                            FUNCIO.id_usuario_reg,
                            FUNCIO.fecha_mod,
                            FUNCIO.id_usuario_mod,
                            FUNCIO.email_empresa,
                            FUNCIO.interno,
                            FUNCIO.fecha_ingreso,
                            PERSON.nombre_completo1 AS desc_person,
                            usu1.cuenta as usr_reg,
						    usu2.cuenta as usr_mod,
                            PERSON.ci, 
                            PERSON.num_documento,
                            PERSON.telefono1, 
                            PERSON.celular1, 
                            PERSON.correo
                            
                            
                            FROM rhum.tfuncionario FUNCIO
                            INNER JOIN SEGU.vpersona PERSON ON PERSON.id_persona=FUNCIO.id_persona
                            inner join segu.tusuario usu1 on usu1.id_usuario = FUNCIO.id_usuario_reg
						    left join segu.tusuario usu2 on usu2.id_usuario = FUNCIO.id_usuario_mod
                            
                            WHERE ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

/*******************************
 #TRANSACCION:  RH_FUNCIO_CONT
 #DESCRIPCION:	Conteo de funcionarios
 #AUTOR:		
 #FECHA:		23/05/11	
***********************************/
     elsif(par_transaccion='RH_FUNCIO_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(FUNCIO.id_funcionario)
                            FROM rhum.tfuncionario FUNCIO
                            INNER JOIN SEGU.vpersona PERSON ON PERSON.id_persona=FUNCIO.id_persona
                            inner join segu.tusuario usu1 on usu1.id_usuario = FUNCIO.id_usuario_reg
						    left join segu.tusuario usu2 on usu2.id_usuario = FUNCIO.id_usuario_mod
                            WHERE ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
    
    /*******************************
     #TRANSACCION:  RH_FUNCIOCAR_SEL
     #DESCRIPCION:	Listado de funcionarios con cargos historicos
     #AUTOR:		KPLIAN (RAC)
     #FECHA:		29/10/11	
    ***********************************/
     elseif(par_transaccion='RH_FUNCIOCAR_SEL')then

          --consulta:=';
          BEGIN
          
           v_filadd = '';
            IF (f_existe_parametro(par_tabla,'estado_reg_asi')) THEN
               v_filadd = ' (FUNCAR.estado_reg_asi = '''||v_parametros.estado_reg_asi||''') and ';
            END IF;

               v_consulta:='SELECT 
                            FUNCAR.id_uo_funcionario,
                            FUNCAR.id_funcionario,
                            FUNCAR.desc_funcionario1,
                            FUNCAR.desc_funcionario2,
                            FUNCAR.id_uo,
                            FUNCAR.nombre_cargo,
                            FUNCAR.fecha_asignacion,
                            FUNCAR.fecha_finalizacion,
                            FUNCAR.num_doc,
                            FUNCAR.ci,
                            FUNCAR.codigo,
                            FUNCAR.email_empresa,
                            FUNCAR.estado_reg_fun,
                            FUNCAR.estado_reg_asi
                            FROM rhum.vfuncionario_cargo FUNCAR 
                            WHERE '||v_filadd;
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

              
raise notice '%',v_consulta;            
               return v_consulta;


         END;

/*******************************
 #TRANSACCION:  RH_FUNCIOCAR_CONT
 #DESCRIPCION:	Conteo de funcionarios con cargos historicos
 #AUTOR:		KPLIAN (rac)
 #FECHA:		23/05/11	
***********************************/
     elsif(par_transaccion='RH_FUNCIOCAR_CONT')then

          --consulta:=';
          BEGIN
          
            v_filadd = '';
            IF (f_existe_parametro(par_tabla,'estado_reg_asi')) THEN
               v_filadd = ' (FUNCAR.estado_reg_asi = '''||v_parametros.estado_reg_asi||''') and ';
            END IF;

               v_consulta:='SELECT
                                  count(id_uo_funcionario)
                            FROM rhum.vfuncionario_cargo FUNCAR 
                            WHERE '||v_filadd;
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;   

      else
         raise exception 'No existe la opcion';

     end if;
     
     
     

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.ft_funcionario_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO mzambrana;

--
-- TOC entry 292 (class 1255 OID 16610)
-- Dependencies: 12 2435
-- Name: ft_parametro_rhum_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: rchumacero
--

CREATE FUNCTION ft_parametro_rhum_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		rhum.ft_parametro_rhum_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 	    KPLIAN (mzm)		
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		17-01-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='rhum.ft_parametro_rhum_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   RH_PARRHH_INS
 #DESCRIPCION:	Inserta Funciones
 #AUTOR:			
 #FECHA:		17-01-2011	
***********************************/
     if(par_transaccion='RH_PARRHH_INS')then

        
          BEGIN
               --inactivar cualquier gestion que exista previamente
               if exists (select 1 from rhum.tparametro_rhum where estado_reg='activo') then
                  update rhum.tparametro_rhum
                  set estado_reg='inactivo';
               end if;
               --insercion de nuevo parametro
               INSERT INTO rhum.tparametro_rhum(salario_min_nal, id_gestion,id_moneda_sal_min_nal,estado_reg,fecha_reg,id_usuario_reg )
               values(v_parametros.salario_min_nal,v_parametros.id_gestion, v_parametros.id_moneda_sal_min_nal,'activo',now()::date, par_id_usuario);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','parametro de RRHH insertado con exito ');
               v_resp = f_agrega_clave(v_resp,'id_periodo',v_id_funcion::varchar);
         END;
 /*******************************    
 #TRANSACCION:      RH_PARRHH_MOD
 #DESCRIPCION:	Modifica la parametrizacion seleccionada
 #AUTOR:			
 #FECHA:		17-01-2011
***********************************/
     elsif(par_transaccion='RH_PARRHH_MOD')then

          
          BEGIN
               --modificacion de periodo
                update rhum.tparametro_rhum
                set salario_min_nal=v_parametros.salario_min_nal,
                    id_moneda_sal_min_nal=v_parametros.id_moneda_sal_min_nal,
                    id_gestion=v_parametros.id_gestion,
                    id_usuario_mod=par_id_usuario,
                    fecha_mod=now()::date
                where id_parametro=v_parametros.id_parametro;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','parametro de RRHH modificado con exito '||v_parametros.id_periodo);
               v_resp = f_agrega_clave(v_resp,'id_parametro',v_parametros.id_parametro::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  RH_PARRHH_ELI
 #DESCRIPCION:	Inactiva la parametrizacion selecionada
 #AUTOR:			
 #FECHA:		17-01-2011
***********************************/

    elsif(par_transaccion='RH_PARRHH_ELI')then
        BEGIN
        
         --inactivacion de la periodo
               update rhum.tparametro_rhum
               set estado_reg='inactivo'
               where id_parametro=v_parametros.id_parametro;
               return 'parametro de RRHH eliminado con exito';
               
               v_resp = f_agrega_clave(v_resp,'mensaje','parametro de RRHH eliminado con exito '||v_parametros.id_periodo);
               v_resp = f_agrega_clave(v_resp,'id_parametro',v_parametros.id_parametro::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.ft_parametro_rhum_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 142 (class 1255 OID 16611)
-- Dependencies: 2435 12
-- Name: ft_parametro_rhum_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: rchumacero
--

CREATE FUNCTION ft_parametro_rhum_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 parametro_rhum: 		RHUM.ft_parametro_rhum_sel
 DESCRIPCIÓN:  listado de parametro_rhum
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		17-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_parametro_rhum_sel';


     if(par_transaccion='RH_PARRHH_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT PARRHH.id_parametro,
                            PARRHH.salario_min_nal,
                            PARRHH.id_gestion,
                            PARRHH.id_moneda_sal_min_nal,
                            PARRHH.estado_reg,
                            PARRHH.id_usuario_reg,
                            PARRHH.fecha_reg,
                            PARRHH.id_usuario_mod,
                            PARRHH.fecha_mod,
                            GESTIO.gestion,
                            MONEDA.moneda
                            FROM rhum.tparametro_rhum PARRHH
                            INNER JOIN PARAM.tgestion GESTIO
                            ON GESTIO.id_gestion=PARRHH.id_gestion
                            INNER JOIN PARAM.tmoneda MONEDA
                            ON MONEDA.id_moneda=PARRHH.id_moneda_sal_min_nal
                            WHERE ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='RH_PARRHH_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(PARRHH.id_parametro)
                            FROM rhum.tparametro_rhum PARRHH
                            INNER JOIN PARAM.tgestion GESTIO
                            ON GESTIO.id_gestion=PARRHH.id_gestion
                            INNER JOIN PARAM.tmoneda MONEDA
                            ON MONEDA.id_moneda=PARRHH.id_moneda_sal_min_nal
                            WHERE  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.ft_parametro_rhum_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 296 (class 1255 OID 16612)
-- Dependencies: 2435 12
-- Name: ft_tipo_columna_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: rchumacero
--

CREATE FUNCTION ft_tipo_columna_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		rhum.ft_tipo_columna_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		31-01-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='rhum.ft_tipo_columna_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   RH_TIPCOL_INS
 #DESCRIPCION:	Inserta tipo columna
 #AUTOR:			
 #FECHA:		31-01-2011	
***********************************/
     if(par_transaccion='RH_TIPCOL_INS')then

        
          BEGIN
               --insercion de nuevo TIPO_COLUMNA
               INSERT INTO rhum.ttipo_columna (
                           codigo,
                           compromete,
                           descripcion,
                           descuento_incremento,
                           formula,
                           id_auxiliar_pasivo,
                           id_cuenta_pasivo,
                           id_moneda,
                           id_parametro_rhum,
                           id_tipo_descuento_bono,
                           id_tipo_obligacion,
                           id_usuario_reg,
                           movimiento_contable,
                           nombre,
                           observacion,
                           prorratea,
                           tipo_aporte,
                           tipo_dato,
                           valor,
                           fecha_reg,
                           estado_reg)

               values(     v_parametros.codigo,
                           v_parametros.compromete,
                           v_parametros.descripcion,
                           v_parametros.descuento_incremento,
                           v_parametros.formula,
                           v_parametros.id_auxiliar_pasivo,
                           v_parametros.id_cuenta_pasivo,
                           v_parametros.id_moneda,
                           v_parametros.id_parametro_rhum,
                           v_parametros.id_tipo_descuento_bono,
                           v_parametros.id_tipo_obligacion,
                           par_id_usuario,
                           v_parametros.movimiento_contable,
                           v_parametros.nombre,
                           v_parametros.observacion,
                           v_parametros.prorratea,
                           v_parametros.tipo_aporte,
                           v_parametros.tipo_dato,
                           0.0::numeric,
                           now()::date,
                           'activo');
              

               v_resp = f_agrega_clave(v_resp,'mensaje','Tipo de columna insertado con exito ');
               v_resp = f_agrega_clave(v_resp,'id_tipo_columna',v_id_funcion::varchar);
         END;
 /*******************************    
 #TRANSACCION:      RH_TIPCOL_MOD
 #DESCRIPCION:	Modifica tipo_columna seleccionado
 #AUTOR:			
 #FECHA:		31-01-2011
***********************************/
     elsif(par_transaccion='RH_TIPCOL_MOD')then

          
          BEGIN raise exception '';
               --modificacion de tipo_columna
                update rhum.ttipo_columna
                set        codigo=v_parametros.codigo,
                           compromete=v_parametros.compromete,
                           descripcion=v_parametros.descripcion,
                           descuento_incremento=v_parametros.descuento_incremento,
                           formula=v_parametros.formula,
                           id_auxiliar_pasivo=v_parametros.id_auxiliar_pasivo,
                           id_cuenta_pasivo=v_parametros.id_cuenta_pasivo,
                           id_moneda=v_parametros.id_moneda,
                           id_parametro_rhum=v_parametros.id_parametro_rhum,
                           id_tipo_descuento_bono=v_parametros.id_tipo_descuento_bono,
                           id_tipo_obligacion=v_parametros.id_tipo_obligacion,

                           movimiento_contable=v_parametros.movimiento_contable,
                           nombre=v_parametros.nombre,
                           observacion=v_parametros.observacion,
                           prorratea=v_parametros.prorratea,
                           tipo_aporte=v_parametros.tipo_aporte,
                           tipo_dato=v_parametros.tipo_dato
                          -- valor=v_parametros.valor
                  
                where id_tipo_columna=v_parametros.id_tipo_columna;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','tipo columna modificado con exito '||v_parametros.id_tipo_columna);
               v_resp = f_agrega_clave(v_resp,'id_tipo_columna',v_parametros.id_tipo_columna::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  RH_TIPCOL_ELI
 #DESCRIPCION:	Inactiva tipo_columna
 #AUTOR:			
 #FECHA:		31-01-2011
***********************************/

    elsif(par_transaccion='RH_TIPCOL_ELI')then
        BEGIN
        
         --inactivacion de tipo_columna
               update rhum.ttipo_columna
               set estado_reg='inactivo'
               where id_tipo_columna=v_parametros.id_tipo_columna;
               return 'Tipo columna eliminado con exito';
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Tipo columna eliminado con exito '||v_parametros.id_tipo_columna);
               v_resp = f_agrega_clave(v_resp,'id_tipo_columna',v_parametros.id_tipo_columna::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.ft_tipo_columna_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 143 (class 1255 OID 16613)
-- Dependencies: 12 2435
-- Name: ft_tipo_columna_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: rchumacero
--

CREATE FUNCTION ft_tipo_columna_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 tipo_columna: 		RHUM.ft_tipo_columna_sel
 DESCRIPCIÓN:  listado de tipo_columna
 AUTOR: 	    KPLIAN (mzm)		
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		27-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_tipo_columna_sel';


     if(par_transaccion='RH_TIPCOL_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            TIPCOL.id_tipo_columna,
                            TIPCOL.codigo,
                            TIPCOL.compromete,
                            TIPCOL.descripcion,
                            TIPCOL.descuento_incremento ,
                            TIPCOL.estado_reg,
                            TIPCOL.fecha_reg,
                            TIPCOL.formula,
                            TIPCOL.id_auxiliar_pasivo,
                            TIPCOL.id_cuenta_pasivo,
                            TIPCOL.id_moneda,
                            TIPCOL.id_parametro_rhum,
                            TIPCOL.id_tipo_descuento_bono,
                            TIPCOL.id_tipo_obligacion ,
                            TIPCOL.movimiento_contable,
                            TIPCOL.nombre,
                            TIPCOL.observacion ,
                            TIPCOL.prorratea,
                            TIPCOL.tipo_aporte,
                            TIPCOL.tipo_dato,
                            TIPCOL.valor,
                            GESTIO.gestion AS desc_parametro_rhum,
                            MONEDA.moneda as desc_moneda,
                            PERREG.nombre_completo1 as desc_usureg,
                            CTA.codigo||''-''||CTA.nombre as desc_cta,
                            AUX.codigo||''-''|| AUX.nombre as desc_aux,
                            TIPOBL.nombre as desc_tipo_obligacion
                            FROM rhum.ttipo_columna TIPCOL
                            LEFT JOIN rhum.tparametro_rhum PARHUM on PARHUM.id_parametro=TIPCOL.id_parametro_rhum
                            LEFT JOIN param.tgestion GESTIO ON GESTIO.id_gestion=PARHUM.id_gestion
                            LEFT JOIN param.tmoneda MONEDA on MONEDA.id_moneda=TIPCOL.id_moneda
                            LEFT JOIN SEGU.tusuario USUREG ON USUREG.id_usuario=TIPCOL.id_usuario_reg
                            LEFT JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN conta.tcuenta CTA on CTA.id_cuenta=TIPCOL.id_cuenta_pasivo
                            LEFT JOIN conta.tauxiliar AUX on AUX.id_auxiliar=TIPCOL.id_auxiliar_pasivo
                            LEFT JOIN RHUM.ttipo_obligacion TIPOBL ON TIPOBL.id_tipo_obligacion=TIPCOL.id_tipo_obligacion
                            WHERE ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='RH_TIPCOL_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(TIPCOL.id_tipo_columna)
                            FROM rhum.ttipo_columna TIPCOL
                            INNER JOIN rhum.tparametro_rhum PARHUM on PARHUM.id_parametro=TIPCOL.id_parametro_rhum
                            INNER JOIN param.tgestion GESTIO ON GESTIO.id_gestion=PARHUM.id_gestion
                            INNER JOIN param.tmoneda MONEDA on MONEDA.id_moneda=TIPCOL.id_moneda
                            INNER JOIN SEGU.tusuario USUREG ON USUREG.id_usuario=TIPCOL.id_usuario_reg
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN conta.tcuenta CTA on CTA.id_cuenta=TIPCOL.id_cuenta_pasivo
                            LEFT JOIN conta.tauxiliar AUX on AUX.id_auxiliar=TIPCOL.id_auxiliar_pasivo
                            LEFT JOIN RHUM.ttipo_obligacion TIPOBL ON TIPOBL.id_tipo_obligacion=TIPCOL.id_tipo_obligacion
                            WHERE ';

               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.ft_tipo_columna_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 146 (class 1255 OID 16614)
-- Dependencies: 12 2435
-- Name: ft_tipo_obligacion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: rchumacero
--

CREATE FUNCTION ft_tipo_obligacion_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		rhum.ft_tipo_obligacion_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		31-01-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='rhum.ft_tipo_obligacion_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   RH_TIPOBL_INS
 #DESCRIPCION:	Inserta tipo obligacion
 #AUTOR:			
 #FECHA:		14-02-2011	
***********************************/
     if(par_transaccion='RH_TIPOBL_INS')then

        
          BEGIN
               --insercion de nuevo tipo_obligacion
               INSERT INTO rhum.ttipo_obligacion (
                           codigo,
                           nombre,
                           estado_reg,
                           fecha_reg,
                           id_usuario_reg
                           )

               values(     v_parametros.codigo,
                           v_parametros.nombre,
                           'activo',
                           now()::date,
                           par_id_usuario);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','Tipo de obligacion insertado con exito ');
               v_resp = f_agrega_clave(v_resp,'id_tipo_obligacion',v_id_funcion::varchar);
         END;
 /*******************************    
 #TRANSACCION:      RH_TIPOBL_MOD
 #DESCRIPCION:	Modifica tipo_obligacion seleccionado
 #AUTOR:			
 #FECHA:		31-01-2011
***********************************/
     elsif(par_transaccion='RH_TIPOBL_MOD')then

          
          BEGIN 
               --modificacion de tipo_obligacion
                update rhum.ttipo_obligacion
                set        codigo=v_parametros.codigo,
                           nombre=v_parametros.nombre
                where id_tipo_obligacion=v_parametros.id_tipo_obligacion;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','tipo obligacion modificado con exito '||v_parametros.id_tipo_obligacion);
               v_resp = f_agrega_clave(v_resp,'id_tipo_obligacion',v_parametros.id_tipo_obligacion::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  RH_TIPOBL_ELI
 #DESCRIPCION:	Inactiva tipo_obligacion
 #AUTOR:			
 #FECHA:		31-01-2011
***********************************/

    elsif(par_transaccion='RH_TIPOBL_ELI')then
        BEGIN
        
         --inactivacion de tipo_obligacion
               update rhum.ttipo_obligacion
               set estado_reg='inactivo'
               where id_tipo_obligacion=v_parametros.id_tipo_obligacion;
               return 'Tipo obligacion eliminado con exito';
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Tipo obligacion eliminado con exito '||v_parametros.id_tipo_obligacion);
               v_resp = f_agrega_clave(v_resp,'id_tipo_obligacion',v_parametros.id_tipo_obligacion::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.ft_tipo_obligacion_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 145 (class 1255 OID 16615)
-- Dependencies: 2435 12
-- Name: ft_tipo_obligacion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: rchumacero
--

CREATE FUNCTION ft_tipo_obligacion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 tipo_columna: 		RHUM.ft_tipo_columna_sel
 DESCRIPCIÓN:  listado de tipo_columna
 AUTOR: 	    KPLIAN (mzm)
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		27-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_tipo_columna_sel';


     if(par_transaccion='RH_TIPOBL_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            TIPOBL.id_tipo_columna,
                            TIPOBL.codigo,
                            TIPOBL.nombre,
                            TIPOBL.estado_reg,
                            TIPOBL.id_usuario_reg,
                            TIPOBL.fecha_reg,
                            TIPOBL.id_usuario_mod,
                            TIPOBL.fecha_mod,
                            PERREG.nombre_completo1 AS desc_usuario_reg
                            FROM rhum.ttipo_obligacion TIPOBL
                            INNER JOIN SEGU.tusuario USUREG ON USUREG.id_usuario= TIPOBL.id_usuario_reg
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            WHERE ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='RH_TIPOBL_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(TIPOBL.id_tipo_obligacion)
                            FROM rhum.ttipo_obligacion TIPOBL
                            INNER JOIN SEGU.tusuario USUREG ON USUREG.id_usuario= TIPOBL.id_usuario_reg
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            WHERE ';

               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.ft_tipo_obligacion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 151 (class 1255 OID 16617)
-- Dependencies: 12 2435
-- Name: ft_tipo_planilla_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: rchumacero
--

CREATE FUNCTION ft_tipo_planilla_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 tipo_planilla: 		RHUM.ft_tipo_planilla_sel
 DESCRIPCIÓN:  listado de tipo_planilla
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		19-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_tipo_planilla_sel';


     if(par_transaccion='RH_TIPPLA_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            TIPPLA.id_tipo_planilla,
                            TIPPLA.nombre,
                            TIPPLA.descripcion,
                            TIPPLA.basica,
                            TIPPLA.tipo,
                            TIPPLA.id_moneda,
                            TIPPLA.estado_reg,
                            TIPPLA.fecha_reg,
                            TIPPLA.id_usuario_reg,
                            TIPPLA.fecha_mod,
                            TIPPLA.id_usuario_mod,
                            MONEDA.moneda as desc_moneda,
                            PERSON.nombre_completo1 as desc_usuario_reg,
                            PERMOD.nombre_completo1 as desc_usuario_mod
                            FROM rhum.ttipo_planilla TIPPLA
                            INNER JOIN param.tmoneda MONEDA ON MONEDA.id_moneda=TIPPLA.id_moneda
                            INNER JOIN SEGU.tusuario USUARI ON USUARI.id_usuario=TIPPLA.id_usuario_reg
                            INNER JOIN SEGU.vpersona PERSON ON PERSON.id_persona=USUARI.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=TIPPLA.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='RH_TIPPLA_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(TIPPLA.id_tipo_planilla)
                            FROM rhum.ttipo_planilla TIPPLA
                            INNER JOIN param.tmoneda MONEDA ON MONEDA.id_moneda=TIPPLA.id_moneda
                            INNER JOIN SEGU.tusuario USUARI ON USUARI.id_usuario=TIPPLA.id_usuario_reg
                            INNER JOIN SEGU.vpersona PERSON ON PERSON.id_persona=USUARI.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=TIPPLA.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.ft_tipo_planilla_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1278 (class 1255 OID 2131340)
-- Dependencies: 12 2435
-- Name: ft_uo_funcionario_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: postgres
--

CREATE FUNCTION ft_uo_funcionario_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		rhum.ft_uofunc_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		03-06-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_uo  				integer;
v_id_funcionario integer;

--10abr12   
v_respuesta_sinc       varchar;
v_id_uo_funcionario     integer;


BEGIN

     v_nombre_funcion:='rhum.ft_uo_funcionario_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:  RH_UOFUNC_INS
 #DESCRIPCION:	Inserta uos funcionario
 #AUTOR:		KPLIAN (mzm)	
 #FECHA:		25-06-2011	
***********************************/
     if(par_transaccion='RH_UOFUNC_INS')then

        
          BEGIN

               -- verificar si la uo permite multiples asignaciones de funcionario
               --RAC NO ESTA FUNCIOANNDO ESTO DEL CARGO INDIVIDUAL
               /*if (select count(*)=1 
                  from rhum.tuo_funcionario where id_uo=v_parametros.id_uo and estado_reg=v_parametros.estado_reg and
                   id_uo=(select id_uo from rhum.tuo where  id_uo=v_parametros.id_uo and estado_reg='activo' and cargo_individual='si')) then
                             raise exception 'El cargo es individual y ya existe otro funcionario asignado actualmente';
               end if;*/
               
                --verficar que el funcionario no este activo en dos unidades simultaneamente
                
                if ( v_parametros.estado_reg='activo' and
                      ((select count(id_funcionario) from 
                           rhum.tuo_funcionario  UOF
                           where     id_funcionario=v_parametros.id_funcionario AND uof.estado_reg='activo' ))>0) then
                           
                           raise exception 'El Funcionario se encuentra en otro cargo vigente primero inactive su asignacion actual';
                end if;
               
               --insercion de nuevo uo
               if exists (select 1 from rhum.tuo_funcionario where id_funcionario=v_parametros.id_funcionario and
               id_uo=v_parametros.id_uo and estado_reg='activo') then
                  raise exception 'Insercion no realizada. El funcionacio ya esta asignado a la unidad';
               end if;

               INSERT INTO rhum.tuo_funcionario
               (id_uo, id_funcionario, fecha_asignacion, estado_reg)
               values(v_parametros.id_uo, v_parametros.id_funcionario,v_parametros.fecha_asignacion, v_parametros.estado_reg)  
               RETURNING id_uo_funcionario INTO v_id_uo_funcionario;
              
               --10-04-2012: sincronizacion de UO entre BD
               v_respuesta_sinc:=rhum.f_sincroniza_uo_empleado_entre_bd(v_id_uo_funcionario,'10.172.0.13','5432','db_link','db_link','dbendesis' ,'INSERT');
                     
               if(v_respuesta_sinc!='si')  then
                  raise exception 'Sincronizacion de UO en BD externa no realizada%',v_respuesta_sinc;
               end if;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Asignacion empleado-uo registrada con exito: Funcionario ('|| (select desc_funcionario1 from rhum.vfuncionario where id_funcionario=v_parametros.id_funcionario) || ') - UO'|| (select nombre_unidad from rhum.tuo where id_uo=v_parametros.id_uo));
               v_resp = f_agrega_clave(v_resp,'id_uo',v_id_uo::varchar);
         END;
 /*******************************    
 #TRANSACCION:  RH_UOFUNC_MOD
 #DESCRIPCION:	Modifica la parametrizacion seleccionada
 #AUTOR:		KPLIAN (mzm)	
 #FECHA:		03-06-2011
***********************************/
     elsif(par_transaccion='RH_UOFUNC_MOD')then

          
          BEGIN
              if ( select count(*)=1 from 
                           rhum.tuo_funcionario 
                           where    id_uo=v_parametros.id_uo 
                                and estado_reg=v_parametros.estado_reg and
                                    id_funcionario!=v_parametros.id_funcionario and
                                    id_uo=(select id_uo from rhum.tuo where estado_reg='activo' and cargo_individual='si')) then
                           
                           raise exception 'El cargo es individual y ya existe otro funcionario asignado actualmente';
               end if;
                
                
                --verficar que el funcionario no este activo en dos unidades simultaneamente
                
               if ( v_parametros.estado_reg='activo' and
                      ((select count(id_funcionario) from 
                           rhum.tuo_funcionario 
                           where     id_funcionario=v_parametros.id_funcionario ))>0) then
                           
                           raise exception 'El Funcionario se encuentra en otro cargo vigente primero inactive su asignacion actual';
               end if;
                
                
                
                --si el estado es inactivo == la fecha finalizacion debe ser llenada
               
               
                if(v_parametros.estado_reg='inactivo' and v_parametros.fecha_finalizacion is null) then
                   raise exception 'La inactivacion al cargo requiere indicar la fecha de finalizacion';
                end if;
                
                update rhum.tuo_funcionario
                set 
                   fecha_asignacion=v_parametros.fecha_asignacion::date,
                   id_funcionario=v_parametros.id_funcionario
                where id_uo=v_parametros.id_uo
                and id_uo_funcionario=v_parametros.id_uo_funcionario;
                
                --10-04-2012: sincronizacion de UO entre BD
                v_respuesta_sinc:=rhum.f_sincroniza_uo_empleado_entre_bd(v_parametros.id_uo_funcionario,'10.172.0.13','5432','db_link','db_link','dbendesis' ,'UPDATE');
                     
                if(v_respuesta_sinc!='si')  then
                  raise exception 'Sincronizacion de UO en BD externa no realizada%',v_respuesta_sinc;
                end if;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','Modificacion a asignacion empleado-uo modificada con exito '||v_parametros.id_uo_funcionario||': Funcionario ('|| (select desc_funcionario1 from rhum.vfuncionario where id_funcionario=v_parametros.id_funcionario) || ') - UO'|| (select nombre_unidad from rhum.tuo where id_uo=v_parametros.id_uo));
               v_resp = f_agrega_clave(v_resp,'id_uo',v_parametros.id_uo::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  RH_UOFUNC_ELI
 #DESCRIPCION:	Inactiva la parametrizacion selecionada
 #AUTOR:	    KPLIAN (mzm)
 #FECHA:		03-06-2011
***********************************/

    elsif(par_transaccion='RH_UOFUNC_ELI')then
        BEGIN
        
         --inactivacion de la uo
               select id_funcionario,id_uo 
               into v_id_funcionario, v_id_uo
               from rhum.tuo_funcionario
               where  id_uo_funcionario=v_parametros.id_uo_funcionario;
               
               --elimina siempre que puede: como el registro de uo_fun es referncial en RHUM, se posible eliminarlo todo el tiempo
               -- se debe cuidar q en el diseno cuando se requiera obtener la dependencia de un funcionario, se deb guardar la referencia vigente de uo_funcionario
               delete from rhum.tuo_funcionario
               where id_uo_funcionario=v_parametros.id_uo_funcionario;
              
               --10-04-2012: sincronizacion de UO entre BD
                v_respuesta_sinc:=rhum.f_sincroniza_uo_empleado_entre_bd(v_parametros.id_uo_funcionario,'10.172.0.13','5432','db_link','db_link','dbendesis' ,'DELETE');
                     
                if(v_respuesta_sinc!='si')  then
                  raise exception 'Sincronizacion de UO en BD externa no realizada%',v_respuesta_sinc;
                end if;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','asignacion empleado-uo eliminada con exito '||v_parametros.id_uo_funcionario||': Funcionario ('|| (select desc_funcionario1 from rhum.vfuncionario where id_funcionario=v_id_funcionario) || ') - UO'|| (select nombre_unidad from rhum.tuo where id_uo=v_id_uo));
               v_resp = f_agrega_clave(v_resp,'id_uo',v_id_uo::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.ft_uo_funcionario_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1277 (class 1255 OID 2131342)
-- Dependencies: 2435 12
-- Name: ft_uo_funcionario_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: postgres
--

CREATE FUNCTION ft_uo_funcionario_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		RHUM.ft_uo_funcionario_sel
 DESCRIPCIÓN:  listado de uo
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		30-05-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;
v_id_padre         integer;

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_uo_funcionario_sel';

/*******************************
 #TRANSACCION:  RH_UO_SEL
 #DESCRIPCION:	Listado de uo funcionarios
 #AUTOR:		
 #FECHA:		30/05/11	
***********************************/
     if(par_transaccion='RH_UOFUNC_SEL')then

          
          BEGIN

               v_consulta:='SELECT
                                  UOFUNC.id_uo_funcionario,
                                  UOFUNC.id_uo,
                                  UOFUNC.id_funcionario,
                                  FUNCIO.ci,
                                  FUNCIO.codigo,
                                  FUNCIO.desc_funcionario1,
                                  FUNCIO.desc_funcionario2,
                                  FUNCIO.num_doc,
                                  UOFUNC.fecha_asignacion,
                                  UOFUNC.fecha_finalizacion,
                                  UOFUNC.estado_reg,
                                  UOFUNC.fecha_mod,
                                  UOFUNC.fecha_reg,
                                  UOFUNC.id_usuario_mod,
                                  UOFUNC.id_usuario_reg,
                                  PERREG.nombre_completo2 AS USUREG,
                                  PERMOD.nombre_completo2 AS USUMOD
                                  
                            FROM rhum.tuo_funcionario UOFUNC
                            INNER JOIN RHUM.tuo UO ON UO.id_uo=UOFUNC.id_uo
                            INNER JOIN RHUM.vfuncionario FUNCIO ON FUNCIO.id_funcionario=UOFUNC.id_funcionario
                            INNER JOIN segu.tusuario USUREG ON  UO.id_usuario_reg=USUREG.id_usuario
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=UO.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE  UOFUNC.estado_reg !=''eliminado'' and ';

              
                v_id_padre:=v_parametros.id_uo;
              
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta || ' and UOFUNC.id_uo='|| v_id_padre;
               
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

/*******************************
 #TRANSACCION:  RH_UO_CONT
 #DESCRIPCION:	Conteo de uos
 #AUTOR:		
 #FECHA:		23/05/11	
***********************************/
     elsif(par_transaccion='RH_UOFUNC_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(UOFUNC.id_uo_funcionario)
                            FROM rhum.tuo_funcionario UOFUNC
                            INNER JOIN RHUM.tuo UO ON UO.id_uo=UOFUNC.id_uo
                            INNER JOIN RHUM.vfuncionario FUNCIO ON FUNCIO.id_funcionario=UOFUNC.id_funcionario
                            INNER JOIN segu.tusuario USUREG ON  UO.id_usuario_reg=USUREG.id_usuario
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=UO.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE UOFUNC.estado_reg !=''eliminado'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.ft_uo_funcionario_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1274 (class 1255 OID 2118154)
-- Dependencies: 2435 12
-- Name: ft_uo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: mzambrana
--

CREATE FUNCTION ft_uo_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		rhum.ft_uo_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 	    KPLIAN (mzm)
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		23-05-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_uo  				integer;


BEGIN

     v_nombre_funcion:='rhum.ft_uo_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:  RH_UO_INS
 #DESCRIPCION:	Inserta uos
 #AUTOR:			
 #FECHA:		25-03-2011	
***********************************/
     if(par_transaccion='RH_UO_INS')then

        
          BEGIN


               --insercion de nuevo uo
               if exists (select 1 from rhum.tuo where codigo=v_parametros.codigo and estado_reg='activo') then
                  raise exception 'Insercion no realizada. CODIGO DE UO EN USO';
               end if;

               INSERT INTO rhum.tuo(cargo_individual,codigo,             descripcion,              estado_reg,  fecha_reg,   id_usuario_reg, nombre_cargo,              nombre_unidad, presupuesta)
               values(v_parametros.cargo_individual, v_parametros.codigo,v_parametros.descripcion, 'activo',    now()::date, par_id_usuario, v_parametros.nombre_cargo, v_parametros.nombre_unidad, v_parametros.presupuesta);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','uo '||v_parametros.codigo ||' insertado con exito ');
               v_resp = f_agrega_clave(v_resp,'id_uo',v_id_uo::varchar);
         END;
 /*******************************    
 #TRANSACCION:  RH_UO_MOD
 #DESCRIPCION:	Modifica la parametrizacion seleccionada
 #AUTOR:			
 #FECHA:		25-01-2011
***********************************/
     elsif(par_transaccion='RH_UO_MOD')then

          
          BEGIN    raise exception 'entra a ft_uo_ime';
                if exists (select 1 from rhum.tuo where id_uo!=v_parametros.id_uo and codigo=v_parametros.codigo and estado_reg='activo') then
                  raise exception 'Modificacion no realizada. CODIGO DE UO EN USO';
                end if;
                
                update rhum.tuo
                set 
                    cargo_individual=v_parametros.cargo_individual,
                    codigo=v_parametros.codigo,
                    descripcion=v_parametros.descripcion,
                    nombre_cargo=v_parametros.nombre_cargo,
                    nombre_unidad=v_parametros.nombre_unidad,
                    presupuesta=v_parametros.presupuesta,
                    fecha_mod=now()::date,
                    id_usuario_mod=par_id_usuario
                where id_uo=v_parametros.id_uo;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','uo modificado con exito '||v_parametros.id_uo);
               v_resp = f_agrega_clave(v_resp,'id_uo',v_parametros.id_uo::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  RH_UO_ELI
 #DESCRIPCION:	Inactiva la parametrizacion selecionada
 #AUTOR:			
 #FECHA:		25-03-2011
***********************************/

    elsif(par_transaccion='RH_UO_ELI')then
        BEGIN
        
         --inactivacion de la uo
               update rhum.tuo
               set estado_reg='inactivo'
               where id_uo=v_parametros.id_uo;
              
               
               v_resp = f_agrega_clave(v_resp,'mensaje','uo eliminada con exito '||v_parametros.id_uo);
               v_resp = f_agrega_clave(v_resp,'id_uo',v_parametros.id_uo::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.ft_uo_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO mzambrana;

--
-- TOC entry 1275 (class 1255 OID 2118155)
-- Dependencies: 2435 12
-- Name: ft_uo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: mzambrana
--

CREATE FUNCTION ft_uo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		RHUM.ft_uo_sel
 DESCRIPCIÓN:  listado de uo
 AUTOR: 	    KPLIAN (mzm)
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		21-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;
v_filadd           varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_uo_sel';

/*******************************
 #TRANSACCION:  RH_UO_SEL
 #DESCRIPCION:	Listado de uos
 #AUTOR:		
 #FECHA:		23/05/11	
***********************************/
     if(par_transaccion='RH_UO_SEL')then

          
          BEGIN
          
          
            v_filadd = '';
            IF (f_existe_parametro(par_tabla,'correspondencia')) THEN
               v_filadd = ' (UO.correspondencia = '''||v_parametros.correspondencia||''') and ';
            END IF;    
            
            --29mar12: para SAJ
            IF (f_existe_parametro(par_tabla,'gerencia')) THEN
               v_filadd = ' (UO.gerencia = '''||v_parametros.gerencia||''') and ';
            END IF;
            
            
               v_consulta:='SELECT UO.id_uo,
                                  UO.cargo_individual,
                                  UO.codigo,
                                  UO.descripcion,
                                  UO.estado_reg,
                                  UO.fecha_mod,
                                  UO.fecha_reg,
                                  
                                  UO.id_usuario_mod,
                                  UO.id_usuario_reg,
                                  UO.nombre_cargo,
                                  UO.nombre_unidad,
                                  UO.presupuesta,
                                  PERREG.nombre_completo2 AS USUREG,
                                  PERMOD.nombre_completo2 AS USUMOD
                            FROM rhum.tuo UO
                            INNER JOIN segu.tusuario USUREG ON  UO.id_usuario_reg=USUREG.id_usuario
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=UO.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE '||v_filadd;
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

/*******************************
 #TRANSACCION:  RH_UO_CONT
 #DESCRIPCION:	Conteo de uos
 #AUTOR:		
 #FECHA:		23/05/11	
***********************************/
     elsif(par_transaccion='RH_UO_CONT')then

          --consulta:=';
          BEGIN
          
           v_filadd = '';
            IF (f_existe_parametro(par_tabla,'correspondencia')) THEN
               v_filadd = ' (UO.correspondencia = '''||v_parametros.correspondencia||''') and ';
            END IF;
           
            --29mar12: para SAJ
            IF (f_existe_parametro(par_tabla,'gerencia')) THEN
               v_filadd = ' (UO.gerencia = '''||v_parametros.gerencia||''') and ';
            END IF;
            
               v_consulta:='SELECT
                                  count(UO.id_uo)
                            FROM rhum.tuo UO
                            INNER JOIN segu.tusuario USUREG ON  UO.id_usuario_reg=USUREG.id_usuario
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=UO.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE  '||v_filadd;
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION rhum.ft_uo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO mzambrana;

SET search_path = saj, pg_catalog;

--
-- TOC entry 1301 (class 1255 OID 2070228)
-- Dependencies: 91 2435
-- Name: f_manejo_estado_proceso(integer, character varying, character varying, integer, integer); Type: FUNCTION; Schema: saj; Owner: mzambrana
--

CREATE FUNCTION f_manejo_estado_proceso(p_id integer, p_tipo character varying, p_observaciones character varying, p_id_usuario integer, p_id_responsable integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		f_manejo_estado_proceso
 DESCRIPCION:   maneja el estado del proceso de contratacion avanzando o retrocediendo
 
 AUTOR: 	    ENDE Mercedes Zambrana Meneces
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES  
 DESCRIPCION:        en ves de utlizar id_Estado comollave foranea con la tabla estado se utiliza el codigo
 AUTOR:		ENDE Rensi Arteaga Copari
 FECHA:		5/12/2011
 ***********************************************************************************************/

DECLARE
  /*
  id: id_proceso_contrato
  tipo: avanzar/retroceder
  */
  v_estado_actual   varchar;
  v_estado_anterior varchar;
  v_num_orden       integer;  
  v_id_estado_nuevo integer;
  v_nombre_estado varchar;
  v_id_alarmas integer[];
  
BEGIN
       --0) obtenemos el estado actual del proceso_contrato
       SELECT 
          coalesce(e.orden,0) , ep.estado_vigente
       into 
          v_num_orden,         v_estado_anterior
       FROM saj.testado_proceso ep
       INNER JOIN saj.testado e ON e.codigo=ep.estado_vigente
       WHERE id_proceso_contrato=p_id 
             and ep.estado_reg='activo';
     
       v_num_orden:=coalesce(v_num_orden,0);
       
       --1)  si buscamos el estado siguiente
       if(p_tipo='siguiente') then
             --1.1) si el proceso no tiene estados obtenemos el primero
             if v_estado_anterior is NULL THEN
             
                     select id_estado,codigo , nombre
                        into 
                       v_id_estado_nuevo,v_estado_actual,v_nombre_estado
                     from saj.testado 
                     where orden=1
                     and estado_reg='activo';
                     
                     --raise exception 'anterior...........';
             

             ELSE
              --1.2) si es un estado mayor al primero
                    select id_estado ,codigo,nombre
                      into 
                          v_id_estado_nuevo,v_estado_actual,v_nombre_estado
                     from saj.testado 
                     where orden=v_num_orden+1 
                     and estado_reg='activo';
                         
                     if(v_id_estado_nuevo is null) then
                        raise exception 'No existe un estado siguiente';
                     end if;
                     
                --    raise exception 'auuuuuunterior...........  %  % % %',v_num_orden,v_estado_actual,v_estado_anterior,p_id;
               
             END IF;

        --2)  si buscamos el estado anterior 
       elsif(p_tipo='anterior') then

           if(v_num_orden=0 or  v_estado_anterior is NULL ) then
                raise exception 'Estado anterior inexistente';
           else    
                select 
                   id_estado,codigo, nombre
                into 
                   v_id_estado_nuevo,v_estado_actual,v_nombre_estado
                from saj.testado 
                where orden=v_num_orden-1 and orden>0
                and estado_reg='activo'; 
           end if;
           
     --3)  si buscamos un estado especial
       else --(p_tipo='anulado') then  
       
                select 
                   id_estado,codigo,nombre 
                into 
                   v_id_estado_nuevo,v_estado_actual,v_nombre_estado
                from saj.testado 
                where 
                  lower(codigo)=lower(p_tipo)  
                and
                  estado_reg='activo' limit 1;           
            
                if(v_id_estado_nuevo is null) then
                     raise exception 'Cambio de Estado no permitido';
                end if;
       end if;
        
    --4) inactivamos los estados anteriores
        
       update  saj.testado_proceso set 
         fecha_fin=now()::date ,
         observaciones= 'cambio estado de:'||v_estado_anterior||' a '|| v_estado_actual || ' - OBS: '||coalesce(p_observaciones,'NINGUNA'),
         id_usuario_mod=p_id_usuario,
         fecha_mod=now(),
       estado_reg='inactivo'       
       where estado_reg='activo'
       and id_proceso_contrato=p_id; 
       
       
      --5) insertamos un nuevo estado proceso      
       insert into saj.testado_proceso (estado_anterior,   estado_vigente,fecha_ini, fecha_reg, id_proceso_contrato, observaciones,    id_responsable_proceso, id_usuario_reg) 
       values                          (v_estado_anterior, v_estado_actual, now(),    now(),    p_id,                 p_observaciones, p_id_responsable,       p_id_usuario);
       
      
       
       
     
 
     
     -- 6) si el nuevo estado concluye el cotrato revisamos si tienes alarmas y  las desatvamos
     
     IF ( v_estado_actual='FINCON' and v_estado_anterior='REGCON')THEN
     
      --6.1 )  si el estado es de finalizacion del contrato 
      --      revisamos si tiene alarmas y las
      --      cambiamos a notificaciones  resetamos el id_alarma
                           
           select pc.id_alarma into v_id_alarmas 
           from saj.tproceso_contrato pc
           where pc.id_proceso_contrato=p_id;
                           
           update param.talarma set
           tipo ='notificacion',
           fecha = now(),
           descripcion ='El contrato fue Finalizado ['||descripcion||']',
           id_usuario_mod = p_id_usuario,
           fecha_mod = now()
           where id_alarma = ANY (v_id_alarmas);
           
      --6.2) actualizamos el estado del proceso_contrato     
         update saj.tproceso_contrato pc set
         estado_proceso = v_estado_actual,
         id_usuario_mod = p_id_usuario,
         fecha_mod = now(),
         id_alarma = NULL
         where id_proceso_contrato = p_id;
         
     ELSE  
      
         update saj.tproceso_contrato pc set
         estado_proceso = v_estado_actual,
         id_usuario_mod = p_id_usuario,
         fecha_mod = now()
         where id_proceso_contrato = p_id;     
   
     
     END IF;
     
        
       return 'exito';

END;
$$;


ALTER FUNCTION saj.f_manejo_estado_proceso(p_id integer, p_tipo character varying, p_observaciones character varying, p_id_usuario integer, p_id_responsable integer) OWNER TO mzambrana;

--
-- TOC entry 1158 (class 1255 OID 1961599)
-- Dependencies: 2435 91
-- Name: f_tboleta_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: postgres
--

CREATE FUNCTION f_tboleta_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_tboleta_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'saj.tboleta'
 AUTOR: 		 (fprudencio)
 FECHA:	        17-11-2011 11:23:54
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp                    varchar;
    v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_boleta    integer;
    v_id_boleta_fk integer;
    v_id_alarmas integer[];
    v_estado varchar;
                
BEGIN
           
    v_nombre_funcion = 'saj.f_tboleta_ime';
    v_parametros = f_get_record(p_tabla);

    /*********************************    
     #TRANSACCION:  'SA_BOLETA_INS'
     #DESCRIPCION:  Insercion de registros
     #AUTOR:        Mercedes Zambrana Meneses
     #FECHA:        17-11-2011 11:23:54
    ***********************************/

    if(p_transaccion='SA_BOLETA_INS')then
                    
        begin
        
        IF(public.f_existe_parametro(p_tabla,'id_boleta_fk')) then
        
           v_id_boleta_fk = v_parametros.id_boleta_fk;
        else
           v_id_boleta_fk = NULL;
        END IF;
        
       -- veirifico si la institucion es del tipo banco
       
       IF (not exists (select 1 from param.tinstitucion i 
                  where i.id_institucion = v_parametros.id_institucion_banco
                  and i.es_banco='SI'))THEN
                  
              raise exception 'La institución seleccionada no esta señalada como un banco';
                  
       END IF;
        
        
        
            --Sentencia de la insercion
            insert into saj.tboleta(
            --extension,
           -- doc_garantia,
           -- id_alarma,
            id_institucion_banco,
           -- fecha_fin,
            numero,
            fecha_vencimiento,
            fecha_suscripcion,
            orden,
            observaciones,
            monto,
            id_moneda,
            tipo,
           -- version,
            estado_reg,
            id_proceso_contrato,
          --  fecha_ini,
            estado,
            id_usuario_reg,
            fecha_reg,
            id_usuario_mod,
            fecha_mod,
            id_boleta_fk
              ) values(
           -- v_parametros.extension,
          --  v_parametros.doc_garantia,
           -- v_parametros.id_alarma,
            v_parametros.id_institucion_banco,
          --  v_parametros.fecha_fin,
            v_parametros.numero,
            v_parametros.fecha_vencimiento,
            v_parametros.fecha_suscripcion,
            v_parametros.orden,
            v_parametros.observaciones,
            v_parametros.monto,
            v_parametros.id_moneda,
            v_parametros.tipo,
          --  v_parametros.version,
            'activo',
            v_parametros.id_proceso_contrato,
           -- v_parametros.fecha_ini,
            'borrador',
            p_id_usuario,
            now(),
            null,
            null,
            v_id_boleta_fk
            )RETURNING id_boleta into v_id_boleta;
            
            
            --cambiamos el estado de la boelta renovada si existe
            
             
                  if(v_id_boleta_fk is not NULL)THEN
                     
                     update saj.tboleta set
                      id_alarma = NULL,
                      estado = 'renovada',
                      id_usuario_mod = p_id_usuario,
                      fecha_mod = now()
                      where id_boleta=v_id_boleta_fk;
                    
                   	   -- si el estado es renovada, cobrada, finalizada
                       -- quitamos las alertas relacionadas
                       
                     
                           --cambiamos el tipo de alerta a notificacion
                           --las notificaciones pueden ser borradas por lo susuarios
                           --mostramos la solucion
                           
                           select id_alarma into v_id_alarmas 
                           from saj.tboleta b
                           where id_boleta=v_id_boleta_fk;
                           
                           update param.talarma set
                           tipo ='notificacion',
                           fecha = now(),
                           descripcion ='La boleta fue renovada  ['||descripcion||']',
                           id_usuario_mod = p_id_usuario,
                           fecha_mod = now()
                           where id_alarma = ANY (v_id_alarmas); 
                           
             
                  END IF;
           
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Boleta almacenado(a) con exito (id_boleta'||v_id_boleta||')'); 
            v_resp = f_agrega_clave(v_resp,'id_boleta',v_id_boleta::varchar);

            --Devuelve la respuesta
            return v_resp;

        end;

    /*********************************    
     #TRANSACCION:  'SA_BOLETA_MOD'
     #DESCRIPCION:    Modificacion de registros
     #AUTOR:        Mercedes Zambrana Meneses
     #FECHA:        17-11-2011 11:23:54
    ***********************************/

    elsif(p_transaccion='SA_BOLETA_MOD')then

        begin
        
            if (NOT EXISTS (select 1 from saj.tboleta b 
                 where b.id_boleta =v_parametros.id_boleta 
                 and estado_reg='activo')) then
               raise exception 'La boleta se encuentra eliminada (actualice su grilla)';            
 			end if;
            
            
             --obtener etado de bolea antes de modificar
            
            select estado into v_estado from saj.tboleta b where  b.id_boleta =v_parametros.id_boleta ;
            --si la boleta no esta en estado borrado o registrada no pueden hacerce cambios
            if(v_estado not in ('borrador','resgistrada')) then
            
              raise exception 'Solo se pueden editar boletas en estado borrador o registradas';
            
            end if;
            
             -- veirifico si la institucion es del tipo banco
       
           IF (not exists (select 1 from param.tinstitucion i 
                      where i.id_institucion = v_parametros.id_institucion_banco
                      and i.es_banco='SI'))THEN
                      
                  raise exception 'La institución seleccionada no esta señalada como un banco';
                      
           END IF;
            
            
            --Sentencia de la modificacion
            update saj.tboleta set
           -- extension = v_parametros.extension,
           -- doc_garantia = v_parametros.doc_garantia,
           -- id_alarma = v_parametros.id_alarma,
            id_institucion_banco = v_parametros.id_institucion_banco,
           -- fecha_fin = v_parametros.fecha_fin,
            numero = v_parametros.numero,
            fecha_vencimiento = v_parametros.fecha_vencimiento,
            fecha_suscripcion = v_parametros.fecha_suscripcion,
            orden = v_parametros.orden,
            observaciones = v_parametros.observaciones,
            monto = v_parametros.monto,
            id_moneda = v_parametros.id_moneda,
            tipo = v_parametros.tipo,
            id_usuario_mod = p_id_usuario,
            fecha_mod = now()
           
           -- version = v_parametros.version,
          --  id_proceso_contrato = v_parametros.id_proceso_contrato,
           -- fecha_ini = v_parametros.fecha_ini
          --  estado = v_parametros.estado,
           
            where id_boleta=v_parametros.id_boleta;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Boleta modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_boleta',v_parametros.id_boleta::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end;
    /*********************************    
 	#TRANSACCION:  'SA_ARCHBOL_MOD'
 	#DESCRIPCION:	Actualiza datos de la boleta  escaneada
 	#AUTOR:		rac	
 	#FECHA:		16-12-2011 17:25:24
	***********************************/

	elsif(p_transaccion='SA_ARCHBOL_MOD')then

		begin
        
          if (NOT EXISTS (select 1 from saj.tboleta b 
                 where b.id_boleta =v_parametros.id_boleta 
                 and estado_reg='activo')) then
               raise exception 'La boleta se encuentra eliminada (actualice su grilla)';            
 			end if;
            
            
             --obtener etado de bolea antes de modificar
            
            select estado into v_estado from saj.tboleta b where  b.id_boleta =v_parametros.id_boleta ;
           -- raise exception '%',v_estado;
            --si la boleta no esta en estado borrado o registrada no pueden hacerce cambios
            if(v_estado not in ('borrador','registrada')) then
            
              raise exception 'Solo se pueden editar boletas en estado borrador o registradas';
            
            end if;
            
            
            --obtener etado de bolea antes de modificar
            
            select estado into v_estado from saj.tboleta b where  b.id_boleta =v_parametros.id_boleta ;
            --si la boleta no esta en estado borrado o registrada no pueden hacerce cambios
            if(v_estado not in ('borrador','resgistrada')) then
            
              raise exception 'Solo se pueden editar boletas en estado borrador o registradas';
            
            end if;
            
        
           --raise exception 'VERSION %',v_parametros.version;
          
           update saj.tboleta set
           extension = v_parametros.extension,
           doc_garantia = v_parametros.doc_garantia,
            id_usuario_mod = p_id_usuario,
            fecha_mod = now(),
           version = v_parametros.version
           where id_boleta=v_parametros.id_boleta;
            
            --Definicion de la respuesta
           v_resp = f_agrega_clave(v_resp,'mensaje','Archivo escaneado de boleta modificado(a)'); 
           v_resp = f_agrega_clave(v_resp,'id_boleta',v_parametros.id_boleta::varchar);
               
            --Devuelve la respuesta
           return v_resp;
           
     end;        
    /*********************************    
 	#TRANSACCION:  'SA_CMBEST_MOD'
 	#DESCRIPCION:	Cambia de estados la boleta
 	#AUTOR:		rac	
 	#FECHA:		16-12-2011 17:25:24
	***********************************/

	elsif(p_transaccion='SA_CMBEST_MOD')then

		begin
          --verificar que boleta existe 
          
          if (NOT EXISTS (select 1 from saj.tboleta b 
                 where b.id_boleta =v_parametros.id_boleta 
                 and estado_reg='activo')) then
               raise exception 'La boleta se encuentra eliminada (actualice su grilla)';            
 			end if;
            
            
             --obtener etado de bolea antes de modificar
            
            select estado into v_estado from saj.tboleta b where  b.id_boleta =v_parametros.id_boleta ;
            --si la boleta no esta en estado borrado o registrada no pueden hacerce cambios
          /*  if(v_estado !=v_parametros.estado) then
            
              raise exception 'La boleta ya se encuentra en el estado % (Posiblemente otro usuario esta modificando simultaneamente esta boleta)',v_parametros.estado;
            
            end if;*/
        
                  
          --modifica estado boleta 
           update saj.tboleta set
           estado = v_parametros.estado,
            id_usuario_mod = p_id_usuario,
            fecha_mod = now()
           where id_boleta=v_parametros.id_boleta;
        
           
           -- si el estado es renovada, cobrada, finalizada
           -- quitamos las alertas relacionadas
           
           if(v_parametros.estado  in ('renovada','cobrada','anulada','finalizada')) THEN
           
         
               --cambiamos el tipo de alerta a notificacion
               --las notificaciones pueden ser borradas por lo susuarios
               --mostramos la solucion
               
               select id_alarma into v_id_alarmas 
               from saj.tboleta b
               where id_boleta=v_parametros.id_boleta;
               
               update param.talarma set
               tipo ='notificacion',
               fecha = now(),
               descripcion ='La boleta fue '||v_parametros.estado||'  ['||descripcion||']',
               id_usuario_mod = p_id_usuario,
               fecha_mod = now()
               where id_alarma = ANY (v_id_alarmas); 
               
               --eliminamos la relacion con las boletas
               update saj.tboleta set
               id_alarma = NULL
               where id_boleta=v_parametros.id_boleta;
               
               
         
           END IF;
           
           --raise exception 'VERSION %',v_parametros.version;
          
          
           
            
            --Definicion de la respuesta
           v_resp = f_agrega_clave(v_resp,'mensaje','Archivo escaneado de boleta modificado(a)'); 
           v_resp = f_agrega_clave(v_resp,'id_boleta',v_parametros.id_boleta::varchar);
               
            --Devuelve la respuesta
           return v_resp;      
           
            
        end; 
    /*********************************    
     #TRANSACCION:  'SA_BOLETA_ELI'
     #DESCRIPCION:  Eliminacion de registros
     #AUTOR:        Mercedes Zambrana Meneses  
     #FECHA:        17-11-2011 11:23:54
    ***********************************/

    elsif(p_transaccion='SA_BOLETA_ELI')then

        begin
            
            
            /*si la boleta eliminada tiene alarmas*/
            
            --cambiamos el tipo de alerta a notificacion
               --las notificaciones pueden ser borradas por lo susuarios
               --mostramos la solucion
               
               select id_alarma into v_id_alarmas 
               from saj.tboleta b
               where id_boleta=v_parametros.id_boleta;
               
               update param.talarma set
               tipo ='notificacion',
               fecha = now(),
               descripcion ='La boleta fue ELIMINADA  ['||descripcion||']',
               id_usuario_mod = p_id_usuario,
               fecha_mod = now()
               where id_alarma = ANY (v_id_alarmas); 
               
           
               
           
            
            
            /* fin alarmas*/
            
            --verifica que no tengas boeltas renovadas
            
            if(select 1 from saj.tboleta b where b.id_boleta_fk =v_parametros.id_boleta) then
				raise exception 'La boleta que quiere eliminar ha sido renovada con anterioridad, no puede realizar esta acción';            
 			end if;
            
            
             --Sentencia de la eliminacion
             
             --eliminamos la relacion con las boletas
             /*update saj.tboleta set
             id_alarma = NULL
           --  estado_reg='inactiva'
             where id_boleta=v_parametros.id_boleta;*/
               
               
            delete from saj.tboleta
            where id_boleta=v_parametros.id_boleta;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Boleta eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_boleta',v_parametros.id_boleta::varchar);
              
            --Devuelve la respuesta
            return v_resp;

        end;
         
    else
     
        raise exception 'Transaccion inexistente: %',p_transaccion;

    end if;

EXCEPTION
                
    WHEN OTHERS THEN
        v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
        raise exception '%',v_resp;
                        
END;
$$;


ALTER FUNCTION saj.f_tboleta_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1155 (class 1255 OID 1961600)
-- Dependencies: 91 2435
-- Name: f_tboleta_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: postgres
--

CREATE FUNCTION f_tboleta_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_tboleta_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'saj.tboleta'
 AUTOR: 		 (fprudencio)
 FECHA:	        17-11-2011 11:23:54
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_id_funcionario integer;
    v_id_responsable_proceso integer;
    v_filtro varchar;
			    
BEGIN

	v_nombre_funcion = 'saj.f_tboleta_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
     #TRANSACCION:  'SA_BOLETA_SEL'
     #DESCRIPCION:    Consulta de datos
     #AUTOR:        fprudencio    
     #FECHA:        17-11-2011 11:23:54
    ***********************************/

    if(p_transaccion='SA_BOLETA_SEL')then
                     
        begin
       
        
            --Sentencia de la consulta
            v_consulta:='select
                        boleta.id_boleta,
                        boleta.extension,
                        boleta.doc_garantia,
                      --  boleta.id_alarma,
                        boleta.id_institucion_banco,
                        boleta.fecha_fin,
                        boleta.numero,
                        boleta.fecha_vencimiento,
                        boleta.fecha_suscripcion,
                        boleta.orden,
                        boleta.observaciones,
                        boleta.monto,
                        boleta.id_moneda,
                        boleta.tipo,
                        boleta.version,
                        boleta.estado_reg,
                        boleta.id_proceso_contrato,
                        boleta.fecha_ini,
                        boleta.estado,
                        boleta.id_usuario_reg,
                        boleta.fecha_reg,
                        boleta.id_usuario_mod,
                        boleta.fecha_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod ,
                        moneda.moneda as desc_moneda,
                        instit.nombre as nombre   
                        from saj.tboleta boleta                                                  
                        inner join param.tmoneda moneda on moneda.id_moneda=boleta.id_moneda
                        inner join param.tinstitucion instit on instit.id_institucion=boleta.id_institucion_banco
                        inner join segu.tusuario usu1 on usu1.id_usuario = boleta.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = boleta.id_usuario_mod
                        where  ';
            
            --Definicion de la respuesta                    
            v_consulta:=v_consulta||v_parametros.filtro;
            if(public.f_existe_parametro(p_tabla,'id_proceso_contrato')) then
               v_consulta:=v_consulta || ' and boleta.id_proceso_contrato='||v_parametros.id_proceso_contrato;
            end if;
            
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

            --Devuelve la respuesta
            return v_consulta;
                        
        end;

    /*********************************    
     #TRANSACCION:  'SA_BOLETA_CONT'
     #DESCRIPCION:    Conteo de registros
     #AUTOR:        fprudencio    
     #FECHA:        17-11-2011 11:23:54
    ***********************************/

    elsif(p_transaccion='SA_BOLETA_CONT')then

        begin
            --Sentencia de la consulta de conteo de registros
            v_consulta:='select count(id_boleta)
                        from saj.tboleta boleta 
                        inner join param.tmoneda moneda on moneda.id_moneda=boleta.id_moneda
                        inner join param.tinstitucion instit on instit.id_institucion=boleta.id_institucion_banco
                        inner join segu.tusuario usu1 on usu1.id_usuario = boleta.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = boleta.id_usuario_mod
                        where ';
            
            --Definicion de la respuesta            
            v_consulta:=v_consulta||v_parametros.filtro;

            --Devuelve la respuesta
            return v_consulta;

        end;
        
    /*********************************    
     #TRANSACCION:  'SA_BOLETAPR_SEL'
     #DESCRIPCION:    Consulta de boletas y procesos
     #AUTOR:        fprudencio    
     #FECHA:        17-11-2011 11:23:54
    ***********************************/

    elseif(p_transaccion='SA_BOLETAPR_SEL')then
                     
        begin
        
         v_filtro='  0=0 '; 
        
         IF(public.f_existe_parametro(p_tabla,'id_usuario')) then

                IF(v_parametros.tipoFiltro!='solicitante')THEN
                
                       Select 
                         fun.id_funcionario, r.id_responsable_proceso
                       into 
                         v_id_funcionario,v_id_responsable_proceso
                       from rhum.tfuncionario fun
                       inner join segu.tusuario usu 
                       on usu.id_persona=fun.id_persona
                       inner join saj.tresponsable_proceso r
                       on r.id_funcionario = fun.id_funcionario and r.tipo = v_parametros.tipoFiltro
                       and r.estado_reg='activo'
                       where usu.id_usuario=v_parametros.id_usuario;
                   
                 ELSE
                 
                       Select 
                         fun.id_funcionario
                       into 
                         v_id_funcionario
                       from rhum.tfuncionario fun
                       inner join segu.tusuario usu 
                       on usu.id_persona=fun.id_persona
                       where usu.id_usuario=v_parametros.id_usuario and usu.estado_reg='activo';
                 
                 END IF;
                   --arma filtro
                 IF(v_parametros.tipoFiltro='rpc') THEN
                    v_filtro= ' pc.id_rpc = '||coalesce(v_id_responsable_proceso,0)::varchar;             

                 ELSEIF (v_parametros.tipoFiltro='supervisor') THEN
                    
                    v_filtro = ' pc.id_supervisor = '||coalesce(v_id_responsable_proceso,0)::varchar;
                
                 
                 ELSEIF (v_parametros.tipoFiltro='solicitante') THEN

                  v_filtro = ' pc.id_funcionario= '||coalesce(v_id_funcionario,0)::varchar;
                 
                 ELSE
                 
                  v_filtro='  0=0 '; 
                 END IF;
                 
                 
                -- raise exception 'xxxxxxx  %',v_parametros.tipoFiltro;
        
        end if;
        
         --raise exception 'xx zz %',v_filtro;
            --Sentencia de la consulta
            v_consulta:='select
                        boleta.id_boleta,
                        boleta.extension,
                        boleta.doc_garantia,
                      --  boleta.id_alarma,
                        boleta.id_institucion_banco,
                        boleta.fecha_fin,
                        boleta.numero,
                        boleta.fecha_vencimiento,
                        boleta.fecha_suscripcion,
                        boleta.orden,
                        boleta.observaciones,
                        boleta.monto,
                        boleta.id_moneda,
                        boleta.tipo,
                        boleta.version,
                        boleta.estado_reg,
                        boleta.id_proceso_contrato,
                        boleta.fecha_ini,
                        boleta.estado,
                        boleta.id_usuario_reg,
                        boleta.fecha_reg,
                        boleta.id_usuario_mod,
                        boleta.fecha_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod ,
                        moneda.moneda as desc_moneda,
                        instit.nombre as nombre,
                        pc.numero_contrato,
                        provee.desc_proveedor,
                        pc.doc_contrato,
                        pc.numero_requerimiento
                        from saj.tboleta boleta  
                        inner join saj.tproceso_contrato pc 
                        on pc.id_proceso_contrato = boleta.id_proceso_contrato 
                        and '||v_filtro||'                                                
                        INNER join param.vproveedor provee on provee.id_proveedor=pc.id_proveedor
                       
                        inner join param.tmoneda moneda on moneda.id_moneda=boleta.id_moneda
                        inner join param.tinstitucion instit on instit.id_institucion=boleta.id_institucion_banco
                        inner join segu.tusuario usu1 on usu1.id_usuario = boleta.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = boleta.id_usuario_mod
                        where  ';
            
            --Definicion de la respuesta                    
            v_consulta:=v_consulta||v_parametros.filtro;
            if(public.f_existe_parametro(p_tabla,'id_proceso_contrato')) then
               v_consulta:=v_consulta || ' and boleta.id_proceso_contrato='||v_parametros.id_proceso_contrato;
            end if;
            
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

            --Devuelve la respuesta
            return v_consulta;
                        
        end;

    /*********************************    
     #TRANSACCION:  'SA_BOLETAPR_CONT'
     #DESCRIPCION:    Conteo de registros de boletas con proceso
     #AUTOR:        fprudencio    
     #FECHA:        17-11-2011 11:23:54
    ***********************************/

    elsif(p_transaccion='SA_BOLETAPR_CONT')then

        begin
            --Sentencia de la consulta de conteo de registros
            v_consulta:='select count(id_boleta)
                        from saj.tboleta boleta 
                        inner join saj.tproceso_contrato pc on pc.id_proceso_contrato = boleta.id_proceso_contrato                                                
                        INNER join param.vproveedor provee on provee.id_proveedor=pc.id_proveedor
                       
                        inner join param.tmoneda moneda on moneda.id_moneda=boleta.id_moneda
                        inner join param.tinstitucion instit on instit.id_institucion=boleta.id_institucion_banco
                        inner join segu.tusuario usu1 on usu1.id_usuario = boleta.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = boleta.id_usuario_mod
                        where ';
            
            --Definicion de la respuesta            
            v_consulta:=v_consulta||v_parametros.filtro;

            --Devuelve la respuesta
            return v_consulta;

        end;    
                    
    else
                         
        raise exception 'Transaccion inexistente';
                             
    end if;
                    
EXCEPTION
                    
    WHEN OTHERS THEN
            v_resp='';
            v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
            v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
            v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
            raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION saj.f_tboleta_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1152 (class 1255 OID 1994653)
-- Dependencies: 91 2435
-- Name: f_tdocumento_anexo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: postgres
--

CREATE FUNCTION f_tdocumento_anexo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.ft_documento_anexo_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'saj.tdocumento_anexo'
 AUTOR: 		 (fprudencio)
 FECHA:	        17-11-2011 10:24:34
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_documento_anexo	integer;
			    
BEGIN

    v_nombre_funcion = 'saj.f_tdocumento_anexo_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SA_DOCANEX_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 10:24:34
	***********************************/

	if(p_transaccion='SA_DOCANEX_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into saj.tdocumento_anexo(
			estado_reg,
			id_proceso_contrato,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.id_proceso_contrato,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_documento_anexo into v_id_documento_anexo;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Documento Anexo almacenado(a) con exito (id_documento_anexo'||v_id_documento_anexo||')'); 
            v_resp = f_agrega_clave(v_resp,'id_documento_anexo',v_id_documento_anexo::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'SA_DOCANEX_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 10:24:34
	***********************************/

	elsif(p_transaccion='SA_DOCANEX_MOD')then

		begin
			--Sentencia de la modificacion
			update saj.tdocumento_anexo set
			id_proceso_contrato = v_parametros.id_proceso_contrato,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_documento_anexo=v_parametros.id_documento_anexo;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Documento Anexo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_documento_anexo',v_parametros.id_documento_anexo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'SA_DOCANEX_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 10:24:34
	***********************************/

	elsif(p_transaccion='SA_DOCANEX_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from saj.tdocumento_anexo
            where id_documento_anexo=v_parametros.id_documento_anexo;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Documento Anexo eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_documento_anexo',v_parametros.id_documento_anexo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION saj.f_tdocumento_anexo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1153 (class 1255 OID 1994654)
-- Dependencies: 91 2435
-- Name: f_tdocumento_anexo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: postgres
--

CREATE FUNCTION f_tdocumento_anexo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.ft_documento_anexo_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'saj.tdocumento_anexo'
 AUTOR: 		 (fprudencio)
 FECHA:	        17-11-2011 10:24:34
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'saj.f_tdocumento_anexo_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SA_DOCANEX_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 10:24:34
	***********************************/

	if(p_transaccion='SA_DOCANEX_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						docanex.id_documento_anexo,
						docanex.estado_reg,
						docanex.id_proceso_contrato,
						docanex.id_usuario_reg,
						docanex.fecha_reg,
						docanex.id_usuario_mod,
						docanex.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from saj.tdocumento_anexo docanex
						inner join segu.tusuario usu1 on usu1.id_usuario = docanex.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = docanex.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'SA_DOCANEX_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 10:24:34
	***********************************/

	elsif(p_transaccion='SA_DOCANEX_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_documento_anexo)
					    from saj.tdocumento_anexo docanex
					    inner join segu.tusuario usu1 on usu1.id_usuario = docanex.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = docanex.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION saj.f_tdocumento_anexo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1151 (class 1255 OID 1993276)
-- Dependencies: 2435 91
-- Name: f_testado_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: postgres
--

CREATE FUNCTION f_testado_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.ft_estado_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'saj.testado'
 AUTOR: 		 (fprudencio)
 FECHA:	        17-11-2011 09:35:55
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_estado	integer;
			    
BEGIN

    v_nombre_funcion = 'saj.f_testado_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SA_ESTAD_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 09:35:55
	***********************************/

	if(p_transaccion='SA_ESTAD_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into saj.testado(
			estado_reg,
			admite_boleta,
			orden,
			codigo,
			admite_anexo,
			nombre,
			dias,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.admite_boleta,
			v_parametros.orden,
			v_parametros.codigo,
			v_parametros.admite_anexo,
			v_parametros.nombre,
			v_parametros.dias,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_estado into v_id_estado;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Estado almacenado(a) con exito (id_estado'||v_id_estado||')'); 
            v_resp = f_agrega_clave(v_resp,'id_estado',v_id_estado::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'SA_ESTAD_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 09:35:55
	***********************************/

	elsif(p_transaccion='SA_ESTAD_MOD')then

		begin
			--Sentencia de la modificacion
			update saj.testado set
			admite_boleta = v_parametros.admite_boleta,
			orden = v_parametros.orden,
			codigo = v_parametros.codigo,
			admite_anexo = v_parametros.admite_anexo,
			nombre = v_parametros.nombre,
			dias = v_parametros.dias,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_estado=v_parametros.id_estado;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Estado modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_estado',v_parametros.id_estado::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'SA_ESTAD_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 09:35:55
	***********************************/

	elsif(p_transaccion='SA_ESTAD_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from saj.testado
            where id_estado=v_parametros.id_estado;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Estado eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_estado',v_parametros.id_estado::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION saj.f_testado_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1139 (class 1255 OID 2287741)
-- Dependencies: 91 2435
-- Name: f_testado_proceso_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: mflores
--

CREATE FUNCTION f_testado_proceso_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_testado_proceso_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'saj.testado_proceso'
 AUTOR: 		(mflores)
 FECHA:	        13-12-2011 18:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'saj.f_testado_proceso_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'AJ_ESTPRO_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			mflores	
 	#FECHA:			13-12-2011 18:30
	***********************************/

	if(p_transaccion='AJ_ESTPRO_SEL')then
    
    	begin
    		--Sentencia de la consulta
			v_consulta:='select estpro.id_estado_proceso,
                                 estpro.id_proceso_contrato,
                                 estpro.observaciones,
                                 estpro.fecha_ini,
                                 COALESCE(pers.nombre || '' '' || pers.apellido_paterno || '' '' || pers.apellido_materno) as responsable,
                                 estpro.fecha_fin,
                                 est.nombre as vigente,
                                 --est1.nombre as anterior,
                                 estpro.estado_reg,
                                 estpro.fecha_reg,
                                 estpro.id_usuario_reg,
                                 estpro.fecha_mod,
                                 estpro.id_usuario_mod,
                                 usu1.cuenta as usr_reg,
                                 usu2.cuenta as usr_mod
                          from saj.testado_proceso estpro
                          left join saj.testado est
                          on est.codigo = estpro.estado_vigente
                          --left join saj.testado est1
                          --on est1.codigo = estpro.estado_anterior
                          left join saj.tresponsable_proceso resp
                          on estpro.id_responsable_proceso = resp.id_responsable_proceso
                          left join rhum.tfuncionario func
                          on resp.id_funcionario = func.id_funcionario
                          left join segu.tpersona pers
                          on func.id_persona = pers.id_persona
                          inner join segu.tusuario usu1 on usu1.id_usuario = estpro.id_usuario_reg
                          left join segu.tusuario usu2 on usu2.id_usuario = estpro.id_usuario_mod
                          where ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion; -- || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            
            raise notice 'consulta: %',v_consulta;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'AJ_ESTPRO_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:			mflores	
 	#FECHA:			13-12-2011 18:40
	***********************************/

	elsif(p_transaccion='AJ_ESTPRO_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_estado_proceso)
					    from saj.testado_proceso estpro                        
						inner join segu.tusuario usu1 on usu1.id_usuario = estpro.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = estpro.id_usuario_mod
				        where estpro.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
        
    /*********************************    
 	#TRANSACCION:  'AJ_EPDET_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			mflores	
 	#FECHA:			13-01-2011 15:53
	***********************************/

	elsif(p_transaccion='AJ_EPDET_SEL')then
    
    	begin
    		--Sentencia de la consulta
			v_consulta:='select est.nombre as vigente,
                          estad.nombre as anterior,
                          estcon.observaciones,
                          estcon.fecha_ini,
                          estcon.fecha_fin
                          from saj.testado_proceso estcon
                          left join saj.testado est
                          on est.codigo = estcon.estado_vigente
                          left join saj.testado estad
                          on estad.codigo = estcon.estado_anterior
                          where ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion;
            
            raise notice 'consulta: %',v_consulta;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'AJ_EPDET_CONT'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			mflores	
 	#FECHA:			13-01-2011 17:00
	***********************************/

	elsif(p_transaccion='AJ_EPDET_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_estado_proceso)
			 			  from saj.testado_proceso estcon
                          left join saj.testado est
                          on est.codigo = estcon.estado_vigente
                          left join saj.testado estad
                          on estad.codigo = estcon.estado_anterior
                          where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION saj.f_testado_proceso_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO mflores;

--
-- TOC entry 1154 (class 1255 OID 1993277)
-- Dependencies: 2435 91
-- Name: f_testado_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: postgres
--

CREATE FUNCTION f_testado_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_testado_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'saj.testado'
 AUTOR: 		 (fprudencio)
 FECHA:	        17-11-2011 09:35:55
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'saj.f_testado_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SA_ESTAD_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 09:35:55
	***********************************/

	if(p_transaccion='SA_ESTAD_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						estad.id_estado,
						estad.estado_reg,
						estad.admite_boleta,
						estad.orden,
						estad.codigo,
						estad.admite_anexo,
						estad.nombre,
						estad.dias,
						estad.id_usuario_reg,
						estad.fecha_reg,
						estad.id_usuario_mod,
						estad.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from saj.testado estad
						inner join segu.tusuario usu1 on usu1.id_usuario = estad.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = estad.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			raise notice 'consulta: %',v_consulta;
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'SA_ESTAD_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 09:35:55
	***********************************/

	elsif(p_transaccion='SA_ESTAD_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_estado)
					    from saj.testado estad
					    inner join segu.tusuario usu1 on usu1.id_usuario = estad.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = estad.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION saj.f_testado_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1126 (class 1255 OID 1954714)
-- Dependencies: 91 2435
-- Name: f_tmodalidad_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: postgres
--

CREATE FUNCTION f_tmodalidad_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_tmodalidad_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'saj.tmodalidad'
 AUTOR: 		 (mzm)
 FECHA:	        11-11-2011 15:23:06
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
    v_parametros               record;
    v_id_requerimiento         integer;
    v_resp                    varchar;
    v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_modalidad    integer;
                
BEGIN

    v_nombre_funcion = 'saj.f_tmodalidad_ime';
    v_parametros = f_get_record(p_tabla);

    /*********************************    
     #TRANSACCION:  'SAJ_MODALI_INS'
     #DESCRIPCION:    Insercion de registros
     #AUTOR:        mzm    
     #FECHA:        11-11-2011 15:23:06
    ***********************************/

    if(p_transaccion='SAJ_MODALI_INS')then
                    
        begin
            --Sentencia de la insercion
            insert into saj.tmodalidad(
            nombre,
            estado_reg,
            id_usuario_reg,
            fecha_reg,
            id_usuario_mod,
            fecha_mod
              ) values(
            v_parametros.nombre,
            'activo',
            p_id_usuario,
            now(),
            null,
            null
            )RETURNING id_modalidad into v_id_modalidad;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Modalidad almacenado(a) con exito (id_modalidad'||v_id_modalidad||')'); 
            v_resp = f_agrega_clave(v_resp,'id_modalidad',v_id_modalidad::varchar);

            --Devuelve la respuesta
            return v_resp;

        end;

    /*********************************    
     #TRANSACCION:  'SAJ_MODALI_MOD'
     #DESCRIPCION:    Modificacion de registros
     #AUTOR:        mzm    
     #FECHA:        11-11-2011 15:23:06
    ***********************************/

    elsif(p_transaccion='SAJ_MODALI_MOD')then

        begin
            --Sentencia de la modificacion
            update saj.tmodalidad set
            nombre = v_parametros.nombre,
            id_usuario_mod = p_id_usuario,
            fecha_mod = now()
            where id_modalidad=v_parametros.id_modalidad;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Modalidad modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_modalidad',v_parametros.id_modalidad::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end;

    /*********************************    
     #TRANSACCION:  'SAJ_MODALI_ELI'
     #DESCRIPCION:    Eliminacion de registros
     #AUTOR:        mzm    
     #FECHA:        11-11-2011 15:23:06
    ***********************************/

    elsif(p_transaccion='SAJ_MODALI_ELI')then

        begin
            --Sentencia de la eliminacion
            delete from saj.tmodalidad
            where id_modalidad=v_parametros.id_modalidad;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Modalidad eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_modalidad',v_parametros.id_modalidad::varchar);
              
            --Devuelve la respuesta
            return v_resp;

        end;
         
    else
     
        raise exception 'Transaccion inexistente: %',p_transaccion;

    end if;

EXCEPTION
                
    WHEN OTHERS THEN
        v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
        raise exception '%',v_resp;
                        
END;
$$;


ALTER FUNCTION saj.f_tmodalidad_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 261 (class 1255 OID 1954715)
-- Dependencies: 2435 91
-- Name: f_tmodalidad_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: postgres
--

CREATE FUNCTION f_tmodalidad_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_tmodalidad_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'saj.tmodalidad'
 AUTOR: 		 (mzm)
 FECHA:	        11-11-2011 15:23:06
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'saj.f_tmodalidad_sel';
    v_parametros = f_get_record(p_tabla);

    /*********************************    
     #TRANSACCION:  'SAJ_MODALI_SEL'
     #DESCRIPCION:    Consulta de datos
     #AUTOR:        mzm    
     #FECHA:        11-11-2011 15:23:06
    ***********************************/

    if(p_transaccion='SAJ_MODALI_SEL')then
                     
        begin
            --Sentencia de la consulta
            v_consulta:='select
                        modal.id_modalidad,
                        modal.nombre,
                        modal.estado_reg,
                        modal.id_usuario_reg,
                        modal.fecha_reg,
                        modal.id_usuario_mod,
                        modal.fecha_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod    
                        from saj.tmodalidad modal
                        inner join segu.tusuario usu1 on usu1.id_usuario = modal.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = modal.id_usuario_mod
                        where  ';
            
            --Definicion de la respuesta
            v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			raise notice 'consulta: %',v_consulta;
            --Devuelve la respuesta
            return v_consulta;
                        
        end;

    /*********************************    
     #TRANSACCION:  'SAJ_MODALI_CONT'
     #DESCRIPCION:    Conteo de registros
     #AUTOR:        mzm    
     #FECHA:        11-11-2011 15:23:06
    ***********************************/

    elsif(p_transaccion='SAJ_MODALI_CONT')then

        begin
            --Sentencia de la consulta de conteo de registros
            v_consulta:='select count(id_modalidad)
                        from saj.tmodalidad modal
                        inner join segu.tusuario usu1 on usu1.id_usuario = modal.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = modal.id_usuario_mod
                        where ';
            
            --Definicion de la respuesta            
            v_consulta:=v_consulta||v_parametros.filtro;

            --Devuelve la respuesta
            return v_consulta;

        end;
                    
    else
                         
        raise exception 'Transaccion inexistente';
                             
    end if;
                    
EXCEPTION
                    
    WHEN OTHERS THEN
            v_resp='';
            v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
            v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
            v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
            raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION saj.f_tmodalidad_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1147 (class 1255 OID 1988515)
-- Dependencies: 91 2435
-- Name: f_tproceso_contrato_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: postgres
--

CREATE FUNCTION f_tproceso_contrato_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_tproceso_contrato_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'saj.tproceso_contrato'
 AUTOR: 		 (mzm)
 FECHA:	        16-11-2011 17:25:24
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_proceso_contrato	integer;
	v_reg_estado_proceso    varchar;	
    v_accion                varchar; 
    v_num_req				varchar; 
    v_id_gestion 			integer;   
    v_id_abogado 			integer; 
    v_id_rep_legal 			integer; 
    v_id_alarmas integer[];        	    
BEGIN

    v_nombre_funcion = 'saj.f_tproceso_contrato_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SA_CONTRA_INS'
 	#DESCRIPCION:	Insercion de requerimeinto de contratos en estado borrador
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 17:25:24
   	#AUTOR_MOD:		mzm	
 	#DESCRIPCION_MOD:	obtiene numero de contrato
 	#FECHA_MOD:		1-12-2011 

	***********************************/

	if(p_transaccion='SA_CONTRA_INS')then
					
        begin 
        
        --0) Obtener numero de requerimiento en funcion del depto de legal
         v_num_req =  param.f_obtener_correlativo('RSAJ',NULL,NULL,v_parametros.id_depto,p_id_usuario,'SAJ',NULL);
                --raise exception 'aa%',v_num_req;
        --1)obtiene el identificador de la gestion 
        
         select g.id_gestion
         into v_id_gestion
         from param.tgestion g
         where g.estado_reg='activo' and g.gestion=to_char(now()::date,'YYYY')::integer;
          
        --2) obetner el reprsentante legal vigente   
        
        SELECT id_responsable_proceso
          into v_id_rep_legal  
        FROM  saj.tresponsable_proceso rp
        WHERE rp.estado_reg='activo' and rp.tipo ='rep_legal'
        LIMIT 1 OFFSET 0;
        

         
        --3) insertar solicitud de requerimietno en estado borrador
        	--Sentencia de la insercion
        	insert into saj.tproceso_contrato(
			--notario,
			--numero_oc,
			fecha_convocatoria,
			numero_requerimiento,
			--multas,
			id_modalidad,
			--fecha_aprobacion,
			fecha_fin,
			plazo,
			objeto_contrato,
			id_depto,
			--extension,
			--id_proyecto,
			forma_pago,
			--id_lugar_suscripcion,
			numero_cuce,
			--fecha_suscripcion,
			--testimonio,
			--monto_contrato,
			--numero_contrato,
			id_rpc,
			--id_alarma,
			--observaciones,
			id_proveedor,
			--origen_recursos,
			id_uo,
			id_representante_legal,
			id_tipo_contrato,
			--fecha_testimonio,
			--doc_contrato,
			id_supervisor,
			--beneficiario,
			--version,
			id_gestion,
			fecha_ini,
			--fecha_ap_acta,
			--id_oc,
			id_funcionario,
			id_moneda ,
            monto_contrato,
            id_usuario_reg,
			numero_licitacion
          	) values(
			--v_parametros.notario,
			--v_parametros.numero_oc,
			v_parametros.fecha_convocatoria,
			v_num_req,
			--v_parametros.multas,
			v_parametros.id_modalidad,
			--v_parametros.fecha_aprobacion,
			v_parametros.fecha_fin,
			v_parametros.plazo,
			v_parametros.objeto_contrato,
			v_parametros.id_depto,
			--v_parametros.extension,
			--v_parametros.id_proyecto,
			v_parametros.forma_pago,
			--v_parametros.id_lugar_suscripcion,
			v_parametros.numero_cuce,
			--v_parametros.fecha_suscripcion,
			--v_parametros.testimonio,
			--v_parametros.monto_contrato,
			--v_parametros.numero_contrato,
			v_parametros.id_rpc,
		--	v_parametros.id_alarma,
			--v_parametros.observaciones,
			v_parametros.id_proveedor,
			--v_parametros.origen_recursos,
			v_parametros.id_uo,
			v_id_rep_legal,
			v_parametros.id_tipo_contrato,
			--v_parametros.fecha_testimonio,
			--v_parametros.doc_contrato,
			v_parametros.id_supervisor,
			--v_parametros.beneficiario,
			--v_parametros.version,
			v_id_gestion,
			v_parametros.fecha_ini,
			--v_parametros.fecha_ap_acta,
			--v_parametros.id_oc,
			v_parametros.id_funcionario,
			v_parametros.id_moneda,
            v_parametros.monto_contrato,
            p_id_usuario,
			v_parametros.numero_licitacion
			)RETURNING id_proceso_contrato into v_id_proceso_contrato;
               
            
            --4) inserta el estado correpondiente al proceso es este caso el inicial
            raise notice 'actualiza el estado';
            v_reg_estado_proceso:=saj.f_manejo_estado_proceso(v_id_proceso_contrato,'siguiente','formulacion de requerimiento',p_id_usuario,null);
            
            
            if(v_reg_estado_proceso!='exito') then                 
	            raise exception 'Error con registro en estado proceso para id_proceso_contrato %', v_id_proceso_contrato;            
            end if;
            
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Proceso de Contratacion almacenado(a) con exito (id_proceso_contrato'||v_id_proceso_contrato||')'); 
            v_resp = f_agrega_clave(v_resp,'id_proceso_contrato',v_id_proceso_contrato::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'SA_CONTRA_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 17:25:24
	***********************************/

	elsif(p_transaccion='SA_CONTRA_MOD')then

		begin
			--Sentencia de la modificacion     
            
            if(public.f_existe_parametro(p_tabla,'operacion')) then      
              

              -- identificar el jefe de abogados vigente al entra al estado de asignacion
              --en otros casos agarra el id_abogado
              
              if(v_parametros.operacion!='anterior') then
                 v_accion:='siguiente';
              else            
                 v_accion:=v_parametros.operacion;
              end if;

            --operacion identifica al estado que se debe cambiar el proceso contrato       
            
            
              v_reg_estado_proceso:=saj.f_manejo_estado_proceso(v_parametros.id_proceso_contrato,v_accion,
              'cambio de estado a:'|| v_parametros.operacion,p_id_usuario,
              null);
              
              if(v_reg_estado_proceso!='exito') then
                 raise exception 'Problema con modificacion a registro';
              end if;
            
            else
            
            --raise exception 'xxxx';
               update saj.tproceso_contrato set
			        --  notario = v_parametros.notario,
			        --  numero_oc = v_parametros.numero_oc,
			          fecha_convocatoria = v_parametros.fecha_convocatoria,
			        --  numero_requerimiento = v_parametros.numero_requerimiento,
                    --  multas = v_parametros.multas,
                      id_modalidad = v_parametros.id_modalidad,
                    --  fecha_aprobacion = v_parametros.fecha_aprobacion,
                      fecha_fin = v_parametros.fecha_fin,
                      plazo = v_parametros.plazo,
                      objeto_contrato = v_parametros.objeto_contrato,
                      id_depto = v_parametros.id_depto,
                    --  extension = v_parametros.extension,
                    --  id_proyecto = v_parametros.id_proyecto,
                      forma_pago = v_parametros.forma_pago,
                    --  id_lugar_suscripcion = v_parametros.id_lugar_suscripcion,
                      numero_cuce = v_parametros.numero_cuce,
                    --  fecha_suscripcion = v_parametros.fecha_suscripcion,
                    --  testimonio = v_parametros.testimonio,
                      monto_contrato = v_parametros.monto_contrato,
                     -- numero_contrato = v_parametros.numero_contrato,
                      id_rpc = v_parametros.id_rpc,
                    --  id_alarma = v_parametros.id_alarma,
                   --   observaciones = v_parametros.observaciones,
                      id_proveedor = v_parametros.id_proveedor,
                    --  origen_recursos = v_parametros.origen_recursos,
                      id_uo = v_parametros.id_uo,
                     -- id_representante_legal = v_parametros.id_representante_legal,
                      id_tipo_contrato = v_parametros.id_tipo_contrato,
                    --  fecha_testimonio = v_parametros.fecha_testimonio,
                    --  doc_contrato = v_parametros.doc_contrato,
                      id_supervisor = v_parametros.id_supervisor,
                     -- beneficiario = v_parametros.beneficiario,
                     -- version = v_parametros.version,
                     -- id_gestion = v_parametros.id_gestion,
                      fecha_ini = v_parametros.fecha_ini,
                     -- fecha_ap_acta = v_parametros.fecha_ap_acta,
                     -- id_oc = v_parametros.id_oc,
                      id_funcionario = v_parametros.id_funcionario,
                      id_moneda = v_parametros.id_moneda,
                      numero_licitacion = v_parametros.numero_licitacion,
                       id_usuario_mod = p_id_usuario,
                       fecha_mod = now()
                      where id_proceso_contrato=v_parametros.id_proceso_contrato;
               end if;
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proceso de Contratacion modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proceso_contrato',v_parametros.id_proceso_contrato::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end;
        
    /*********************************    
 	#TRANSACCION:  'SA_CAMEST_MOD'
 	#DESCRIPCION:	Cambia estados del proceso contrato
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 17:25:24
	***********************************/

	elsif(p_transaccion='SA_CAMEST_MOD')then

		begin
			-- identificar el jefe de abogados vigente al entra al estado de asignacion
              --en otros casos agarra el id_abogado
              
              if(v_parametros.operacion!='anterior') then
                 v_accion:='siguiente';
              else            
                 v_accion:=v_parametros.operacion;
              end if;
              
              
              
              IF(public.f_existe_parametro(p_tabla,'id_abogado')) then      
                   v_id_abogado=v_parametros.id_abogado;
              ELSE
	              v_id_abogado = NULL;
              END IF;
              
              --operacion identifica al estado que se debe cambiar el proceso contrato       
              v_reg_estado_proceso:=saj.f_manejo_estado_proceso(v_parametros.id_proceso_contrato,v_accion,
              'cambio de estado a:'|| v_parametros.operacion,p_id_usuario,
              v_id_abogado);
              
              if(v_reg_estado_proceso!='exito') then
                 raise exception 'Problema con el cambio de estado del proceso';
              end if;
            
            
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proceso de Contratacion modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proceso_contrato',v_parametros.id_proceso_contrato::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end; 
        
        
	/*********************************    
 	#TRANSACCION:  'SA_CONELA_MOD'
 	#DESCRIPCION:	Modificacionde contratos en elaboración
 	#AUTOR:		rac	
 	#FECHA:		20-12-2011 17:25:24
	***********************************/
        
        elsif(p_transaccion='SA_CONELA_MOD')then

		begin
			--Sentencia de la modificacion     
            
           
               update saj.tproceso_contrato set
			          notario = v_parametros.notario,
			          --numero_oc = v_parametros.numero_oc,
			          fecha_convocatoria = v_parametros.fecha_convocatoria,
			        --  numero_requerimiento = v_parametros.numero_requerimiento,
                    --  multas = v_parametros.multas,
                      id_modalidad = v_parametros.id_modalidad,
                    --  fecha_aprobacion = v_parametros.fecha_aprobacion,
                      fecha_fin = v_parametros.fecha_fin,
                      plazo = v_parametros.plazo,
                      objeto_contrato = v_parametros.objeto_contrato,
                    --  id_depto = v_parametros.id_depto,
                    --  extension = v_parametros.extension,
                    --  id_proyecto = v_parametros.id_proyecto,
                      forma_pago = v_parametros.forma_pago,
                    --  id_lugar_suscripcion = v_parametros.id_lugar_suscripcion,
                      numero_cuce = v_parametros.numero_cuce,
                      fecha_suscripcion = v_parametros.fecha_suscripcion,
                    --  testimonio = v_parametros.testimonio,
                      monto_contrato = v_parametros.monto_contrato,
                      numero_contrato = v_parametros.numero_contrato,
                      id_rpc = v_parametros.id_rpc,
                    --  id_alarma = v_parametros.id_alarma,
                      observaciones = v_parametros.observaciones,
                      id_proveedor = v_parametros.id_proveedor,
                    --  origen_recursos = v_parametros.origen_recursos,
                    --  id_uo = v_parametros.id_uo,
                      id_representante_legal = v_parametros.id_representante_legal,
                      id_tipo_contrato = v_parametros.id_tipo_contrato,
                    --  fecha_testimonio = v_parametros.fecha_testimonio,
                    --  doc_contrato = v_parametros.doc_contrato,
                      id_supervisor = v_parametros.id_supervisor,
                     -- beneficiario = v_parametros.beneficiario,
                     -- version = v_parametros.version,
                     -- id_gestion = v_parametros.id_gestion,
                      fecha_ini = v_parametros.fecha_ini,
                     -- fecha_ap_acta = v_parametros.fecha_ap_acta,
                     -- id_oc = v_parametros.id_oc,
                    -- id_funcionario = v_parametros.id_funcionario,
                      id_moneda = v_parametros.id_moneda,
                      numero_licitacion = v_parametros.numero_licitacion,
                       id_usuario_mod = p_id_usuario,
                        fecha_mod = now()::date
                      where id_proceso_contrato=v_parametros.id_proceso_contrato;
             
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proceso de Contratacion modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proceso_contrato',v_parametros.id_proceso_contrato::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end; 
        
        
     
     /*********************************    
 	#TRANSACCION:  'SA_ARCHCON_MOD'
 	#DESCRIPCION:	Actualiza datos del archivo escaneado
 	#AUTOR:		rac	
 	#FECHA:		16-12-2011 17:25:24
	***********************************/

	elsif(p_transaccion='SA_ARCHCON_MOD')then

		begin
        
        --raise exception 'VERSION %',v_parametros.version;
          
           update saj.tproceso_contrato set
           extension = v_parametros.extension,
           doc_contrato = v_parametros.doc_contrato,
           version = v_parametros.version,
           id_usuario_mod = p_id_usuario,
           fecha_mod = now()
           where id_proceso_contrato=v_parametros.id_proceso_contrato;
            
            --Definicion de la respuesta
           v_resp = f_agrega_clave(v_resp,'mensaje','Archivo escaneado de contrato modificado(a)'); 
           v_resp = f_agrega_clave(v_resp,'id_proceso_contrato',v_parametros.id_proceso_contrato::varchar);
               
            --Devuelve la respuesta
           return v_resp;
            
        end; 
  
        
    /*********************************    
 	#TRANSACCION:  'SA_CONASIG_MOD'
 	#DESCRIPCION:	Modificacion de contratos desde la pantalla de asignacion
 	#AUTOR:		rac	
 	#FECHA:		13-12-2011 17:25:24
	***********************************/

	elsif(p_transaccion='SA_CONASIG_MOD')then

		begin
			--Sentencia de la modificacion   
            
            --raise exception 'v_parametros.numero_contrato %',v_parametros.numero_contrato;  
           
                   update saj.tproceso_contrato set
			          notario = v_parametros.notario,
			        --  numero_oc = v_parametros.numero_oc,
			          fecha_convocatoria = v_parametros.fecha_convocatoria,
			        --  numero_requerimiento = v_parametros.numero_requerimiento,
                    --  multas = v_parametros.multas,
                      id_modalidad = v_parametros.id_modalidad,
                    --  fecha_aprobacion = v_parametros.fecha_aprobacion,
                      fecha_fin = v_parametros.fecha_fin,
                      plazo = v_parametros.plazo,
                    --  objeto_contrato = v_parametros.objeto_contrato,
                    --  id_depto = v_parametros.id_depto,
                    --  extension = v_parametros.extension,
                    --  id_proyecto = v_parametros.id_proyecto,
                      forma_pago = v_parametros.forma_pago,
                    --  id_lugar_suscripcion = v_parametros.id_lugar_suscripcion,
                      numero_cuce = v_parametros.numero_cuce,
                     fecha_suscripcion = v_parametros.fecha_suscripcion,
                    --  testimonio = v_parametros.testimonio,
                      monto_contrato = v_parametros.monto_contrato,
                      numero_contrato = v_parametros.numero_contrato,
                      id_rpc = v_parametros.id_rpc,
                    --  id_alarma = v_parametros.id_alarma,
                      observaciones = v_parametros.observaciones,
                      id_proveedor = v_parametros.id_proveedor,
                    --  origen_recursos = v_parametros.origen_recursos,
                    --  id_uo = v_parametros.id_uo,
                     -- id_representante_legal = v_parametros.id_representante_legal,
                      id_tipo_contrato = v_parametros.id_tipo_contrato,
                    --  fecha_testimonio = v_parametros.fecha_testimonio,
                    --  doc_contrato = v_parametros.doc_contrato,
                      id_supervisor = v_parametros.id_supervisor,
                     -- beneficiario = v_parametros.beneficiario,
                     -- version = v_parametros.version,
                     -- id_gestion = v_parametros.id_gestion,
                      fecha_ini = v_parametros.fecha_ini,
                     -- fecha_ap_acta = v_parametros.fecha_ap_acta,
                     -- id_oc = v_parametros.id_oc,
                     -- id_funcionario = v_parametros.id_funcionario,
                      id_moneda = v_parametros.id_moneda,
                      numero_licitacion = v_parametros.numero_licitacion,
                       id_usuario_mod = p_id_usuario,
                       fecha_mod = now()
                      where id_proceso_contrato=v_parametros.id_proceso_contrato;
            
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proceso de Contratacion modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proceso_contrato',v_parametros.id_proceso_contrato::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
          end; 
        

    /*********************************    
     #TRANSACCION:  'SA_CONTRA_ELI'
     #DESCRIPCION:    Eliminacion de registros
     #AUTOR:        mzm    
     #FECHA:        16-11-2011 17:25:24
    ***********************************/

    elsif(p_transaccion='SA_CONTRA_ELI')then

        begin               
            
             v_reg_estado_proceso:=saj.f_manejo_estado_proceso(v_parametros.id_proceso_contrato,'ANULADO','anulacion de proceso contrato',p_id_usuario,null);
              
            if(v_reg_estado_proceso!='exito') then
                 raise exception 'Error con anulacion de proceso';
            end if;
            
            --verifica si el contrato tiene alarmas
            
             select pc.id_alarma into v_id_alarmas 
             from saj.tproceso_contrato pc
             where pc.id_proceso_contrato=v_parametros.id_proceso_contrato;
                           
             update param.talarma set
             tipo ='notificacion',
             fecha = now(),
             descripcion ='El contrato fue Eliminado ['||descripcion||']',
             id_usuario_mod = p_id_usuario,
             fecha_mod = now()
             where id_alarma = ANY (v_id_alarmas);
           
        
              
            --Sentencia de la eliminacion
            update saj.tproceso_contrato
            set estado_reg='inactivo',
            fecha_mod=now(),
            id_alarma = NULL,
            id_usuario_mod=p_id_usuario
            where id_proceso_contrato=v_parametros.id_proceso_contrato;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proceso de Contratacion eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proceso_contrato',v_parametros.id_proceso_contrato::varchar);
              
            --Devuelve la respuesta
            return v_resp;

        end;
         
    else
     
        raise exception 'Transaccion inexistente: %',p_transaccion;

    end if;

EXCEPTION
                
    WHEN OTHERS THEN
        v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
        raise exception '%',v_resp;
                        
END;
$$;


ALTER FUNCTION saj.f_tproceso_contrato_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1150 (class 1255 OID 1988514)
-- Dependencies: 91 2435
-- Name: f_tproceso_contrato_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: postgres
--

CREATE FUNCTION f_tproceso_contrato_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_tproceso_contrato_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'saj.tproceso_contrato'
 AUTOR: 		 (mzm)
 FECHA:	        16-11-2011 17:25:24
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_filtro            varchar;
    v_criterio_join     varchar;
    v_id_responsable integer;
    v_id_funcionario integer;
    v_id_responsable_proceso integer;
    v_id_supervidor integer;
    v_id_rpc integer;
			    
BEGIN

	v_nombre_funcion = 'saj.f_tproceso_contrato_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SA_CONTRA_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 17:25:24
	***********************************/

	if(p_transaccion='SA_CONTRA_SEL')then
     				
    	begin
             v_criterio_join ='LEFT JOIN';
            
             
             IF(public.f_existe_parametro(p_tabla,'tipo_interfaz')) then
             
             
               
                     IF(v_parametros.tipo_interfaz='REQUER')THEN
                     --si es la interface de requerimiento se linstan los procesos en todos los
                     --estados 
                     
                    
                           
                           IF(public.f_existe_parametro(p_tabla,'id_funcionario') ) then
                               
                                     IF p_administrador =1 THEN
                                     
                                      v_filtro=' and 0=0 ';
                                     
                                     ELSEIF(v_parametros.id_funcionario is not null) then 
                                     v_filtro = ' and (contra.id_usuario_reg= '||p_id_usuario||' 
                                                  or contra.id_funcionario = '||v_parametros.id_funcionario::varchar||')  ';
                                     ELSE 
                                     raise exception 'el usuario no tiene funcionario relacionado (Registre al usuario como funcionario en el sistema de recursos humanos)';
                                     END IF;
                            END IF;
                     END IF;
                 
                     IF (v_parametros.tipo_interfaz='FINREQ') THEN
                        v_filtro:=' and (estpro.estado_vigente=''FINREQ'' or estpro.estado_vigente=''ASIGNA'')';
                     END IF;
               
               
                     IF (v_parametros.tipo_interfaz='ELABORACION') THEN
                           --raise exception 'LLEGA';
                   
                           v_criterio_join ='LEFT JOIN';
                           
                           IF p_administrador =1 THEN
                             v_filtro:=' and (estpro.estado_vigente in (''ASIGNA'',''BORCON'',''REVCON'',''REGCON''))';
                           ELSEIF(v_parametros.id_funcionario is not null ) then 
                         
                               select id_responsable_proceso
                                 into v_id_responsable
                               from saj.tresponsable_proceso rp
                               where rp.id_funcionario = v_parametros.id_funcionario::integer;
                                 v_filtro:=' and (estpro.estado_vigente in (''ASIGNA'',''BORCON'',''REVCON'',''REGCON'',''FINCON'') 
                                                   and abogado.id_responsable_proceso='||v_id_responsable::varchar||')';
                         
                           ELSE 
                                         raise exception 'el usuario no tiene funcionario relacionado';
                           END IF;
                     END IF;
            
             
                IF (v_parametros.tipo_interfaz='CONCLUIDO') THEN
                      v_filtro:=' and (estpro.estado_vigente=''FINCON'')';
                 END IF;
           
                 IF (v_parametros.tipo_interfaz='VIGENTE') THEN
                        v_filtro:=' and (estpro.estado_vigente=''REGCON'')';
                 END IF;
             
                 IF (v_parametros.tipo_interfaz='ADMIN') THEN
                        v_filtro:=' and (estpro.estado_vigente!=''REQUER'')';
                 END IF;
                 
                 
                 
                 IF (v_parametros.tipo_interfaz='BUSQUEDA') THEN
                 
                 
                    --TIPO FILTRO
                    IF(public.f_existe_parametro(p_tabla,'tipoFiltro') ) then 
                    
                     
                     --raise exception 'tipoFiltro = %',v_parametros.tipoFiltro;
                    
                     
                                 --SI TIPO FILTRO ESTA HABILITADO ACCEDE DESDE ALARMAS
                                 --puede ver todos los estados pero hace un filtro por el tipo 
                                 --de usuario  que revisa: solicitante, rpc, supervidor
                               IF(v_parametros.tipoFiltro!='solicitante')THEN
                              
                                         Select 
                                            r.id_responsable_proceso
                                         into 
                                           v_id_responsable_proceso
                                         from saj.tresponsable_proceso r
                                         where r.id_funcionario = v_parametros.id_funcionario 
                                         and r.estado_reg='activo' and r.tipo = v_parametros.tipoFiltro;
                                     
                               ELSEIF(v_parametros.id_funcionario is  null ) then 
                                    
                                    raise exception 'el usuario no tiene funcionario relacionado';
                               
                               END IF;
                          
                              IF (v_parametros.tipoFiltro='solicitante') THEN
                              
                                     v_filtro:=' and (contra.id_funcionario='||COALESCE(v_parametros.id_funcionario,0)||')';
                                
                              ELSEIF (v_parametros.tipoFiltro='rpc') THEN
                              
                                    v_filtro:=' and (contra.id_rpc='||COALESCE(v_id_responsable_proceso,0)||')';
                                
                                
                              ELSEIF (v_parametros.tipoFiltro='supervidor') THEN
                          
                                    v_filtro:=' and (contra.id_supervisor='||COALESCE(v_id_responsable_proceso,0)||')';
                            
                              ELSE
                                    v_filtro=' and 0=0 ';
                              END IF;
                   ELSE
                      --SIN TIPO FILTRO ACCEDE DIRECTO
                               --raise exception 'XXXXXXXX    11111111';
                               
                               Select 
                                  r.id_responsable_proceso
                               into 
                                 v_id_rpc                                 
                               from saj.tresponsable_proceso r
                               where r.id_funcionario::integer = v_parametros.id_funcionario::integer 
                               and r.estado_reg::varchar='activo' and r.tipo::varchar = 'rpc';
                               
                               
                               --raise notice 'zz  22222222';
                               
                               Select 
                                  r.id_responsable_proceso
                               into 
                                 v_id_supervidor
                               from saj.tresponsable_proceso r
                               where r.id_funcionario = v_parametros.id_funcionario::integer 
                               and r.estado_reg::Varchar='activo' and r.tipo::varchar = 'supervisor';
                              
                              
                              --raise notice '33333333333333';
                              
                              
                              
                          IF(p_administrador=1) then 
                          
                               v_filtro=' and 0=0 ';
                          
                          ELSE
                          
                                IF(v_parametros.id_funcionario is  null ) then 
                                  
                                  raise exception 'el usuario no tiene funcionario relacionado';
                               
                               ELSE
                                   --mflores: revisar el filtro para las busquedas porque no lista nada para el rol SAJ - abogado                  
                                 v_filtro:=' and (contra.id_supervisor='||COALESCE(v_id_supervidor,0)::varchar||' OR contra.id_rpc='||COALESCE(v_id_rpc,0)::varchar||' OR contra.id_funcionario='||COALESCE(v_parametros.id_funcionario,0)::varchar||')';
                               
                               END IF; 
                          
                          END IF;
                        
                          --raise exception 'v_filtro: %', v_filtro; --and (contra.id_supervisor=0 OR contra.id_rpc=0 OR contra.id_funcionario=518
                                                     --raise notice '5555555555'; 
                          
                   END IF;    
               END IF;
                 
              else
                     v_filtro=' and 0=0 ';
              end if;    
                 
        
    		--Sentencia de la consulta
			v_consulta:='select
						contra.id_proceso_contrato,
						contra.notario,
						contra.numero_oc,
						contra.fecha_convocatoria,
						contra.numero_requerimiento,
						contra.multas,
						contra.id_modalidad,
						contra.fecha_aprobacion,
						contra.fecha_fin,
						contra.plazo,
						contra.objeto_contrato,
						contra.id_depto,
						contra.extension,
						contra.id_proyecto,
						contra.forma_pago,
						contra.id_lugar_suscripcion,
						contra.numero_cuce,
						contra.fecha_suscripcion,
						contra.testimonio,
						contra.monto_contrato,
						contra.numero_contrato,
						contra.id_rpc,
						--contra.id_alarma,
						contra.observaciones,
						contra.id_proveedor,
						contra.origen_recursos,
						contra.id_uo,
						contra.id_representante_legal,
						contra.id_tipo_contrato,
						contra.fecha_testimonio,
						contra.doc_contrato,
						contra.id_supervisor,
						contra.beneficiario,
						contra.version,
						contra.id_gestion,
						contra.fecha_ini,
						contra.fecha_ap_acta,
						contra.id_oc,
						contra.id_funcionario,
						contra.id_moneda,
						contra.numero_licitacion,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	,
                        
                        modali.nombre as desc_modalidad,
                        depto.nombre as desc_depto,
                        rpc.desc_responsable_proceso as desc_rpc,
                        provee.desc_proveedor,
                        uo.nombre_unidad as desc_uo,
                        rep_legal.desc_responsable_proceso as desc_rep_legal,
                        tipcon.nombre as desc_tipo_contrato,
                        superv.desc_responsable_proceso as desc_supervisor,
                        gestio.gestion as desc_gestion ,
                        funcio.desc_funcionario1::varchar as desc_funcionario,
                        moneda.moneda as desc_moneda,
                        --alarma.descripcion as desc_alarma,
                        proyec.nombre_proyecto as desc_proyecto,
                        lugar.nombre as desc_lugar,
                        est.nombre as nombre_estado,
                        contra.estado_proceso,
                        abogado.id_responsable_proceso as id_abogado,
                        abogado.desc_responsable_proceso as abogado,
                        contra.fecha_reg,
                        contra.fecha_mod,
                        contra.estado_reg
                            
					from saj.tproceso_contrato contra
                        inner join saj.testado_proceso estpro 
                          on estpro.id_proceso_contrato=contra.id_proceso_contrato 
                          and estpro.estado_reg=''activo''
                        inner join saj.testado est on est.codigo = estpro.estado_vigente
						inner join rhum.vfuncionario funcio on funcio.id_funcionario=contra.id_funcionario
                        inner join segu.tusuario usu1 on usu1.id_usuario = contra.id_usuario_reg
						inner join param.tdepto depto on depto.id_depto=contra.id_depto --inner
                        inner join rhum.tuo uo on uo.id_uo=contra.id_uo
						INNER join param.tgestion gestio on gestio.id_gestion=contra.id_gestion           
                        INNER join param.tmoneda moneda on moneda.id_moneda=contra.id_moneda
                        INNER join saj.ttipo_contrato tipcon on tipcon.id_tipo_contrato=contra.id_tipo_contrato
                        INNER join saj.vresponsable_proceso rep_legal on rep_legal.id_responsable_proceso=contra.id_representante_legal
						INNER join param.vproveedor provee on provee.id_proveedor=contra.id_proveedor

                        
                        --inner join param.tdepto_usuario depto_usuario on depto_usuario.id_depto 
                        '||v_criterio_join||'  saj.vresponsable_proceso abogado on estpro.id_responsable_proceso=abogado.id_responsable_proceso  
                        left join saj.tmodalidad modali on modali.id_modalidad=contra.id_modalidad
                        left join segu.tusuario usu2 on usu2.id_usuario = contra.id_usuario_mod   

                        left join saj.vresponsable_proceso rpc on rpc.id_responsable_proceso=contra.id_rpc  
                        

                        left join saj.vresponsable_proceso superv on superv.id_responsable_proceso=contra.id_supervisor  

                        
                        --left join param.talarma alarma on alarma.id_alarma=contra.id_alarma
                        left join param.tpm_proyecto proyec on proyec.id_proyecto=contra.id_proyecto
                        left join param.tlugar lugar on lugar.id_lugar=contra.id_lugar_suscripcion    
                       
                         
                        
                        
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;     
            		
            
             IF v_filtro is not null then
                v_consulta:=v_consulta || v_filtro;
             END IF;
            
           
   
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            raise notice  'cons: %',v_consulta;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'SA_CONTRA_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 17:25:24
	***********************************/

	elsif(p_transaccion='SA_CONTRA_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(contra.id_proceso_contrato)
					    from saj.tproceso_contrato contra
                        inner join saj.testado_proceso estpro 
                          on estpro.id_proceso_contrato=contra.id_proceso_contrato 
                          and estpro.estado_reg=''activo''
                        inner join saj.testado est on est.codigo = estpro.estado_vigente
						inner join rhum.vfuncionario funcio on funcio.id_funcionario=contra.id_funcionario
                        inner join segu.tusuario usu1 on usu1.id_usuario = contra.id_usuario_reg
						inner join param.tdepto depto on depto.id_depto=contra.id_depto --inner
                        inner join rhum.tuo uo on uo.id_uo=contra.id_uo
						INNER join param.tgestion gestio on gestio.id_gestion=contra.id_gestion           
                        INNER join param.tmoneda moneda on moneda.id_moneda=contra.id_moneda
                        INNER join saj.ttipo_contrato tipcon on tipcon.id_tipo_contrato=contra.id_tipo_contrato
                        INNER join saj.vresponsable_proceso rep_legal on rep_legal.id_responsable_proceso=contra.id_representante_legal
                        INNER join param.vproveedor provee on provee.id_proveedor=contra.id_proveedor
                       
                        
                        left join saj.tmodalidad modali on modali.id_modalidad=contra.id_modalidad
                        left join segu.tusuario usu2 on usu2.id_usuario = contra.id_usuario_mod   

                        left join saj.vresponsable_proceso rpc on rpc.id_responsable_proceso=contra.id_rpc  
                        
                        left join saj.vresponsable_proceso superv on superv.id_responsable_proceso=contra.id_supervisor  

                        
                        --left join param.talarma alarma on alarma.id_alarma=contra.id_alarma
                        left join param.tpm_proyecto proyec on proyec.id_proyecto=contra.id_proyecto
                        left join param.tlugar lugar on lugar.id_lugar=contra.id_lugar_suscripcion    
                       
                        left join saj.vresponsable_proceso abogado on estpro.id_responsable_proceso=abogado.id_responsable_proceso  
                         
                        
                        where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;
             IF(public.f_existe_parametro(p_tabla,'estado_proceso')) then
               v_consulta:=v_consulta || ' and estpro.estado_vigente='''||v_parametros.estado_proceso||'''';
            end if;
			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
/*					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;*/
END;
$$;


ALTER FUNCTION saj.f_tproceso_contrato_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1165 (class 1255 OID 1988513)
-- Dependencies: 91 2435
-- Name: f_tresponsable_proceso_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: postgres
--

CREATE FUNCTION f_tresponsable_proceso_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_tresponsable_proceso_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'saj.tresponsable_proceso'
 AUTOR: 		 (mzm)
 FECHA:	        16-11-2011 16:54:59
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_responsable_proceso	integer;
			    
BEGIN

    v_nombre_funcion = 'saj.f_tresponsable_proceso_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SA_RESPRO_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 16:54:59
	***********************************/

	if(p_transaccion='SA_RESPRO_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into saj.tresponsable_proceso(
			estado_reg,
			tipo,
			id_funcionario,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.tipo,
			v_parametros.id_funcionario,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_responsable_proceso into v_id_responsable_proceso;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Responsable de Proceso almacenado(a) con exito (id_responsable_proceso'||v_id_responsable_proceso||')'); 
            v_resp = f_agrega_clave(v_resp,'id_responsable_proceso',v_id_responsable_proceso::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'SA_RESPRO_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 16:54:59
	***********************************/

	elsif(p_transaccion='SA_RESPRO_MOD')then

		begin
			--Sentencia de la modificacion
            --05ene12: validamos si se trata de una asignacion de nuevo responsable para uno q esten dando de baja        
            if(public.f_existe_parametro(p_tabla,'id_funcionario_')) then  
            
                if(v_parametros.id_funcionario_>0) then    
                   --damos de baja(estado=inactivo) e insertamos otro registro q dependa del q estamos inactivando
                   update saj.tresponsable_proceso
                   set estado_reg='inactivo',      
                   fecha_mod=now()::date
                   where id_responsable_proceso=v_parametros.id_responsable_proceso;
               
                   insert into saj.tresponsable_proceso(
                       estado_reg,
                      tipo,
                      id_funcionario,
                      id_usuario_reg,
                      fecha_reg,
                      id_usuario_mod,
                      fecha_mod   ,
                      id_responsable_proceso_anterior
                      ) values(
                      'activo',
                      v_parametros.tipo,
                      v_parametros.id_funcionario_,
                      p_id_usuario,
                      now(),
                      null,
                      null   ,
                      v_parametros.id_responsable_proceso
                      )  ;        
    
                else   --modificacion simple de datos     
                    --verificar q no tenga procesos en los q esté con el tipo indicado 
                    if exists (select 1 from saj.tresponsable_proceso where id_responsable_proceso=v_parametros.id_responsable_proceso and tipo!=v_parametros.tipo) then
                    
                        if (v_parametros.tipo='abogado') then
                         --validamos en proceso_contrato 

                            if exists(select 1 from saj.testado_proceso where id_responsable_proceso=v_parametros.id_responsable_proceso) then
                                raise exception 'El responsable indicado tiene procesos en otro rol';
                            end if;
                        else                                    
                         --validamos en proceso_contrato_estado  
                            if exists (select 1 from saj.tproceso_contrato 
                                       where (id_supervisor=v_parametros.id_responsable_proceso
                                              or id_rpc=v_parametros.id_responsable_proceso 
                                              or id_representante_legal=v_parametros.id_responsable_proceso )
                            ) then
                                  raise exception 'El responsable indicado tiene procesos en otro rol';
                            end if;                      
                        end if;  
                    end if;
                    
                    
                    
                    update saj.tresponsable_proceso set
			            tipo = v_parametros.tipo,
                        id_funcionario = v_parametros.id_funcionario,
                        id_usuario_mod = p_id_usuario,
                        fecha_mod = now()
                        where id_responsable_proceso=v_parametros.id_responsable_proceso;
                end if;
            end if; 
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Responsable de Proceso modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_responsable_proceso',v_parametros.id_responsable_proceso::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'SA_RESPRO_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 16:54:59
	***********************************/

	elsif(p_transaccion='SA_RESPRO_ELI')then

        begin
            
            --validamos q se pueda eliminar el registro
            if exists(select 1 from saj.tresponsable_proceso where id_responsable_proceso_anterior=v_parametros.id_responsable_proceso) then
            end if;
               
            --Sentencia de la eliminacion         
            delete from saj.tresponsable_proceso
            where id_responsable_proceso=v_parametros.id_responsable_proceso;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Responsable de Proceso eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_responsable_proceso',v_parametros.id_responsable_proceso::varchar);
              
            --Devuelve la respuesta
            return v_resp;

        end;
         
    else
     
        raise exception 'Transaccion inexistente: %',p_transaccion;

    end if;

EXCEPTION
                
    WHEN OTHERS THEN
        v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
        raise exception '%',v_resp;
                        
END;
$$;


ALTER FUNCTION saj.f_tresponsable_proceso_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1182 (class 1255 OID 1988512)
-- Dependencies: 2435 91
-- Name: f_tresponsable_proceso_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: postgres
--

CREATE FUNCTION f_tresponsable_proceso_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_tresponsable_proceso_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'saj.tresponsable_proceso'
 AUTOR: 		 (mzm)
 FECHA:	        16-11-2011 16:54:59
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'saj.f_tresponsable_proceso_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SA_RESPRO_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 16:54:59
	***********************************/

	if(p_transaccion='SA_RESPRO_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						respro.id_responsable_proceso,
						respro.estado_reg,
						respro.tipo,
						respro.id_funcionario,
						respro.id_usuario_reg,
						respro.fecha_reg,
						respro.id_usuario_mod,
						respro.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                       -- person.nombre_completo1,
                       funcio.desc_funcionario1 as nombre_completo1,
                        coalesce((select distinct 1 from saj.tproceso_contrato where estado_proceso not in (''FINCON'',''ANULADO'')
                           and (
                                   (id_supervisor=respro.id_responsable_proceso and respro.tipo=''supervisor'') 
                                or (id_rpc=respro.id_responsable_proceso and respro.tipo=''rpc'') 
                                or (id_representante_legal=respro.id_responsable_proceso and respro.tipo=''rep_legal'')
                                or (id_proceso_contrato in (select id_proceso_contrato from saj.testado_proceso where estado_vigente not in (''FINCON'',''ANULADO'')
                                    and estado_reg=''activo'' and respro.id_responsable_proceso=id_responsable_proceso) and respro.tipo=''abogado'')
                           )
                        ),0)::integer as tiene_procesos_pendientes     ,
                        funcio_ant.desc_funcionario1 as desc_resp_ant
						from saj.tresponsable_proceso respro
						inner join segu.tusuario usu1 on usu1.id_usuario = respro.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = respro.id_usuario_mod      
                        inner join rhum.vfuncionario funcio on funcio.id_funcionario=respro.id_funcionario   
--                        inner join segu.persona person on person.id_persona=funcio.id_persona
                        left join saj.tresponsable_proceso respro_ant on respro_ant.id_responsable_proceso=respro.id_responsable_proceso_anterior
                        left join rhum.vfuncionario  funcio_ant on funcio_ant.id_funcionario=respro_ant.id_funcionario
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;   
               -- raise exception '%', 'and respro.tipo like  '' '''||v_parametros.tipo||''' ';
            if(f_existe_parametro(p_tabla,'tipo')) then                        --        raise exception 'aa%',v_parametros.tipo;
               v_consulta:=v_consulta ||  ' and respro.tipo like ''' ||v_parametros.tipo ||'''';     
            end if;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
               
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'SA_RESPRO_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 16:54:59
	***********************************/

	elsif(p_transaccion='SA_RESPRO_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(respro.id_responsable_proceso)
					    from saj.tresponsable_proceso respro
						inner join segu.tusuario usu1 on usu1.id_usuario = respro.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = respro.id_usuario_mod      
                        inner join rhum.vfuncionario funcio on funcio.id_funcionario=respro.id_funcionario   
--                        inner join segu.persona person on person.id_persona=funcio.id_persona
                        left join saj.tresponsable_proceso respro_ant on respro_ant.id_responsable_proceso=respro.id_responsable_proceso_anterior
                        left join rhum.vfuncionario  funcio_ant on funcio_ant.id_funcionario=respro_ant.id_funcionario
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;   
               -- raise exception '%', 'and respro.tipo like  '' '''||v_parametros.tipo||''' ';
            if(f_existe_parametro(p_tabla,'tipo')) then                        --        raise exception 'aa%',v_parametros.tipo;
               v_consulta:=v_consulta ||  ' and respro.tipo ilike ''' ||v_parametros.tipo ||'''';     
            end if;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION saj.f_tresponsable_proceso_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1127 (class 1255 OID 1988511)
-- Dependencies: 91 2435
-- Name: f_ttipo_contrato_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: postgres
--

CREATE FUNCTION f_ttipo_contrato_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_ttipo_contrato_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'saj.ttipo_contrato'
 AUTOR: 		 (mzm)
 FECHA:	        16-11-2011 16:54:07
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_tipo_contrato    integer;
                
BEGIN

    v_nombre_funcion = 'saj.f_ttipo_contrato_ime';
    v_parametros = f_get_record(p_tabla);

    /*********************************    
     #TRANSACCION:  'SA_TIPCON_INS'
     #DESCRIPCION:    Insercion de registros
     #AUTOR:        mzm    
     #FECHA:        16-11-2011 16:54:07
    ***********************************/

    if(p_transaccion='SA_TIPCON_INS')then
                    
        begin
            --Sentencia de la insercion
            insert into saj.ttipo_contrato(
            nombre,
            estado_reg,
            id_usuario_reg,
            fecha_reg,
            id_usuario_mod,
            fecha_mod
              ) values(
            v_parametros.nombre,
            'activo',
            p_id_usuario,
            now(),
            null,
            null
            )RETURNING id_tipo_contrato into v_id_tipo_contrato;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo de Contrato almacenado(a) con exito (id_tipo_contrato'||v_id_tipo_contrato||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_contrato',v_id_tipo_contrato::varchar);

            --Devuelve la respuesta
            return v_resp;

        end;

    /*********************************    
     #TRANSACCION:  'SA_TIPCON_MOD'
     #DESCRIPCION:    Modificacion de registros
     #AUTOR:        mzm    
     #FECHA:        16-11-2011 16:54:07
    ***********************************/

    elsif(p_transaccion='SA_TIPCON_MOD')then

        begin
            --Sentencia de la modificacion
            update saj.ttipo_contrato set
            nombre = v_parametros.nombre,
            id_usuario_mod = p_id_usuario,
            fecha_mod = now()
            where id_tipo_contrato=v_parametros.id_tipo_contrato;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo de Contrato modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_contrato',v_parametros.id_tipo_contrato::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end;

    /*********************************    
     #TRANSACCION:  'SA_TIPCON_ELI'
     #DESCRIPCION:    Eliminacion de registros
     #AUTOR:        mzm    
     #FECHA:        16-11-2011 16:54:07
    ***********************************/

    elsif(p_transaccion='SA_TIPCON_ELI')then

        begin
            --Sentencia de la eliminacion
            delete from saj.ttipo_contrato
            where id_tipo_contrato=v_parametros.id_tipo_contrato;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo de Contrato eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_contrato',v_parametros.id_tipo_contrato::varchar);
              
            --Devuelve la respuesta
            return v_resp;

        end;
         
    else
     
        raise exception 'Transaccion inexistente: %',p_transaccion;

    end if;

EXCEPTION
                
    WHEN OTHERS THEN
        v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
        raise exception '%',v_resp;
                        
END;
$$;


ALTER FUNCTION saj.f_ttipo_contrato_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1144 (class 1255 OID 1988510)
-- Dependencies: 91 2435
-- Name: f_ttipo_contrato_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: postgres
--

CREATE FUNCTION f_ttipo_contrato_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_ttipo_contrato_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'saj.ttipo_contrato'
 AUTOR: 		 (mzm)
 FECHA:	        16-11-2011 16:54:07
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

    v_consulta            varchar;
    v_parametros          record;
    v_nombre_funcion       text;
    v_resp                varchar;
                
BEGIN

    v_nombre_funcion = 'saj.f_ttipo_contrato_sel';
    v_parametros = f_get_record(p_tabla);

    /*********************************    
     #TRANSACCION:  'SA_TIPCON_SEL'
     #DESCRIPCION:    Consulta de datos
     #AUTOR:        mzm    
     #FECHA:        16-11-2011 16:54:07
    ***********************************/

    if(p_transaccion='SA_TIPCON_SEL')then
                     
        begin
            --Sentencia de la consulta
            v_consulta:='select
                        tipcon.id_tipo_contrato,
                        tipcon.nombre,
                        tipcon.estado_reg,
                        tipcon.id_usuario_reg,
                        tipcon.fecha_reg,
                        tipcon.id_usuario_mod,
                        tipcon.fecha_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod    
                        from saj.ttipo_contrato tipcon
                        inner join segu.tusuario usu1 on usu1.id_usuario = tipcon.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = tipcon.id_usuario_mod
                        where  ';
            
            --Definicion de la respuesta
            v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

            --Devuelve la respuesta
            return v_consulta;
                        
        end;

    /*********************************    
     #TRANSACCION:  'SA_TIPCON_CONT'
     #DESCRIPCION:    Conteo de registros
     #AUTOR:        mzm    
     #FECHA:        16-11-2011 16:54:07
    ***********************************/

    elsif(p_transaccion='SA_TIPCON_CONT')then

        begin
            --Sentencia de la consulta de conteo de registros
            v_consulta:='select count(id_tipo_contrato)
                        from saj.ttipo_contrato tipcon
                        inner join segu.tusuario usu1 on usu1.id_usuario = tipcon.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = tipcon.id_usuario_mod
                        where ';
            
            --Definicion de la respuesta            
            v_consulta:=v_consulta||v_parametros.filtro;

            --Devuelve la respuesta
            return v_consulta;

        end;
                    
    else
                         
        raise exception 'Transaccion inexistente';
                             
    end if;
                    
EXCEPTION
                    
    WHEN OTHERS THEN
            v_resp='';
            v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
            v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
            v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
            raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION saj.f_ttipo_contrato_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 298 (class 1255 OID 2235993)
-- Dependencies: 91 2435
-- Name: f_verifica_alarma(integer); Type: FUNCTION; Schema: saj; Owner: fprudencio
--

CREATE FUNCTION f_verifica_alarma(p_id_usuario integer) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: 		f_verifica_alarma
 DESCRIPCION:   Verifica las alarmas correspondientes al subsistema enviado desde el control si no existe la alarma la inserta,
                para los casos que se tengan alarmas con tiempo de vencimiento
 
 AUTOR: 	    Fernando Prudencio Cardona
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES  
 DESCRIPCION:  TErmino la funcion que quedo a medias
 AUTOR:		Rensi Artega Copari
 FECHA:		14/01/2012
 ***********************************************************************************************/

DECLARE
 
    v_dif_dias				integer;
    v_id_subsistema			integer;
    v_id_rpc				integer;
    v_id_sup    			integer;
    v_id_rep_legal			integer; 
    v_id_sup_boleta			integer;  
    v_dias_boleta			integer;
    v_dias_contrato			integer;
    v_descrip_boleta		varchar;
    v_descrip_contrato		varchar;
    v_registros				record;  
    v_alarmas				integer[];
    v_alarmas_con			integer[];
    v_id_funcionario		integer;
    v_id_alarma				integer; 
    v_funcionarios			integer[];
    v_funcionarios_cargo	varchar[];
    v_funcionarios_con		integer[]; 
    v_funcionarios_url      varchar[]; 
	v_funcionarios_class	varchar[];
    v_indice				integer;
    
    v_desc_alarma           varchar;
    v_num_cotrato varchar;
    v_contratista varchar;
BEGIN       
         v_indice:=0;
       --0) obtenemos el id_subsistema
          SELECT id_subsistema INTO v_id_subsistema
          FROM segu.tsubsistema 
          WHERE codigo='SAJ';
       
       --1)  obtenemos los datos de configuracion de boleta y contratos
       
       SELECT descripcion,dias INTO v_descrip_boleta,v_dias_boleta
       FROM param.tconfig_alarma 
       WHERE codigo='tboleta' AND id_subsistema=v_id_subsistema;
       
       SELECT descripcion,dias INTO v_descrip_contrato,v_dias_contrato
       FROM param.tconfig_alarma 
       WHERE codigo='tproceso_contrato' AND id_subsistema=v_id_subsistema; 
       
       
    --2) iniciamos el recorrido para boleta solo para las boletas que no tienen alarmas
         FOR v_registros IN (SELECT b.id_boleta,
                                    b.id_proceso_contrato,
                                    b.fecha_vencimiento,
                                    b.monto,
                                    b.id_moneda,
                                    b.numero,
                                    m.codigo
                             FROM saj.tboleta b
                             INNER JOIN param.tmoneda m on m.id_moneda = b.id_moneda
                             WHERE id_alarma IS NULL
                             and ((fecha_vencimiento-now()::date)<=v_dias_boleta)
                             and b.estado not in ('finalizada','renovada','anulada','cobrada') 
                          )LOOP
                             
                             
                           
                             
                              --falta filtro de boleas ya finalizadas, renovadas y cobradas  
             
             --calculo cuanto de cuantos dias falta para vencer
             --numero negativo indica que ya vencio
             v_dif_dias= v_registros.fecha_vencimiento-now()::date;
             
             --VERIFICA SI CUMPLE LA DIFERENCIA DE DIAS PARA CREAR UNA ALARMA
             if(v_dif_dias <= v_dias_boleta)THEN
              
              --  crea alarmas para:
              --   rpc,supervisor,representante legal,funcionario solicitante
              
                 SELECT c.id_rpc,c.id_supervisor,c.id_representante_legal,
                        c.id_funcionario 		,c.numero_contrato,desc_proveedor
                 INTO   v_id_rpc,v_id_sup,v_id_rep_legal,
                        v_id_funcionario,v_num_cotrato, v_contratista
                 FROM saj.tproceso_contrato c
                 INNER JOIN param.vproveedor provee 
                 on provee.id_proveedor=c.id_proveedor
                 WHERE id_proceso_contrato=v_registros.id_proceso_contrato;
                 
                 --obtiene el identificador de los funcionario
                 v_id_rpc:=id_funcionario FROM saj.tresponsable_proceso 
                                          WHERE id_responsable_proceso=v_id_rpc;
                 
                 v_id_sup:=id_funcionario FROM saj.tresponsable_proceso 
                                          WHERE id_responsable_proceso=v_id_sup;
                 
                 v_id_rep_legal:=id_funcionario FROM saj.tresponsable_proceso 
                                                WHERE id_responsable_proceso=v_id_rep_legal;

                 --obtiene el usuario responsable de las boletas para el departamento correspondiente
                 v_id_sup_boleta:=  fun.id_funcionario 
                                          FROM rhum.tfuncionario fun
                                          inner join segu.tusuario usu 
                                                 on usu.id_persona=fun.id_persona
                                          inner join param.tdepto_usuario dusu 
                                                 on dusu.id_usuario=usu.id_usuario and dusu.estado_reg='activo'
                                          where dusu.cargo='resp_bolet';


                   raise NOTICE 'FUNCIONARIO %',v_id_funcionario;   
                   
                 
                  v_funcionarios=NULL;
                     v_funcionarios_cargo=NULL;
                     
                     
                     v_funcionarios[1] =v_id_funcionario;
                     v_funcionarios_cargo[1] ='solicitante';
                     v_funcionarios[2] =v_id_rpc;
                     v_funcionarios_cargo[2] ='rpc';
                     v_funcionarios[3] =v_id_sup;
                     v_funcionarios_cargo[3] ='supervisor';
                     v_funcionarios[4] =v_id_sup_boleta;
                     v_funcionarios_cargo[4] ='encargadobol';
                 
                  raise NOTICE '>>>>> dias % , % % % % ',v_dias_boleta,v_funcionarios[1],v_funcionarios[2],v_funcionarios[3],v_funcionarios[4];
                  
                   
                   --inserta alarmas
                  v_indice:=1;
                   
                 --arma la descripcion de la alarma
                 v_desc_alarma='Se esta cumpliendo la Boleta de garantia Nº '||coalesce(v_registros.numero::varchar,'NR') ||' por '||coalesce(v_registros.monto::varchar,'NR')||' '||coalesce(v_registros.codigo,'NR') ||'  del contraro Nº '||coalesce(v_num_cotrato,'NR')||' del Contratista '||coalesce(v_contratista,'NR');
                   
              --  raise notice '%',v_desc_alarma;
                   
                   WHILE (v_indice <= 4)Loop
                   
                   --raise notice '%, %',v_funcionarios_cargo[v_indice],v_registros.id_boleta;
                   
                      v_id_alarma:=param.f_inserta_alarma(
                                     v_funcionarios[v_indice],
                                     v_desc_alarma,
                                     '../../../sis_legal/vista/boleta/AdministracionBoleta.php',
                                     v_registros.fecha_vencimiento,
                                     'alarma',
                                     'SAJ-Boletas',
                                     p_id_usuario,
                                     'AdministracionBoleta',
                                     'Boletas',
                                     '{tipoFiltro:'''||v_funcionarios_cargo[v_indice]::varchar||''',filtrar:true,id_boleta:'||v_registros.id_boleta::varchar||'}'
                                     ); 
                       
                      v_alarmas[v_indice]:=v_id_alarma;                        
                      v_indice:=v_indice+1;
                   End Loop;                                          
                   
                   --Actualizamos la tabla boleta con el array de alarmas
                   Update saj.tboleta SET
                      id_alarma=v_alarmas
                   WHERE id_boleta=v_registros.id_boleta;
                                            
                                          
             end if;
         END LOOP; 
       --3) iniciamos el recorrido para contrato solo para los que no tienen alarmas
      
       
       FOR v_registros IN (SELECT c.id_proceso_contrato,c.fecha_fin,c.id_funcionario,
                                  c.id_rpc,id_supervisor,c.id_representante_legal,
                                  provee.desc_proveedor,c.numero_contrato
                           FROM saj.tproceso_contrato c 
                           INNER JOIN param.vproveedor provee 
                           on provee.id_proveedor=c.id_proveedor
                           WHERE id_alarma IS NULL
                           and ((c.fecha_fin-now()::date)<=v_dias_contrato)
                           and c.estado_reg='activo' and c.estado_proceso in ('REGCON','REVCON','BORCON')
                           )LOOP 
                               
                 v_dif_dias= v_registros.fecha_fin-now()::date;
                 
                 If (v_dif_dias<=v_dias_contrato)then
             
                 
                 v_id_rpc:=id_funcionario FROM saj.tresponsable_proceso 
                                          WHERE id_responsable_proceso=v_registros.id_rpc;
                 
                 v_id_sup:=id_funcionario FROM saj.tresponsable_proceso 
                                          WHERE id_responsable_proceso=v_registros.id_supervisor;
                 
                 v_id_rep_legal:=id_funcionario FROM saj.tresponsable_proceso 
                                                WHERE id_responsable_proceso=v_registros.id_representante_legal; 
                 
                 
                 
                     v_funcionarios_con[1] =v_registros.id_funcionario;
                     v_funcionarios_cargo[1] ='solicitante';
  
					 v_funcionarios_url[1] ='../../../sis_legal/vista/proceso_contrato/ProcesoRequerimiento.php';
                     v_funcionarios_class[1] = 'ProcesoRequerimiento';
                     v_funcionarios_con[2] =v_id_rpc;
                     v_funcionarios_cargo[2] ='rpc';
					 v_funcionarios_url[2] ='../../../sis_legal/vista/proceso_contrato/ProcesoBusqueda.php';
					 v_funcionarios_class[2] = 'ProcesoBusqueda';
                     v_funcionarios_con[3] =v_id_sup;
                     v_funcionarios_cargo[3] ='supervisor';
  					 v_funcionarios_url[3] ='../../../sis_legal/vista/proceso_contrato/ProcesoBusqueda.php';
                     v_funcionarios_class[3] = 'ProcesoBusqueda';
            
                 
                 -- arma la descripcion de la alarma
                 v_desc_alarma='Se esta cumpliendo el contrato Nº '||coalesce(v_registros.numero_contrato,'NR')||' del Contratista '||coalesce(v_registros.desc_proveedor,'NR');
                 v_indice:=1;
                 
                   WHILE (v_indice <= 3)Loop
                      v_id_alarma:=param.f_inserta_alarma(
                      v_funcionarios_con[v_indice],
                      v_desc_alarma,
                      v_funcionarios_url[v_indice],
                      v_registros.fecha_fin,
                      'alarma',
                      'SAJ - Contratos',
                      p_id_usuario,
                      v_funcionarios_class[v_indice],--clase
                      'Contratos - '||v_funcionarios_cargo[v_indice],--titulo
                      '{tipoFiltro:'''||v_funcionarios_cargo[v_indice]::varchar||''',filtrar:true,id_proceso_contrato:'||v_registros.id_proceso_contrato::varchar||'}'
                     );
                                      
                         
                      v_alarmas_con[v_indice]:=v_id_alarma;                        
                      v_indice:=v_indice+1;
                   End Loop;  
                                                           
                   --Actualizamos la tabla contrato con el array de alarmas
                   Update saj.tproceso_contrato SET
                      id_alarma=v_alarmas_con
                   WHERE id_proceso_contrato=v_registros.id_proceso_contrato;
                   
                 end if;
                 
       END Loop;
           
       return 'exito';

END;
$$;


ALTER FUNCTION saj.f_verifica_alarma(p_id_usuario integer) OWNER TO fprudencio;

SET search_path = sast, pg_catalog;

--
-- TOC entry 1302 (class 1255 OID 2977449)
-- Dependencies: 92 2435
-- Name: f_manejo_estado_requerimiento(integer, character varying, character varying, integer, integer); Type: FUNCTION; Schema: sast; Owner: rvasquez
--

CREATE FUNCTION f_manejo_estado_requerimiento(p_id integer, p_tipo character varying, p_observaciones character varying, p_id_usuario integer, p_id_responsable integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**********************************************************************************************
 HISTORIA DE MODIFICACIONES  
 DESCRIPCION:   en ves de utlizar id_estado como llave foranea con la tabla estado se utiliza el codigo
 AUTOR:			rortiz
 FECHA:			8/12/2011
 ***********************************************************************************************/

DECLARE
  v_estado_actual   varchar;
  v_estado_anterior varchar;
  v_num_orden       integer;  
  v_id_estado_nuevo integer;
  v_nombre_estado 	varchar;
  
BEGIN
       --0) obtenemos el estado actual del requerimiento
       SELECT 
          coalesce(e.orden,0) , er.estado_vigente
       into 
          v_num_orden, v_estado_anterior
       FROM sast.testado_requerimiento er
       INNER JOIN sast.testado e ON e.codigo =er.estado_vigente
       WHERE id_requerimiento=p_id 
             and er.estado_reg='activo';
             v_num_orden:=coalesce(v_num_orden,0);
       
       --1)  si buscamos el estado siguiente
       if(p_tipo='siguiente') then
       
        raise notice 'ELSE siguiente %',p_tipo;
             --1.1) si el requerimiento no tiene estados obtenemos el primero
             if v_estado_anterior is NULL THEN
             
                     select id_estado,codigo , nombre
                        into 
                       v_id_estado_nuevo,v_estado_actual,v_nombre_estado
                     from sast.testado 
                     where orden=1
                     and estado_reg='activo';
             

             ELSE
              --1.2) si es un estado mayor al primero
                    select id_estado,codigo,nombre
                      into 
                          v_id_estado_nuevo,v_estado_actual,v_nombre_estado
                     from sast.testado 
                     where orden=v_num_orden+1 
                     and estado_reg='activo';
                         
                     if(v_id_estado_nuevo is null) then
                        raise exception 'No existe un estado siguiente';
                     end if;
               
             END IF;

        --2)  si buscamos el estado anterior 
       elsif(p_tipo='anterior') then
       
              raise notice 'ELSE anterior %',p_tipo;

           if(v_num_orden=0 or  v_estado_anterior is NULL ) then
                raise exception 'Estado anterior inexistente';
           else    
                select 
                   id_estado,codigo, nombre
                into 
                   v_id_estado_nuevo,v_estado_actual,v_nombre_estado
                from sast.testado 
                where orden=v_num_orden-1 and orden>0
                and estado_reg='activo'; 
           end if;
           
     --3)  si buscamos un estado especial
       else  --if (p_tipo='proceso') then  
       
       raise notice 'ELSE  %',p_tipo;
       
                select 
                   id_estado,codigo,nombre 
                into 
                   v_id_estado_nuevo,v_estado_actual,v_nombre_estado
                from sast.testado 
                where lower(codigo)=lower(p_tipo) 
                and  estado_reg='activo' limit 1;           
            
                if(v_id_estado_nuevo is null) then
                     raise exception 'Cambio de Estado no permitido';
                end if;
       end if;
       
        --raise exception 'XXXXXX  % % %',  v_id_estado_nuevo,v_estado_actual,v_nombre_estado  ;
        
        
    --4) inactivamos los estados anteriores
        
       update  sast.testado_requerimiento set 
      -- fecha_fin=now()::date ,
         observaciones= 'cambio estado de:'||v_estado_anterior||' a '|| v_estado_actual || ' - OBS: '||coalesce(p_observaciones,'NINGUNA'),
         id_usuario_mod=p_id_usuario,
         fecha_mod=now(),
       estado_reg='inactivo'       
       where estado_reg='activo'
       and id_requerimiento=p_id; 
       
       
      --5) insertamos un nuevo estado requerimiento                                                    
       insert into sast.testado_requerimiento (estado_anterior,   estado_vigente,  fecha_ini, fecha_reg, id_requerimiento, observaciones,   id_depto_usuario,  id_usuario_reg,hora, fecha_fin)
       values                          		  (v_estado_anterior, v_estado_actual, now(),     now(),     p_id,             p_observaciones, p_id_responsable,  p_id_usuario,  now(),now());
     --6) actualizamos el estado del requerimiento
     
     update sast.trequerimientos req set
     estado_requerimiento = v_estado_actual
     where id_requerimiento = p_id;
        
       return 'exito';

END;
$$;


ALTER FUNCTION sast.f_manejo_estado_requerimiento(p_id integer, p_tipo character varying, p_observaciones character varying, p_id_usuario integer, p_id_responsable integer) OWNER TO rvasquez;

--
-- TOC entry 1304 (class 1255 OID 3314429)
-- Dependencies: 2435 92
-- Name: f_testado_requerimiento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: sast; Owner: rvasquez
--

CREATE FUNCTION f_testado_requerimiento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Atencion en Servicio Tecnico
 FUNCION: 		sast.f_testado_requerimiento_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'sast.testado_requerimiento'
 AUTOR: 		(rortiz)
 FECHA:	        13-03-2012 18:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'sast.f_testado_requerimiento_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SAST_ESTREQ_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			rortiz	
 	#FECHA:			20-03-2012 18:30
	***********************************/

	if(p_transaccion='SAST_ESTREQ_SEL')then
    
    raise notice '%', v_parametros;
    
    	begin
    		--Sentencia de la consulta
			v_consulta:='SELECT 
            					 estreq.id_estado_requerimiento,
                                 estreq.id_requerimiento,
                                 estreq.observaciones,
                                 estreq.fecha_ini,
                                 COALESCE(pers.nombre || '' '' || pers.apellido_paterno || '' '' || pers.apellido_materno) as responsable,
                                 estreq.fecha_fin,
                                 est.nombre as vigente,
                                 --est1.nombre as anterior,
                                 estreq.estado_reg,
                                 estreq.fecha_reg,
                                 estreq.id_usuario_reg,
                                 estreq.fecha_mod,
                                 estreq.id_usuario_mod,
                                 usu1.cuenta as usr_reg,
                                 usu2.cuenta as usr_mod
                          from sast.testado_requerimiento estreq
                          left join sast.testado est on est.codigo = estreq.estado_vigente
                          inner join param.tdepto_usuario resp on resp.id_depto_usuario = estreq.id_depto_usuario 
                          inner join param.tdepto depto on depto.id_depto = resp.id_depto
                          left join sast.trequerimientos requer on requer.id_depto = depto.id_depto                         
                          left join rhum.tfuncionario func on func.id_funcionario = requer.id_funcionario
                          left join segu.tpersona pers on func.id_persona = pers.id_persona
                          inner join segu.tusuario usu1 on usu1.id_usuario = estreq.id_usuario_reg
                          left join segu.tusuario usu2 on usu2.id_usuario = estreq.id_usuario_mod
                          where ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion; -- || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            
            raise notice 'consulta: %',v_consulta;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'SAST_ESTREQ_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:			rortiz	
 	#FECHA:			20-03-2012 18:40
	***********************************/

	elsif(p_transaccion='SAST_ESTREQ_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_estado_requerimiento)
					    from sast.testado_requerimiento estreq                        
						inner join segu.tusuario usu1 on usu1.id_usuario = estreq.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = estreq.id_usuario_mod
				        where estreq.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
  
    /*********************************    
 	#TRANSACCION:  'AJ_EPDET_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			rortiz	
 	#FECHA:			13-03-2012 15:53
	***********************************/

	elsif(p_transaccion='AJ_EPDET_SEL')then
    
    	begin
    		--Sentencia de la consulta
			v_consulta:='select est.nombre as vigente,
                          estad.nombre as anterior,
                          estcon.observaciones,
                          estcon.fecha_ini,
                          estcon.fecha_fin
                          from sast.testado_requerimiento estcon
                          left join sast.testado est
                          on est.codigo = estcon.estado_vigente
                          left join sast.testado estad
                          on estad.codigo = estcon.estado_anterior
                          where ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion;
            
            raise notice 'consulta: %',v_consulta;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'AJ_EPDET_CONT'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			rortiz	
 	#FECHA:			13-03-2012 17:00
	***********************************/

	elsif(p_transaccion='AJ_EPDET_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_estado_requerimiento)
			 			  from sast.testado_requerimiento estcon
                          left join sast.testado est
                          on est.codigo = estcon.estado_vigente
                          left join sast.testado estad
                          on estad.codigo = estcon.estado_anterior
                          where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaste',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION sast.f_testado_requerimiento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rvasquez;

--
-- TOC entry 263 (class 1255 OID 2059042)
-- Dependencies: 2435 92
-- Name: ft_estado_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: sast; Owner: rvasquez
--

CREATE FUNCTION ft_estado_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de atencion en servicio técnico 
 FUNCION: 		sast.ft_estado_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'sast.testado'
 AUTOR: 		 (rortiz)
 FECHA:	        22-11-2011 18:23:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_estado 			integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
			    
BEGIN

    v_nombre_funcion = 'sast.ft_estado_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'ST_EST_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		22-11-2011 18:23:30
	***********************************/

	if(p_transaccion='ST_EST_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into sast.testado(			
			id_usuario_reg,
            id_usuario_mod,
            fecha_reg,
            fecha_mod,
            estado_reg,
            nombre,
            orden,
            codigo	           			
          	) values(          
			p_id_usuario,
            null,
            now()::date,
            null,
            'activo',
			v_parametros.nombre,
            v_parametros.orden,
            v_parametros.codigo            
			)RETURNING id_estado into v_id_estado;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida almacenado(a) con exito (id_estado'||v_id_estado||')'); 
            v_resp = f_agrega_clave(v_resp,'id_estado',v_id_estado::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'ST_EST_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		22-11-2011 18:23:30
	***********************************/

	elsif(p_transaccion='ST_EST_MOD')then

		begin
			--Sentencia de la modificacion
			update sast.testado set
			nombre = v_parametros.nombre,
            orden=v_parametros.orden,
            codigo=v_parametros.codigo,
			fecha_mod = now()::date,
			id_usuario_mod = p_id_usuario
			where id_estado=v_parametros.id_estado;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_estado',v_parametros.id_estado::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'ST_EST_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		22-11-2011 18:23:30
	***********************************/

	elsif(p_transaccion='ST_EST_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from sast.testado
            
             --rortiz 22-11-11 estado inactivo en vez de eliminar el registro
            UPDATE sast.testado
            SET estado_reg = 'inactivo'
            where id_estado=v_parametros.id_estado;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_estado',v_parametros.id_estado::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION sast.ft_estado_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rvasquez;

--
-- TOC entry 1194 (class 1255 OID 2022609)
-- Dependencies: 92 2435
-- Name: ft_estado_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: sast; Owner: rvasquez
--

CREATE FUNCTION ft_estado_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		sast.testado
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'sast.testado'
 AUTOR: 		rortiz
 FECHA:	        21-11-2011 15:23:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE
	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'sast.f_testado_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'ST_EST_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			rortiz	
 	#FECHA:			21-11-2011 15:23:30
	***********************************/

	if(p_transaccion='ST_EST_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						est.id_estado,	                     
                        est.nombre,	
                        est.orden,
                        est.codigo,
                        est.id_usuario_reg,
                        est.estado_reg,
                        est.fecha_reg,
						est.id_usuario_mod,						
						est.fecha_mod,																						
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod											
						from sast.testado est
                        inner join segu.tusuario usu1 on usu1.id_usuario = est.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = est.id_usuario_mod                        					
				        where est.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;   

	/*********************************    
 	#TRANSACCION:  'ST_EST_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rortiz	
 	#FECHA:		18-11-2011 
	***********************************/

	elsif(p_transaccion='ST_EST_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_estado)
					    from sast.testado est
					    inner join segu.tusuario usu1 on usu1.id_usuario = est.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = est.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
        				
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION sast.ft_estado_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rvasquez;

--
-- TOC entry 1201 (class 1255 OID 2923215)
-- Dependencies: 2435 92
-- Name: ft_requerimientos_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: sast; Owner: rvasquez
--

CREATE FUNCTION ft_requerimientos_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de atencion en servicio técnico 
 FUNCION: 		sast.ft_requerimientos
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'sast.trequerimientos'
 AUTOR: 		 (rortiz)
 FECHA:	        24-11-2011 15:23:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_parametros           		record;
	v_id_requerimiento			integer;
	v_resp		            	varchar;
	v_nombre_funcion        	text;
    v_reg_estado_requerimiento  varchar;	
    v_accion                	varchar; 
	v_mensaje_error         	text;
    v_num_req					varchar; 
    v_id_gestion 				integer; 
    v_id_tec					integer; 
    v_id_tecnico 				integer; 
   			    
BEGIN

    v_nombre_funcion = 'sast.ft_requerimientos_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'ST_REQ_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		24-11-2011 15:23:30
	***********************************/

	if(p_transaccion='ST_REQ_INS')then				
        begin
         --0) Obtener numero de requerimiento en funcion del depto de legal
         v_num_req =  param.f_obtener_correlativo('RSAST',NULL,NULL,v_parametros.id_depto,p_id_usuario,'SAST',NULL);
         
        --1)obtiene el identificador de la gestion 
        
         select g.id_gestion
         into v_id_gestion
         from param.tgestion g
         where g.estado_reg='activo' and g.gestion=to_char(now()::date,'YYYY')::integer;
         
       --2) obtener el tecnico vigente   
        
        SELECT id_depto_usuario
          into v_id_tec  
        FROM  param.tdepto_usuario tdu
        WHERE tdu.estado_reg='activo' and tdu.cargo ='tec'
        LIMIT 1 OFFSET 0;
         
        --3) insertar solicitud de requerimietno en estado borrador
        --Sentencia de la insercion
        	insert into sast.trequerimientos(			
			id_usuario_reg,
            id_usuario_mod,
            fecha_reg,
            fecha_mod,
            estado_reg,
            numero_requerimiento,
            id_funcionario,
            id_tipo_requerimiento,
            id_depto,
            descripcion,
            id_gestion,
      --	solucion,
            hora_requer,
            fecha_requer
          	) values(          
			p_id_usuario,
            null,
            now()::date,
            null,
            'activo',
            v_num_req,
            v_parametros.id_funcionario,
            v_parametros.id_tipo_requerimiento,
            v_parametros.id_depto,
            v_parametros.descripcion,
            v_id_gestion,
       --v_parametros.solucion,
            now(),
            now()::date
                      
			)RETURNING id_requerimiento into v_id_requerimiento;
            
       	--4) inserta el estado correpondiente al requerimiento inicial
            raise notice 'actualiza el estado';
            v_reg_estado_requerimiento:=sast.f_manejo_estado_requerimiento(v_id_requerimiento,'siguiente','formulacion de requerimiento',p_id_usuario,null);
            
            
            if(v_reg_estado_requerimiento!='exito') then        
                 raise exception 'Error con registro en estado requerimiento para id_requerimiento %', v_id_requerimiento;
            end if;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida almacenado(a) con exito (id_requerimiento'||v_id_requerimiento||')'); 
            v_resp = f_agrega_clave(v_resp,'id_requerimiento',v_id_requerimiento::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'ST_REQ_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		24-11-2011 15:23:30
	***********************************/

	elsif(p_transaccion='ST_REQ_MOD')then

		begin                
			--Sentencia de la modificacion
            
            if(public.f_existe_parametro(p_tabla,'operacion')) then      
                If(v_parametros.operacion!='anterior') then
                	v_accion:='siguiente';
                else            
                   	v_accion:=v_parametros.operacion;
                End if;
         
              --operacion identifica al estado que se debe cambiar el requerimiento                
                v_reg_estado_requerimiento:=sast.f_manejo_estado_requerimiento(v_parametros.id_requerimiento,v_accion,
                'cambio de estado a:'|| v_parametros.operacion,p_id_usuario, v_id_tecnico);              
                if(v_reg_estado_requerimiento!='exito') then
                   raise exception 'Problema con modificacion a registro';
                end if;   
                                        
            else  
                update sast.trequerimientos set
                  descripcion = v_parametros.descripcion,
                  id_funcionario = v_parametros.id_funcionario,
                  id_tipo_requerimiento = v_parametros.id_tipo_requerimiento,
                  id_depto = v_parametros.id_depto,            
                  fecha_mod = now()::date,
                  id_usuario_mod = p_id_usuario,
                  v_id_tecnico = v_parametros.id_tecnico
                  --solucion=v_parametros.solucion
                where id_requerimiento=v_parametros.id_requerimiento;
        	end if;             
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_requerimiento',v_parametros.id_requerimiento::varchar);              
            --Devuelve la respuesta
            return v_resp;            
		end;
        
    /*********************************    
 	#TRANSACCION:  'ST_REQASIG_MOD'
 	#DESCRIPCION:	Modificacion de asignacion de tecnico desde pantalla de asignacion
 	#AUTOR:			RORTIZ	
 	#FECHA:		13-12-2011 17:25:24
	***********************************/

	elsif(p_transaccion='ST_REQASIG_MOD')then

		begin
			--Sentencia de la modificacion   
			update sast.trequerimientos set
              descripcion = v_parametros.descripcion,
              id_funcionario = v_parametros.id_funcionario,
              id_tipo_requerimiento = v_parametros.id_tipo_requerimiento,
              id_depto = v_parametros.id_depto,            
              fecha_mod = now()::date,
              id_usuario_mod = p_id_usuario
          	-- v_id_tecnico = v_parametros.id_tecnico
			where id_requerimiento=v_parametros.id_requerimiento;
            
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proceso de Requerimiento Modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_requerimiento',v_parametros.id_requerimiento::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
          end; 
   
    /*********************************    
 	#TRANSACCION: 'ST_CAMEST_MOD'
 	#DESCRIPCION: Cambia estados del requerimiento
 	#AUTOR:	      RORTIZ
 	#FECHA:		  16-11-2011 17:25:24
	***********************************/

	elsif(p_transaccion='ST_CAMEST_MOD')then
		begin 
        	if(public.f_existe_parametro(p_tabla,'operacion')) then
                                 
                     v_accion:=v_parametros.operacion;
                     
                     if  v_accion = 'proceso' THEN
                        v_accion='PROREQ';            
                     end if;
                                 
                    IF(public.f_existe_parametro(p_tabla,'id_tecnico')) THEN
                        v_id_tecnico=v_parametros.id_tecnico;                    
                    ELSE
                        v_id_tecnico = NULL;
                    END IF;
                  --operacion identifica al estado que se debe cambiar el requerimiento                
                    v_reg_estado_requerimiento:=sast.f_manejo_estado_requerimiento(v_parametros.id_requerimiento,v_accion,
                    'cambio de estado a:'|| v_parametros.operacion,p_id_usuario,
                    v_id_tecnico);  
                    
                    IF(public.f_existe_parametro(p_tabla,'solucion'))THEN
                          update sast.trequerimientos
                              set solucion = v_parametros.solucion
                          where id_requerimiento = v_parametros.id_requerimiento;
                    END IF;  
                               
                    if(v_reg_estado_requerimiento!='exito') then
                       raise exception 'Problema con el cambio de estado del requerimiento';
                    end if; 
            end if;
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Requerimiento modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_requerimiento',v_parametros.id_requerimiento::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end; 
        
/*******************************
 #TRANSACCION:  ST_UPCAPTREQ_MOD
 #DESCRIPCION:	Modifica la captura1 de la persona
 #AUTOR:		RORTIZ	
 #FECHA:		29/11/11	
***********************************/
     elsif(p_transaccion='ST_UPCAPTREQ_MOD')then

          --consulta:=';
          BEGIN

			   update sast.trequerimientos
               set 
               captura1	= v_parametros.captura1,
               extension = v_parametros.extension,
               version = v_parametros.version,
           	   id_usuario_mod = p_id_usuario,
           	   fecha_mod = now()::date
               where id_requerimiento = v_parametros.id_requerimiento;
             
             v_resp = f_agrega_clave(v_resp,'mensaje','captura1 del requerimiento modificada con exito '||v_parametros.id_requerimiento); 
             v_resp = f_agrega_clave(v_resp,'id_requerimiento',v_parametros.id_requerimiento::varchar);
             
             return v_resp;

               
          END;
 
	/*********************************    
 	#TRANSACCION:  'ST_REQ_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		24-11-2011 15:23:30
	***********************************/

	elsif(p_transaccion='ST_REQ_ELI')then

		begin
             v_reg_estado_requerimiento:=sast.f_manejo_estado_requerimiento(v_parametros.id_requerimiento,'ANUREQ','anulacion de requerimiento',p_id_usuario,null);
              
              if(v_reg_estado_requerimiento!='exito') then
                 raise exception 'Error con anulacion de requerimiento';
              end if;
            --Sentencia de la eliminacion
            UPDATE sast.trequerimientos
            SET estado_reg = 'inactivo',
            fecha_mod=now()::date,
            id_usuario_mod=p_id_usuario
            where id_requerimiento=v_parametros.id_requerimiento;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_requerimiento',v_parametros.id_requerimiento::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION sast.ft_requerimientos_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rvasquez;

--
-- TOC entry 1157 (class 1255 OID 2220019)
-- Dependencies: 92 2435
-- Name: ft_requerimientos_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: sast; Owner: rvasquez
--

CREATE FUNCTION ft_requerimientos_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:			rortiz		
 FECHA:			23/11/11
***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp 				varchar;
v_filtro            varchar;
v_criterio_join     varchar;
v_id_depto_usuario integer;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(p_tabla);
     v_nombre_funcion:='sast.ft_requerimientos_sel';

/*********************************    
#TRANSACCION:  'ST_CAPTU_SEL'
#DESCRIPCION:	Obtiene la captura del requerimiento
 #AUTOR:		rortiz		
 #FECHA:		23/11/11	
***********************************/

	    if(p_transaccion='ST_CAPTU_SEL')then

          --  Se arma la consulta de personas
          BEGIN
          v_criterio_join ='LEFT JOIN';
                   IF(public.f_existe_parametro(p_tabla,'tipo_interfaz')) then             
                     IF(v_parametros.tipo_interfaz='BORREQ')THEN
                     --si es la interface de requerimiento se linstan los procesos en todos los
                     --estados 
                           
                           IF(public.f_existe_parametro(p_tabla,'id_funcionario') ) then                           
                                     IF p_administrador =1 THEN                                 
                                      v_filtro=' and 0=0 ';                              
                                     ELSEIF(v_parametros.id_funcionario is not null and v_parametros.id_funcionario!='') then 
                                     v_filtro = ' and (contra.id_usuario_reg= '||p_id_usuario||' 
                                                  or contra.id_funcionario = '||v_parametros.id_funcionario||')  ';
                                     ELSE 
                                     raise exception 'el usuario no tiene funcionario relacionado';
                                     END IF;
                     END IF;
                   END IF;
                   
     	--Face de Asignacion del requerimiento                              
                   IF (v_parametros.tipo_interfaz='PENREQ') THEN
                      v_filtro:=' and (estreq.estado_vigente=''PENREQ'' or estreq.estado_vigente=''ASIGNA'')';
                   END IF;    
       				
        --Face de elaboracion del requerimiento
                    IF (v_parametros.tipo_interfaz='ELABORACION') THEN
                       --raise exception 'hhhhhhhh';              
                       v_criterio_join ='LEFT JOIN';                       
                       IF p_administrador =1 THEN
                         		v_filtro:=' and (estreq.estado_vigente in (''ASIGNA'',''PENREQ'',''FINREQ''))';
                       ELSEIF(v_parametros.id_usuario is not null and v_parametros.id_usuario!='') then 
                     
                           		select id_depto_usuario
                             	into v_id_depto_usuario
                           		from param.tdepto_usuario du
                           		where du.id_usuario = v_parametros.id_usuario::integer;
                             	v_filtro:=' and (estreq.estado_vigente in (''ASIGNA'',''PENREQ'',''FINREQ''); 
                                and tecnico.id_depto_usuario='||v_id_depto_usuario::varchar||')';
                     
                       ELSE 
                                     raise exception 'el usuario no tiene funcionario relacionado';
                       END IF;
                 END IF;
             end if;
          		
		--Sentencia de la consulta   
               v_consulta:='SELECT 
               				req.id_requerimiento,
               				req.id_funcionario,
                            req.id_tipo_requerimiento,
                            req.id_depto,
               				req.id_gestion,
                            req.numero_requerimiento,
                            req.version,
                            req.descripcion,
               				req.estado_reg,
                        	req.id_usuario_reg,
                        	req.fecha_reg,
							req.id_usuario_mod,						
							req.fecha_mod,
                        	usu1.cuenta as usr_reg,
                        	usu2.cuenta as usr_mod,
                            req.estado_requerimiento,                           
                        	funcio.desc_funcionario1::varchar as desc_funcionario,
       						tipreq.nombre as requerimiento,
       						depto.nombre as departamento,               
                            gestio.gestion as desc_gestion,
                            estado.nombre as nombre_estado,
                            tecnico.id_depto_usuario as id_tecnico,
                        	tecnico.desc_depto_usuario as tecnico,
                            req.fecha_requer,
                            estreq.fecha_ini,
                            req.hora_requer,
                         	req.solucion,
                      		estreq.fecha_fin,
                            estreq.hora,
                            req.extension,                                   
                            req.captura1                           
                        	                            
   							FROM sast.trequerimientos req                                             
								inner join rhum.vfuncionario funcio on funcio.id_funcionario=req.id_funcionario
                            	inner join sast.ttipo_requerimiento tipreq on tipreq.id_tipo_requerimiento = req.id_tipo_requerimiento
                        		inner join segu.tusuario usu1 on usu1.id_usuario = req.id_usuario_reg
                                inner join param.tdepto depto on depto.id_depto = req.id_depto
                                left join sast.testado_requerimiento estreq 
                        		on estreq.id_requerimiento=req.id_requerimiento 
                        		and estreq.estado_reg=''activo''
                        		left join sast.testado estado on estado.codigo = estreq.estado_vigente                             
                                left join param.tgestion gestio on gestio.id_gestion=req.id_gestion                        
								left join segu.tusuario usu2 on usu2.id_usuario = req.id_usuario_mod
                            	'||v_criterio_join||'  sast.vdepto_usuario  tecnico on estreq.id_depto_usuario=tecnico.id_depto_usuario
                          WHERE';
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;     
            		
            
             IF v_filtro is not null then
                v_consulta:=v_consulta || v_filtro;
             END IF;
            
            raise notice '%',v_consulta;
   
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
         END;     


/*******************************
 #TRANSACCION:  ST_CAPTU_CONT
 #DESCRIPCION:	Cuenta Requerimientos con captura
 #AUTOR:		rortiz		
 #FECHA:		23/11/11	
***********************************/

     elsif(p_transaccion='ST_CAPTU_CONT')then

          --se arma la sonsulta que cuenta personas
          BEGIN
               
               v_consulta:='select count(req.id_requerimiento)
   							FROM sast.trequerimientos req                                             
								inner join rhum.vfuncionario funcio on funcio.id_funcionario=req.id_funcionario
                            	inner join sast.ttipo_requerimiento tipreq on tipreq.id_tipo_requerimiento = req.id_tipo_requerimiento
                        		inner join segu.tusuario usu1 on usu1.id_usuario = req.id_usuario_reg
                                inner join param.tdepto depto on depto.id_depto = req.id_depto
                                left join sast.testado_requerimiento estreq 
                        		on estreq.id_requerimiento=req.id_requerimiento 
                        		and estreq.estado_reg=''activo''
                        		left join sast.testado estado on estado.codigo = estreq.estado_vigente                             
                                left join param.tgestion gestio on gestio.id_gestion=req.id_gestion                        
								left join segu.tusuario usu2 on usu2.id_usuario = req.id_usuario_mod
                            	left join sast.vdepto_usuario  tecnico on estreq.id_depto_usuario=tecnico.id_depto_usuario
                           WHERE';
              v_consulta:=v_consulta||v_parametros.filtro;
              
            IF(public.f_existe_parametro(p_tabla,'requerimientos')) then
               v_consulta:=v_consulta || ' and estreq.estado_vigente='''||v_parametros.estado_requerimiento||'''';
            end if;
			--Devuelve la respuesta
			return v_consulta;
         END;
         
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION sast.ft_requerimientos_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rvasquez;

--
-- TOC entry 1187 (class 1255 OID 2015186)
-- Dependencies: 2435 92
-- Name: ft_tipo_requerimiento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: sast; Owner: rvasquez
--

CREATE FUNCTION ft_tipo_requerimiento_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de atencion en servicio técnico 
 FUNCION: 		sast.f_tipo_requerimiento_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'sast.ttipo_requerimiento'
 AUTOR: 		 (rortiz)
 FECHA:	        18-11-2011 15:23:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_tipo_requerimiento integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
			    
BEGIN

    v_nombre_funcion = 'sast.f_tipo_requerimiento_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'ST_TIPREQ_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		18-11-2011 15:23:30
	***********************************/

	if(p_transaccion='ST_TIPREQ_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into sast.ttipo_requerimiento(			
			id_usuario_reg,
            id_usuario_mod,
            fecha_reg,
            fecha_mod,
            estado_reg,
            nombre	           			
          	) values(          
			p_id_usuario,
            null,
            now()::date,
            null,
            'activo',
			v_parametros.nombre
            
			)RETURNING id_tipo_requerimiento into v_id_tipo_requerimiento;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida almacenado(a) con exito (id_tipo_requerimiento'||v_id_tipo_requerimiento||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_requerimiento',v_id_tipo_requerimiento::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'ST_TIPREQ_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		18-11-2011 15:23:30
	***********************************/

	elsif(p_transaccion='ST_TIPREQ_MOD')then

		begin
			--Sentencia de la modificacion
			update sast.ttipo_requerimiento set
			nombre = v_parametros.nombre,
			fecha_mod = now()::date,
			id_usuario_mod = p_id_usuario
			where id_tipo_requerimiento=v_parametros.id_tipo_requerimiento;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_requerimiento',v_parametros.id_tipo_requerimiento::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'ST_TIPREQ_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		18-11-2011 15:23:30
	***********************************/

	elsif(p_transaccion='ST_TIPREQ_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from sast.ttipo_requerimiento
            
             --rortiz 03-10-11 estado inactivo en vez de eliminar el registro
            UPDATE sast.ttipo_requerimiento
            SET estado_reg = 'inactivo'
            where id_tipo_requerimiento=v_parametros.id_tipo_requerimiento;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_requerimiento',v_parametros.id_tipo_requerimiento::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION sast.ft_tipo_requerimiento_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rvasquez;

--
-- TOC entry 1212 (class 1255 OID 2014222)
-- Dependencies: 92 2435
-- Name: ft_tipo_requerimiento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: sast; Owner: rvasquez
--

CREATE FUNCTION ft_tipo_requerimiento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		sast.ttipo_requerimiento
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'sast.ttipo_requerimiento'
 AUTOR: 		rortiz
 FECHA:	        18-11-2011 15:23:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE
	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'sast.f_ttipo_requerimiento_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'ST_TIPREQ_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			rortiz	
 	#FECHA:			18-11-2011 15:23:30
	***********************************/

	if(p_transaccion='ST_TIPREQ_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						tipreq.id_tipo_requerimiento,
                        tipreq.nombre,
                        tipreq.estado_reg,		
                        tipreq.id_usuario_reg,
                        tipreq.fecha_reg,
						tipreq.id_usuario_mod,						
						tipreq.fecha_mod,																	
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod											
						from sast.ttipo_requerimiento tipreq
                        inner join segu.tusuario usu1 on usu1.id_usuario = tipreq.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipreq.id_usuario_mod                        					
				        where tipreq.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;   

	/*********************************    
 	#TRANSACCION:  'ST_TIPREQ_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rortiz	
 	#FECHA:		18-11-2011 
	***********************************/

	elsif(p_transaccion='ST_TIPREQ_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_requerimiento)
					    from sast.ttipo_requerimiento tipreq
					    inner join segu.tusuario usu1 on usu1.id_usuario = tipreq.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipreq.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
        				
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION sast.ft_tipo_requerimiento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rvasquez;

SET search_path = secont, pg_catalog;

--
-- TOC entry 147 (class 1255 OID 16618)
-- Dependencies: 13 2435
-- Name: f_cambiar_estado_requerimiento(character varying, integer, text); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_cambiar_estado_requerimiento(par_tipo_cambio character varying, par_id_requerimiento integer, par_observaciones text) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nombre_funcion            text;
v_mensaje_error             text;
v_indice_actual             integer;
v_id_estado_siguiente       integer;
v_id_estado_requerimiento   integer;
BEGIN
v_nombre_funcion:='secont.f_cambiar_estado_requerimiento';

if(par_tipo_cambio='siguiente')then
    select  e.orden,er.id_estado_requerimiento into v_indice_actual,v_id_estado_requerimiento from secont.estado_requerimiento er inner join secont.estado e on (e.id_estado=er.id_estado)
    where er.id_requerimiento=par_id_requerimiento
    and er.estado_reg='activo';

    select e.id_estado into v_id_estado_siguiente from secont.estado e where e.orden=v_indice_actual+1;
    
    if(v_id_estado_siguiente is not null)then
        update secont.estado_requerimiento set estado_reg='inactivo',fecha_fin=now() where id_estado_requerimiento=v_id_estado_requerimiento;

        insert into secont.estado_requerimiento (id_requerimiento,id_estado,fecha_ini,estado_reg,observaciones)
        values(par_id_requerimiento,v_id_estado_siguiente,now(),'activo',par_observaciones);
    else
        raise exception 'No existe estado siguiente para el requerimiento: %',par_id_requerimiento;

    end if;

elsif(par_tipo_cambio='anterior')then

    select  e.orden,er.id_estado_requerimiento into v_indice_actual,v_id_estado_requerimiento from secont.estado_requerimiento er inner join secont.estado e on (e.id_estado=er.id_estado)
    where er.id_requerimiento=par.id_requerimiento
    and er.estado_reg='activo';
    
    select e.id_estado into v_id_estado_siguiente from secont.estado e where e.orden=v_indice_actual-1;

    if(v_id_estado_siguiente is not null)then
        update secont.estado_requerimiento set estado_reg='inactivo',fecha_fin=now() where id_estado_requerimiento=v_id_estado_requerimiento;

        insert into secont.estado_requerimiento (id_requerimiento,id_estado,fecha_ini,estado_reg,observaciones)
        values(par_id_requerimiento,v_id_estado_siguiente,now(),'activo',par_observaciones);
    else
        raise exception 'No existe estado anterior para el requerimiento: %',par_id_requerimiento;

    end if;
ELSE

    raise exception 'No existe el cambio: %',par_tipo_cambio;

end if;
    
    return 'exito';
    
    
EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null,null);
         raise exception '%', v_mensaje_error;
END;
$$;


ALTER FUNCTION secont.f_cambiar_estado_requerimiento(par_tipo_cambio character varying, par_id_requerimiento integer, par_observaciones text) OWNER TO rchumacero;

--
-- TOC entry 148 (class 1255 OID 16619)
-- Dependencies: 13 2435
-- Name: f_t_alarma_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_alarma_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_alarma_contrato           boolean;
v_alarma_garantia           boolean;


/*

 id_unidad 
 cod_unidad 
 nombre_unidad 
 gerencia_unidad 
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='secont.f_t_alarma_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_ALARMA_INS')then

          --consulta:=';
          BEGIN
               v_alarma_contrato=false;
               v_alarma_garantia=false;
               if(v_parametros.alarma_contrato='on')then
                    v_alarma_contrato=true;
               end if;

               if(v_parametros.alarma_garantia='on')then
                    v_alarma_garantia=true;
               end if;
               update secont.alarma set estado_reg='inactivo' where id_proyecto=v_parametros.id_proyecto and estado_reg='activo';
               
               insert into secont.alarma(id_proyecto,alarma_contrato,alarma_garantia,dias_contrato,dias_garantia,dias_proceso,fecha_reg,estado_reg,fecha_cambio)
               values(v_parametros.id_proyecto,v_alarma_contrato,v_alarma_garantia,v_parametros.dias_contrato,
               v_parametros.dias_garantia,v_parametros.dias_proceso,now(),'activo',v_parametros.fecha_cambio);

               return 'Unidad insertada con exito';

         END;

     elsif(par_transaccion='SCO_ALARMA_MOD')then

          --consulta:=';
          BEGIN

               v_alarma_contrato=false;
               v_alarma_garantia=false;
               if(v_parametros.alarma_contrato='on')then
                    v_alarma_contrato=true;
               end if;

               if(v_parametros.alarma_garantia='on')then
                    v_alarma_garantia=true;
               end if;
               
               update secont.alarma set alarma_contrato=v_alarma_contrato,
               alarma_garantia=v_alarma_garantia,
               dias_contrato=v_parametros.dias_contrato,
               dias_garantia=v_parametros.dias_garantia,
               dias_proceso=v_parametros.dias_proceso,
               fecha_cambio=v_parametros.fecha_cambio
               where id_alarma=v_parametros.id_alarma;
               return 'Alarma modificada con exito';
          END;

     elsif(par_transaccion='SCO_ALARMA_ELI')then

          --consulta:=';
          BEGIN

               update secont.alarma set estado_reg='inactivo'
               where id_alarma=v_parametros.id_alarma;
               return 'Alarma eliminada con exito';
          END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_alarma_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 149 (class 1255 OID 16620)
-- Dependencies: 13 2435
-- Name: f_t_alarma_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_alarma_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_alarma_sel';


     if(par_transaccion='SCO_ALARMA_SEL')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select id_alarma,p.id_proyecto,denominacion,
               case
               when (alarma_contrato)then
                    ''true''::varchar
               ELSE
                   ''false''::varchar
               end,
               case
               when (alarma_garantia)then
                    ''true''::varchar
               ELSE
                   ''false''::varchar
               end,dias_contrato,dias_garantia,dias_proceso,a.fecha_reg,a.estado_reg,a.fecha_cambio
               from secont.alarma a inner join secont.proyecto p on (p.id_proyecto=a.id_proyecto) where a.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_ALARMA_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(a.id_alarma)
               from secont.alarma a inner join secont.proyecto p on (p.id_proyecto=a.id_proyecto) where a.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_alarma_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 150 (class 1255 OID 16621)
-- Dependencies: 13 2435
-- Name: f_t_contratista_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_contratista_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;


/*

 id_unidad 
 cod_unidad 
 nombre_unidad 
 gerencia_unidad 
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='secont.f_t_contratista_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_TRATISTA_INS')then

          --consulta:=';
          BEGIN

               
               if(v_parametros.tipo='Persona Natural')then
                   insert into secont.contratista (id_persona,nit,tipo,obs,estado_reg)
                   values(v_parametros.id_persona,v_parametros.nit,
                   v_parametros.tipo,v_parametros.obs,'activo');
               ELSE
                    insert into secont.contratista (id_persona_juridica,id_persona,nit,tipo,obs,estado_reg)
                   values(v_parametros.id_persona_juridica,v_parametros.id_persona,v_parametros.nit,
                   v_parametros.tipo,v_parametros.obs,'activo');
               end if;
               
               return 'Contratista insertado con exito';

         END;

     elsif(par_transaccion='SCO_TRATISTA_MOD')then

          --consulta:=';
          BEGIN
               if(v_parametros.tipo='Persona Natural')then
                    update secont.contratista set id_persona_juridica=null,
                    id_persona=v_parametros.id_persona,
                    nit=v_parametros.nit,
                    tipo=v_parametros.tipo,
                    obs=v_parametros.obs
                    where id_contratista=v_parametros.id_contratista;
               ELSE
                     update secont.contratista set id_persona_juridica=v_parametros.id_persona_juridica,
                     id_persona=null,
                     nit=v_parametros.nit,
                     tipo=v_parametros.tipo,
                     obs=v_parametros.obs

               where id_contratista=v_parametros.id_contratista;
               end if;


              
               return 'Contratista modificado con exito';
          END;

    elsif(par_transaccion='SCO_TRATISTA_ELI')then

          --consulta:=';
          BEGIN
               update secont.contratista set estado_reg='inactivo'
               where id_contratista=v_parametros.id_contratista;
               return 'Contratista eliminado con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_contratista_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 152 (class 1255 OID 16622)
-- Dependencies: 13 2435
-- Name: f_t_contratista_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_contratista_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_contratista_sel';


     if(par_transaccion='SCO_TRATISTA_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:=' select c.id_contratista,
                             c.id_persona_juridica,
                             c.id_persona,
                             c.nit,
                             c.tipo,
                             c.obs,
                             c.nombre,
                             c.nombre_institucion,
                             c.nombre_persona
                             from secont.v_contratista c
                             where c.estado_reg=''activo'' and ';
                             v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
 return v_consulta;


         END;


     elsif(par_transaccion='SCO_TRATISTA_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(c.id_contratista)
               from secont.v_contratista c
               where c.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opción';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_contratista_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 153 (class 1255 OID 16623)
-- Dependencies: 13 2435
-- Name: f_t_contrato_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_contrato_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion       text;
v_mensaje_error        text;

v_id_repre             integer;
/*

 id_unidad
 cod_unidad
 nombre_unidad
 gerencia_unidad
 estado_reg

*/

BEGIN


     v_nombre_funcion:='secont.f_t_contrato_ime';
     v_parametros:=f_get_record(par_tabla);
     
     

     if(par_transaccion='SCO_CONTRA_INS')then
     v_id_repre:=(select id_representante from secont.representante where id_contratista=v_parametros.id_representante and estado_reg='activo');

     if(v_id_repre is null)then
                   raise exception 'No existe representante legal para el contratista';
     end if;
     
          BEGIN
          
               insert into secont.contrato(id_representante,
                                           id_empleado,
                                           id_proyecto,
                                           emp_id_empleado,
                                           numero,
                                           objeto,
                                           gerencia,
                                           moneda,
                                           monto_cifra,
                                           multas,
                                           forma_pago,
                                           origen_recursos,
                                           fecha_ini,
                                           fecha_fin,
                                           forma_contratacion,
                                           tipo_contrato,
                                           doc_contrato,
                                           numero_licitacion,
                                           numero_cuce,
                                           lugar_sus,
                                           fecha_sus,
                                           obs,
                                           intermediario,
                                           estado_reg,
                                           beneficiario,
                                           id_requerimiento
                                           )
               values(v_id_repre,
                                           
                                           v_parametros.emp_id_empleado,
                                           v_parametros.id_proyecto,
                                           v_parametros.emp_id_empleado,
                                           v_parametros.numero,
                                           v_parametros.objeto,
                                           v_parametros.gerencia,
                                           v_parametros.moneda,
                                           v_parametros.monto_cifra,
                                           v_parametros.multas,
                                           v_parametros.forma_pago,
                                           v_parametros.origen_recursos,
                                           v_parametros.fecha_ini,
                                           v_parametros.fecha_fin,
                                           v_parametros.forma_contratacion,
                                           v_parametros.tipo_contrato,
                                           v_parametros.doc_contrato,
                                           v_parametros.numero_licitacion,
                                           v_parametros.numero_cuce,
                                           v_parametros.lugar_sus,
                                           v_parametros.fecha_sus,
                                           v_parametros.obs,
                                           v_parametros.intermediario,
                                           'activo',
                                           v_parametros.beneficiario,
                                           v_parametros.id_requerimiento);

               update secont.requerimiento set num_contrato=v_parametros.numero
               where id_requerimiento=v_parametros.id_requerimiento;

               return 'Contrato insertado con exito';
         END;

     elsif(par_transaccion='SCO_CONTRA_MOD')then

          --consulta:=';
          BEGIN
          
           v_id_repre:=(select id_representante from secont.representante where id_contratista=v_parametros.id_representante and estado_reg='activo');

     if(v_id_repre is null)then
                   raise exception 'No existe representante legal para el contratista';
     end if;

               update secont.contrato set
                      id_representante=v_id_repre,
                      id_empleado     =v_parametros.id_empleado,
                      id_proyecto     =v_parametros.id_proyecto,
                      emp_id_empleado =v_parametros.emp_id_empleado,
                      numero          =v_parametros.numero,
                      objeto          =v_parametros.objeto,
                      gerencia        =v_parametros.gerencia,
                      moneda          =v_parametros.moneda,
                      monto_cifra     =v_parametros.monto_cifra,
                      multas          =v_parametros.multas,
                      forma_pago      =v_parametros.forma_pago,
                      origen_recursos =v_parametros.origen_recursos,
                      fecha_ini       =v_parametros.fecha_ini,
                      fecha_fin       =v_parametros.fecha_fin,
                      forma_contratacion=v_parametros.forma_contratacion,
                      tipo_contrato   =v_parametros.tipo_contrato,
                      doc_contrato    =v_parametros.doc_contrato,
                      numero_licitacion=v_parametros.numero_licitacion,
                      numero_cuce     =v_parametros.numero_cuce,
                      lugar_sus       =v_parametros.lugar_sus,
                      fecha_sus       =v_parametros.fecha_sus,
                      obs             =v_parametros.obs,
                      intermediario   =v_parametros.intermediario,
                      beneficiario    =v_parametros.beneficiario,
                      id_requerimiento=v_parametros.id_requerimiento
               where id_contrato=v_parametros.id_contrato;

               update secont.requerimiento set num_contrato=v_parametros.numero
               where id_requerimiento=v_parametros.id_requerimiento;
               
               return 'Contrato modificado con exito';
          END;

    elsif(par_transaccion='SCO_CONTRA_ELI')then

          --consulta:=';
          BEGIN
               update secont.contrato
               set estado_reg='inactivo'
               where id_contrato=v_parametros.id_contrato;

               return 'Contrato eliminado con exito';
         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_contrato_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 154 (class 1255 OID 16624)
-- Dependencies: 13 2435
-- Name: f_t_contrato_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_contrato_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_contrato_sel';


     if(par_transaccion='SCO_CONTRA_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select c.id_contrato,
                                   c.id_representante,
                                   c.id_empleado,
                                   c.id_proyecto,
                                   c.emp_id_empleado,
                                   c.numero,
                                   c.objeto,
                                   c.gerencia,
                                   c.moneda,
                                   c.monto_cifra,
                                   c.multas,
                                   c.forma_pago,
                                   c.origen_recursos,
                                   c.fecha_ini,
                                   c.fecha_fin,
                                   c.forma_contratacion,
                                   c.tipo_contrato,
                                   c.doc_contrato,
                                   c.numero_licitacion,
                                   c.numero_cuce,
                                   c.lugar_sus,
                                   c.fecha_sus,
                                   c.obs,
                                   c.intermediario,
                                   c.estado_reg,
                                   c.beneficiario,
                                   c.id_requerimiento ,
                                   con.nombre as contratista,
                                   abo.nombre_completo1 as abogado,
                                   p.denominacion as proyecto,
                                   resp_contrata.nombre_completo1 as resp_contratacion,
                                   req.descripcion as requerimiento
               from secont.contrato c
                                   inner join secont.v_empleado abo
                                   on abo.id_personal=c.id_empleado
                                   and abo.estado_reg=''activo''
                                   inner join secont.proyecto p
                                   on p.id_proyecto=c.id_proyecto
                                   and p.estado_reg=''activo''
                                   inner join secont.representante r
                                   on r.id_representante=c.id_representante
                                   and r.estado_reg=''activo''
                                   inner join secont.v_contratista con
                                   on con.id_contratista=r.id_contratista
                                   and con.estado_reg=''activo''
                                   inner join secont.v_empleado resp_contrata
                                   on resp_contrata.id_personal=c.emp_id_empleado
                                   and resp_contrata.estado_reg=''activo''
                                   inner join secont.v_requerimiento req
                                   on req.id_requerimiento=c.id_requerimiento
                                   and req.estado_reg=''activo''
                                   where c.estado_reg=''activo''
                                   and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_CONTRA_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(c.id_contrato)
                            from secont.contrato c
                            inner join secont.v_empleado abo
                            on abo.id_personal=c.id_empleado
                            and abo.estado_reg=''activo''
                            inner join secont.proyecto p
                            on p.id_proyecto=c.id_proyecto
                            and p.estado_reg=''activo''
                            inner join secont.representante r
                            on r.id_representante=c.id_representante
                            and r.estado_reg=''activo''
                            inner join secont.v_contratista con
                            on con.id_contratista=r.id_contratista
                            and con.estado_reg=''activo''
                            inner join secont.v_empleado resp_contrata
                            on resp_contrata.id_personal=c.emp_id_empleado
                            and resp_contrata.estado_reg=''activo''
                            inner join secont.v_requerimiento req
                            on req.id_requerimiento=c.id_requerimiento
                            and req.estado_reg=''activo''
                            where c.estado_reg=''activo''
                            and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_contrato_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 155 (class 1255 OID 16625)
-- Dependencies: 13 2435
-- Name: f_t_empleado_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_empleado_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;


/*

  id_personal
  id_persona
  id_unidad
  cod_empleado
  oficina
  regional
  gerencia
  cargo
  obs
  estado_reg

*/

BEGIN

     v_nombre_funcion:='secont.f_t_empleado_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_EMPLEA_INS')then

          --consulta:=';
          BEGIN

               
               
               insert into secont.empleado (id_persona,id_unidad,cod_empleado,oficina,regional,gerencia,
               cargo,obs,estado_reg)
               values(v_parametros.id_persona,v_parametros.id_unidad,v_parametros.cod_empleado,v_parametros.oficina,
               v_parametros.regional,v_parametros.gerencia,v_parametros.cargo,v_parametros.obs,'activo');
               
               return 'Empleado insertado con exito';

         END;

     elsif(par_transaccion='SCO_EMPLEA_MOD')then

          --consulta:=';
          BEGIN

               update secont.empleado set id_persona=v_parametros.id_persona,
               id_unidad=v_parametros.id_unidad,
               cod_empleado=v_parametros.cod_empleado,
               oficina=v_parametros.oficina,
               regional=v_parametros.regional,
               gerencia=v_parametros.gerencia,
               cargo=v_parametros.cargo,
               obs=v_parametros.obs
               where id_personal=v_parametros.id_personal;
               return 'Empleado modificado con exito';
          END;

    elsif(par_transaccion='SCO_EMPLEA_ELI')then

          --consulta:=';
          BEGIN
               update secont.empleado set estado_reg='inactivo'
               where id_personal=v_parametros.id_personal;
               return 'Empleado eliminado con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_empleado_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 156 (class 1255 OID 16626)
-- Dependencies: 13 2435
-- Name: f_t_empleado_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_empleado_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_empleado_sel';


     if(par_transaccion='SCO_EMPLEA_SEL')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select id_persona,
                            ap_materno,
                            ap_paterno,
                                nombre,
                                    ci,
                            id_personal,
                            cod_empleado,
                                    cargo,
                                estado_reg,
                                gerencia,
                                oficina,
                                regional,
                                    obs,
                        nombre_completo1,
                        nombre_completo2,
                        id_unidad,
                        nombre_unidad
                        from secont.v_empleado e where estado_reg=''activo'' and ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='SCO_EMPLEA_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(e.id_personal) from secont.v_empleado e where estado_reg=''activo'' and  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_empleado_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 157 (class 1255 OID 16627)
-- Dependencies: 13 2435
-- Name: f_t_estado_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_estado_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;


/*

 id_unidad 
 cod_unidad 
 nombre_unidad 
 gerencia_unidad 
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='secont.f_t_estado_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_ESTADO_INS')then

          --consulta:=';
          BEGIN

               
               
               insert into secont.estado (nombre_estado,desc_estado,orden,rango_inf,rango_sup,estado_reg)
               values(v_parametros.nombre_estado,v_parametros.desc_estado,v_parametros.orden,
               v_parametros.rango_inf,v_parametros.rango_sup,'activo');
               
               return 'Estado insertado con exito';

         END;

     elsif(par_transaccion='SCO_ESTADO_MOD')then

          --consulta:=';
          BEGIN
                
               update secont.estado set nombre_estado=v_parametros.nombre_estado,
               desc_estado=v_parametros.desc_estado,
               orden=v_parametros.orden,
               rango_inf=v_parametros.rango_inf,
               rango_sup=v_parametros.rango_sup
               
               where id_estado=v_parametros.id_estado;
               return 'Estado modificado con exito';
          END;

    elsif(par_transaccion='SCO_ESTADO_ELI')then

          --consulta:=';
          BEGIN
               update secont.estado set estado_reg='inactivo'
               where id_estado=v_parametros.id_estado;
               return 'Estado eliminada con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_estado_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 158 (class 1255 OID 16628)
-- Dependencies: 13 2435
-- Name: f_t_estado_requerimiento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_estado_requerimiento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_estado_requerimiento_sel';


     if(par_transaccion='SCO_REPHIS_SEL')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select *
               from secont.v_estado_requerimiento er where ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_estado_requerimiento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 159 (class 1255 OID 16629)
-- Dependencies: 13 2435
-- Name: f_t_estado_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_estado_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_estado_sel';


     if(par_transaccion='SCO_ESTADO_SEL')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select * from secont.estado e where e.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
              
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_ESTADO_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(e.id_estado) from secont.estado e where estado_reg=''activo'' and  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_estado_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 160 (class 1255 OID 16630)
-- Dependencies: 13 2435
-- Name: f_t_garantia_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_garantia_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;


/*

  id_garantia
  id_contrato
  tipo
  numero
  orden
  moneda
  monto_cifra
  fecha_vencimiento
  banco
  fecha_sus
  lugar_suc
  obs
  doc_garantia
  estado_reg

*/

BEGIN

     v_nombre_funcion:='secont.f_t_garantia_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_REQUER_INS')then

          --consulta:=';
          BEGIN

               
               
               insert into secont.garantia (id_contrato,tipo,numero,orden,moneda,monto_cifra,
               fecha_vencimiento,banco,fecha_sus,lugar_suc,obs,doc_garantia,estado_reg)
               values(v_parametros.id_contrato,v_parametros.tipo,v_parametros.numero,v_parametros.orden,v_parametros.moneda,
               v_parametros.monto_cifra,v_parametros.fecha_vencimiento,v_parametros.banco,v_parametros.fecha_sus,
               v_parametros.lugar_suc,v_parametros.obs,v_parametros.doc_garantia,'activo');
               
               return 'Garantia insertada con exito';

         END;

     elsif(par_transaccion='SCO_REQUER_MOD')then

          --consulta:=';
          BEGIN

               update secont.garantia set
               tipo=v_parametros.tipo,
               numero=v_parametros.numero,
               orden=v_parametros.orden,
               moneda=v_parametros.moneda,
               monto_cifra=v_parametros.monto_cifra,
               fecha_vencimiento=v_parametros.fecha_vencimiento,
               banco=v_parametros.banco,
               fecha_sus=v_parametros.fecha_sus,
               lugar_suc=v_parametros.lugar_suc,
               obs=v_parametros.obs,
               doc_garantia=v_parametros.doc_garantia
               where id_garantia=v_parametros.id_garantia;
               return 'Garantia modificada con exito';
          END;

    elsif(par_transaccion='SCO_REQUER_ELI')then

          --consulta:=';
          BEGIN
               update secont.garantia set estado_reg='inactivo'
               where id_garantia=v_parametros.id_garantia;
               return 'Garantia eliminada con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_garantia_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 161 (class 1255 OID 16631)
-- Dependencies: 13 2435
-- Name: f_t_garantia_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_garantia_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_garantia_sel';


     if(par_transaccion='SCO_GARANTIA_SEL')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select g.id_garantia,g.id_contrato,
                                    g.tipo,g.numero,
                                    g.orden,g.moneda,g.monto_cifra,
                                    g.fecha_vencimiento,g_banco,g.fecha_sus,g.obs,c.numero
                                    from secont.garantia g
                                    inner join secont.contrato c on(c.id_contrato=g.id_contrato)
                                    where estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta|| ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_GARANTIA_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(g.id_garantia) from secont.garantia g
                                    inner join secont.contrato c on(c.id_contrato=g.id_contrato)
                                    where estado_reg=''activo'' and  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_garantia_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 162 (class 1255 OID 16632)
-- Dependencies: 13 2435
-- Name: f_t_persona_juridica_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_persona_juridica_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;


/*

 id_persona_juridica
 nombre
 domicilio
 telefono
 correo
 pag_web
 obs
 estado_reg
*/

BEGIN

     v_nombre_funcion:='secont.f_t_persona_juridica_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_PERJUR_INS')then

          --consulta:=';
          BEGIN

               
               
               insert into secont.persona_juridica (nombre,domicilio,telefono,correo,pag_web,obs,estado_reg)
               values(v_parametros.nombre,v_parametros.domicilio,v_parametros.telefono,v_parametros.correo,v_parametros.pag_web,v_parametros.obs,'activo');
               
               return 'Persona Juridica insertada con exito';

         END;

     elsif(par_transaccion='SCO_PERJUR_MOD')then

          --consulta:=';
          BEGIN

               update secont.persona_juridica set nombre=v_parametros.nombre,
               domicilio=v_parametros.domicilio,
               telefono=v_parametros.telefono,
               correo=v_parametros.correo,
               pag_web=v_parametros.pag_web,
               obs=v_parametros.obs
               where id_persona_juridica=v_parametros.id_persona_juridica;
               return 'Persona Juridica modificada con exito';
          END;

    elsif(par_transaccion='SCO_PERJUR_ELI')then

          --consulta:=';
          BEGIN
               update secont.persona_juridica set estado_reg='inactivo'
               where id_persona_juridica=v_parametros.id_persona_juridica;
               return 'Persona Juridica eliminada con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_persona_juridica_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 164 (class 1255 OID 16633)
-- Dependencies: 13 2435
-- Name: f_t_persona_juridica_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_persona_juridica_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_persona_juridica_sel';


     if(par_transaccion='SCO_PERJUR_SEL')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select * from secont.persona_juridica pj where estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta || ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_PERJUR_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(pj.id_persona_juridica) from secont.persona_juridica pj where estado_reg=''activo'' and  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_persona_juridica_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 165 (class 1255 OID 16634)
-- Dependencies: 13 2435
-- Name: f_t_proyecto_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_proyecto_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

    v_nro_requerimiento    	integer;
    v_parametros           	record;
    v_id_requerimiento     	integer;
    v_resp		            varchar;
    v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_proyecto			integer;


/*

 id_proyecto
 denominacion 
 descripcion
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='secont.f_t_proyecto_ime';
     v_parametros:=f_get_record(p_tabla);

     if(p_transaccion='SCO_PROYEC_INS')then

          --consulta:=';
          BEGIN
				
               v_id_proyecto = nextval('secont.proyecto_id_proyecto_seq'::regclass);
               
               insert into secont.proyecto (id_proyecto,denominacion,descripcion,estado_reg)
               values(v_id_proyecto,v_parametros.denominacion,v_parametros.descripcion,'activo');
               
               --v_mensaje_error = f1();

			   v_resp = f_agrega_clave(v_resp,'mensaje','Proyecto almacenado'); 
               v_resp = f_agrega_clave(v_resp,'id_proyecto',v_id_proyecto::varchar);

               return v_resp;

         END;

     elsif(p_transaccion='SCO_PROYEC_MOD')then

          BEGIN
				v_id_proyecto = 3/0;
               update secont.proyecto set denominacion=v_parametros.denominacion,
               descripcion=v_parametros.descripcion
               where id_proyecto=v_parametros.id_proyecto;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Proyecto modificado'); 
               v_resp = f_agrega_clave(v_resp,'id_proyecto',v_parametros.id_proyecto::varchar);
               
               return v_resp;
          END;

    elsif(p_transaccion='SCO_PROYEC_ELI')then

          --consulta:=';
          BEGIN
               --raise exception 'Error al eliminar';
               update secont.proyecto set estado_reg='inactivo'
               where id_proyecto=v_parametros.id_proyecto;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Proyecto eliminado'); 
               v_resp = f_agrega_clave(v_resp,'id_proyecto',v_parametros.id_proyecto::varchar);
              
               return v_resp;
         END;
         
     else
     
         raise exception 'Transacción inexistente: %',p_transaccion;

     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION secont.f_t_proyecto_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 166 (class 1255 OID 16635)
-- Dependencies: 13 2435
-- Name: f_t_proyecto_ime_orig(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_proyecto_ime_orig(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;


/*

 id_proyecto
 denominacion 
 descripcion
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='secont.f_t_proyecto_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_PROYEC_INS')then

          --consulta:=';
          BEGIN

               
               
               insert into secont.proyecto (denominacion,descripcion,estado_reg)
               values(v_parametros.denominacion,v_parametros.descripcion,'activo');
               
               return 'Proyecto insertada con exito';

         END;

     elsif(par_transaccion='SCO_PROYEC_MOD')then

          --consulta:=';
          BEGIN

               update secont.proyecto set denominacion=v_parametros.denominacion,
               descripcion=v_parametros.descripcion
               where id_proyecto=v_parametros.id_proyecto;
               return 'Proyecto modificada con exito';
          END;

    elsif(par_transaccion='SCO_PROYEC_ELI')then

          --consulta:=';
          BEGIN
               --raise exception 'Error al eliminar';
               update secont.proyecto set estado_reg='inactivo'
               where id_proyecto=v_parametros.id_proyecto;
               return 'Proyecto eliminada con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_proyecto_ime_orig(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 167 (class 1255 OID 16636)
-- Dependencies: 13 2435
-- Name: f_t_proyecto_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_proyecto_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_proyecto_sel';


     if(par_transaccion='SCO_PROYEC_SEL')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select * from secont.proyecto p where estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_PROYEC_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(p.id_proyecto) from secont.proyecto p where estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_proyecto_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 168 (class 1255 OID 16637)
-- Dependencies: 13 2435
-- Name: f_t_representante_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_representante_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;


/*

 id_unidad 
 cod_unidad 
 nombre_unidad 
 gerencia_unidad 
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='secont.f_t_representante_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_REPRES_INS')then

          --consulta:=';
          BEGIN

               
               
               insert into secont.representante (id_contratista,cargo,respaldo,estado_reg,obs,id_persona)
               values(v_parametros.id_contratista,v_parametros.cargo,v_parametros.respaldo,
               'activo',v_parametros.obs,v_parametros.id_persona);
               
               return 'Representante insertado con exito';

         END;

     elsif(par_transaccion='SCO_REPRES_MOD')then

          --consulta:=';
          BEGIN

               update secont.representante set cargo=v_parametros.cargo,
               respaldo=v_parametros.respaldo,
               obs=v_parametros.obs,
               id_persona=v_parametros.id_persona
               where id_representante=v_parametros.id_representante;
               return 'Representante modificado con exito';
          END;

    elsif(par_transaccion='SCO_REPRES_ELI')then

          --consulta:=';
          BEGIN
               update secont.representante set estado_reg='inactivo'
               where id_representante=v_parametros.id_representante;
               return 'Representante eliminado con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_representante_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 169 (class 1255 OID 16638)
-- Dependencies: 13 2435
-- Name: f_t_representante_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_representante_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_representante_sel';


     if(par_transaccion='SCO_REPRES_SEL')then

          --consulta:=';
          BEGIN
               --raise exception 'llega';
               v_consulta:=' select r.id_representante,
                             r.id_contratista,r.cargo,
                             r.respaldo,r.obs,
                             r.id_persona,
                             p.ci,
                             p.nombre_completo1,
                             c.nombre
                             from secont.representante r inner join segu.v_persona p on(r.id_persona=p.id_persona)
                             inner join secont.v_contratista c on (r.id_contratista=c.id_contratista)
                             where r.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_REPRES_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(r.id_representante)
               from secont.representante r inner join segu.v_persona p on(r.id_persona=p.id_persona)
               inner join secont.v_contratista c on (r.id_contratista=c.id_contratista)
               where r.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opción';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_representante_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 163 (class 1255 OID 16639)
-- Dependencies: 13 2435
-- Name: f_t_requerimiento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_requerimiento_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_id_personal          integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_nro_contrato              numeric;


/*

id_requerimiento
id_personal
emp_id_personal
fecha_requerimiento
hora_requerimiento
descripcion
estado_reg
num_contrato
id_unidad
nro_requerimiento

*/

BEGIN

     v_nombre_funcion:='secont.f_t_requerimiento_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_REQUER_INS')then

          --consulta:=';
          BEGIN
               select id_personal into v_id_personal from secont.v_empleado
               where id_persona=(select id_persona from segu.usuario where id_usuario=par_id_usuario);
               if(v_id_personal is null)then
                                raise exception 'El usuario que registra el requerimiento no es empleado';
               end if;

               v_nro_requerimiento:=(select coalesce(max(nro_requerimiento),0) from secont.requerimiento
               where id_unidad=v_parametros.id_unidad)::integer;
               v_nro_requerimiento=v_nro_requerimiento+1;
               v_id_requerimiento:=(select nextval('secont.requerimiento_id_requerimiento_seq'));
               --raise exception '%',v_nro_requerimiento;
               insert into secont.requerimiento (id_requerimiento,id_personal,fecha_requerimiento,hora_requerimiento,
               descripcion,estado_reg,id_unidad,nro_requerimiento)
               values(v_id_requerimiento,v_id_personal,now()::date,now()::time,v_parametros.descripcion,
               'activo',v_parametros.id_unidad,v_nro_requerimiento);
               
               insert into secont.estado_requerimiento (id_requerimiento,id_estado,fecha_ini,estado_reg,observaciones)
               values(v_id_requerimiento,0,now(),'activo','Primer estado del requerimiento');
               
               return 'Requerimiento insertado con exito';

         END;

     elsif(par_transaccion='SCO_REQUER_MOD')then

          --consulta:=';
          BEGIN

               update secont.requerimiento set descripcion=v_parametros.descripcion,
               id_unidad=v_parametros.id_unidad
               
               where id_requerimiento=v_parametros.id_requerimiento;
               return 'Requerimiento modificado con exito';
          END;

     elsif(par_transaccion='SCO_RESIEST_MOD')then

          --consulta:=';
          BEGIN
               
               update secont.requerimiento set
               emp_id_personal=v_parametros.emp_id_personal
               where id_requerimiento=v_parametros.id_requerimiento;
               
               v_respuesta:=secont.f_cambiar_estado_requerimiento('siguiente',v_parametros.id_requerimiento,v_parametros.observaciones);
                
               return 'Estado cambiado con exito para el requerimiento';

         END;

     elsif(par_transaccion='SCO_RESIASI_MOD')then

          --consulta:=';
          BEGIN
          
               update secont.requerimiento set emp_id_personal=v_parametros.emp_id_personal
               where id_requerimiento=parametros.id_requerimiento;
               
               v_respuesta:=secont.f_cambiar_estado_requerimiento('siguiente',v_parametros.id_requerimiento,v_parametros.observaciones);
               return 'Estado cambiado con exito para el requerimiento: %',v_parametros.id_requerimiento;

         END;

     elsif(par_transaccion='SCO_REANEST_MOD')then

          --consulta:=';
          BEGIN
               v_respuesta:=secont.f_cambiar_estado_requerimiento('anterior',v_parametros.id_requerimiento,v_parametros.observaciones);
               return 'Estado cambiado con exito para el requerimeinto: %',v_parametros.id_requerimiento;

         END;

     elsif(par_transaccion='SCO_REQUER_ELI')then

          --consulta:=';
          BEGIN
               update secont.requerimiento set estado_reg='inactivo'
               where id_requerimiento=v_parametros.id_requerimiento;
               return 'Requerimiento eliminado con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_requerimiento_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 170 (class 1255 OID 16640)
-- Dependencies: 13 2435
-- Name: f_t_requerimiento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_requerimiento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_id_persona       integer;
v_cargo            varchar;

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_primo_sel';
    
     
     if(par_transaccion='SCO_REQSEG_SEL')then

          --consulta:=';
          BEGIN
               select id_persona into v_id_persona  from segu.usuario where id_usuario=par_id_usuario;
               select e.cargo into v_cargo from secont.empleado e where id_persona=v_id_persona and estado_reg='activo';
               v_consulta:='select * from secont.v_requerimiento r where estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;

               if(par_administrador!=1 and v_cargo!='Jefe Departamento Legal')then
                   v_consulta:=v_consulta||' and (r.id_unidad in (select id_unidad from secont.empleado e on (e.id_persona='|| v_id_persona ||' and e.estado_reg=''activo''))
                   or r.id_persona_abo='||v_id_persona||')';
               end if;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_REQSEG_CONT')then

          --consulta:=';
          BEGIN
               select id_persona into v_id_persona  from segu.usuario where id_usuario=par_id_usuario;
               select e.cargo into v_cargo from secont.empleado e where id_persona=v_id_persona and estado_reg='activo';
               v_consulta:='select count(r.id_requerimiento) from secont.v_requerimiento r where estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;

               if(par_administrador!=1 and v_cargo!='Jefe Departamento Legal')then
                    v_consulta:=v_consulta||' and (r.id_unidad in (select id_unidad from secont.empleado e on (e.id_persona='|| v_id_persona ||' and e.estado_reg=''activo''))
                   or r.id_persona_abo='||v_id_persona||')';
               end if;
               return v_consulta;


         END;

     else
         raise exception 'No existe la transaccion: %',par_transaccion;

     end if;
     
EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_requerimiento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 171 (class 1255 OID 16641)
-- Dependencies: 13 2435
-- Name: f_t_unidad_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_unidad_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;


/*

 id_unidad 
 cod_unidad 
 nombre_unidad 
 gerencia_unidad 
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='secont.f_t_unidad_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_UNIDAD_INS')then

          --consulta:=';
          BEGIN

               
               
               insert into secont.unidad (cod_unidad,nombre_unidad,gerencia_unidad,estado_reg)
               values(v_parametros.cod_unidad,v_parametros.nombre_unidad,v_parametros.gerencia_unidad,'activo');
               
               return 'Unidad insertada con exito';

         END;

     elsif(par_transaccion='SCO_UNIDAD_MOD')then

          --consulta:=';
          BEGIN

               update secont.unidad set cod_unidad=v_parametros.cod_unidad,
               nombre_unidad=v_parametros.nombre_unidad,
               gerencia_unidad=v_parametros.gerencia_unidad
               where id_unidad=v_parametros.id_unidad;
               return 'Unidad modificada con exito';
          END;

    elsif(par_transaccion='SCO_UNIDAD_ELI')then

          --consulta:=';
          BEGIN
               update secont.unidad set estado_reg='inactivo'
               where id_unidad=v_parametros.id_unidad;
               return 'Unidad eliminada con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_unidad_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 172 (class 1255 OID 16642)
-- Dependencies: 13 2435
-- Name: f_t_unidad_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION f_t_unidad_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_unidad_sel';


     if(par_transaccion='SCO_UNIDAD_SEL')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select * from secont.unidad u where estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta || ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_UNIDAD_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(u.id_unidad) from secont.unidad u where estado_reg=''activo'' and  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION secont.f_t_unidad_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 173 (class 1255 OID 16643)
-- Dependencies: 13 2435
-- Name: funcion1(); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION funcion1() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare


begin

raise exception 'veremos q pasa';


EXCEPTION
       
       WHEN OTHERS THEN
         --DBMS_OUTPUT.PUT_LINE("Error, abortando ejecucin.");
         raise exception '%,%',  SQLERRM,SQLSTATE;
         
     

end;
$$;


ALTER FUNCTION secont.funcion1() OWNER TO rchumacero;

--
-- TOC entry 174 (class 1255 OID 16644)
-- Dependencies: 13 2435
-- Name: prueba(); Type: FUNCTION; Schema: secont; Owner: rchumacero
--

CREATE FUNCTION prueba() RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$
DECLARE
	v varchar[];
    
BEGIN

	--v=array_append(v,f_forma_array('mensaje','Funcion ejecutada con exito'));
    --v=array_append(v,f_forma_array('id_clardad','12'));
    v=f_resp_array(v,'mensaje','Funcion ejecutada con exito');
    v=f_resp_array(v,'id_clardad','12');
    v=f_resp_array(v,'tipo','CEFALO');
    
--v[1][1]='adas';
--v[2][1]='sss';
--v[2]='CCC';
--v[1][2]='xxxx';
	--v='zxkczlkchzklhchhxzkxz';--'{{mensaje,todobien}'||',{id_col,5}}';
    /*v[0:0]='mensaje';
    v[0:1]='todovabien';
    v[1:0]='id_colasd';
    v[1:1]='123';*/
    
    --v=ARRAY[['mensaje','todovabien']['id_colasd','123']];
    
    return v;
END;
$$;


ALTER FUNCTION secont.prueba() OWNER TO rchumacero;

SET search_path = segu, pg_catalog;

--
-- TOC entry 321 (class 1255 OID 2981046)
-- Dependencies: 2435 14
-- Name: f_actualiza_persona_entre_bd(); Type: FUNCTION; Schema: segu; Owner: mzambrana
--

CREATE FUNCTION f_actualiza_persona_entre_bd() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_nombre_bd       varchar;
    v_nombre_usuario  varchar;
    v_id_usuario      integer;
    g_consulta        varchar;  
    v_id_tipo_doc     integer;
BEGIN
    
                     
    v_id_usuario:=1;


   SELECT P.id_tipo_doc_identificacion    into v_id_tipo_doc
   FROM dblink('hostaddr=10.172.0.13 port=5432 dbname=dbendesis user=db_link password=db_link',
                                             'select id_tipo_doc_identificacion from sss.tsg_tipo_doc_identificacion where nombre_tipo_documento ilike ''ci'' ') AS P(
                                                                                  "id_tipo_doc_identificacion" integer);   
   
 
                   
        IF TG_OP = 'INSERT' THEN
            BEGIN
                     
                 /*  if not exists (select P.id_persona from dblink('hostaddr=10.172.0.13 port=5432 dbname=dbendesis user=db_link password=db_link',
                                             'SELECT id_persona
                                               FROM sss.tsg_persona where id_persona='|| new.id_persona) AS P(
                                                                                 id_persona integer) ) then
                   raise exception 'en otra bd... cobra';
                          perform dblink_connect('hostaddr=10.172.0.13 port=5432 dbname=dbendesis user=db_link password=db_link');
                       --   perform dblink_exec ('LOCK TABLE sss.tsg_persona in SHARE ROW EXCLUSIVE MODE');        
                          perform dblink_exec('insert into sss.tsg_persona(id_persona , nombre , apellido_paterno
                                  
                                  , apellido_materno   
                                  ,doc_id, email1 , celular1 , telefono1, telefono2,celular2, extension,  genero
                                  , fecha_nacimiento, direccion     
                                  
                                  , id_tipo_doc_identificacion        
                                  )
                                  values ('||new.id_persona||','''||NEW.nombre||''','''||NEW.apellido_paterno||'''
                                   ,'''||NEW.apellido_materno||''' 
                                  ,'''||coalesce(new.ci,'')||''' ,'''||coalesce(new.correo,'')||''' ,'''||coalesce(new.celular1,'')||'''
                                   ,'''||coalesce(new.telefono1,'')||''','''||coalesce(new.telefono2,'')||''' ,'''||coalesce(new.celular2,'')||''',
                                  '''||coalesce(new.extension,'')||''','''||f_iif(NEW.genero='m','varon','mujer')||''' 
                                  
                                 ,'''||coalesce(new.fecha_nacimiento,now()::date)||''',
                                  '''||coalesce(new.direccion,'')||'''
                                  , '||coalesce(v_id_tipo_doc,'1')||'     
                                            
                                  
                                  );
                                   '); 
         
                          perform dblink_disconnect();  
                    end if;    */
            end;
       /* ELSEIF TG_OP='UPDATE' THEN
               BEGIN            
                   perform dblink_connect('hostaddr=10.172.0.11 port=5432 dbname=dbendesis_cobra user=db_link password=db_link');
                   perform dblink_exec('update segu.tpersona set 
                   nombre='''||new.nombre||''' , 
                   apellido_paterno='''||new.apellido_paterno||''', 
                   apellido_materno='''||coalesce(new.apellido_materno,'')||''',
                   ci='''||coalesce(new.doc_id,'')||''', 
                   correo='''||coalesce(new.email1,'')||''' , 
                   celular1= '''||coalesce(new.celular1,'0')||''', 
                   telefono1='''||coalesce(new.telefono1,'0')||''', 
                   telefono2= '''||coalesce(new.telefono2,'0')||''',
                   celular2='''||coalesce(new.celular2,'0')||''', 
                   extension='''||coalesce(new.extension,'')||''',  
                   genero= '''||f_iif(NEW.genero='varon','m','f')||'''   , 
                   fecha_nacimiento='''||coalesce(new.fecha_nacimiento,now()::date)||''', 
                   direccion='''||coalesce(new.direccion,'')||'''
                   where id_persona='||old.id_persona||';' ); 

                   --perform dblink_exec('insert into product_product(product_tmpl_id) values (currval(''product_template_id_seq''::regclass));');
                   perform dblink_disconnect();  
               END;
        ELSIF TG_OP='DELETE' THEN
               BEGIN           
                   perform dblink_connect('hostaddr=10.172.0.13 port=5432 dbname=dbendesis user=db_link password=db_link');   
                   perform dblink_exec('delete from sss.tsg_persona where id_persona='|| OLD.id_persona||';');
                   perform dblink_disconnect();
                   
               END;  */
        END IF;     
        
RETURN NEW;
            
            
              
  RETURN NULL;
END;
$$;


ALTER FUNCTION segu.f_actualiza_persona_entre_bd() OWNER TO mzambrana;

--
-- TOC entry 285 (class 1255 OID 16645)
-- Dependencies: 14 2435
-- Name: f_actualizar_log_bd(character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION f_actualizar_log_bd(par_url_log character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.f_actualizar_log_bd
 DESCRIPCION: 	Actualiza la tabla log a partir de los logs del
                motor de bd
 AUTOR: 		KPLIAN(jrr)
 FECHA:			08/03/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/
DECLARE
    v_registros       record;
    v_nombre_funcion  varchar;
    v_resp            varchar;
    v_fecha_actual    date;
    v_fecha_max_log   timestamp;
    v_fecha_min_tt    timestamp;
    v_tipo_log        varchar;
    v_consulta        varchar;
BEGIN
    v_nombre_funcion:='segu.f_actualizar_log_bd';

    select max(l.fecha_reg)
    into v_fecha_max_log
    from segu.tlog l
    where l.tipo_log='LOG_BD' or l.tipo_log='ERROR_BD';
    
    v_fecha_actual=now();
    
    execute ('
    create temporary table tt_log_bd(
        fecha_hora timestamp(3) with time zone, usuario text, bd text,  pid integer,
        ip_puerto text, id_sesion text, numero_accion bigint,
        etiqueta_comando text,fecha_hora_sesion timestamp with time zone,
        id_transaccion_vir text, id_transaccion_regu bigint,tipo_log varchar,
        codigo_error varchar, mensaje text, detalle_mensaje text,
        sugerencia text, consulta_interna_error text,
        carac_pos_error integer, error_context text,
        consulta_error text, cantidad_carac_pos_error integer,
        ubicacion text,
        nombre_aplicacion text) on commit drop');
    
    execute ('
    COPY tt_log_bd
    FROM '''||par_url_log||'-'||to_char(v_fecha_actual,'YYYY-MM-DD')||'.csv''
    WITH csv;');
    
    select min(fecha_hora)
    into v_fecha_min_tt
    from tt_log_bd;
    
    while(v_fecha_max_log is not null and v_fecha_min_tt is not null and v_fecha_min_tt>v_fecha_max_log)loop
        execute ('
        COPY tt_log_bd
        FROM '''||par_url_log||'-'||to_char(v_fecha_actual-interval '1 day','YYYY-MM-DD')||'.csv''
        WITH csv;');
        
        select min(fecha_hora)
        into v_fecha_min_tt
        from tt_log_bd;
        
    end loop;
    
    for v_registros in
    (select *
    from tt_log_bd
    where v_fecha_max_log is null or date_trunc('second',fecha_hora)>v_fecha_max_log)loop
    
    if(current_database()::text=v_registros.bd and v_registros.codigo_error!='P0001')then
        if(v_registros.tipo_log='ERROR')then
            v_tipo_log='ERROR_BD';
            v_consulta=v_registros.consulta_error;
        else
            v_tipo_log='LOG_BD';
            v_consulta=v_registros.mensaje;
        end if;
    
    
        insert into segu.tlog(
            ip_maquina,tipo_log,descripcion,
            fecha_reg,estado_reg,procedimientos,
            transaccion,consulta,tiempo_ejecucion,
            usuario_base,codigo_error,
            dia_semana,
            pid_db,pid_web,sid_web,si_log
        ) values(
            v_registros.ip_puerto,v_tipo_log,v_registros.mensaje,
            v_registros.fecha_hora,'activo','base de datos',
            'ninguna',v_consulta,0,
            v_registros.usuario,v_registros.codigo_error,
            to_char(v_registros.fecha_hora,'D')::integer,
            v_registros.pid,0,v_registros.id_sesion,1
        );
    end if;
     
    
    
    end loop;

    return 'exito';

EXCEPTION

       WHEN OTHERS THEN

       	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%,%',v_resp,v_consulta;

END;
$$;


ALTER FUNCTION segu.f_actualizar_log_bd(par_url_log character varying) OWNER TO rchumacero;

--
-- TOC entry 175 (class 1255 OID 16646)
-- Dependencies: 2435 14
-- Name: f_actualizar_sesion(integer, character varying, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION f_actualizar_sesion(p_pid_bd integer, p_sid_web character varying, p_pid_web integer, p_transaccion character varying, p_procedimiento character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: 		segu.f_actualizar_log_bd
 DESCRIPCION: 	Actualiza llos datos de sesion del usuario cada vez que se realiza una
                transaccion
 AUTOR: 		KPLIAN(jrr)
 FECHA:			08/03/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/
DECLARE
    v_resp      varchar;
    v_nombre_funcion   text;
    v_mensaje_error    text;
BEGIN
    v_nombre_funcion:='segu.f_actualizar_sesion';
    
    update segu.tsesion
    set pid_bd=p_pid_bd,
    transaccion_actual=p_transaccion,
    funcion_actual=p_procedimiento
    where pid_web=p_pid_web and estado_reg='activo' and variable=p_sid_web;

    return 'exito';
EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION segu.f_actualizar_sesion(p_pid_bd integer, p_sid_web character varying, p_pid_web integer, p_transaccion character varying, p_procedimiento character varying) OWNER TO rchumacero;

--
-- TOC entry 1193 (class 1255 OID 2920523)
-- Dependencies: 14 2435
-- Name: f_get_id_usuario(character varying); Type: FUNCTION; Schema: segu; Owner: rac
--

CREATE FUNCTION f_get_id_usuario(v_cuenta character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: 		segu.f_get_id_usuario
 DESCRIPCION: 	recupera id de usuario apartir del nombre de cuenta
 AUTOR: 		KPLIAN(RAC)
 FECHA:			29/02/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/
DECLARE
  v_id_usuario integer;
BEGIN
        select u.id_usuario
        into v_id_usuario
        from segu.tusuario u
        where u.cuenta=v_cuenta;
        
   RETURN v_id_usuario;


END;
$$;


ALTER FUNCTION segu.f_get_id_usuario(v_cuenta character varying) OWNER TO rac;

--
-- TOC entry 1203 (class 1255 OID 2924131)
-- Dependencies: 14 2435
-- Name: f_grant_all_privileges(text, text); Type: FUNCTION; Schema: segu; Owner: rac
--

CREATE FUNCTION f_grant_all_privileges(p_user text, p_esquema text) RETURNS void
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA ENDESIS - SISTEMA DE SSS
***************************************************************************
 SCRIPT: 		segu.f_grant_all_privileges
 DESCRIPCIÓN: 	Función para asignar todos los privilegios 
               objetos de esquema sobre un usuario o rol
 AUTOR: 		RAC
 FECHA:			29/02/2012
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE
   objeto record;
   v_record record;
   x	varchar;
   consulta varchar;
   v_conjunto_esquemas varchar;
BEGIN
   IF p_esquema = 'todos' THEN
      --listas esquemas
     v_conjunto_esquemas='';
      FOR v_record IN (select * from segu.tsubsistema) LOOP
             x=' GRANT ALL PRIVILEGES ON SCHEMA '||v_record.codigo||' TO "'||p_user||'"';
              RAISE NOTICE  '%',x;
              EXECUTE (x);              
              if(v_conjunto_esquemas='') THEN
	              v_conjunto_esquemas=''''|| lower(v_record.codigo)||'''';
              ELSE
                 v_conjunto_esquemas=v_conjunto_esquemas||','''||lower(v_record.codigo)||'''';
              END IF;
              
      END LOOP;
      
      
               consulta:= 'SELECT viewname as d , schemaname as c FROM pg_views WHERE schemaname IN ('||v_conjunto_esquemas||')
               UNION
               SELECT tablename as d, schemaname as c FROM pg_tables WHERE schemaname IN ('||v_conjunto_esquemas||')
               UNION
               SELECT relname as d, schemaname as c FROM pg_statio_all_sequences WHERE schemaname IN ('||v_conjunto_esquemas||')';

      
       
   ELSE
   
  
  
       x='GRANT ALL PRIVILEGES ON SCHEMA "'||p_esquema||'" TO "'||p_user'"';   
       RAISE NOTICE  '%',x;
       EXECUTE (x);
       
       
   consulta:= 'SELECT viewname as d, schemaname as c FROM pg_views WHERE schemaname='''||p_esquema||'''
               UNION
               SELECT tablename as d, schemaname as c FROM pg_tables WHERE schemaname='''||p_esquema||'''
               UNION
               SELECT relname as d, schemaname as c FROM pg_statio_all_sequences WHERE schemaname='''||p_esquema||'''';
   
   END IF;
    
    raise notice '%',consulta;

   FOR objeto IN   EXECUTE (consulta)   LOOP
    --  RAISE NOTICE 'Asignando todos los privilegios a % sobre %  en el esquema %', p_user, objeto.d, p_esquema;
      

       if((objeto.c||'.'||objeto.d) not in ('segu.tusuario','segu.tlog')
        
       ) THEN
       
         x= 'GRANT ALL PRIVILEGES ON  "'||objeto.c||'"."'|| objeto.d ||'"  TO "'||p_user||'"';
         RAISE NOTICE  '%',x;
         EXECUTE (x);
         
       ELSE
         raise notice '>>>>>>>>>>>>>>>>>>   Ingnorar %.%',objeto.c,objeto.d;
       END IF;
       
   END LOOP;
END;
$$;


ALTER FUNCTION segu.f_grant_all_privileges(p_user text, p_esquema text) OWNER TO rac;

--
-- TOC entry 1133 (class 1255 OID 3198984)
-- Dependencies: 14 2435
-- Name: f_importar_menu(integer, character varying); Type: FUNCTION; Schema: segu; Owner: rac
--

CREATE FUNCTION f_importar_menu(p_id_gui integer, p_cadena_nonexion character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA ENDESIS - SISTEMA DE SSS
***************************************************************************
 SCRIPT: 		segu.f_importar_menu
 DESCRIPCIÓN: 	Esta funcion permite  importar el menu de otra base de datos

 AUTOR: 		RAC
 FECHA:			14/03/2012
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE
   objeto record;
   v_record record;
   x	varchar;
   consulta varchar;
   v_conjunto_esquemas varchar;
   v_sw integer;
   v_id_subsistema_equi integer;
   v_id_gui_equi integer;
   v_codigo varchar;
   v_id_subsistema integer;
   v_id_gui_padre_equi integer;
   v_id_procedimiento integer;
   v_id_procedimiento_gui integer;
   v_respuesta varchar;
   
   
BEGIN

    /*
     A) MIGRAR MENU
     
        1)  buscamos equivalencia del id_subsistema. 
            
        
        
        2)  crear tabla temporal de equivalencias
        3)  for para recorrer los resultados, 
            consulta con deblink toda la rama a partir del id del padre señalado
        
            3.1) si primer registro
             
             3.1.1 buscamos ei el codigo de gui ya existe recuperamos id
            
                 3.1.1.1)  insertar nuevo gui  y salvar id 
                 3.1.1.2)  inserta  nueva estructura gui con el id salvado y padre (mismo padre que tabla original)
             
             
          
            
            3.2) si no es el primer registro
            
                3.2.1) buscar equivalencia del padre 
            	3.2.2) insertar nuevo gui con equivalencia del padre  y salvar id 
                3.2.3) inserta  nueva estructura gui con el id salvado y padre equivalente
                
           3.3)  guardar equivalencia en la tabla temporal    
  
   B) MIGRAR metaprocesos 
       (PENDIENTE)        
             
        
        
        
    
    */
  

-- A) MIGRAR MENU
     
  --      1)  buscamos equivalencia del ide del subsistema
  		  v_sw = 0;
          
          
          --hostaddr=10.172.0.11 port=5432 dbname=bdweb_gv user=db_link password=db_link
          
           SELECT P.id_subsistema,P.codigo  into  v_id_subsistema, v_codigo
           FROM dblink(p_cadena_nonexion,
                       'select s.id_subsistema, s.codigo 
                        from segu.tsubsistema s          
                        inner join segu.tgui g on s.id_subsistema = g.id_subsistema
                        where g.id_gui = '||p_id_gui::varchar) AS P(id_subsistema integer , 
                                                            codigo varchar);
                                                            
             select s.id_subsistema into v_id_subsistema
             from  segu.tsubsistema s
             where s.codigo = v_codigo;                                                
  
  
  IF(v_id_subsistema is null) THEN
  
  		raise exception 'solo nodo de sistema pueden migrarse o el sistema con dodigo % no existe en el destino',v_codigo;
  
  END IF;
  
  
  --      2)  crear tabla temporal de equivalencias
  create 
  temporary 
  table t_gui_equivalencia_temp (id_gui_orig integer , 
                                 id_gui_dest integer) on commit drop;


  --      3)  for para recorrer los resultados
  
  raise notice 'inicia FOR';
  
  FOR objeto IN   (SELECT id_gui , 
                                        nombre , 
                                        descripcion , 
                                        fecha_reg , 
                                        codigo_gui , 
                                        visible , 
                                        orden_logico , 
                                        ruta_archivo , 
                                        nivel , 
                                        icono , 
                                        id_subsistema, 
                                        clase_vista,
                                        fk_id_gui
                               FROM dblink(p_cadena_nonexion,
                                          'WITH RECURSIVE recursegui( id_gui , 
                                        nombre , 
                                        descripcion , 
                                        fecha_reg , 
                                        codigo_gui , 
                                        visible , 
                                        orden_logico , 
                                        ruta_archivo , 
                                        nivel , 
                                        icono , 
                                        id_subsistema, 
                                        clase_vista,
                                        fk_id_gui ) AS (
                                          SELECT g.id_gui , 
                                                 g.nombre , 
                                                 g.descripcion , 
                                                 g.fecha_reg , 
                                                 g.codigo_gui , 
                                                 g.visible , 
                                                 g.orden_logico , 
                                                 g.ruta_archivo , 
                                                 g.nivel , 
                                                 g.icono , 
                                                 g.id_subsistema, 
                                                 g.clase_vista,
                                                 eg.fk_id_gui
                                          FROM segu.tgui g 
                                          join segu.testructura_gui eg 
                                               on g.id_gui = eg.id_gui
                                          WHERE  g.id_gui= '||p_id_gui::varchar||'
                                        UNION
                                          SELECT  g.id_gui , 
                                                 g.nombre , 
                                                 g.descripcion , 
                                                 g.fecha_reg , 
                                                 g.codigo_gui , 
                                                 g.visible , 
                                                 g.orden_logico , 
                                                 g.ruta_archivo , 
                                                 g.nivel , 
                                                 g.icono , 
                                                 g.id_subsistema, 
                                                 g.clase_vista,
                                                 eg.fk_id_gui
                                          FROM segu.tgui g 
                                          join segu.testructura_gui eg 
                                               on g.id_gui = eg.id_gui
                                          JOIN recursegui  rt ON rt.id_gui = eg.fk_id_gui
                                        )
                                      SELECT * FROM recursegui;') AS P(
                                                                         id_gui INTEGER, 
                                                                          nombre VARCHAR(50), 
                                                                          descripcion TEXT, 
                                                                          fecha_reg DATE , 
                                                                          codigo_gui VARCHAR, 
                                                                          visible VARCHAR, 
                                                                          orden_logico INTEGER, 
                                                                          ruta_archivo TEXT, 
                                                                          nivel INTEGER, 
                                                                          icono VARCHAR, 
                                                                          id_subsistema INTEGER, 
                                                                          clase_vista VARCHAR,  
                                                                          fk_id_gui integer))   LOOP
                                                                          
        
   --          3.1) si primer registro
               IF (v_sw = 0) THEN
               
         --          3.1.1 buscamos ei el codigo si ya existe recuperamos id
         
                     select g.id_gui  into v_id_gui_equi
                     from segu.tgui g 
                     where g.codigo_gui = objeto.codigo_gui;
                     
                     if(v_id_gui_equi is null) THEN
                     
         --         3.1.1.1)  insertar nuevo gui  y salvar id 
         
                  insert into  segu.tgui(
                                        codigo_gui,
                                        nombre, 
                                        descripcion, 
                                        visible,
                                        orden_logico,
                                        ruta_archivo,
                                        nivel,
                                        icono,
                                        id_subsistema,
                                        clase_vista)
                                 values(
                                      
                                        objeto.codigo_gui,
                                        objeto.nombre,
                                        objeto.descripcion,
                                        objeto.visible,
                                        objeto.orden_logico,
                                        objeto.ruta_archivo,
                                        objeto.nivel, 
                                        objeto.icono,
                                        v_id_subsistema,
                                        objeto.clase_vista)
                                 RETURNING id_gui into v_id_gui_equi;
         
         
         --         3.1.1.2)  inserta  nueva estructura gui con el id salvado y padre (mismo padre que tabla original)
         
                                  insert into segu.testructura_gui(
                                         id_gui,
                                         fk_id_gui
                                         )
                                  values(
                                         v_id_gui_equi,
                                         objeto.fk_id_gui);




                     END IF;
                     -- para indicar que la raiz ya fue procesada
                     v_sw=1;

                
               ELSE 
                
               
               
   --         3.2) si no es el primer registro
   
   
                select g.id_gui  into v_id_gui_equi
                from segu.tgui g 
                where g.codigo_gui = objeto.codigo_gui;
                
                 if(v_id_gui_equi is null) THEN
            
             --           3.2.1) buscar equivalencia del padre 
                          select id_gui_dest  into v_id_gui_padre_equi
                          from  t_gui_equivalencia_temp et 
                          where et.id_gui_orig = objeto.fk_id_gui; 
             
             --         	3.2.2) insertar nuevo gui con equivalencia del padre  y salvar id 
             
                          insert into  segu.tgui(
                                                  codigo_gui,
                                                  nombre, 
                                                  descripcion, 
                                                  visible,
                                                  orden_logico,
                                                  ruta_archivo,
                                                  nivel,
                                                  icono,
                                                  id_subsistema,
                                                  clase_vista)
                                           values(
                                                
                                                  objeto.codigo_gui,
                                                  objeto.nombre,
                                                  objeto.descripcion,
                                                  objeto.visible,
                                                  objeto.orden_logico,
                                                  objeto.ruta_archivo,
                                                  objeto.nivel, 
                                                  objeto.icono,
                                                  NULL,
                                                  objeto.clase_vista)
                                           RETURNING id_gui into v_id_gui_equi;
                   
                        
             
             
             --           3.2.3) inserta  nueva estructura gui con el id salvado y padre equivalente
                               insert into segu.testructura_gui(
                                                                     id_gui,
                                                                     fk_id_gui
                                                                     )
                                                              values(
                                                                     v_id_gui_equi,
                                                                     v_id_gui_padre_equi);
   				END IF;
              END IF;
              
          --3.3   guardar equivalencia en la tabla temporal
   
               insert into t_gui_equivalencia_temp(id_gui_orig, id_gui_dest)
               values(objeto.id_gui,v_id_gui_equi);
   
   
                            
   
  
   END LOOP;

  
   -- B) MIGRAR metaprocesos 
   --    (PENDIENTE) 
   
   
   -- 1) correr la funcion de sincronizacion para insertar los metaprocesos de las funciones del sistema a importar
   
    v_respuesta:=segu.f_sinc_funciones_subsistema(v_id_subsistema);
    
   -- 2) FOR del istado de las relaciones entre gui y procedimientos por 
   --    las funciones del sistema
   
   FOR objeto IN   (SELECT  P.id_gui, P.id_procedimiento, P.boton, P.nombre, P.codigo
                    FROM dblink(p_cadena_nonexion,
                                             'select  pg.id_gui, pg.id_procedimiento, pg.boton,f.nombre,p.codigo
                                              from  segu.tfuncion f
                                              inner join segu.tprocedimiento p on f.id_funcion = p.id_funcion
                                              inner join segu.tprocedimiento_gui pg on pg.id_procedimiento=p.id_procedimiento
                                              where f.id_subsistema ='||v_id_subsistema::varchar) AS P( id_gui integer, 
                                                                                                        id_procedimiento integer, 
                                                                                                        boton varchar,
                                                                                                        nombre varchar,
                                                                                                        codigo varchar)) LOOP 
   
   
           -- 2.1) buscamos el procedimeinto en el destino y guardamos el id equivalente   
           v_id_procedimiento =NULL;
            select id_procedimiento into v_id_procedimiento 
            FROM segu.tprocedimiento p where p.codigo = objeto.codigo;
           
           
           if (v_id_procedimiento is null) THEN
           -- 2.1.1)   si no existe lanzamos error  para que revisen las funcion y el codigo faltantes en el destino
              raise exception 'No existe el procedimiento % en la funcion % o la sincronizacion fallor por comentarios mal hechos',objeto.codigo,objeto.nombre;
           END IF;
           
           
           
           -- 2.2)  buscamos equivalencia de gui en la tabla temporal
           
           select id_gui_dest into v_id_gui_equi
           from  t_gui_equivalencia_temp et 
           where et.id_gui_orig = objeto.id_gui; 
   
   
   
           -- 2.5) buscamos si ya existe la relacion entre gui y procedimiento
           v_id_procedimiento_gui=NULL;
           select id_procedimiento_gui   into v_id_procedimiento_gui
           from segu.tprocedimiento_gui pg 
           where pg.id_gui=v_id_gui_equi 
           and pg.id_procedimiento=v_id_procedimiento;
       
           if(v_id_procedimiento_gui is NULL )THEN   
           -- 2.5.1) si no existe insertamos en gui_procedimiento con las equivalencias
           
                 INSERT INTO segu.tprocedimiento_gui(
                                   id_procedimiento, 
                                   id_gui,
                                   boton)
                 VALUES (v_id_procedimiento, 
                         v_id_gui_equi,
                         objeto.boton);
                         
              raise notice 'procedimiento insertado %',objeto.codigo;              
           ELSE
           
             raise notice 'procedimiento existiente %',objeto.codigo;
           
           END IF;
   
   END LOOP;

   
   
  
END;
$$;


ALTER FUNCTION segu.f_importar_menu(p_id_gui integer, p_cadena_nonexion character varying) OWNER TO rac;

--
-- TOC entry 176 (class 1255 OID 16648)
-- Dependencies: 14 2435
-- Name: f_monitorear_recursos(); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION f_monitorear_recursos() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.f_monitorear_recursos
 DESCRIPCION: 	Monitorea el uso de recursos en el servidor de base de datos
 AUTOR: 		KPLIAN(jrr)
 FECHA:			08/03/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/
DECLARE
    v_res       integer;
    v_curdb     varchar;
    v_resp          varchar;
    v_nombre_funcion   text;
    
BEGIN
    v_nombre_funcion='segu.f_monitorear_recursos';
    v_curdb=current_database();
    v_res=monitor_phx(1);
    execute ('
    create temporary table tt_procesos_so(
        pid integer, proceso varchar, usuario varchar,  pcpu numeric,
        pmem numeric, vmstat varchar) on commit drop');
        
    COPY tt_procesos_so
    FROM '/tmp/procesos.csv'
    WITH csv;
    
    execute ('CREATE TEMPORARY TABLE tt_monitor_recursos ON COMMIT DROP AS
                select pa.usename::varchar as usuario_bd,
                s.transaccion_actual,s.funcion_actual,
                pa.current_query::text as consulta,to_char(s.inicio_proceso,''DD/MM/YYYY HH24:MI:SS'') as hora_inicio_proceso,
                to_char(query_start,''DD/MM/YYYY HH24:MI:SS'') as hora_inicio_consulta,
                mbd.pid as pid_bd,
                mbd.proceso as proceso_bd,
                mbd.usuario as usuario_pbd,
                mbd.pcpu as pcpu_bd,
                mbd.pmem as pmem_bd,
                mbd.vmstat as vmstat_bd,
                mweb.pid as pid_web,
                mweb.proceso as proceso_web,
                mweb.usuario as usuario_web,
                mweb.pcpu as pcpu_web,
                mweb.pmem as pmem_web,
                mweb.vmstat as vmstat_web,
                s.variable as sid_web
                from segu.tsesion s
                inner join tt_procesos_so mbd
                on(mbd.pid=s.pid_bd)
                inner join pg_stat_activity pa
                on(pa.procpid=mbd.pid)
                inner join tt_procesos_so mweb
                on(mweb.pid=s.pid_web)
                where datname='''||v_curdb||'''');
    return 'exito';
EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION segu.f_monitorear_recursos() OWNER TO rchumacero;

--
-- TOC entry 177 (class 1255 OID 16649)
-- Dependencies: 14 2435
-- Name: f_permiso_rol(integer, integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION f_permiso_rol(par_id_gui integer, par_id_procedimiento_gui integer, par_id_rol integer, par_accion character varying, par_direccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************

 FUNCION: 		segu.f_permiso_rol
 DESCRIPCION: 	Asigna permisos a un rol de forma recursiva en el arbol
 AUTOR: 		KPLIAN(JRR)
 FECHA:			19/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/
DECLARE

v_consulta    varchar;
v_registros  record;
v_respuesta     varchar;
v_nombre_funcion varchar;
v_mensaje_error  varchar;
v_resp		varchar;

/*
paramteros:

solo se puede tener id_gui o id_procedimiento (uno a la vez)


par_id_gui: id_gui al que se quiere otorgar o quitar permisos
par_id_procedimiento:id_procedimiento al q se quiere otorgar o quitar permisos
par_id_rol: id_del rol al que se totorga o se quitan los permisos
par_accion: "dar"=> da permisos al rol sobre la interfaz o la transaccion
        "quitar" =>revoca permisos sobre la interfaz o la transaccion
par_direccion:  "subir" => llamada q va dando permisos sobre las transacciones padre
                "bajar" => llamada q va dando permiso sobre todos los hijos
                "subir_bajar"=>otorga permisos tanto de subida comod e bajada (Para la primera llamada "subir_bajar")




1) Validamos la accion a realizar dar permiso o quitar permiso
    1.1) "dar" Se otorga permiso sobre la interfaz o transaccion
    1.2) "quitar" Se quita permiso sobre la interfaz o transaccion
2) Validamos la sigueinte accionde acuerdo a la direccion "subir","bajar","subir_bajar"
    2.1) Si es "subir" o "subir_bajar" hacemos una llamada recursiva a esta funcion para el padre de esta transaccion
        o vista
    2.2) Si es "bajar" o "subir_bajar" y no es una transaccion
        hacemos una llamada recursiva a esta funcion para cada hijo de este metaproceso

*/

BEGIN


    v_nombre_funcion:='segu.fpermiso_rol';
--1) Validamos la accion a realizar dar permiso o quitar permiso
    --1.1) "dar" Se otorga permiso sobre la interfaz o transaccion
    if(par_accion='dar')then
        --1.1.1) Si no existe el permiso sobre la transaccion lo insertamos
        if(par_id_gui is null)then
            if(not exists(select
                            1
                        from segu.trol_procedimiento_gui
                        where id_rol=par_id_rol and id_procedimiento_gui=par_id_procedimiento_gui
                        and estado_reg='activo'))then

            insert into segu.trol_procedimiento_gui (
                id_rol,
                id_procedimiento_gui)
            values(
                par_id_rol,
                par_id_procedimiento_gui);
            end if;
        --1.1.2) Si no existe el permiso sobre la vista lo insertamos
        else
            if(not exists(select
                            1
                        from segu.tgui_rol
                        where id_rol=par_id_rol and id_gui=par_id_gui
                        and estado_reg='activo'))then

            insert into segu.tgui_rol (
                id_rol,
                id_gui)
            values(
                par_id_rol,
                par_id_gui);
            end if;
        end if;
    
    --1.2) "quitar" Se quita permiso sobre la interfaz o transaccion
    ELSE
        --1.2.1) Quitamos cualquier permiso sobre la transaccion
        if(par_id_gui is null)then
            update segu.trol_procedimiento_gui set
                estado_reg='inactivo'
            where id_rol=par_id_rol and id_procedimiento_gui=par_id_procedimiento_gui;
        --1.2.1) Quitamos cualquier permiso sobre la vista
        else
            if(par_direccion='subir')then
                if(not exists(select 1 from segu.tgui_rol gr 
                              inner join segu.testructura_gui eg on(gr.id_gui=eg.id_gui)
                        where fk_id_gui=par_id_gui
                    and id_rol=par_id_rol and gr.estado_reg='activo' 
                    and eg.estado_reg='activo'))then
                    if(not exists(select 1 from segu.tprocedimiento_gui pg 
                                           inner join segu.trol_procedimiento_gui rpg 
                                           on(pg.id_procedimiento_gui=rpg.id_procedimiento_gui)
                        where pg.id_gui=par_id_gui
                          and id_rol=par_id_rol and rpg.estado_reg='activo' and pg.estado_reg='activo'))then
                            update segu.tgui_rol set
                                estado_reg='inactivo'
                            where id_rol=par_id_rol and id_gui=par_id_gui;
                    end if;
                end if;

            else
                update segu.tgui_rol set
                    estado_reg='inactivo'
                where id_rol=par_id_rol and id_gui=par_id_gui;
            end if;
        end if;
    
    
    end if;
--2) Validamos la sigueinte accionde acuerdo a la direccion "subir","bajar","subir_bajar"
    --2.1) Si es "subir" o "subir_bajar" hacemos una llamada recursiva a esta funcion para el padre de esta transaccion
        --o vista
    if(par_direccion='subir' or par_direccion='subir_bajar')then
        if(par_id_gui is null)THEN
            v_consulta:='select id_gui
                         from segu.tprocedimiento_gui
                         where estado_reg=''activo'' 
                         and id_procedimiento_gui='||par_id_procedimiento_gui;

        else
            v_consulta:='select fk_id_gui as id_gui
                         from segu.testructura_gui
                         where estado_reg=''activo'' and id_gui='||par_id_gui;
        
        end if;


        for v_registros in
        execute(v_consulta)loop
            v_respuesta:= segu.f_permiso_rol(v_registros.id_gui,null,par_id_rol,par_accion,'subir');

        end loop;
    end if;
    
    --2.2) Si es "bajar" o "subir_bajar" y no es una transaccion
        --hacemos una llamada recursiva a esta funcion para cada hijo de este metaproceso
    if((par_direccion='bajar' or par_direccion='subir_bajar') and par_id_gui is not null)then
         v_consulta:='select id_procedimiento_gui
                         from segu.tprocedimiento_gui
                         where estado_reg=''activo'' 
                         and id_gui='||par_id_gui;
                         
         for v_registros in
         execute(v_consulta)loop
             v_respuesta:= segu.f_permiso_rol(null,v_registros.id_procedimiento_gui,par_id_rol,par_accion,'bajar');

         end loop;

        
         v_consulta:='select id_gui
                       from segu.testructura_gui
                       where estado_reg=''activo'' and fk_id_gui='||par_id_gui;

        
        for v_registros in
         execute(v_consulta)loop
             v_respuesta:= segu.f_permiso_rol(v_registros.id_gui,null,par_id_rol,par_accion,'bajar');

         end loop;

    end if;
    return 'exito';


EXCEPTION

       WHEN OTHERS THEN

       	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


ALTER FUNCTION segu.f_permiso_rol(par_id_gui integer, par_id_procedimiento_gui integer, par_id_rol integer, par_accion character varying, par_direccion character varying) OWNER TO rchumacero;

--
-- TOC entry 183 (class 1255 OID 16651)
-- Dependencies: 14 2435
-- Name: f_sinc_funciones_subsistema(integer); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION f_sinc_funciones_subsistema(par_id_subsistema integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.f_sinc_funciones_subsistema
 DESCRIPCIÓN:   sincronizacion de la funciones de un subsistema a partir de los metadatos der SGBD
        
 AUTOR: 		KPLIAN(RAC)
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	- actualizacion a nueva version xph
                - listado de ufnciones en vez de tablas
                - ahora tambien saca las descripcion de la transaccion a partir de
                  de los comentarios del programador                     
 AUTOR:		KPLIAN(RAC)	
 FECHA:		27/11/10
 ***************************************************************************
 DESCRIPCION:	- arreglo para omitir funciones bakup con barra baja por delante '_'
                - se hicieron unicos los nombre de funcion, los codigos de procedimientos y de gui
                   
 AUTOR:		KPLIAN(RAC)	
 FECHA:		15/03/12


***************************************************************************/

DECLARE
v_registros       record;
v_esquema         varchar;
v_mensaje_error   text;
v_nombre_funcion  varchar;

v_prefijo          varchar;
v_cant             integer;
v_bandera          boolean;
v_contenido        text;
v_codigo           varchar;
v_id_funcion       integer;
v_nombre_function          varchar;
v_nombre_tabla          varchar;
v_desc_transaccion varchar;
v_bandera_desc boolean;
v_nombre_fun   varchar;

BEGIN

v_nombre_funcion:='segu.f_sinc_funciones_subsistema';

     --  raise exception 'LLEGA';
     select lower(codigo), lower(prefijo)
     into v_esquema, v_prefijo
     from segu.tsubsistema
     where id_subsistema=par_id_subsistema;
     
     
    -- raise exception 'LLEGA %',v_esquema;
     
    
     --RAC 15032012  se incremente el NOT LIKE para que no se considere las copias de las funciones
     --estas se distinguen por que comienzan con una '_' por delante
     --si existe una funcion backup sin esta caracteristica podemos obtener un error
     --de codigos duplicados
     
     for v_registros in (  SELECT p.proname AS v_funcion
                           FROM pg_proc p
                              INNER JOIN pg_namespace n ON p.pronamespace = n.oid
                           WHERE n.nspname = v_esquema AND   ( p.proname  LIKE '_%')) loop   -- p.proname not like '_%'  ==> 9-04-2012 ==> no listaba nada
                         
                       v_nombre_function=v_registros.v_funcion; 
                       
                       if(v_nombre_function != 'f_sinc_funciones_subsistema')THEN
                         --
                         
                         -- verifica la existencia de la funcion tipo sel con prefijo ft
                         
                                   
                                   --raise exception '%',substr(v_nombre_tabla, 2);

                                   v_cant:=2;
                                   v_bandera:=true;

                                   if not exists(select 1
                                                  from segu.tfuncion
                                                  where nombre = v_nombre_function
                                                  and id_subsistema=par_id_subsistema and estado_reg='activo') then

                                         -- si no existe inserta una funcion 

                                          insert into segu.tfuncion(nombre,descripcion,id_subsistema,estado_reg)
                                          values(v_nombre_function,
                                          'Funcion para tabla     ',par_id_subsistema,'activo')
                                          returning id_funcion into v_id_funcion ;

                                   else
                                   
                                    --si existe recupera el id de la fucion
                                          v_id_funcion:=(select id_funcion
                                                     from segu.tfuncion
                                                     where nombre = v_nombre_function
                                                     and id_subsistema=par_id_subsistema
                                                     and estado_reg='activo');
                                   end if;
                                   
                                   --recupera el cuerpo de la funcion

                                   select prosrc
                                   into v_contenido
                                   from pg_proc 
                                   where proname = v_nombre_function;

                                 
                                    raise notice '%   %',v_nombre_function,v_esquema; 
                                    
                                    
                                   while((v_bandera) or (v_cant<20)) loop
                                   
                                    
                                        
                                           
                                     --busca las transacciones en el cuerpo de la funcion       
                                    if(strpos(split_part(TRIM(v_contenido),'_transaccion=''',v_cant),''')')<1) then
                                                v_bandera:=false;
                                           else
                                           
                                           
                                            
                                               --Verifica si la trasanccion tiene descripcion    
                                               v_bandera_desc:=true;  
                                               v_desc_transaccion= 'CODIGO NO DOCUMENTADO';
                                            
                                              if(strpos(split_part(v_contenido,'#DESCRIPCION:',v_cant),'#AUTOR:')<1) then
                                                 
                                                   
                                                 v_bandera_desc:=false;
                                             
                                              else 
                                              
                                                 
                                                  v_desc_transaccion:=TRIM((select substr(split_part(v_contenido,'#DESCRIPCION:',v_cant),1,strpos(split_part(v_contenido,'#DESCRIPCION:',v_cant),'#AUTOR:')-1))::varchar);
                                              
                                              end IF;
                                            
                                            v_codigo:=(select substr(split_part(TRIM(v_contenido),'_transaccion=''',v_cant),1,strpos(split_part(TRIM(v_contenido),'_transaccion=''',v_cant),''')')-1))::varchar;

                                                     
                                            raise notice '% ---  %',v_codigo, v_desc_transaccion;   
                                            
                                             if(v_codigo is null or v_codigo='') then
                                                     v_bandera:=false;
                                                end if;


                                                if not exists(select 1 
                                                              from segu.tprocedimiento
                                                              where codigo =v_codigo --)then
--                                                              and id_funcion=v_id_funcion and estado_reg='activo') then
                                                               and id_funcion=v_id_funcion) then
                                                               
                                                               
                                                           
                                                           if exists(select 1 
                                                              from segu.tprocedimiento
                                                              where codigo =v_codigo )then 
                                                              
                                                              
                                                                select  f.nombre into v_nombre_fun
                                                                from segu.tprocedimiento p
                                                                inner join segu.tfuncion f on f.id_funcion = p.id_funcion
                                                                where p.codigo =v_codigo ;
                                                                --OFFSET  START 0 LIMIT 1;
                                                              
                                                                raise exception 'el se duplica para la funcion  % existe en la funcion % y minimamente en %',v_codigo,v_nombre_function,v_nombre_fun;
                                                           
                                                           
                                                           END IF;   
                                                  


                                                
                                                   insert into segu.tprocedimiento(codigo,descripcion,id_funcion,estado_reg)
                                                   values(v_codigo,v_desc_transaccion, v_id_funcion,'activo');
                                                
                                                else
                                                        
                                                    UPDATE segu.tprocedimiento 
                                                      SET descripcion= v_desc_transaccion
                                                    WHERE codigo =v_codigo 
                                                       and id_funcion=v_id_funcion;
                                                       
                                                       
                                                end if;
                                                
                                                
                                                
                                                
                                                
                                           end if;
                                           v_cant=v_cant+1;
                                           
                                           -- busca los mensaje de descripcion en el cuerpo de la funcion 
                                           
                                           
                                           
                                   end loop;

                         
                      END IF; 

     end loop;

    return 'exito';

END;
$$;


ALTER FUNCTION segu.f_sinc_funciones_subsistema(par_id_subsistema integer) OWNER TO rchumacero;

--
-- TOC entry 1174 (class 1255 OID 3325143)
-- Dependencies: 2435 14
-- Name: f_sincroniza_persona_entre_bd(integer, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: mzambrana
--

CREATE FUNCTION f_sincroniza_persona_entre_bd(p_id_persona integer, p_host_destino character varying, p_port_destino character varying, p_user_destino character varying, p_pwd_destino character varying, p_bd_destino character varying, p_opcion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    
v_consulta  varchar;
v_respuesta varchar;
v_registros record;

BEGIN
                           
   
       
        IF p_opcion = 'INSERT' THEN
            BEGIN   
            
                                                                                                        /*
              v_consulta:='SELECT id_persona
                                               FROM segu.tpersona where id_persona='||p_id_persona;   */
                  --raise exception 'aa%',coalesce(new.genero,'');          
              if not exists (select P.id_persona from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_persona
                                               FROM sss.tsg_persona where id_persona='||p_id_persona) AS P(
                                                                                id_persona integer) ) then
                     
                  select * into v_registros from segu.tpersona where id_persona=p_id_persona;                                       
                     
                  v_consulta:='insert into sss.tsg_persona(id_persona,nombre,apellido_paterno,apellido_materno, doc_id, email2,celular1,telefono1,telefono2,celular2,extension,id_usuario_reg,fecha_reg,genero,fecha_nacimiento,direccion) 
                  values ('||p_id_persona||','''||coalesce(v_registros.nombre,'-')||''','''||coalesce(v_registros.apellido_paterno,'-')||''','''||coalesce(v_registros.apellido_materno,'-')||''','''||coalesce(v_registros.ci,'-')||''','''||coalesce( v_registros.correo,'-')||''','''||coalesce(v_registros.celular1,'-')||''','''||coalesce(v_registros.telefono1,'-')||''','''||coalesce(v_registros.telefono2,'-')||''',
                  '''||coalesce(v_registros.celular2,'-')||''','''||coalesce(v_registros.extension,'-')||''','||1||','''||now()::date||''','''||f_iif(coalesce(v_registros.genero,'m')='m','varon','mujer')::varchar||''','''|| coalesce(v_registros.fecha_nacimiento,now()::date)||''', 
                  '''||coalesce( v_registros.direccion,'')||''' );'    ;
                        
                  v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                  return 'si';
             else 
                  raise exception 'ya existe';
             end if;                                   
            
          end;
        ELSEIF p_opcion='UPDATE' THEN
               BEGIN       
               
                      if exists (select P.id_persona from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_persona
                                               FROM sss.tsg_persona where id_persona='||p_id_persona) AS P(
                                                                                id_persona integer) ) then   
                                                                                
                          select * into v_registros from segu.tpersona where id_persona=p_id_persona;                                       
                     
                          v_consulta:='update sss.tsg_persona
                          set 
                          nombre='''||coalesce(v_registros.nombre,'-')||''',
                          apellido_paterno='''||coalesce(v_registros.apellido_paterno,'-')||''',
                          apellido_materno='''||coalesce(v_registros.apellido_materno,'-')||''', 
                          doc_id='''||coalesce(v_registros.ci,'-')||''', 
                          email2='''||coalesce( v_registros.correo,'-')||''',
                          celular1='''||coalesce(v_registros.celular1,'-')||''',
                          telefono1='''||coalesce(v_registros.telefono1,'-')||''',
                          telefono2='''||coalesce(v_registros.telefono2,'-')||''',
                          celular2='''||coalesce(v_registros.celular2,'-')||''',
                          extension='''||coalesce(v_registros.extension,'-')||''',
                          genero='''||f_iif(coalesce(v_registros.genero,'m')='m','varon','mujer')::varchar||''',
                          fecha_nacimiento='''|| coalesce(v_registros.fecha_nacimiento,now()::date)||''',
                          direccion= '''||coalesce( v_registros.direccion,'')||'''
                          where id_persona='||p_id_persona;
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                           return 'si';
                     else
                           return 'no';          
                     end if;
               END;
        ELSIF p_opcion='DELETE' THEN               
               BEGIN     
                     if exists (select P.id_persona from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_persona
                                               FROM sss.tsg_persona where id_persona='||p_id_persona) AS P(
                                                                                id_persona integer) ) then   
                                                                                
                           v_consulta:='delete from sss.tsg_persona where id_persona='||p_id_persona;
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                           return 'si';                                                      
                     else
                       return 'no';
                     end if;
                   
               END;
        END IF;     
        
--RETURN NEW;
            
            
           
  RETURN NULL;
END;
$$;


ALTER FUNCTION segu.f_sincroniza_persona_entre_bd(p_id_persona integer, p_host_destino character varying, p_port_destino character varying, p_user_destino character varying, p_pwd_destino character varying, p_bd_destino character varying, p_opcion character varying) OWNER TO mzambrana;

--
-- TOC entry 1177 (class 1255 OID 3327599)
-- Dependencies: 2435 14
-- Name: f_sincroniza_usuario_entre_bd(integer, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: mzambrana
--

CREATE FUNCTION f_sincroniza_usuario_entre_bd(p_id_usuario integer, p_host_destino character varying, p_port_destino character varying, p_user_destino character varying, p_pwd_destino character varying, p_bd_destino character varying, p_opcion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    
v_consulta  varchar;
v_respuesta varchar;
v_registros record;

BEGIN
                           
   
       
        IF p_opcion = 'INSERT' THEN
            BEGIN   
            
              
              if not exists (select P.id_usuario from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_usuario
                                               FROM sss.tsg_usuario where id_usuario='||p_id_usuario) AS P(
                                                                                id_usuario integer) ) then
                     
                  select * into v_registros from segu.tusuario where id_usuario=p_id_usuario;                                       
                     
                  v_consulta:='insert into sss.tsg_usuario(id_usuario, id_nivel_seguridad, login, contrasenia,fecha_expiracion , estilo_usuario, id_persona, autentificacion, estado_usuario) 
                                   values ('||p_id_usuario||',
                                           '||v_registros.id_clasificador||',
                                           '''||coalesce(v_registros.cuenta,'-')||''',
                                           '''||coalesce(v_registros.contrasena,'-')||''',
                                           '''||v_registros.fecha_caducidad||''',
                                           '''||coalesce( v_registros.estilo,'-')||''',
                                           '||v_registros.id_persona||',
                                           '''||coalesce(v_registros.autentificacion,'local')||'''
                                           ,''activo''
                  );' ;
                        
                  v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                  return 'si';
             else 
                  raise exception 'ya existe';
             end if;                                   
            
          end;
        ELSEIF p_opcion='UPDATE' THEN
               BEGIN                
                      if exists (select P.id_usuario from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_usuario
                                               FROM sss.tsg_usuario where id_usuario='||p_id_usuario) AS P(
                                                                                id_usuario integer) ) then   
                                                                                
                          select * into v_registros from segu.tusuario where id_usuario=p_id_usuario;                                       
                     
                          v_consulta:='update sss.tsg_usuario
                          set 
                          id_nivel_seguridad='||v_registros.id_clasificador||',
                          login='''||coalesce(v_registros.cuenta,'-')||''',
                          contrasenia='''||coalesce(v_registros.contrasena,'-')||''',       
                          fecha_expiracion='''||v_registros.fecha_caducidad||''', 
                          estilo_usuario='''||coalesce( v_registros.estilo,'-')||''', 
                          id_persona='||v_registros.id_persona||', 
                          autentificacion='''||coalesce(v_registros.autentificacion,'local')||''', 
                          estado_usuario='''||coalesce(v_registros.estado_reg,'activo')||'''
                          where id_usuario='||p_id_usuario;
                          v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                           return 'si';
                     else
                           return 'no';          
                     end if;
               END;
        ELSIF p_opcion='DELETE' THEN               
               BEGIN     
                     if exists (select P.id_usuario from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_usuario
                                               FROM sss.tsg_usuario where id_usuario='||p_id_usuario) AS P(
                                                                                id_usuario integer) ) then   
                                                                                
                           v_consulta:='update sss.tsg_usuario set estado_usuario=''inactivo'' where id_usuario='||p_id_usuario;
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                           return 'si';                                                      
                     else
                       return 'no';
                     end if;
                   
               END;
        END IF;     
        
--RETURN NEW;
            
            
           
  RETURN NULL;
END;
$$;


ALTER FUNCTION segu.f_sincroniza_usuario_entre_bd(p_id_usuario integer, p_host_destino character varying, p_port_destino character varying, p_user_destino character varying, p_pwd_destino character varying, p_bd_destino character varying, p_opcion character varying) OWNER TO mzambrana;

--
-- TOC entry 288 (class 1255 OID 16653)
-- Dependencies: 14 2435
-- Name: f_verif_eliminado(integer); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION f_verif_eliminado(par_id_subsistema integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.f_verif_eliminado
 DESCRIPCION:   
 AUTOR: 		KPLIAN(rac)
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)	
 FECHA:		08/01/11
***************************************************************************/
DECLARE
v_registros       record;
v_esquema         varchar;
v_mensaje_error   text;
v_nombre_funcion  varchar;
v_contenido        text;
v_cant             integer;
v_bandera          boolean;
v_codigo           varchar;
v_array_cod        integer[];
i                  integer;
cont               integer;
v_array_id         integer[];
j                  integer;
cont_id            integer;

BEGIN


v_nombre_funcion:='segu.f_verif_eliminado';

     for v_registros in (select nombre, id_funcion from segu.tfuncion where id_subsistema=par_id_subsistema order by nombre) loop
                         
                 if not exists(select * from pg_proc where proname ~ v_registros.nombre order by proname) then
                        if exists(select 1 from segu.tprocedimiento where id_funcion=v_registros.id_funcion) then
                             delete from segu.tprocedimiento where id_funcion=v_registros.id_funcion;
                        end if;
                        delete from segu.tfuncion where lower(nombre) ~ v_registros.nombre and id_subsistema=par_id_subsistema;
                 else
                 --existe la funcion (verificar q todos los procedimientos sigan existiendo)
                          select prosrc
                                 into v_contenido
                                 from pg_proc where proname ~ v_registros.nombre;

                                 v_bandera:=true;
                                 v_cant:=2;
                                 cont:=0;
                                 while((v_bandera) or (v_cant<20)) loop

                                           if(strpos(split_part(v_contenido,'par_transaccion=''',v_cant),''')then')<1) then
                                                v_bandera:=false;
                                           else
                                                v_codigo:=(select substr(split_part(v_contenido,'par_transaccion=''',v_cant),1,strpos(split_part(v_contenido,'par_transaccion=''',v_cant),''')then')-1))::varchar;
                                                v_array_cod[v_cant-1]:=(select id_procedimiento from segu.tprocedimiento where lower(codigo)=lower(v_codigo) and id_funcion=v_registros.id_funcion);
                                                cont=cont+1;
                                           end if;
                                           v_cant=v_cant+1;
                                 end loop;

                                 
                                 i=(array_upper(v_array_cod,1));
                                 select aggarray(id_procedimiento) into v_array_id
                                 from segu.tprocedimiento where id_funcion=v_registros.id_funcion;

                                 j=(array_upper(v_array_id,1));

                                 if(j>i) then
                                   j:=j;
                                 else
                                   j:=i;
                                 end if;

raise exception 'id%',v_array_cod;
                                /* for i in 1..j loop
                                     if(v_array_cod[i]=v_array_id[i]) then
                                     else
                                     end if;
                                 
                                 end loop;*/



                                /* while (cont>=i) loop

                                        if exists (select 1 from segu.procedimiento where lower(v_array_cod[i])~ lower(codigo) and id_funcion=v_registros.id_funcion) then

                                           v_array_id[j]:=(select id_procedimiento from segu.procedimiento where lower(v_array_cod[i])~ lower(codigo) and id_funcion=v_registros.id_funcion);
                                            j:=j+1;

                                            cont_id:=cont_id+1;
                                        end if;
                                        i=i+1;
                                    end loop;



                                    while(cont_id>0) loop

                                       delete from segu.procedimiento where id_funcion=v_registros.id_funcion
                                       and id_procedimiento not in (v_array_id [cont_id]);
                                    
                                    end loop;*/
                                    
                                 --end if;
                                 
                                 
                 end if;

     end loop;
    return 'exito';

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION segu.f_verif_eliminado(par_id_subsistema integer) OWNER TO rchumacero;

--
-- TOC entry 178 (class 1255 OID 16654)
-- Dependencies: 2435 14
-- Name: ft_actividad_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_actividad_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_actividad_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'segu.tactividad'
 AUTOR: 		 (w)
 FECHA:	        17-10-2011 06:48:53
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_actividad	integer;
			
BEGIN

    v_nombre_funcion = 'segu.ft_actividad_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************
 	#TRANSACCION:  'SG_ACT_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:48:53
	***********************************/

	if(p_transaccion='SG_ACT_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into segu.tactividad(
			codigo,
			descripcion,
			estado_reg,
			nombre,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			v_parametros.codigo,
			v_parametros.descripcion,
			'activo',
			v_parametros.nombre,
			now(),
			p_id_usuario,
			null,
			null
			)RETURNING id_actividad into v_id_actividad;

			--Definici?n de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Actividad almacenado(a) con exito (id_actividad'||v_id_actividad||')');
            v_resp = f_agrega_clave(v_resp,'id_actividad',v_id_actividad::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************
 	#TRANSACCION:  'SG_ACT_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:48:53
	***********************************/

	elsif(p_transaccion='SG_ACT_MOD')then

		begin
			--Sentencia de la modificacion
			update segu.tactividad set
			codigo = v_parametros.codigo,
			descripcion = v_parametros.descripcion,
			nombre = v_parametros.nombre,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_actividad=v_parametros.id_actividad;

			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Actividad modificado(a)');
            v_resp = f_agrega_clave(v_resp,'id_actividad',v_parametros.id_actividad::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************
 	#TRANSACCION:  'SG_ACT_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:48:53
	***********************************/

	elsif(p_transaccion='SG_ACT_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from segu.tactividad
            where id_actividad=v_parametros.id_actividad;

            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Actividad eliminado(a)');
            v_resp = f_agrega_clave(v_resp,'id_actividad',v_parametros.id_actividad::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	else

    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				
END;
$$;


ALTER FUNCTION segu.ft_actividad_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 179 (class 1255 OID 16655)
-- Dependencies: 14 2435
-- Name: ft_actividad_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_actividad_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_actividad_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'segu.tactividad'
 AUTOR: 		 (w)
 FECHA:	        17-10-2011 06:48:53
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			
BEGIN

	v_nombre_funcion = 'segu.ft_actividad_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************
 	#TRANSACCION:  'SG_ACT_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:48:53
	***********************************/

	if(p_transaccion='SG_ACT_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						act.id_actividad,
						act.codigo,
						act.descripcion,
						act.estado_reg,
						act.nombre,
						act.fecha_reg,
						act.id_usuario_reg,
						act.fecha_mod,
						act.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from segu.tactividad act
						inner join segu.tusuario usu1 on usu1.id_usuario = act.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = act.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			
			if(f_existe_parametro(p_tabla,'estado_reg')) then
			  v_consulta:=v_consulta || ' and act.estado_reg='''||v_parametros.estado_reg||'''';
			end if;
			
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************
 	#TRANSACCION:  'SG_ACT_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:48:53
	***********************************/

	elsif(p_transaccion='SG_ACT_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_actividad)
					    from segu.tactividad act
					    inner join segu.tusuario usu1 on usu1.id_usuario = act.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = act.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		
			v_consulta:=v_consulta||v_parametros.filtro;
            if(f_existe_parametro(p_tabla,'estado_reg')) then
			  v_consulta:=v_consulta || ' and act.estado_reg='''||v_parametros.estado_reg||'''';
			end if;
			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					
		raise exception 'Transaccion inexistente';
					
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION segu.ft_actividad_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 180 (class 1255 OID 16656)
-- Dependencies: 14 2435
-- Name: ft_bloqueo_notificacion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_bloqueo_notificacion_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_bloqueo_notificacion_ime
 DESCRIPCION:   Cambia el estado de las notificaciones y bloqueos
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/

DECLARE

    v_nro_requerimiento    	integer;
    v_parametros           	record;
    v_id_requerimiento     	integer;
    v_resp		            varchar;
    v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_proyecto			integer;


/*

 id_proyecto
 denominacion 
 descripcion
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='segu.ft_bloqueo_notificacion_ime';
     v_parametros:=f_get_record(p_tabla);

/*******************************
 #TRANSACCION:  SEG_ESBLONO_MOD
 #DESCRIPCION:	Cambia el estado de notificacion y bloqueos
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
    if(p_transaccion='SEG_ESBLONO_MOD')then

          --consulta:=';
          BEGIN
               
               update segu.tbloqueo_notificacion
               set estado_reg='inactivo'
               where id_bloqueo_notificacion=v_parametros.id_bloqueo_notificacion;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Bloqueo Notificacion desactivado');
               v_resp = f_agrega_clave(v_resp,'id_bloqueo_notificacion',v_parametros.id_bloqueo_notificacion::varchar);
              
               return v_resp;
         END;
         
     else
     
         raise exception 'Transaccion inexistente: %',p_transaccion;

     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
        
END;
$$;


ALTER FUNCTION segu.ft_bloqueo_notificacion_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 289 (class 1255 OID 16657)
-- Dependencies: 14 2435
-- Name: ft_bloqueo_notificacion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_bloqueo_notificacion_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_bloqueo_notificacion_sel
 DESCRIPCIÓN:   listado de los bloquos y notificaciones del sistema
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:
 AUTOR:		
 FECHA:	
***************************************************************************/

DECLARE                  

v_consulta    varchar;
v_parametros  record;
v_resp          varchar;
v_nombre_funcion   text;
v_mensaje_error    text;
v_res_actualiz    varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(p_tabla);
     v_nombre_funcion:='segu.f_t_bloqueo_notificacion_sel';

/*******************************    
 #TRANSACCION:  SEG_NOTI_SEL
 #DESCRIPCION:	Listado del notificacion de eventos del sistema
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     if(p_transaccion='SEG_NOTI_SEL')then

          
          BEGIN
               v_consulta:='select blono.id_bloqueo_notificacion,
                                    blono.nombre_patron,
                                    blono.aplicacion,
                                    blono.tipo_evento,
                                    blono.usuario,
                                    blono.ip,
                                    to_char(blono.fecha_hora_ini,''DD/MM/YYYY HH:MI:SS''),
                                    to_char(blono.fecha_hora_fin,''DD/MM/YYYY HH:MI:SS'')
               
                        from segu.tbloqueo_notificacion blono
                        where tipo=''notificacion'' and estado_reg=''activo'' and ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************    
 #TRANSACCION:  SEG_NOTI_CONT
 #DESCRIPCION:	Contar registros de notificaciones de enventos del sistema
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_NOTI_CONT')then

          --consulta:=';
          BEGIN
               v_consulta:='select count(blono.id_bloqueo_notificacion)
                              from segu.tbloqueo_notificacion blono
                              where tipo=''notificacion'' and estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
         
/*******************************
 #TRANSACCION:  SEG_BLOQUE_SEL
 #DESCRIPCION:	Listado de bloqueos del sistema
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_BLOQUE_SEL')then


          BEGIN
               v_consulta:='select blono.id_bloqueo_notificacion,
                                    blono.nombre_patron,
                                    blono.aplicacion,
                                    blono.tipo_evento,
                                    blono.usuario,
                                    blono.ip,
                                    to_char(blono.fecha_hora_ini,''DD/MM/YYYY HH:MI:SS''),
                                    to_char(blono.fecha_hora_fin,''DD/MM/YYYY HH:MI:SS'')

                        from segu.tbloqueo_notificacion blono
                        where tipo=''bloqueo'' and estado_reg=''activo'' and
                                fecha_hora_fin>now() and ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************
 #TRANSACCION:  SEG_BLOQUE_CONT
 #DESCRIPCION:	Contar registros de bloqueos del sistema
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_BLOQUE_CONT')then

          --consulta:=';
          BEGIN
               v_consulta:='select count(blono.id_bloqueo_notificacion)
                              from segu.tbloqueo_notificacion blono
                              where tipo=''bloqueo'' and estado_reg=''activo'' and
                                fecha_hora_fin>now() and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_bloqueo_notificacion_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 181 (class 1255 OID 16658)
-- Dependencies: 14 2435
-- Name: ft_clasificador_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_clasificador_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_clasificador_ime
 DESCRIPCION:   modificaciones de clasificador
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/

DECLARE


v_parametros           record;
v_resp                 varchar;
v_nombre_funcion       text;
v_mensaje_error        text;
v_id_clasificador      integer;

BEGIN

     v_nombre_funcion:='segu.ft_clasificador_ime';
     v_parametros:=f_get_record(p_tabla);

 /*******************************
 #TRANSACCION:  SEG_CLASIF_INS
 #DESCRIPCION:	Inserta Actividades
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/

     if(p_transaccion='SEG_CLASIF_INS')then

        
          BEGIN
               insert into segu.tclasificador(
               codigo,              descripcion,                prioridad)
               values(
               v_parametros.codigo, v_parametros.descripcion,   v_parametros.prioridad
               )RETURNING id_clasificador into v_id_clasificador;


		      v_resp = f_agrega_clave(v_resp,'mensaje','Clasificador insertado con exito(id_clasificador'||v_id_clasificador||')');
              v_resp = f_agrega_clave(v_resp,'id_clasificador',v_id_clasificador::varchar);

         END;

 /*******************************
 #TRANSACCION:  SEG_CLASIF_MOD
 #DESCRIPCION:	Modifica Clasificacion
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     elsif(p_transaccion='SEG_CLASIF_MOD')then

          
          BEGIN
               
               update segu.tclasificador set

                     codigo=v_parametros.codigo,
                     descripcion=v_parametros.descripcion,
                     prioridad=v_parametros.prioridad

               where id_clasificador=v_parametros.id_clasificador;



               v_resp = f_agrega_clave(v_resp,'mensaje','Clasificador modificado: '||v_parametros.id_clasificador);
               v_resp = f_agrega_clave(v_resp,'id_clasificador',v_parametros.id_clasificador::varchar);

          END;

 /*******************************
 #TRANSACCION:  SEG_CLASIF_ELI
 #DESCRIPCION:	Elimina Clasificacion
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
    elsif(p_transaccion='SEG_CLASIF_ELI')then

         
          BEGIN
               update segu.tclasificador set estado_reg='inactivo'
               where id_clasificador=v_parametros.id_clasificador;


               v_resp = f_agrega_clave(v_resp,'mensaje','Clasificador eliminado: '||v_parametros.id_clasificador);
               v_resp = f_agrega_clave(v_resp,'id_clasificador',v_parametros.id_clasificador::varchar);

         END;

     else

         raise exception 'No existe la transaccion: %',p_transaccion;
     end if;
    return v_resp;
EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_clasificador_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 182 (class 1255 OID 16659)
-- Dependencies: 14 2435
-- Name: ft_clasificador_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_clasificador_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_clasificador_sel
 DESCRIPCION:   consultas de clasificador
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/



DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp                 varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(p_tabla);
     v_nombre_funcion:='segu.ft_clasificador_sel';

 /*******************************
 #TRANSACCION:  SEG_CLASIF_SEL
 #DESCRIPCION:	Selecciona Clasificador
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/

     if(p_transaccion='SEG_CLASIF_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select id_clasificador,
                            codigo,
                            descripcion,
                            prioridad,
                            fecha_reg
                            --estado_reg
                        from segu.tclasificador where estado_reg=''activo'' and ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

 /*******************************
 #TRANSACCION:  SEG_CLASIF_CONT
 #DESCRIPCION:	Cuenta Clasificador
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/

     elsif(p_transaccion='SEG_CLASIF_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(id_clasificador)
               from segu.tclasificador where  estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_clasificador_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1298 (class 1255 OID 2187238)
-- Dependencies: 14 2435
-- Name: ft_configurar_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: mflores
--

CREATE FUNCTION ft_configurar_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Esquema de seguridad
 FUNCION: 		segu.ft_configurar_ime
 DESCRIPCION:   Funcion que modifica la configuración de la vista, la autentificación y las contraseñas
 AUTOR: 		 (mflores)
 FECHA:	        01-12-2011 15:03
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    		integer;
	v_parametros           		record;
	v_id_requerimiento     		integer;
	v_resp		            	varchar;
	v_nombre_funcion       	 	text;
	v_mensaje_error         	text;
    v_clave_anterior			varchar;
    v_mod_exito 				varchar;
    v_clave_actual				varchar;
			    
BEGIN

    v_nombre_funcion = 'segu.ft_configurar_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SG_CONF_MOD'
 	#DESCRIPCION:	Configuración de cuenta de usuario
 	#AUTOR:			mflores	
 	#FECHA:			01-12-2011
	***********************************/

	if(p_transaccion='SG_CONF_MOD')then				
        
	--1) IF Si la opcion es modifcar contraseña (mod_contraseña = SI) y autentificacion = local
    --1.1) IF verifico si la contraseña actual es valida
    --1.1.1) IF si la contraseña nueva es igual a la confirmacion
    --1.1.1.1) modifico contraseña
    --1.1.2) ELSE, mensaje de error las ontraseñas no son iguales
    --1.2) ELSE, mensaje de error la contraseñaa actual no es valida
    --2) ELSE, modifico estilo, filtro avanzado y autentificacion (LDAP)
    
		begin
        
        if (v_parametros.autentificacion = 'Contraseña ENDESIS') then
        	v_parametros.autentificacion = 'local';
        else
        	v_parametros.autentificacion = 'ldap';
        end if;
        
        select contrasena
        into v_clave_anterior
        from segu.tusuario
        where id_usuario = p_id_usuario;
        
        /*v_parametros.clave_anterior = md5(v_parametros.clave_anterior);
        v_parametros.clave_nueva = md5(v_parametros.clave_nueva);
        v_parametros.clave_confirmacion = md5(v_parametros.clave_confirmacion);*/
        
        --1) IF Si la opcion es modifcar contraseña (mod_contraseña = SI) y autentificacion = local
         IF (v_parametros.modificar_clave = 'SI' AND v_parametros.autentificacion = 'local') THEN         	      	
            
            --1.1) IF verifico si la contraseña actual es valida         
			IF EXISTS(SELECT 1 FROM segu.tusuario usuari WHERE usuari.contrasena = v_parametros.clave_anterior
            and usuari.id_usuario = p_id_usuario) THEN
			
            --  guarda nueva contraseña solo si coinciden la nueva y la confirmacion
		
                --1.1.1) IF si la contraseña nueva es igual a la confirmacion
				IF (v_parametros.clave_nueva = v_parametros.clave_confirmacion) THEN
		
		        --1.1.1.1) modifico contraseña
	            -- se actualiza la clave  
                  UPDATE segu.tusuario SET
                   		 contrasena_anterior = v_clave_anterior,
			             contrasena = v_parametros.clave_nueva,
                         estilo = v_parametros.estilo,
                         autentificacion = v_parametros.autentificacion
                         
					WHERE segu.tusuario.id_usuario = p_id_usuario;
                    
                    v_mod_exito = 1;
                    
                    select contrasena
                    into v_clave_actual
                    from segu.tusuario
                    where id_usuario = p_id_usuario;
    			
                --1.1.2) ELSE, mensaje de error las ontraseñas no son iguales
                ELSE
       	            raise exception 'LOS DATOS NUEVOS NO COINCIDEN';

                END IF;
			--1.2) ELSE, mensaje de error la contraseña actual no es valida
            ELSE
   	            raise exception 'LA CONTRASEÑA ANTIGUA NO ES CORRECTA';           
            
            END IF;
            
          --2) ELSE, modifico estilo y filtro avanzado
          ELSE  
          -- se actualiza el estilo y el filtro avanzado
                                        
               UPDATE segu.tusuario SET
                    estilo = v_parametros.estilo,
                    autentificacion = v_parametros.autentificacion
                         
                WHERE segu.tusuario.id_usuario = p_id_usuario;
                      
                v_mod_exito = 0;
                
                select contrasena
                into v_clave_actual
                from segu.tusuario
                where id_usuario = p_id_usuario;
                
          END IF;
                         
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Preferencias de usuario modificadas)'); 
            v_resp = f_agrega_clave(v_resp,'id_usuario',p_id_usuario::varchar);
            v_resp = f_agrega_clave(v_resp,'mod_exito',v_mod_exito::varchar);  
            v_resp = f_agrega_clave(v_resp,'clave',v_clave_actual::varchar);      
			v_resp = f_agrega_clave(v_resp,'autentificacion',v_parametros.autentificacion::varchar);  
               
            --Devuelve la respuesta
            return v_resp;
            
		end;
	         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION segu.ft_configurar_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO mflores;

--
-- TOC entry 279 (class 1255 OID 1475531)
-- Dependencies: 14 2435
-- Name: ft_ep_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: postgres
--

CREATE FUNCTION ft_ep_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_ep_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'segu.tep'
 AUTOR: 		 (w)
 FECHA:	        18-10-2011 02:09:50
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_ep	integer;
			
BEGIN

    v_nombre_funcion = 'segu.ft_ep_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************
 	#TRANSACCION:  'SG_ESP_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		w	
 	#FECHA:		18-10-2011 02:09:50
	***********************************/

	if(p_transaccion='SG_ESP_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into segu.tep(
			estado_reg,
			id_actividad,
			id_programa,
			id_proyecto,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			'activo',
			v_parametros.id_actividad,
			v_parametros.id_programa,
			v_parametros.id_proyecto,
			now(),
			p_id_usuario,
			null,
			null
			)RETURNING id_ep into v_id_ep;

			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Estructura Programatica almacenado(a) con exito (id_ep'||v_id_ep||')');
            v_resp = f_agrega_clave(v_resp,'id_ep',v_id_ep::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************
 	#TRANSACCION:  'SG_ESP_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		w	
 	#FECHA:		18-10-2011 02:09:50
	***********************************/

	elsif(p_transaccion='SG_ESP_MOD')then

		begin
			--Sentencia de la modificacion
			update segu.tep set
			id_actividad = v_parametros.id_actividad,
			id_programa = v_parametros.id_programa,
			id_proyecto = v_parametros.id_proyecto,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_ep=v_parametros.id_ep;

			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Estructura Programatica modificado(a)');
            v_resp = f_agrega_clave(v_resp,'id_ep',v_parametros.id_ep::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************
 	#TRANSACCION:  'SG_ESP_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		w	
 	#FECHA:		18-10-2011 02:09:50
	***********************************/

	elsif(p_transaccion='SG_ESP_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from segu.tep
            where id_ep=v_parametros.id_ep;

            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Estructura Programatica eliminado(a)');
            v_resp = f_agrega_clave(v_resp,'id_ep',v_parametros.id_ep::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	else

    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				
END;
$$;


ALTER FUNCTION segu.ft_ep_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 280 (class 1255 OID 1475532)
-- Dependencies: 2435 14
-- Name: ft_ep_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: postgres
--

CREATE FUNCTION ft_ep_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_ep_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'segu.tep'
 AUTOR: 		 (w)
 FECHA:	        18-10-2011 02:09:50
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			
BEGIN

	v_nombre_funcion = 'segu.ft_ep_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************
 	#TRANSACCION:  'SG_ESP_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		w	
 	#FECHA:		18-10-2011 02:09:50
	***********************************/

	if(p_transaccion='SG_ESP_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						ep.id_ep,
						ep.estado_reg,
						ep.id_actividad,
						ep.nombre_actividad,
						ep.id_programa,
						ep.nombre_programa,
						ep.id_proyecto,
						ep.nombre_proyecto,
						ep.fecha_reg,
						ep.id_usuario_reg,
						ep.fecha_mod,
						ep.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from segu.vep ep
						inner join segu.tusuario usu1 on usu1.id_usuario = ep.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ep.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************
 	#TRANSACCION:  'SG_ESP_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		w	
 	#FECHA:		18-10-2011 02:09:50
	***********************************/

	elsif(p_transaccion='SG_ESP_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_ep)
					    from segu.vep ep
					    inner join segu.tusuario usu1 on usu1.id_usuario = ep.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ep.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					
		raise exception 'Transaccion inexistente';
					
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION segu.ft_ep_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 184 (class 1255 OID 16660)
-- Dependencies: 14 2435
-- Name: ft_estructura_dato_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_estructura_dato_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_estructura_dato_ime
 DESCRIPCION:   modificaciones de estructura_dato
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/

DECLARE


v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_resp                  varchar;
v_id_estructura_dato    integer;

BEGIN

     v_nombre_funcion:='segu.ft_estructura_dato_ime';
     v_parametros:=f_get_record(par_tabla);


 /*******************************
 #TRANSACCION:  SEG_ESTDAT_INS
 #DESCRIPCION:	Inserta Estructura Dato
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_ESTDAT_INS')then

        
          BEGIN
               insert into segu.testructura_dato(
                id_subsistema,              nombre,             descripcion,
                encripta,                   log,                tipo)
               values(
                v_parametros.id_subsistema, v_parametros.nombre,v_parametros.descripcion,
                v_parametros.encripta,      v_parametros.log,   v_parametros.tipo
               )RETURNING id_estructura_dato into v_id_estructura_dato;

                v_resp = f_agrega_clave(v_resp,'mensaje','Estructura Dato insertado con exito: '||v_id_estructura_dato);
                v_resp = f_agrega_clave(v_resp,'id_estructura_dato',v_id_estructura_dato::varchar);


         END;

 /*******************************
 #TRANSACCION:  SEG_ESTDAT_MOD
 #DESCRIPCION:	Modifica Estructura Dato
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_ESTDAT_MOD')then

          
          BEGIN
               
               update segu.testructura_dato set
                      id_subsistema=v_parametros.id_subsistema,
                     nombre=v_parametros.nombre,
                     descripcion=v_parametros.descripcion,
                     encripta=v_parametros.encripta,
                     log=v_parametros.log,
                     tipo=v_parametros.tipo

               where id_estructura_dato=v_parametros.id_estructura_dato;

                v_resp = f_agrega_clave(v_resp,'mensaje','Estructura Dato modificado con exito: '||v_parametros.id_estructura_dato);
                v_resp = f_agrega_clave(v_resp,'id_estructura_dato',v_parametros.id_estructura_dato::varchar);


          END;

 /*******************************
 #TRANSACCION:  SEG_ESTDAT_ELI
 #DESCRIPCION:	Elimina Estructura Dato
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
    elsif(par_transaccion='SEG_ESTDAT_ELI')then

         
          BEGIN
               update segu.testructura_dato set estado_reg='inactivo'
               where id_estructura_dato=v_parametros.id_estructura_dato;

                v_resp = f_agrega_clave(v_resp,'mensaje','Estructura Dato eliminado con exito: '||v_parametros.id_estructura_dato);
                v_resp = f_agrega_clave(v_resp,'id_estructura_dato',v_parametros.id_estructura_dato::varchar);

         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     return v_resp;

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_estructura_dato_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 291 (class 1255 OID 16661)
-- Dependencies: 14 2435
-- Name: ft_estructura_dato_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_estructura_dato_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_estructura_dato_sel
 DESCRIPCION:   consultas de estructura_dato
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp           varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_estructura_dato_sel';


 /*******************************
 #TRANSACCION:  SEG_ESTDAT_SEL
 #DESCRIPCION:	Selecciona Estructura dato
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_ESTDAT_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select estdat.id_estructura_dato,
                            estdat.id_subsistema,
                            estdat.nombre,
                            estdat.descripcion,
                            estdat.encripta,
                            estdat.log,
                            estdat.fecha_reg,
                            estdat.estado_reg,
                            estdat.tipo,
                            subsis.nombre as nombre_subsis
                        from segu.testructura_dato estdat
                        inner join segu.tsubsistema subsis
                        on subsis.id_subsistema=estdat.id_subsistema where
                        estdat.estado_reg=''activo'' and';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


 /*******************************
 #TRANSACCION:  SEG_ESTDAT_CONT
 #DESCRIPCION:	Cuenta Estructura dato
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_ESTDAT_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(estdat.id_estructura_dato)
                        from segu.testructura_dato estdat
                        inner join segu.tsubsistema subsis
                        on subsis.id_subsistema=estdat.id_subsistema where
                        estdat.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

        WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_estructura_dato_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 185 (class 1255 OID 16662)
-- Dependencies: 14 2435
-- Name: ft_estructura_gui_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_estructura_gui_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_estructura_gui_ime
 DESCRIPCION:   modificaciones de estructura_gui
 AUTOR: 		
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		Jaime Rivera Rojas	
 FECHA:		08/01/11
***************************************************************************/


DECLARE


v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_resp                  varchar;
v_id_estructura_gui    integer;
BEGIN

     v_nombre_funcion:='segu.ft_estructura_gui_ime';
     v_parametros:=f_get_record(par_tabla);


 /*******************************
 #TRANSACCION:  SEG_ESTGUI_INS
 #DESCRIPCION:	Inserta Estructura gui
 #AUTOR:		Jaime Rivera Rojas	
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_ESTGUI_INS')then

        
          BEGIN
               insert into segu.testructura_gui(id_gui, fk_id_gui)
               values(v_parametros.id_gui,v_parametros.fk_id_gui
               )RETURNING id_estructura_gui into v_id_estructura_gui;

               v_resp = f_agrega_clave(v_resp,'mensaje','Estructura gui insertado con exito: '||v_id_estructura_gui);
               v_resp = f_agrega_clave(v_resp,'id_estructura_gui',v_id_estructura_gui::varchar);

         END;


 /*******************************
 #TRANSACCION:  SEG_ESTGUI_MOD
 #DESCRIPCION:	Modifica Estructura gui
 #AUTOR:		Jaime Rivera Rojas	
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_ESTGUI_MOD')then

          
          BEGIN
               
               update segu.testructura_gui set

                     id_gui=v_parametros.id_gui,
                     fk_id_gui=v_parametros.fk_id_gui

               where id_estructura_gui=v_parametros.id_estructura_gui;
                v_resp = f_agrega_clave(v_resp,'mensaje','Estructura Gui modificado con exito: '||v_parametros.id_estructura_gui);
                v_resp = f_agrega_clave(v_resp,'id_estructura_gui',v_parametros.id_estructura_gui::varchar);




          END;


 /*******************************
 #TRANSACCION:  SEG_ESTGUI_ELI
 #DESCRIPCION:	Elimina Estructura gui
 #AUTOR:		Jaime Rivera Rojas	
 #FECHA:		08/01/11	
***********************************/
    elsif(par_transaccion='SEG_ESTGUI_ELI')then

         
          BEGIN
               update segu.testructura_gui set estado_reg='inactivo'
               where id_estructura_gui=v_parametros.id_estructura_gui;
               v_resp = f_agrega_clave(v_resp,'mensaje','Estructura Gui modificado con exito: '||v_parametros.id_estructura_gui);
               v_resp = f_agrega_clave(v_resp,'id_estructura_gui',v_parametros.id_estructura_gui::varchar);
         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     return v_resp;

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;



END;
$$;


ALTER FUNCTION segu.ft_estructura_gui_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 186 (class 1255 OID 16663)
-- Dependencies: 14 2435
-- Name: ft_estructura_gui_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_estructura_gui_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_estructura_gui_sel
 DESCRIPCION:   consultas de estructura_gui
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp          varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_estructura_gui_sel';


 /*******************************
 #TRANSACCION:  SEG_ESTGUI_SEL
 #DESCRIPCION:	Selecciona Estructura gui
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_ESTGUI_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select id_estructura_gui,
                            id_gui,
                            fk_id_gui,
                            fecha_reg,
                            estado_reg
                        from segu.testructura_gui estgui
                        inner join segu.tgui guihij
                        on guihij.id_gui=estgui.id_gui
                        inner join segu.tgui guipad
                        on guipad.id_gui=estgui.fk_id_gui where
                        guihij.estado_reg=''activo'' and guipad.estado_reg=''activo'' and
                        estgui. estado_reg=''activo'' and ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


 /*******************************
 #TRANSACCION:  SEG_ESTGUI_CONT
 #DESCRIPCION:	Cuenta Estructura gui
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_ESTGUI_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(id_estructura_gui) from segu.testructura_gui estgui
                        inner join segu.tgui guihij
                        on guihij.id_gui=estgui.id_gui
                        inner join segu.tgui guipad
                        on guipad.id_gui=estgui.fk_id_gui where
                        guihij.estado_reg=''activo'' and guipad.estado_reg=''activo'' and
                        estgui. estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_estructura_gui_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1129 (class 1255 OID 16664)
-- Dependencies: 14 2435
-- Name: ft_funcion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_funcion_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_funcion_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 		KPLIAN(rac)		
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(rac)		
 FECHA:		27/11/10
***************************************************************************/
DECLARE


v_parametros                record;
v_resp                		varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_sinc_funcion_subsis       varchar;
v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='segu.ft_funcion_ime';
     v_parametros:=f_get_record(par_tabla);             
     
 /*******************************    
 #TRANSACCION:  SEG_FUNCIO_INS
 #DESCRIPCION:	Inserta Funciones
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		16-11-2010	
***********************************/
     if(par_transaccion='SEG_FUNCIO_INS')then

        
          BEGIN
          
          --insercion de nueva funcion
               INSERT INTO segu.tfuncion(nombre, descripcion,id_subsistema)
               values(v_parametros.nombre,v_parametros.descripcion,v_parametros.id_subsistema)
               returning  id_funcion into v_id_funcion;

               v_resp = f_agrega_clave(v_resp,'mensaje','Funcion insertada con exito '||v_id_funcion); 
               v_resp = f_agrega_clave(v_resp,'id_funcion',v_id_funcion::varchar);


         END;     
         
 /*******************************    
 #TRANSACCION:  SEG_FUNCIO_MOD
 #DESCRIPCION:	Modifica la funcion seleccionada 
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		16-11-2010	
***********************************/
     elsif(par_transaccion='SEG_FUNCIO_MOD')then

          
          BEGIN
               --modificacion de funciones
               update segu.tfuncion set

                     nombre=v_parametros.id_gui,
                     descripcion=v_parametros.descripcion,
                     id_subsistema=v_parametros.id_subsistema

               where id_funcion=v_parametros.id_funcion;

               v_resp = f_agrega_clave(v_resp,'mensaje','Funcion modificada con exito '||v_parametros.id_funcion); 
               v_resp = f_agrega_clave(v_resp,'id_funcion',v_parametros.id_funcion::varchar);

             
          END;
          
/*******************************    
 #TRANSACCION:   SEG_FUNCIO_ELI
 #DESCRIPCION:	Inactiva las funcion selecionada 
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		16-11-2010	
***********************************/

    elsif(par_transaccion='SEG_FUNCIO_ELI')then
        BEGIN
        
         --inactivacion de la funcion
               DELETE FROM segu.tfuncion 
               where id_funcion=v_parametros.id_funcion;
               return 'Funcion eliminada con exito';
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Funcion eliminada con exito: '||v_parametros.id_funcion); 
               v_resp = f_agrega_clave(v_resp,'id_funcion',v_parametros.id_funcion::varchar);

               
        END;                    
        
/*******************************    
 #TRANSACCION:  SEG_SINCFUN_MOD
 #DESCRIPCION:	Este proceso busca todas las funciones de base de datos para el esquema seleccionado
                las  introduce en la tabla de fucniones luego revisa el cuerpo de la funcion 
                y saca los codigos de procedimiento y sus descripciones
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		16-11-2010	
***********************************/
        
    elsif(par_transaccion='SEG_SINCFUN_MOD') then
        BEGIN
             --sincronizacion de la funciones de un subsistema a partir de los metadatos der SGBD
        
             v_sinc_funcion_subsis:=(select segu.f_sinc_funciones_subsistema(v_parametros.id_subsistema));
             
             v_resp = f_agrega_clave(v_resp,'mensaje','Funcion sincronizadas con exito para el sistema '||v_parametros.id_subsistema); 
             v_resp = f_agrega_clave(v_resp,'id_subsistema',v_parametros.id_subsistema::varchar);
        END;
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_funcion_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 187 (class 1255 OID 16665)
-- Dependencies: 14 2435
-- Name: ft_funcion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_funcion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_funcion_sel
 DESCRIPCIÓN:   listado de interfaces en formato arbol
 AUTOR: 		KPLIAN(rac)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(rac)		
 FECHA:		27/11/10
***************************************************************************/


DECLARE


v_consulta   		varchar;
v_parametros  		record;
v_nombre_funcion  	text;
v_mensaje_error    	text;
v_resp              varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_funcion_sel';   
     
/*******************************    
 #TRANSACCION:  SEG_FUNCIO_SEL
 #DESCRIPCION:	Listado de funciones registradas del sistema
 #AUTOR:		Rensi Arteaga Copari	
 #FECHA:		27/11/10	
***********************************/

     if(par_transaccion='SEG_FUNCIO_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                             funcio.id_funcion,
                             funcio.nombre,
                             funcio.descripcion,
                             funcio.fecha_reg,
                             funcio.id_subsistema,
                             funcio.estado_reg
                             FROM segu.tfuncion funcio 
                             INNER JOIN  segu.tsubsistema subsis 
                             on subsis.id_subsistema=funcio.id_subsistema
                             WHERE funcio.estado_reg=''activo'' and funcio.id_subsistema = '|| v_parametros.id_subsistema || '  and ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;
         
/*******************************    
 #TRANSACCION:  SEG_FUNCIO_CONT
 #DESCRIPCION:	Contar  funciones registradas del sistema
 #AUTOR:		Rensi Arteaga Copari	
 #FECHA:		27/11/10	
***********************************/
     elsif(par_transaccion='SEG_FUNCIO_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(funcio.id_funcion)
                            FROM segu.tfuncion funcio 
                            INNER JOIN  segu.tsubsistema subsis 
                            on subsis.id_subsistema=funcio.id_subsistema
                            WHERE funcio.estado_reg=''activo'' and  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;      
END;
$$;


ALTER FUNCTION segu.ft_funcion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 190 (class 1255 OID 16666)
-- Dependencies: 14 2435
-- Name: ft_gui_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_gui_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 CAPA:          MODELO
 FUNCION: 		segu.ft_gui_ime
 DESCRIPCIÓN: 	Permite la gestion de interfaces 
                de usario con todas sus operaciones basicas                
 AUTOR: 		KPLIAN(rac)	
 FECHA:			19/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:
***************************************************************************/
DECLARE


v_parametros 				record;
v_respuesta           		varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_id_gui                    integer;
v_resp          			varchar;
v_cont_padre    			integer;
v_cont_hijo      			integer;
v_cont_prodecimiento_hijo 	integer;
v_cont_rol				  	integer;
v_nivel                 	integer;	
v_tipo_dato              	varchar;
v_orden_logico integer;

BEGIN

     v_nombre_funcion:='segu.ft_gui_ime';
     v_parametros:=f_get_record(par_tabla); 
     
 /*******************************    
 #TRANSACCION:	SEG_GUIDD_IME
 #DESCRIPCION:	Inserta interfaces en el arbol
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		02-03-2012
 #RESUMEN:		1) si point es igual append
                  1.1) eliminamos la relacion de dependecias con el anterior padre
                  1.2) verificamos orden_logico mayor de los hijos del nodo target
                  1.3) insertamos como nodo hijo del target 
                  1.4) modificamos el orden logico del nodo para que sea el ultimo en el listado
 				2) regresar error point no soportados
                
                
***********************************/

     if(par_transaccion='SEG_GUIDD_IME')then                
          BEGIN
           
        --  1) si point es igual append
        IF(v_parametros.punto='append')then 
        
        --raise exception '% % %',v_parametros.id_target,v_parametros.id_nodo,v_parametros.id_olp_parent;
        --  1.1) eliminamos la relacion de dependecias con el anterior padre
               DELETE FROM segu.testructura_gui
                      WHERE id_gui=v_parametros.id_nodo  
                      AND  fk_id_gui=v_parametros.id_olp_parent;
            --  1.2) verificamos orden_logico mayor de los hijos den nodo target
                    select orden_logico 
                    into v_orden_logico
                    FROM segu.tgui g 
                    inner join segu.testructura_gui eg on eg.id_gui = g.id_gui
                    WHERE eg.fk_id_gui = v_parametros.id_target
                    order by g.orden_logico desc
                    limit 1 offset 0;
            
            --  1.3) insertamos como nodo hijo del target
            
               insert into segu.testructura_gui(
                               id_gui,
                               fk_id_gui
                               )
                        values(
                               v_parametros.id_nodo,
                               v_parametros.id_target); 
            
             --  1.4) modificamos el orden logico del nodo para que sea el ultimo en el listado
             
                update segu.tgui set
                orden_logico=v_orden_logico+1
                where id_gui=v_parametros.id_nodo;
              
        ELSE
 		  --	2) regresar error point no soportados
          raise exception 'POINT no soportado %',v_parametros.punto;
        
        END IF;
          
        
               
               v_resp = f_agrega_clave(v_resp,'mensaje','DRANG AND DROP exitoso id_gui='||v_parametros.id_nodo||' id_target= '|| v_parametros.id_target||'  id_old_gui='|| v_parametros.id_olp_parent); 
               --datos obligados a regresar para configurar el 
               --traslado del nodo si regargar el padre
               --v_resp = f_agrega_clave(v_resp,'id_gui',v_parametros.id_nodo::varchar);--nuevo ide del nodo
               v_resp = f_agrega_clave(v_resp,'id_p',v_parametros.id_target::varchar);--nuevo id del padre
               v_resp = f_agrega_clave(v_resp,'id_gui_padre',v_parametros.id_target::varchar);--nuevo id del padre
               v_resp = f_agrega_clave(v_resp,'orden_logico',v_orden_logico::varchar);--algun dato extra
               return v_resp;  
                    
        END;
     
     
/*******************************    
 #TRANSACCION:	SEG_GUI_INS
 #DESCRIPCION:	Inserta interfaces en el arbol
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		10-10-2010
 #RESUMEN:		1) inserta la intergace en la tabla t_gui
 				2) inserta la relacion con el padre y la interface recien
                creada en estructura_gui              
***********************************/
     elseif(par_transaccion='SEG_GUI_INS')then                
          BEGIN
          --0) calcula el nivel del nodo padre
            select g.nivel into v_nivel 
               from segu.tgui g 
               where g.id_gui = v_parametros.id_gui_padre;                     
              
          -- 1) inserta la intergace en la tabla t_gui
          
            insert into  segu.tgui(
                                
                                codigo_gui,
                                nombre, 
                                descripcion, 
                                visible,
                                orden_logico,
                                ruta_archivo,
                                nivel,
                                icono,
                                --id_subsistema,
                                clase_vista)
                         values(
                              
                                v_parametros.codigo_gui,
                                v_parametros.nombre,
                                v_parametros.descripcion,
                                v_parametros.visible,
                                v_parametros.orden_logico,
                                v_parametros.ruta_archivo,
                                v_nivel+1, 
                                v_parametros.icono,
                                --v_parametros.id_subsistema,
                                v_parametros.clase_vista)
                         RETURNING id_gui into v_id_gui;
                            

          --  1) inserta la relacion con el padre y la interface recien creada en estructura_gui
              
             
          	--introcude la relacion con el nodo padre
          
               insert into segu.testructura_gui(
                           id_gui,
                           fk_id_gui
                           )
                    values(
                           v_id_gui,
                           v_parametros.id_gui_padre);
               
               v_resp = f_agrega_clave(v_resp,'mensaje','GUI insertada con exito '||v_id_gui); 
               v_resp = f_agrega_clave(v_resp,'id_gui',v_id_gui::varchar);
               return v_resp;  
                    
        END;
        
 /*******************************    
 #TRANSACCION:  SEG_FUNCIO_MOD
 #DESCRIPCION:	Modifica la interfaz del arbol seleccionada 
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		10-10-2010
***********************************/
     elsif(par_transaccion='SEG_GUI_MOD')then        
          
          BEGIN
          if(v_parametros.ruta_archivo is null or v_parametros.ruta_archivo='') then
          v_tipo_dato:='carpeta';
          else
          v_tipo_dato:='interface';
          end if;
          

               IF v_tipo_dato='carpeta' THEN
               
                  update segu.tgui set

                       codigo_gui=v_parametros.codigo_gui,
                       visible=v_parametros.visible,
                       nombre=v_parametros.nombre,
                       descripcion=v_parametros.descripcion,
                       orden_logico=v_parametros.orden_logico
                       --id_subsistema=v_parametros.id_subsistema

                 where id_gui=v_parametros.id_gui;
              
               ELSEIF v_tipo_dato='interface' THEN
                
                 update segu.tgui set

                       codigo_gui=v_parametros.codigo_gui,
                       visible=v_parametros.visible,
                       nombre=v_parametros.nombre,
                       descripcion=v_parametros.descripcion,
                       orden_logico=v_parametros.orden_logico,
                       ruta_archivo=v_parametros.ruta_archivo,                      
                       icono=v_parametros.icono,
                       --id_subsistema=v_parametros.id_subsistema,
                       clase_vista=v_parametros.clase_vista

                 where id_gui=v_parametros.id_gui;  
                 
               END IF;          
               
               v_resp = f_agrega_clave(v_resp,'mensaje','GUI modificada con exito '||v_parametros.id_gui);
               v_resp = f_agrega_clave(v_resp,'id_gui',v_parametros.id_gui::varchar);
               
               return 'GUI '||v_parametros.id_gui||' modificado con exito';
          END;
          
 /*******************************    
 #TRANSACCION:  SEG_GUI_ELI
 #DESCRIPCION:	Inactiva la interfaz del arbol seleccionada 
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		03-10-2010
 #RESUMEN:		0) Verificamos que el uig no tenga roles asociados
 				1) Verificamos que el gui no tenga mas de un padre
                    
                2.1) IF si tiene mas de un padre 
                	2.1.1)  solamente eliminamos la relacion con el padre indicado 
                    en estructura_gui
                             
                2.2) ELSE si solo tiene un padre
                	2.2.0) Contamos cueantos gui hijos tiene el nodo que se quiere eliminar
                    2.2.1) Contamos cuantos procedimientos hijo tiene  el nodo que se quiere eliminar
                	2.2.2) IF si no tienen hijos eliminamos su relacion con el padre
                    en estructura_gui
                    	2.2.2.1) eliminamos el gui
                	2.2.3) ELSE Retornamos un error
***********************************/
    elsif(par_transaccion='SEG_GUI_ELI')then          
         
          BEGIN
                             
                v_cont_padre=0;                     
    
          --0) verificamos que el gui no tenga roles asociados
           v_cont_rol=0;
           SELECT 
               count(gr.id_gui_rol)
           INTO
                   v_cont_rol
           FROM segu.tgui_rol gr
           WHERE gr.id_gui=v_parametros.id_gui and gr.estado_reg='activo';
           
           IF  (v_cont_rol > 0) THEN
           
           raise exception 'La interface no puede eliminarce por que tiene roles relacionados';
           END IF;                  
                                             
          --1) verificamos que el gui no tenga mas de un padre
           SELECT 
               count(eg.fk_id_gui)
           INTO
                   v_cont_padre
           FROM segu.testructura_gui eg
           WHERE id_gui=v_parametros.id_gui;
          
             --2.1) IF si tiene mas de un padre 
            IF  (v_cont_padre > 1) THEN      
              
              -- 2.1.1)  solamente eliminamos la relacion con el padre indicado en estructura_gui
                    update segu.testructura_gui
                            set estado_reg='inactivo'
                    WHERE     id_gui=v_parametros.id_gui  
                       AND  fk_id_gui=v_parametros.id_gui_padre;
              
           -- 2.2) ELSEIF si solo tiene un padre
              
           ELSEIF v_cont_padre = 1 THEN
              
              -- 2.2.0) Contamos cueantos gui hijos tiene el nodo que se quiere eliminar                  SELECT 
                     
                      v_cont_hijo=0;
                      
                      SELECT
                        count(eg.id_gui)
                      INTO
                         v_cont_hijo
                      FROM segu.testructura_gui eg
                      WHERE fk_id_gui=v_parametros.id_gui;
                      
              -- 2.2.1) Contamos cuantos procedimientos hijo tiene  el nodo que se quiere eliminar
                      
                      v_cont_prodecimiento_hijo=0;
                      SELECT 
                         count(pg.id_procedimiento)
                      INTO
                         v_cont_prodecimiento_hijo
                      FROM segu.tprocedimiento_gui pg
                      WHERE pg.id_gui=v_parametros.id_gui;
                      
               
              -- 2.2.2) IF si no tienen hijos
                IF (v_cont_prodecimiento_hijo = 0 AND v_cont_hijo = 0) THEN 
                    
                    -- 2.2.2.1 eliminamos su relacion con el padre en estructura_gui
                    DELETE FROM segu.testructura_gui
                    WHERE     id_gui=v_parametros.id_gui  
                         AND  fk_id_gui=v_parametros.id_gui_padre;
                
                     -- 2.2.2.2) eliminamos el gui
                    
                    update segu.tgui set estado_reg='inactivo'
                    WHERE  id_gui=v_parametros.id_gui;
                    
                    -- 2.2.3) ELSE Retornamos un error 
                 
                 ELSE
              
                   raise exception 'La interfaz que quiera elimminar tiene nodos dependientes';
                   
                 END IF;
              
          -- 2.3) ELSEIF no tiene un padre
              
           ELSE
              --2.3.1 retornamos un error de consistencia todos los gui deberian tener padre
              --(excepto la raiz que no puede eliminarce)
            
                raise exception 'No puede eliminar la interfaz raiz';
              
           END IF;

             v_resp = f_agrega_clave(v_resp,'mensaje','GUI eliminado con exito '||v_parametros.id_gui); 
             v_resp = f_agrega_clave(v_resp,'id_gui',v_parametros.id_gui::varchar);

            return v_resp;
               
         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

       	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


ALTER FUNCTION segu.ft_gui_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 246 (class 1255 OID 16668)
-- Dependencies: 14 2435
-- Name: ft_gui_rol_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_gui_rol_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************

 FUNCION: 		segu.ft_gui_rol_ime
 DESCRIPCIÓN: 	registro de permisos sobre gui y procedimiento en roles
 AUTOR: 		KPLIAN(jrr)	
 FECHA:			19/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE

v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion       text;
v_mensaje_error        text;
v_accion               varchar;
v_resp                 varchar;

BEGIN

     v_nombre_funcion:='segu.ft_gui_rol_ime';
     v_parametros:=f_get_record(par_tabla); 
     
 /*******************************    
 #TRANSACCION:  SEG_GUIROL_INS
 #DESCRIPCION:	Modifica los permisos del un rol ID_ROL sobre un  tipo TIPO
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		19-07-2010	
***********************************/

     if(par_transaccion='SEG_GUIROL_INS')then

        
          BEGIN
               if(v_parametros.checked='true')then
                   v_accion='dar';
               else
                   v_accion='quitar';
               end if;
               
               if(v_parametros.tipo='gui')then
                   v_respuesta:=segu.f_permiso_rol(v_parametros.id,null,v_parametros.id_rol,v_accion,'subir_bajar');
               else
                   v_respuesta:=segu.f_permiso_rol(null,v_parametros.id,v_parametros.id_rol,v_accion,'subir_bajar');
               end if;   
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Se modifico con exito los permisos del rol '||v_parametros.id_rol ||' sobre '|| v_parametros.tipo ||'  id='||v_parametros.id); 
               v_resp = f_agrega_clave(v_resp,'id_rol',v_parametros.id_rol::varchar);
    
         END;          
   
     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     
   return v_resp; 

EXCEPTION

       WHEN OTHERS THEN

       	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


ALTER FUNCTION segu.ft_gui_rol_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 188 (class 1255 OID 16669)
-- Dependencies: 14 2435
-- Name: ft_gui_rol_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_gui_rol_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.fr_gui_rol_sel
 DESCRIPCIÓN: 	listado de interfaces con privilegios sobre procedimientos
                segun el rol especificado                     
 AUTOR: 		KPLIAN(rac)	
 FECHA:			26/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/


DECLARE



v_consulta    		varchar;
v_parametros  		record;
v_nombre_funcion	text;
v_mensaje_error		text;
v_id_padre         	integer;

v_resp              varchar;
v_where 			varchar;
                            

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

 --raise exception 'XXXXXXXXXXXXXXXXXXXXxxx   No existe la opcion';

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_gui_rol_sel';

/*******************************    
 #TRANSACCION:  SEG_GUIROL_SEL
 #DESCRIPCION:	Listado de interfaces con privilegios sobre procedimientos
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		26/07/10	
***********************************/
     if(par_transaccion='SEG_GUIROL_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                             estgui.id_estructura_gui,
                             gui.id_gui,
                             gui.id_subsistema,
                             subsis.nombre as desc_subsistema,
                             gui_padre.id_gui as id_p,
                             gui.nivel,
                             coalesce(gui.nombre,'' '') as nombre,
                             gui.descripcion,
							 gui.codigo_gui,
                             gui.visible,
                             gui.orden_logico,
                             gui.ruta_archivo,
							 gui.icono,
                                (case
                                 when exists (  SELECT 1
                                                FROM segu.tgui_rol gr
                                                WHERE gr.id_gui=gui.id_gui
                                                AND gr.estado_reg=''activo'' 
                                                AND gr.id_rol='||v_parametros.id_rol||')then
                                   ''true''
                                 ELSE
                                    ''false''
                                 end)::varchar as checked,
                               -- (''gui''::varchar) as tipo_meta,
                                 case
                                        when (gui.ruta_archivo is null or gui.ruta_archivo='''')then
                                             ''carpeta''::varchar
                                        ELSE
                                            ''interface''::varchar
                                        END as tipo_meta,
                                
                                (gui.id_gui||''_gui'')::varchar  as id_nodo,
                                
                                '||v_parametros.id_rol||'::integer as id_rol
                        FROM segu.tgui gui 
                        LEFT JOIN segu.tsubsistema subsis 
                         ON subsis.id_subsistema=gui.id_subsistema
                        LEFT JOIN segu.testructura_gui estgui 
                         ON estgui.id_gui=gui.id_gui
                        LEFT JOIN segu.tgui gui_padre 
                         ON gui_padre.id_gui=estgui.fk_id_gui
                        WHERE gui.estado_reg=''activo'' and gui_padre.estado_reg=''activo'' ';
              

              if(v_parametros.id_padre = '%') then
                v_id_padre:=0;
              --  v_consulta:=v_consulta|| ' AND gui.id_subsistema= '|| v_parametros.id_subsistema;
              else
                v_id_padre:=v_parametros.id_padre;
              end if;
--raise exception 'sss%',v_id_padre;
               v_consulta:=v_consulta|| ' AND estgui.fk_id_gui= '|| v_id_padre;
               --v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               
              -- raise exception '%',v_consulta;
              
            --  v_consulta='select id_gui from segu.tgui gui';
              
               return v_consulta;


         END;

/*******************************    
 #TRANSACCION:  SEG_GUIROL_CONT
 #DESCRIPCION:	Contar las interfaces con privilegios sobre procedimientos
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		26/07/10	
***********************************/    
     elsif(par_transaccion='SEG_GUIROL_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(guirol.id_gui_rol)
                            FROM segu.tgui_rol guirol 
                            INNER JOIN segu.tgui gui 
                              ON gui.id_gui=guirol.id_gui
                            INNER JOIN segu.trol rol
                              ON rol.id_rol=guirol.id_rol 
                            WHERE guirol.estado_reg=''activo'' and   ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;


EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;          
END;
$$;


ALTER FUNCTION segu.ft_gui_rol_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 294 (class 1255 OID 16671)
-- Dependencies: 14 2435
-- Name: ft_gui_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_gui_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.fgui_wel
 DESCRIPCIÓN:   listado de interfaces en formato arbol
 AUTOR: 		KPLIAN(rac)	
 FECHA:			26/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/
                                                                          
DECLARE            

v_consulta    		varchar;
v_parametros  		record;
v_nombre_funcion   	text;
v_mensaje_error    	text;
v_id_padre         	integer;

v_resp             	varchar;
v_where 			varchar;
v_join  			varchar;      

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_gui_sel';

/*******************************    
 #TRANSACCION:  SEG_GUI_SEL
 #DESCRIPCION:	Listado de interfaces en formato de arbol
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		26/07/10
 *******************************    
 #DESCRIPCION:	se modifica el filtro inicial para que considera nivel 0 o nivel 1
 #AUTOR_MOD:		KPLIAN(rac)		
 #FECHA_MOD:		22/11/11	
***********************************/
     if(par_transaccion='SEG_GUI_SEL')then

          --consulta:=';
          BEGIN
          
              if(v_parametros.id_padre = '%') then
                v_where := '  (g.nivel = 1 or  g.nivel = 0)
                              AND  g.id_subsistema = '||v_parametros.id_subsistema;
                 v_join:= 'LEFT';      
                      
              else
                v_where := ' eg.fk_id_gui = '||v_parametros.id_padre;
                v_join := 'INNER';
              end if;
          

                               v_consulta =  'SELECT
                                        g.id_gui,
                                        g.id_subsistema,
                                        eg.fk_id_gui as id_gui_padre,
                                        g.codigo_gui,
                                        g.nombre,
                                        g.descripcion,
                                        g.nivel,
                                        g.visible,
                                        g.orden_logico,
                                        g.ruta_archivo,
                                        g.icono,
                                        g.clase_vista,
                                        case
                                        when (g.ruta_archivo is null or g.ruta_archivo='''')then
                                             ''carpeta''::varchar
                                        ELSE
                                            ''interface''::varchar
                                        END as tipo_dato,
                                        case
                                           when (g.ruta_archivo is null or g.ruta_archivo = '''') then 
                                           (g.id_gui||''_carpeta'')::varchar
                                           ELSE 
                                           (g.id_gui||''_interface'')::varchar
                                         END 
                                         as id_nodo
                                  FROM segu.tgui g
                                       '||v_join||' JOIN segu.testructura_gui eg
                                       ON g.id_gui=eg.id_gui
                                   WHERE '|| v_where ||' 
                       
                                  ORDER BY g.orden_logico, eg.fk_id_gui';
               
               return v_consulta;


         END;

/*******************************    
 #TRANSACCION:  SEG_GUI_CONT
 #DESCRIPCION:	Contar  vistas registradas del sistema
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		26/07/10	
***********************************/
     elsif(par_transaccion='SEG_GUI_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(gui.id_gui)
                        from segu.tgui gui inner join
                        segu.subsistema subsis on subsis.id_subsistema=gui.id_subsistema
                        left join segu.testructura_gui estgui on estgui.id_gui=gui.id_gui
                        left join segu.tgui gui_padre on gui_padre.id_gui=estgui.fk_id_gui
                        where gui.estado_reg=''activo'' and gui_padre.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               
               if(v_parametros.id_padre like '%') then
                v_id_padre:=0;
              else
                v_id_padre:=v_parametros.id_padre;
              end if;
              v_consulta:=v_consulta|| ' and estgui.fk_id_gui= '||v_id_padre;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;      
END;
$$;


ALTER FUNCTION segu.ft_gui_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 189 (class 1255 OID 16672)
-- Dependencies: 14 2435
-- Name: ft_horario_trabajo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_horario_trabajo_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************

 FUNCION: 		segu.ft_horario_trabajo_ime
 DESCRIPCIÓN: 	
 AUTOR: 		KPLIAN(jrr)	
 FECHA:			
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE

v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion       text;
v_mensaje_error        text;
v_accion               varchar;
v_resp                 varchar;

BEGIN

     v_nombre_funcion:='segu.ft_horario_trabajo_ime';
     v_parametros:=f_get_record(par_tabla); 
     

     if(par_transaccion='SEG_HORTRA_INS')then

        --raise exception 'lelga%',v_parametros.hora_ini;--||'---'||(select to_char(v_parametros.hora_ini,'HH24:mm'));
          BEGIN
              INSERT INTO segu.thorario_trabajo (
                          dia_semana,
                          hora_ini,
                          hora_fin
                           )

               values(     v_parametros.dia_semana,
                           v_parametros.hora_ini,
                           v_parametros.hora_fin);


               v_resp = f_agrega_clave(v_resp,'mensaje','Horario de Trabajo insertado con exito ');
               v_resp = f_agrega_clave(v_resp,'horario_trabajo',1::varchar);
    
         END;          
   
     elsif(par_transaccion='SEG_HORTRA_MOD')then


          BEGIN
               --modificacion de tipo_obligacion
                update segu.thorario_trabajo
                set
                          dia_semana=v_parametros.dia_semana,
                          hora_ini=v_parametros.hora_ini,
                          hora_fin=v_parametros.hora_fin
                where id_horario_trabajo=v_parametros.id_horario_trabajo;

                v_resp = f_agrega_clave(v_resp,'mensaje','horario_trabajo modificado con exito '||v_parametros.id_horario_trabajo);
                v_resp = f_agrega_clave(v_resp,'id_horario_trabajo',v_parametros.id_horario_trabajo::varchar);
          END;
     elsif(par_transaccion='SEG_HORTRA_ELI')then
        BEGIN

         --inactivacion de tipo_obligacion
              delete from segu.thorario_trabajo
              where id_horario_trabajo=v_parametros.id_horario_trabajo;

               v_resp = f_agrega_clave(v_resp,'mensaje','horario_trabajo eliminado con exito '||v_parametros.id_horario_trabajo);
               v_resp = f_agrega_clave(v_resp,'horario_trabajo',v_parametros.id_horario_trabajo::varchar);

        END;
     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     
   return v_resp; 

EXCEPTION

       WHEN OTHERS THEN

       	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


ALTER FUNCTION segu.ft_horario_trabajo_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 191 (class 1255 OID 16673)
-- Dependencies: 14 2435
-- Name: ft_horario_trabajo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_horario_trabajo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.fhorario_trabajo_sel
 DESCRIPCIÓN:   listado de horario de trabajo
 AUTOR: 		KPLIAN(jrr)	
 FECHA:			
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/
                                                                          
DECLARE            

v_consulta    		varchar;
v_parametros  		record;
v_nombre_funcion   	text;
v_mensaje_error    	text;
v_id_padre         	integer;

v_resp             	varchar;
v_where 			varchar;
v_join  			varchar;      

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_horario_trabajo_sel';


     if(par_transaccion='SEG_HORTRA_SEL')then

          --consulta:=';
          BEGIN
          
              v_consulta =  'SELECT
                             HORTRA.id_horario_trabajo,
                             HORTRA.dia_semana,
                             HORTRA.hora_ini,
                             HORTRA.hora_fin,
                             (f_iif(to_char(HORTRA.dia_semana,''d'') = ''1'',''Domingo'',f_iif(to_char(HORTRA.dia_semana,''d'') = ''2'',''Lunes'',f_iif(to_char(HORTRA.dia_semana,''d'') = ''3'',''Martes'', f_iif(to_char(HORTRA.dia_semana,''d'') = ''4'',''Jueves'',f_iif(to_char(HORTRA.dia_semana,''d'') = ''5'',''Viernes'',''Sabado'')))))) ::varchar as dia_literal

                             from segu.thorario_trabajo HORTRA
                             WHERE
                             ';
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;
         END;

     elsif(par_transaccion='SEG_HORTRA_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(HORTRA.id_horario_trabajo)
                            from segu.thorario_trabajo HORTRA  WHERE ';
               v_consulta:=v_consulta||v_parametros.filtro;
               --v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;      
END;
$$;


ALTER FUNCTION segu.ft_horario_trabajo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1315 (class 1255 OID 3512172)
-- Dependencies: 2435 14
-- Name: ft_libreta_her_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: postgres
--

CREATE FUNCTION ft_libreta_her_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_libreta_her_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'segu.libreta_her'
 AUTOR: 		 (rac)
 FECHA:	        18-06-2012 16:45:50
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_libreta_her	integer;
			    
BEGIN

    v_nombre_funcion = 'segu.ft_libreta_her_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SG_LIB_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		18-06-2012 16:45:50
	***********************************/

	if(p_transaccion='SG_LIB_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into segu.libreta_her(
			estado_reg,
			telefono,
			nombre,
			obs,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.telefono,
			v_parametros.nombre,
			v_parametros.obs,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_libreta_her into v_id_libreta_her;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','LIBRETA almacenado(a) con exito (id_libreta_her'||v_id_libreta_her||')'); 
            v_resp = f_agrega_clave(v_resp,'id_libreta_her',v_id_libreta_her::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'SG_LIB_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		18-06-2012 16:45:50
	***********************************/

	elsif(p_transaccion='SG_LIB_MOD')then

		begin
			--Sentencia de la modificacion
			update segu.libreta_her set
			telefono = v_parametros.telefono,
			nombre = v_parametros.nombre,
			obs = v_parametros.obs,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_libreta_her=v_parametros.id_libreta_her;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','LIBRETA modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_libreta_her',v_parametros.id_libreta_her::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'SG_LIB_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		18-06-2012 16:45:50
	***********************************/

	elsif(p_transaccion='SG_LIB_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from segu.libreta_her
            where id_libreta_her=v_parametros.id_libreta_her;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','LIBRETA eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_libreta_her',v_parametros.id_libreta_her::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION segu.ft_libreta_her_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1316 (class 1255 OID 3512173)
-- Dependencies: 14 2435
-- Name: ft_libreta_her_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: postgres
--

CREATE FUNCTION ft_libreta_her_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_libreta_her_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'segu.libreta_her'
 AUTOR: 		 (rac)
 FECHA:	        18-06-2012 16:45:50
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'segu.ft_libreta_her_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SG_LIB_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		18-06-2012 16:45:50
	***********************************/

	if(p_transaccion='SG_LIB_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						lib.id_libreta_her,
						lib.estado_reg,
						lib.telefono,
						lib.nombre,
						lib.obs,
						lib.id_usuario_reg,
						lib.fecha_reg,
						lib.id_usuario_mod,
						lib.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from segu.libreta_her lib
						inner join segu.tusuario usu1 on usu1.id_usuario = lib.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = lib.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'SG_LIB_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		18-06-2012 16:45:50
	***********************************/

	elsif(p_transaccion='SG_LIB_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_libreta_her)
					    from segu.libreta_her lib
					    inner join segu.tusuario usu1 on usu1.id_usuario = lib.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = lib.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION segu.ft_libreta_her_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 192 (class 1255 OID 16674)
-- Dependencies: 14 2435
-- Name: ft_log_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_log_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_log_sel
 DESCRIPCIÓN:   listado de los eventos (log) del sistema
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:
 AUTOR:		
 FECHA:	
***************************************************************************/

DECLARE                  

v_consulta    varchar;
v_parametros  record;
v_resp          varchar;
v_nombre_funcion   text;
v_mensaje_error    text;
v_res_actualiz    varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(p_tabla);
     v_nombre_funcion:='segu.f_t_log_sel';

/*******************************    
 #TRANSACCION:  SEG_LOGMON_SEL
 #DESCRIPCION:	Listado del monitoreo de eventos del  XPH sistema
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     if(p_transaccion='SEG_LOGMON_SEL')then

          --consulta:=';
          BEGIN
-- to_char(logg.fecha_reg,''dd/mm/yyyy hh24:mi:ss''),


               v_consulta:='select logg.id_log,
                            logg.id_usuario,
                            logg.cuenta_usuario,
                            logg.mac_maquina,
                            logg.ip_maquina,
                            logg.tipo_log,
                            logg.descripcion,
                            logg.fecha_reg,
                            logg.procedimientos,
                            logg.transaccion,
                            logg.consulta,
                            logg.usuario_base,
                            logg.tiempo_ejecucion,
                            logg.pid_web,
                            logg.pid_db,
                            logg.sid_web,
                            logg.codigo_error,
                            logg.descripcion_transaccion,
                            logg.codigo_subsistema
                            
                        from segu.vlog logg
                        where  ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************    
 #TRANSACCION:  SEG_LOGMON_CONT
 #DESCRIPCION:	Contar registros del monitor de enventos del sistema(Actualiza eventos de BD)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_LOGMON_CONT')then

          --consulta:=';
          BEGIN
                /*Actualiza eventos de BD*/
                v_res_actualiz=segu.f_actualizar_log_bd (v_parametros.archivo_log);
                
               v_consulta:='select count(logg.id_log)
                              from segu.vlog logg
                           where  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     elsif(p_transaccion='SEG_LOG_SEL')then

          --consulta:=';
          BEGIN
-- to_char(logg.fecha_reg,''dd/mm/yyyy hh24:mi:ss''),

            if(not exists (select 1
                FROM pg_namespace n
                INNER JOIN pg_class c ON c.relnamespace = n.oid
                where n.nspname like 'log'
                and c.relkind='r' and
                c.relname='tlog_'||v_parametros.gestion||'_'||v_parametros.periodo))then
                raise exception 'No se tienen registros para la gestion y periodo seleccionados';
            end if;

               v_consulta:='select logg.id_log,
                            logg.id_usuario,
                            logg.cuenta_usuario,
                            logg.mac_maquina,
                            logg.ip_maquina,
                            logg.tipo_log,
                            logg.descripcion,
                            logg.fecha_reg,
                            logg.procedimientos,
                            logg.transaccion,
                            logg.consulta,
                            logg.usuario_base,
                            logg.tiempo_ejecucion,
                            logg.pid_web,
                            logg.pid_db,
                            logg.sid_web,
                            logg.codigo_error,
                            logg.descripcion_transaccion,
                            logg.codigo_subsistema

                        from log.tlog_'||v_parametros.gestion||'_'||v_parametros.periodo||' logg
                        where  si_log=1 and ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************
 #TRANSACCION:  SEG_LOG_CONT
 #DESCRIPCION:	Contar  los eventos del sistema registrados
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_LOG_CONT')then

          --consulta:=';
          BEGIN

                if(not exists (select 1
                    FROM pg_namespace n
                    INNER JOIN pg_class c ON c.relnamespace = n.oid
                    where n.nspname like 'log'
                    and c.relkind='r' and
                    c.relname='tlog_'||v_parametros.gestion||'_'||v_parametros.periodo))then
                    raise exception 'No se tienen registros para la gestion y periodo seleccionados';
                end if;
               v_consulta:='select count(logg.id_log)
                              from log.tlog_'||v_parametros.gestion||'_'||v_parametros.periodo||' logg
                           where  si_log=1 and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

 /*******************************
 #TRANSACCION:  SEG_LOGHOR_SEL
 #DESCRIPCION:	Lista eventos del sistema sucedidos fuera de horarios de trabajo
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
    elsif(p_transaccion='SEG_LOGHOR_SEL')then

          --consulta:=';
          BEGIN
-- to_char(logg.fecha_reg,''dd/mm/yyyy hh24:mi:ss''),

            if(not exists (select 1
                FROM pg_namespace n
                INNER JOIN pg_class c ON c.relnamespace = n.oid
                where n.nspname like 'log'
                and c.relkind='r' and
                c.relname='tlog_'||v_parametros.gestion||'_'||v_parametros.periodo))then
                raise exception 'No se tienen registros para la gestion y periodo seleccionados';
            end if;

               v_consulta:='select logg.id_log,
                            logg.id_usuario,
                            logg.cuenta_usuario,
                            logg.mac_maquina,
                            logg.ip_maquina,
                            logg.tipo_log,
                            logg.descripcion,
                            logg.fecha_reg,
                            logg.procedimientos,
                            logg.transaccion,
                            logg.consulta,
                            logg.usuario_base,
                            logg.tiempo_ejecucion,
                            logg.pid_web,
                            logg.pid_db,
                            logg.sid_web,
                            logg.codigo_error,
                            logg.descripcion_transaccion,
                            logg.codigo_subsistema,
                            (case when logg.dia_semana=1 then
                                ''domingo''
                            when logg.dia_semana=2 then
                                ''lunes''
                            when logg.dia_semana=3 then
                                ''martes''
                            when logg.dia_semana=4 then
                                ''miercoles''
                            when logg.dia_semana=5 then
                                ''jueves''
                            when logg.dia_semana=6 then
                                ''viernes''
                            else
                                ''sabado''
                            end)::varchar as dia_semana

                        from log.tlog_'||v_parametros.gestion||'_'||v_parametros.periodo||' logg
                        inner join segu.thorario_trabajo hor
                        on(hor.dia_semana=logg.dia_semana and logg.fecha_reg::time between hor.hora_ini and hor.hora_fin)
                        where ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************
 #TRANSACCION:  SEG_LOGHOR_CONT
 #DESCRIPCION:	Contar  los eventos fuera de horario de trabajo
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_LOGHOR_CONT')then

          --consulta:=';
          BEGIN

                if(not exists (select 1
                    FROM pg_namespace n
                    INNER JOIN pg_class c ON c.relnamespace = n.oid
                    where n.nspname like 'log'
                    and c.relkind='r' and
                    c.relname='tlog_'||v_parametros.gestion||'_'||v_parametros.periodo))then
                    raise exception 'No se tienen registros para la gestion y periodo seleccionados';
                end if;
               v_consulta:='select count(logg.id_log)
                              from log.tlog_'||v_parametros.gestion||'_'||v_parametros.periodo||' logg
                        inner join segu.thorario_trabajo hor
                        on(hor.dia_semana=logg.dia_semana and logg.fecha_reg::time between hor.hora_ini and hor.hora_fin)
                        where ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_log_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 258 (class 1255 OID 16676)
-- Dependencies: 14 2435
-- Name: ft_menu_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_menu_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_menu_sel
 DESCRIPCION:   consultas de la tabla gui para armar el menu
 AUTOR: 	    KPLIAN(jrr)		
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		Jaime Rivera Rojas	
 FECHA:		08/01/11
***************************************************************************/


DECLARE

    v_consulta    varchar;
    v_parametros  record;
    v_nombre_funcion   text;
    v_mensaje_error    text;
    v_nivel             varchar;
    v_resp				varchar;

/*

'id_padre'
'id_subsistema'

*/

BEGIN

    v_parametros:=f_get_record(par_tabla);
    v_nombre_funcion:='segu.ft_menu_sel';

 /*******************************
 #TRANSACCION:  SEG_MENU_SEL
 #DESCRIPCION:	Arma el menu que aparece en la parte izquierda
                de la pantalla del sistema
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
    if(par_transaccion='SEG_MENU_SEL')then
        if(v_parametros.id_padre='%')then
            v_nivel:='1';
        else
            v_nivel='%';
        end if;

        IF(par_administrador=1) THEN
           BEGIN
              v_consulta:= 'SELECT
                                        g.id_gui,
                                        g.nombre,
                                        g.descripcion,
                                        g.nivel,
                                        g.orden_logico,
                                        g.ruta_archivo,
                                        g.clase_vista,
                                        case
                                        when (g.ruta_archivo is null or g.ruta_archivo='''')then
                                             ''carpeta''::varchar
                                        ELSE
                                            ''hoja''::varchar
                                        END,
                                        g.icono 
                                  FROM segu.tgui g
                                       INNER JOIN segu.testructura_gui eg
                                       ON g.id_gui=eg.id_gui
                                  WHERE g.visible=''si''
                                  AND eg.fk_id_gui::text like '''||v_parametros.id_padre||'''
                                  AND g.nivel::text like '''||v_nivel||'''
                                  ORDER BY g.orden_logico,eg.fk_id_gui';
                                  
                                  raise notice 'adm: %',v_consulta;
              
              return v_consulta;
           END;
        ELSE
           BEGIN
           
              v_consulta:=
                   'SELECT g.id_gui,
                   g.nombre,
                   g.descripcion,
                   g.nivel,
                   g.orden_logico,
                   g.ruta_archivo,
                   g.clase_vista,
                   case
                       when (g.ruta_archivo is null or g.ruta_archivo='''')then
                            ''carpeta''::varchar
                       ELSE
                           ''hoja''::varchar
                   END,
                   g.icono 
                   FROM segu.tgui g
                   inner join segu.testructura_gui eg
                   on g.id_gui=eg.id_gui
                   and g.estado_reg=''activo''
                   and eg.estado_reg=''activo''
                   inner join segu.tgui_rol gr
                   on gr.id_gui=g.id_gui
                   and gr.estado_reg=''activo''
                   inner join segu.trol r
                   on r.id_rol=gr.id_rol
                   and r.estado_reg=''activo''
                   inner join segu.tusuario_rol ur
                   on ur.id_rol=r.id_rol
                   and ur.estado_reg=''activo''
                   inner join segu.tusuario u
                   on u.id_usuario=ur.id_usuario
                   and u.estado_reg=''activo''
                   where g.visible=''si''
                   and eg.fk_id_gui::text like '''||v_parametros.id_padre||'''
                   AND g.nivel::text like '''||v_nivel||'''
                   and u.id_usuario ='|| par_id_usuario||'
                   order by g.orden_logico,eg.fk_id_gui';
                   raise notice 'pueblo: %',v_consulta;
                  
              return v_consulta;
           END;
        END IF;
     else
         raise exception 'No existe la opcion';

     end if;

    EXCEPTION

  	 WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


ALTER FUNCTION segu.ft_menu_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 193 (class 1255 OID 16677)
-- Dependencies: 14 2435
-- Name: ft_monitor_bd_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_monitor_bd_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_monitor_bd_sel
 DESCRIPCIÓN:   listado de los objetos dela bd
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:
 AUTOR:		
 FECHA:	
***************************************************************************/

DECLARE                  

v_consulta    varchar;
v_parametros  record;
v_resp          varchar;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(p_tabla);
     v_nombre_funcion:='segu.f_t_log_sel';

/*******************************    
 #TRANSACCION:  SEG_MONESQ_SEL
 #DESCRIPCION:	Listado de registros del monitor de objetos de bd (Esquemas)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     if(p_transaccion='SEG_MONESQ_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select *
                            
                        from segu.vmonitor_bd_esquema mes
                        where  ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************    
 #TRANSACCION:  SEG_MONESQ_CONT
 #DESCRIPCION:	Contar registros del monitor de objetos de bd (Esquemas)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_MONESQ_CONT')then

          --consulta:=';
          BEGIN
                
               v_consulta:='select count(mes.nspoid)
                            from segu.vmonitor_bd_esquema mes
                            where  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
/*******************************
 #TRANSACCION:  SEG_MONTAB_SEL
 #DESCRIPCION:	Listado de registros del monitor de objetos de bd (Tablas)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_MONTAB_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select *

                        from segu.vmonitor_bd_tabla mta
                        where  ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************
 #TRANSACCION:  SEG_MONTAB_CONT
 #DESCRIPCION:	Contar registros del monitor de objetos de bd (Tablas)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_MONTAB_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(mta.oid)
                            from segu.vmonitor_bd_tabla mta
                            where  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
/*******************************
 #TRANSACCION:  SEG_MONFUN_SEL
 #DESCRIPCION:	Listado de registros del monitor de objetos de bd (Funciones)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_MONFUN_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select *

                        from segu.vmonitor_bd_funcion mfu
                        where  ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************
 #TRANSACCION:  SEG_MONFUN_CONT
 #DESCRIPCION:	Contar registros del monitor de objetos de bd (funciones)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_MONFUN_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(mfu.oid)
                            from segu.vmonitor_bd_funcion mfu
                            where  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
/*******************************
 #TRANSACCION:  SEG_MONIND_SEL
 #DESCRIPCION:	Listado de registros del monitor de objetos de bd (Indices)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_MONIND_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select *

                        from segu.vmonitor_bd_indice min
                        where  ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************
 #TRANSACCION:  SEG_MONIND_CONT
 #DESCRIPCION:	Contar registros del monitor de objetos de bd (indices)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_MONIND_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(min.indexrelid)
                            from segu.vmonitor_bd_indice min
                            where  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
/*******************************
 #TRANSACCION:  SEG_MONREC_SEL
 #DESCRIPCION:	Monitorear recursos usados por el sistema
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_MONREC_SEL')then

          --consulta:=';
          BEGIN
                v_resp=segu.f_monitorear_recursos();
                --raise exception 'llega';
               v_consulta:='select *
                            from tt_monitor_recursos mr
                            where  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_monitor_bd_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 194 (class 1255 OID 16678)
-- Dependencies: 14 2435
-- Name: ft_patron_evento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_patron_evento_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************

 FUNCION: 		segu.ft_patron_evento_ime
 DESCRIPCIÓN: 	
 AUTOR: 		KPLIAN(jrr)	
 FECHA:			
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE

v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion       text;
v_mensaje_error        text;
v_accion               varchar;
v_resp                 varchar;

BEGIN

     v_nombre_funcion:='segu.ft_patron_evento_ime';
     v_parametros:=f_get_record(par_tabla); 
     

     if(par_transaccion='SEG_PATEVE_INS')then

        
          BEGIN
              INSERT INTO segu.tpatron_evento (
                           tipo_evento,
                           operacion,
                           aplicacion,
                           cantidad_intentos,
                           periodo_intentos,
                           tiempo_bloqueo,
                           email,
                           nombre_patron,
                           estado_reg
                           )

               values(     v_parametros.tipo_evento,
                           v_parametros.operacion,
                           v_parametros.aplicacion,
                           v_parametros.cantidad_intentos,
                           v_parametros.periodo_intentos,
                           v_parametros.tiempo_bloqueo,
                           v_parametros.email,
                           v_parametros.nombre_patron,
                           'activo');


               v_resp = f_agrega_clave(v_resp,'mensaje','Patron evento insertado con exito ');
               v_resp = f_agrega_clave(v_resp,'patron_evento',1::varchar);
    
         END;          
   
     elsif(par_transaccion='SEG_PATEVE_MOD')then


          BEGIN
               --modificacion de tipo_obligacion
                update segu.tpatron_evento
                set
                           tipo_evento=v_parametros.tipo_evento,
                           operacion=v_parametros.operacion,
                           aplicacion=v_parametros.aplicacion,
                           cantidad_intentos=v_parametros.cantidad_intentos,
                           periodo_intentos=v_parametros.periodo_intentos,
                           tiempo_bloqueo=v_parametros.tiempo_bloqueo,
                           email=v_parametros.email,
                           nombre_patron=v_parametros.nombre_patron
                where id_patron_evento=v_parametros.id_patron_evento;

                v_resp = f_agrega_clave(v_resp,'mensaje','patron_evento modificado con exito '||v_parametros.id_patron_evento);
                v_resp = f_agrega_clave(v_resp,'id_patron_evento',v_parametros.id_patron_evento::varchar);
          END;
     elsif(par_transaccion='SEG_PATEVE_ELI')then
        BEGIN

         --inactivacion de patron_evento
              update segu.tpatron_evento
              set estado_reg='inactivo'
              where id_patron_evento=v_parametros.id_patron_evento;

               v_resp = f_agrega_clave(v_resp,'mensaje','patron_evento eliminado con exito '||v_parametros.id_patron_evento);
               v_resp = f_agrega_clave(v_resp,'patron_evento',v_parametros.id_patron_evento::varchar);

        END;
     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     
   return v_resp; 

EXCEPTION

       WHEN OTHERS THEN

       	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


ALTER FUNCTION segu.ft_patron_evento_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 195 (class 1255 OID 16679)
-- Dependencies: 14 2435
-- Name: ft_patron_evento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_patron_evento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.fpatron_evento_sel
 DESCRIPCIÓN:   listado de patrones de evento
 AUTOR: 		KPLIAN(jrr)	
 FECHA:			
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/
                                                                          
DECLARE            

v_consulta    		varchar;
v_parametros  		record;
v_nombre_funcion   	text;
v_mensaje_error    	text;
v_id_padre         	integer;

v_resp             	varchar;
v_where 			varchar;
v_join  			varchar;      

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_patron_evento_sel';


     if(par_transaccion='SEG_PATEVE_SEL')then

          --consulta:=';
          BEGIN
          
              v_consulta =  'SELECT
                             PATEVE.id_patron_evento,
                             PATEVE.tipo_evento,
                             PATEVE.operacion,
                             PATEVE.aplicacion,
                           
                             PATEVE.cantidad_intentos,
                             
                             PATEVE.periodo_intentos,
                             PATEVE.tiempo_bloqueo,
                             PATEVE.email,
                             PATEVE.nombre_patron
                             from segu.tpatron_evento PATEVE
                             WHERE PATEVE.estado_reg=''activo'' AND
                             ';
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;
         END;

     elsif(par_transaccion='SEG_PATEVE_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(PATEVE.id_patron_evento)
                            from segu.tpatron_evento PATEVE  WHERE
                            PATEVE.estado_reg=''activo'' AND ';
               v_consulta:=v_consulta||v_parametros.filtro;
               --v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;      
END;
$$;


ALTER FUNCTION segu.ft_patron_evento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1305 (class 1255 OID 16680)
-- Dependencies: 14 2435
-- Name: ft_persona_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_persona_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_persona_ime
 DESCRIPCION:   modificaciones de persona
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		Jaime Rivera Rojas	
 FECHA:		08/01/11
***************************************************************************/

DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_resp                 varchar;
v_nombre_funcion       text;
v_mensaje_error        text;
v_id_persona           integer;

--04/04/2012
v_respuesta_sinc       varchar;
/*
 id_persona_juridica
 nombre
 domicilio
 telefono
 correo
 pag_web
 obs
 estado_reg
*/

BEGIN

           

     v_nombre_funcion:='segu.ft_persona_ime';
     v_parametros:=f_get_record(par_tabla);

 /*******************************
 #TRANSACCION:  SEG_PERSON_INS
 #DESCRIPCION:	Inserta Persona
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_PERSON_INS')then

          --consulta:=';
          BEGIN

                       
               insert into segu.tpersona (
                               nombre,
                               apellido_paterno,
                               apellido_materno,
                               ci,
                               correo,
                               celular1,
               				   telefono1,
                               telefono2,
                               celular2)
               values(
                      v_parametros.nombre,
                      v_parametros.ap_paterno,
                      v_parametros.ap_materno,
                      v_parametros.ci,
                      v_parametros.correo,
                      v_parametros.celular1,
                      v_parametros.telefono1,
                      v_parametros.telefono2,
                      v_parametros.celular2)  
                        
               RETURNING id_persona INTO v_id_persona;
              
               v_respuesta_sinc:= segu.f_sincroniza_persona_entre_bd(v_id_persona,'10.172.0.13','5432','db_link','db_link','dbendesis','INSERT');
               if(v_respuesta_sinc!='si')  then
                  raise exception 'Sincronizacion de persona en BD externa no realizada%',v_respuesta_sinc;
               end if;
               --raise exception 'lega al final del insert';
               v_resp = f_agrega_clave(v_resp,'mensaje','Persona insertada con exito '||v_id_persona); 
               v_resp = f_agrega_clave(v_resp,'id_persona',v_id_persona::varchar);

              

         END;

 /*******************************
 #TRANSACCION:  SEG_PERSON_MOD
 #DESCRIPCION:	Modifica Persona
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_PERSON_MOD')then

          --consulta:=';
          BEGIN
          
   -- raise exception 'ERROR al subir archivo';

               update segu.tpersona 
               set nombre=v_parametros.nombre,
               apellido_paterno=v_parametros.ap_paterno,
               apellido_materno=v_parametros.ap_materno,
               ci=v_parametros.ci,
               correo=v_parametros.correo,
               celular1=v_parametros.celular1,
               telefono1=v_parametros.telefono1,
               telefono2=v_parametros.telefono2,
               celular2=v_parametros.celular2
               where id_persona=v_parametros.id_persona;
              
               v_respuesta_sinc:= segu.f_sincroniza_persona_entre_bd(v_parametros.id_persona,'10.172.0.13','5432','db_link','db_link','dbendesis','UPDATE');
               if(v_respuesta_sinc!='si')  then
                  raise exception 'Sincronizacion a actualizacion de persona en BD externa no realizada%',v_respuesta_sinc;
               end if;
   
             v_resp = f_agrega_clave(v_resp,'mensaje','Persona modificada con exito '||v_parametros.id_persona); 
             v_resp = f_agrega_clave(v_resp,'id_persona',v_parametros.id_persona::varchar);
               
             --v_resp = 'exito'; 
             
            -- raise exception 'XXXXXXXXXXXXXxxx' ;  
               
          END;

 /*******************************
 #TRANSACCION:  SEG_UPFOTOPER_MOD
 #DESCRIPCION:	Modifica la foto de la persona
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_UPFOTOPER_MOD')then

          --consulta:=';
          BEGIN

   -- raise exception 'ERROR al subir archivo';

               update segu.tpersona 
               set 
               foto=v_parametros.foto,
               extension=v_parametros.extension
               where id_persona=v_parametros.id_persona;
             
             v_resp = f_agrega_clave(v_resp,'mensaje','Foto de la persona modificada con exito '||v_parametros.id_persona); 
             v_resp = f_agrega_clave(v_resp,'id_persona',v_parametros.id_persona::varchar);

               
          END;
/*******************************
 #TRANSACCION:  SEG_PERSON_ELI
 #DESCRIPCION:	Elimina Persona
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
    elsif(par_transaccion='SEG_PERSON_ELI')then
                     
          --consulta:=';
          BEGIN
             
            delete from segu.tpersona where id_persona=v_parametros.id_persona;
          
            v_respuesta_sinc:= segu.f_sincroniza_persona_entre_bd(v_parametros.id_persona,'10.172.0.13','5432','db_link','db_link','dbendesis','DELETE');
            if(v_respuesta_sinc!='si')  then
                  raise exception 'Sincronizacion a eliminacion de persona en BD externa no realizada%',v_respuesta_sinc;
            end if;
            v_resp = f_agrega_clave(v_resp,'mensaje','Persona eliminada '||v_parametros.id_persona); 
            v_resp = f_agrega_clave(v_resp,'id_persona',v_parametros.id_persona::varchar);
            
         END;
         
     else
     
         raise exception 'Transacción inexistente: %',par_transaccion;

     end if;
     
       
    return v_resp;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION segu.ft_persona_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1119 (class 1255 OID 16681)
-- Dependencies: 14 2435
-- Name: ft_persona_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_persona_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_persona_sel
 DESCRIPCION:   consultas de persona
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_persona_sel';


 /*******************************
 #TRANSACCION:  SEG_PERSON_SEL
 #DESCRIPCION:	Selecciona Personas
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_PERSON_SEL')then

          --  Se arma la consulta de personas
          BEGIN

               v_consulta:='SELECT 
                              p.id_persona,
                              p.ap_materno,
                              p.ap_paterno,
                              p.nombre,
                              p.nombre_completo1,
                              p.nombre_completo2,
                              p.ci,
                              p.correo,
                              p.celular1,
                              p.num_documento,
                              p.telefono1,
                              p.telefono2,
                              p.celular2
                          FROM segu.vpersona p WHERE ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta || ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               --raise exception '%',v_consulta;
               return v_consulta;


         END;
         
         


/*******************************
 #TRANSACCION:  SEG_PERSON_CONT
 #DESCRIPCION:	Cuenta Personas
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/

     elsif(par_transaccion='SEG_PERSON_CONT')then

          --se arma la sonsulta que cuenta personas
          BEGIN
               
               v_consulta:='select count(p.id_persona)
               from segu.vpersona p where ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
         
         
 /*******************************
 #TRANSACCION:  SEG_PERSONMIN_SEL
 #DESCRIPCION:	Selecciona Personas + fotografia
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_PERSONMIN_SEL')then

          --  Se arma la consulta de personas
          BEGIN
          
               v_consulta:='SELECT p.id_persona,
                             p.apellido_materno AS ap_materno,
                             p.apellido_paterno AS ap_paterno,
                             p.nombre,
                             (((COALESCE(p.nombre, '''' ::character varying) ::text || '' '' ::text) ||
                              COALESCE(p.apellido_paterno, '''' ::character varying) ::text) || '' ''
                               ::text) || COALESCE(p.apellido_materno, '''' ::character varying)
                                ::text AS nombre_completo1,
                             (((COALESCE(p.apellido_paterno, '''' ::character varying) ::text || '' ''
                              ::text) || COALESCE(p.apellido_materno, '''' ::character varying) ::text
                              ) || '' '' ::text) || COALESCE(p.nombre, '''' ::character varying) ::text
                               AS nombre_completo2,
                             p.ci,
                             p.correo,
                             p.celular1,
                             p.num_documento,
                             p.telefono1,
                             p.telefono2,
                             p.celular2,                             
                             p.extension,
                             p.foto
                          FROM segu.tpersona p WHERE ';
                          
                         
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta || ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               --raise exception '%',v_consulta;
               return v_consulta;


         END;    


/*******************************
 #TRANSACCION:  SEG_PERSONMIN_CONT
 #DESCRIPCION:	Cuenta Personas con foto
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/

     elsif(par_transaccion='SEG_PERSONMIN_CONT')then
                            

          --se arma la sonsulta que cuenta personas
          BEGIN
               
               v_consulta:='select count(p.id_persona)
               from segu.tpersona p where ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
         
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_persona_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 773 (class 1255 OID 16682)
-- Dependencies: 14 2435
-- Name: ft_primo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_primo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_primo_sel
 DESCRIPCIÓN: 	manejo de consultas en a tabla primo
 AUTOR: 		KPLIAN(jrr)		
 FECHA:		    28/02/2008
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR: 		Rensi Arteaga Copari
 FECHA:			16/11/2010			
***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp varchar;

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_primo_sel';
     
 /*******************************    
 #TRANSACCION:  SEG_FUNCIO_INS
 #DESCRIPCION:	Obtienen un numero primo segun indice
                el indice se obtiene en el servidor web randomicamente
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2008	
***********************************/


     if(par_transaccion='SEG_OBTEPRI_SEL')then
     
          --consulta:=';
          BEGIN
               v_consulta:='SELECT numero 
                            from segu.tprimo u 
                            where id_primo='||v_parametros.id_primo;
               return v_consulta;
               
               
         END;
    
/*******************************    
 #TRANSACCION:  SEG_FUNCIO_INS
 #DESCRIPCION:	listado de numeros primo
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2008	
***********************************/     
     elsif(par_transaccion='SEG_PRIMO_SEL')then
     
          --consulta:=';
          BEGIN
               --raise exception 'entra';
               v_consulta:='select * from segu.tprimo p where '|| v_parametros.filtro ||'
               order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;

         END;
/*******************************    
 #TRANSACCION:  SEG_FUNCIO_INS
 #DESCRIPCION:	cuenta el listado de numeros primos
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2008	
***********************************/
     elsif(par_transaccion='SEG_PRIMO_CONT')then

          --consulta:=';
          BEGIN
               v_consulta:='select count(*) 
                            from segu.primo p 
                            where '|| v_parametros.filtro;
               return v_consulta;


         END;
     end if;
     
EXCEPTION

        WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_primo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 196 (class 1255 OID 16683)
-- Dependencies: 2435 14
-- Name: ft_procedimiento_gui_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_procedimiento_gui_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_procedimiento_gui
 DESCRIPCIÓN: 	gestion de procedimiento GUI
 AUTOR: 		KPLIAN(rac)	
 FECHA:			18/10/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/

DECLARE


v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_id_procedimiento_gui      integer;
v_resp varchar;

BEGIN

     v_nombre_funcion:='segu.ft_procedimiento_gui_ime';
     v_parametros:=f_get_record(par_tabla);
/*******************************
 #TRANSACCION:  SEG_PROGUI_INS
 #DESCRIPCION:	Inserta Procedimiento_Gui
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_PROGUI_INS')then

        
          BEGIN
               INSERT INTO segu.tprocedimiento_gui(
                     id_procedimiento, 
                     id_gui,
                     boton)
               VALUES (
                       v_parametros.id_procedimiento, 
                       v_parametros.id_gui,
               		   v_parametros.boton)
               RETURNING id_procedimiento_gui into v_id_procedimiento_gui;

             --  return 'Procedimiento GUI insertado con exito';
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Procedimiento GUI  insertada con exito '||v_id_procedimiento_gui); 
               v_resp = f_agrega_clave(v_resp,'id_procedimiento_gui',v_id_procedimiento_gui::varchar);

         END;
/*******************************
 #TRANSACCION:  SEG_PROGUI_MOD
 #DESCRIPCION:	Modifica Procedimiento_Gui
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_PROGUI_MOD')then

          
          BEGIN
               
               update segu.tprocedimiento_gui set
                      id_procedimiento=v_parametros.id_procedimiento,
                      id_gui=v_parametros.id_gui,
                      boton=v_parametros.boton
                     

               where id_procedimiento_gui=v_parametros.id_procedimiento_gui;


             
            v_resp = f_agrega_clave(v_resp,'mensaje','Procedimiento GUI modificado con exito '||v_parametros.id_procedimiento_gui::varchar); 
            v_resp = f_agrega_clave(v_resp,'id_procedimiento_gui',v_parametros.id_procedimiento_gui::varchar);
          
     
      END;
/*******************************
 #TRANSACCION:  SEG_PROGUI_ELI
 #DESCRIPCION:	Elimina Procedimiento_Gui
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
    elsif(par_transaccion='SEG_PROGUI_ELI')then

         
          BEGIN
            
          DELETE FROM segu.tprocedimiento_gui
          WHERE id_procedimiento_gui=v_parametros.id_procedimiento_gui;
              
              
              v_resp = f_agrega_clave(v_resp,'mensaje','Procedimiento GUI inactivado con exito '|| v_parametros.id_procedimiento_gui); 
              v_resp = f_agrega_clave(v_resp,'id_procedimiento_gui',v_parametros.id_procedimiento_gui::varchar);
         
    
    
      END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
 
 return v_resp;  

EXCEPTION

       WHEN OTHERS THEN

       	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


ALTER FUNCTION segu.ft_procedimiento_gui_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 197 (class 1255 OID 16684)
-- Dependencies: 14 2435
-- Name: ft_procedimiento_gui_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_procedimiento_gui_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 CAPA:          MODELO
 FUNCION: 		segu.ft_procedimiento_gui_sel
 DESCRIPCIÓN: 	Permite la gestion de interfaces 
                 de usario con todas sus operaciones basicas
                
 AUTOR: 		KPLIAN(rac)
 FECHA:			16/10/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp                  varchar;
v_where varchar;



/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_procedimiento_gui_sel';

 /*******************************
 #TRANSACCION:  SEG_PROGUI_SEL
 #DESCRIPCION:	Lista procedimientos de una interfaz dada
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/

     if(par_transaccion='SEG_PROGUI_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select 
                            progui.id_procedimiento_gui,
                            progui.id_procedimiento,
                            progui.id_gui,
                            sub.codigo as codigo_sub,
                            fun.nombre as nombre_fun,
                            proced.codigo,
                            proced.descripcion as desc_procedimiento,                           
                            progui.boton,
                            progui.fecha_reg,
                            progui.estado_reg
                        from segu.tprocedimiento_gui progui
                        inner join segu.tprocedimiento proced
                        on proced.id_procedimiento=progui.id_procedimiento
                        inner join segu.tgui gui
                        on gui.id_gui=progui.id_gui 
                        inner join segu.tfuncion fun
                        on proced.id_funcion = fun.id_funcion
                        inner join segu.tsubsistema sub
                        on sub.id_subsistema = fun.id_subsistema 
                        where progui.estado_reg=''activo'' AND progui.id_gui ='|| v_parametros.id_gui||'  AND ';
                   
                   
                   v_consulta:=v_consulta||v_parametros.filtro;


               return v_consulta;


         END;

/*******************************
 #TRANSACCION:  SEG_PROGUI_CONT
 #DESCRIPCION:	Cuenta procedimientos de una interfaz dada
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_PROGUI_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(progui.id_procedimiento_gui)
                            from segu.tprocedimiento_gui progui
                            where progui.estado_reg=''activo'' AND progui.id_gui='||v_parametros.id_gui;
                            
               /* v_consulta:='select count(progui.id_procedimiento_gui)
                            from segu.tprocedimiento_gui progui'; */            
                            
            
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_procedimiento_gui_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 198 (class 1255 OID 16685)
-- Dependencies: 14 2435
-- Name: ft_procedimiento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_procedimiento_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_procedimiento_ime
 DESCRIPCION:   modificaciones de procedimiento
 AUTOR: 	    KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/


DECLARE
v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_resp                  varchar;
v_id_procedimiento      integer;

BEGIN

     v_nombre_funcion:='segu.ft_procedimiento_ime';
     v_parametros:=f_get_record(par_tabla);
/*******************************
 #TRANSACCION:  SEG_PROCED_INS
 #DESCRIPCION:	Inserta Procedimiento
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_PROCED_INS')then

        
          BEGIN
               insert into segu.tprocedimiento(
                id_funcion,             codigo,             descripcion,
                habilita_log)
               values(
                v_parametros.id_funcion,v_parametros.codigo,v_parametros.descripcion,
                v_parametros.habilita_log) RETURNING id_procedimiento into v_id_procedimiento;

               v_resp = f_agrega_clave(v_resp,'mensaje','Procedimiento insertado con exito '||v_id_procedimiento);
               v_resp = f_agrega_clave(v_resp,'id_procedimiento',v_id_procedimiento::varchar);


         END;
/*******************************
 #TRANSACCION:  SEG_PROCED_MOD
 #DESCRIPCION:	Modifica Procedimiento
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_PROCED_MOD')then

          
          BEGIN
               
               update segu.tprocedimiento set
                      id_funcion=v_parametros.id_funcion,
                      codigo=v_parametros.codigo,
                      descripcion=v_parametros.descripcion,
                      habilita_log=v_parametros.habilita_log
                     

               where id_procedimiento=v_parametros.id_procedimiento;
                v_resp = f_agrega_clave(v_resp,'mensaje','Procedimiento modificado con exito '||v_parametros.id_procedimiento);
                v_resp = f_agrega_clave(v_resp,'id_procedimiento',v_parametros.id_procedimiento::varchar);

          END;
/*******************************
 #TRANSACCION:  SEG_PROCED_ELI
 #DESCRIPCION:	Elimina Procedimiento
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
    elsif(par_transaccion='SEG_PROCED_ELI')then

         
          BEGIN
               update segu.tprocedimiento set estado_reg='inactivo'
               where id_procedimiento=v_parametros.id_procedimiento;
               v_resp = f_agrega_clave(v_resp,'mensaje','Procedimiento eliminado con exito '||v_parametros.id_procedimiento);
                v_resp = f_agrega_clave(v_resp,'id_procedimiento',v_parametros.id_procedimiento::varchar);

         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     return v_resp;

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_procedimiento_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 293 (class 1255 OID 16686)
-- Dependencies: 14 2435
-- Name: ft_procedimiento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_procedimiento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_procedimiento_sel
 DESCRIPCIÓN: 	Realiza el listado de procedimientos (trasacciones)
 AUTOR: 		KPLIAN(rac)	
 FECHA:			17/10/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/


DECLARE


v_consulta    			varchar;
v_parametros  record;
v_nombre_funcion   		text;
v_mensaje_error    		text;
v_id_padre         		integer;
v_resp                  varchar;

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_procedimiento_sel';

 /*******************************
 #TRANSACCION:  SEG_PROCED_SEL
 #DESCRIPCION:	Selecciona Procedimientos para agregar al listado del arbol
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		08/01/11	
***********************************/

     if(par_transaccion='SEG_PROCED_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select
               
               progui.id_procedimiento_gui,
               proced.id_procedimiento,
               progui.id_gui,
                            proced.id_funcion,
                            proced.codigo,
                            proced.descripcion,
                            
                            proced.habilita_log,
                            (select distinct ''transaccion'') as tipo_meta
                        from segu.tprocedimiento proced
                        inner join segu.tfuncion funcio
                        on funcio.id_funcion=proced.id_funcion 
                        left join segu.tprocedimiento_gui progui on progui.id_procedimiento=proced.id_procedimiento
                        where proced.estado_reg=''activo'' and ';
              v_consulta:=v_consulta||v_parametros.filtro;
              if(v_parametros.id_padre = '%') then
                v_id_padre:=0;
              else
                v_id_padre:=v_parametros.id_padre;
              end if;
              v_consulta:=v_consulta|| ' and progui.id_gui='|| v_id_padre;
              v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;
 /*******************************
 #TRANSACCION:  SEG_PROCED_CONT
 #DESCRIPCION:	Cuenta Procedimientos para agregar al listado del arbol
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/

     elsif(par_transaccion='SEG_PROCED_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(proced.id_procedimiento)
                            FROM segu.tprocedimiento proced
                            INNER join segu.tfuncion funcio
                            on funcio.id_funcion=proced.id_funcion 
                            WHERE proced.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
            
               return v_consulta;
         END;
/*******************************
 #TRANSACCION:  SEG_PROCE_SEL
 #DESCRIPCION:	Listado de Procedimientos
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_PROCE_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select
                            proced.id_procedimiento,
                            proced.id_funcion,
                            proced.codigo,
                            proced.descripcion,
                            proced.habilita_log,
                            (select distinct ''transaccion'') as tipo_meta
                            from segu.tprocedimiento proced
                            inner join segu.tfuncion funcio
                            on funcio.id_funcion=proced.id_funcion
                            where proced.estado_reg=''activo'' and ';
              v_consulta:=v_consulta||v_parametros.filtro;
                 v_consulta:=v_consulta || ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
            
              /*if(v_parametros.id_padre = '%') then
                v_id_padre:=0;
              else
                v_id_padre:=v_parametros.id_padre;
              end if;*/

              return v_consulta;


         END;
/*******************************
 #TRANSACCION:  SEG_PROCE_CONT
 #DESCRIPCION:	Cuenta Procedimientos
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		08/01/11	
***********************************/

     elsif(par_transaccion='SEG_PROCE_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(proced.id_procedimiento)
                            from segu.tprocedimiento proced
                            inner join segu.tfuncion funcio
                            on funcio.id_funcion=proced.id_funcion where proced.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
              
               return v_consulta;
         END;
/*******************************
 #TRANSACCION:  SEG_PROCECMB_SEL
 #DESCRIPCION:	Selecciona Procedimientos para el listado
                del combo en la vista de procedimiento_gui
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		08/01/11	
***********************************/
      
        elsif(par_transaccion='SEG_PROCECMB_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                                   pro.id_procedimiento,
                                   pro.id_funcion,
                                   sub.id_subsistema,
                                   sub.codigo as codigo_sub,
                                   fun.nombre as nombre_fun,
                                   pro.codigo,
                                   pro.descripcion,
                                   pro.habilita_log
                            FROM segu.tprocedimiento pro
                                 INNER JOIN segu.tfuncion fun on fun.id_funcion = pro.id_funcion
                                 INNER JOIN segu.tsubsistema sub on sub.id_subsistema = fun.id_subsistema

                            WHERE pro.estado_reg = ''activo'' and ';
                            
                            -- pro.id_funcion='|| v_parametros.id_funcion || ' and ';
              v_consulta:=v_consulta||v_parametros.filtro;
              v_consulta:=v_consulta || ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
            
         

              return v_consulta;


         END;

/*******************************
 #TRANSACCION:  SEG_PROCECMB_CONT
 #DESCRIPCION:	Cuenta Procedimientos para el listado
                del combo en la vista de procedimiento_gui
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_PROCECMB_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(pro.id_procedimiento)
         
                            FROM segu.tprocedimiento pro
                                 INNER JOIN segu.tfuncion fun 
                                 on fun.id_funcion = pro.id_funcion
                                 INNER JOIN segu.tsubsistema sub 
                                 on sub.id_subsistema = fun.id_subsistema

                            WHERE pro.estado_reg = ''activo'' and
                            ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
         
         

     else
         raise exception 'No existe la opcion';

     end if;




EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_procedimiento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 282 (class 1255 OID 1475536)
-- Dependencies: 14 2435
-- Name: ft_programa_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: postgres
--

CREATE FUNCTION ft_programa_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_programa_ime
 DESCRIPCION:   Funci?n que gestiona las operaciones b?sicas (inserciones, modificaciones, eliminaciones de la tabla 'segu.tprograma'
 AUTOR: 		 (w)
 FECHA:	        14-08-2011 15:36:44
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCI?N:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_programa	integer;
			
BEGIN

    v_nombre_funcion = 'segu.ft_programa_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************
 	#TRANSACCION:  'SG_PROGRA_INS'
 	#DESCRIPCION:	Inserci?n de registros
 	#AUTOR:		w	
 	#FECHA:		14-08-2011 15:36:44
	***********************************/

	if(p_transaccion='SG_PROGRA_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into segu.tprograma(
			codigo,
			descripcion,
			nombre,
			estado_reg,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			v_parametros.codigo,
			v_parametros.descripcion,
			v_parametros.nombre,
			'activo',
			now(),
			p_id_usuario,
			null,
			null
			)RETURNING id_programa into v_id_programa;

			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Programa almacenado(a) con exito (id_programa'||v_id_programa||')');
            v_resp = f_agrega_clave(v_resp,'id_programa',v_id_programa::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************
 	#TRANSACCION:  'SG_PROGRA_MOD'
 	#DESCRIPCION:	Modificaci?n de registros
 	#AUTOR:		w	
 	#FECHA:		14-08-2011 15:36:44
	***********************************/

	elsif(p_transaccion='SG_PROGRA_MOD')then

		begin
			--Sentencia de la modificacion
			update segu.tprograma set
			codigo= v_parametros.codigo,
			descripcion= v_parametros.descripcion,
			nombre= v_parametros.nombre,
			fecha_mod=now(),
			id_usuario_mod = p_id_usuario
			where id_programa=v_parametros.id_programa;

			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Programa modificado(a)');
            v_resp = f_agrega_clave(v_resp,'id_programa',v_parametros.id_programa::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************
 	#TRANSACCION:  'SG_PROGRA_ELI'
 	#DESCRIPCION:	Eliminaci?n de registros
 	#AUTOR:		w	
 	#FECHA:		14-08-2011 15:36:44
	***********************************/

	elsif(p_transaccion='SG_PROGRA_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from segu.tprograma
            where id_programa=v_parametros.id_programa;

            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Programa eliminado(a)');
            v_resp = f_agrega_clave(v_resp,'id_programa',v_parametros.id_programa::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	else

    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				
END;
$$;


ALTER FUNCTION segu.ft_programa_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 283 (class 1255 OID 1475537)
-- Dependencies: 14 2435
-- Name: ft_programa_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: postgres
--

CREATE FUNCTION ft_programa_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCI?N: 		segu.ft_programa_sel
 DESCRIPCI?N:   Funci?n que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'segu.tprograma'
 AUTOR: 		 (w)
 FECHA:	        13-08-2011 16:32:52
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCI?N:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			
BEGIN

	v_nombre_funcion = 'segu.ft_programa_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************
 	#TRANSACCION:  'SG_PROGRA_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		w	
 	#FECHA:		13-08-2011 16:32:52
	***********************************/

	if(p_transaccion='SG_PROGRA_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						progra.id_programa,
						progra.codigo,
						progra.descripcion,
						progra.estado_reg,
						progra.nombre,
						progra.fecha_reg,
						progra.id_usuario_reg,
						progra.fecha_mod,
						progra.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from segu.tprograma progra
						inner join segu.tusuario usu1 on usu1.id_usuario = progra.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = progra.id_usuario_mod
				        where  ';
			
			--Definici?n de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			
			if(f_existe_parametro(p_tabla,'estado_reg')) then
			  v_consulta:=v_consulta || ' and progra.estado_reg='''||v_parametros.estado_reg||'''';
			end if;
			
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************
 	#TRANSACCION:  'SG_PROGRA_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		w	
 	#FECHA:		13-08-2011 16:32:52
	***********************************/

	elsif(p_transaccion='SG_PROGRA_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_programa)
					    from segu.tprograma progra
					    inner join segu.tusuario usu1 on usu1.id_usuario = progra.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = progra.id_usuario_mod
					    where ';
			
			--Definici?n de la respuesta		
			v_consulta:=v_consulta||v_parametros.filtro;


            if(f_existe_parametro(p_tabla,'estado_reg')) then
			  v_consulta:=v_consulta || ' and progra.estado_reg='''||v_parametros.estado_reg||'''';
			end if;
			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					
		raise exception 'Transaccion inexistente';
					
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION segu.ft_programa_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 262 (class 1255 OID 16687)
-- Dependencies: 14 2435
-- Name: ft_proyecto_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_proyecto_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_proyecto_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'segu.tproyecto'
 AUTOR: 		 (w)
 FECHA:	        17-10-2011 06:35:44
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_proyecto	integer;
			
BEGIN

    v_nombre_funcion = 'segu.ft_proyecto_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************
 	#TRANSACCION:  'SG_PROY_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:35:44
	***********************************/

	if(p_transaccion='SG_PROY_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into segu.tproyecto(
			codigo,
			descripcion,
			estado_reg,
			nombre,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			v_parametros.codigo,
			v_parametros.descripcion,
			'activo',
			v_parametros.nombre,
			now(),
			p_id_usuario,
			null,
			null
			)RETURNING id_proyecto into v_id_proyecto;

			--Definici?n de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Proyecto almacenado(a) con exito (id_proyecto'||v_id_proyecto||')');
            v_resp = f_agrega_clave(v_resp,'id_proyecto',v_id_proyecto::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************
 	#TRANSACCION:  'SG_PROY_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:35:44
	***********************************/

	elsif(p_transaccion='SG_PROY_MOD')then

		begin
			--Sentencia de la modificacion
			update segu.tproyecto set
			codigo = v_parametros.codigo,
			descripcion = v_parametros.descripcion,
			nombre = v_parametros.nombre,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_proyecto=v_parametros.id_proyecto;

			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proyecto modificado(a)');
            v_resp = f_agrega_clave(v_resp,'id_proyecto',v_parametros.id_proyecto::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************
 	#TRANSACCION:  'SG_PROY_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:35:44
	***********************************/

	elsif(p_transaccion='SG_PROY_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from segu.tproyecto
            where id_proyecto=v_parametros.id_proyecto;

            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proyecto eliminado(a)');
            v_resp = f_agrega_clave(v_resp,'id_proyecto',v_parametros.id_proyecto::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	else

    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				
END;
$$;


ALTER FUNCTION segu.ft_proyecto_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 247 (class 1255 OID 16688)
-- Dependencies: 14 2435
-- Name: ft_proyecto_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_proyecto_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_proyecto_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'segu.tproyecto'
 AUTOR: 		 (w)
 FECHA:	        17-10-2011 06:35:44
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			
BEGIN

	v_nombre_funcion = 'segu.ft_proyecto_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************
 	#TRANSACCION:  'SG_PROY_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:35:44
	***********************************/

	if(p_transaccion='SG_PROY_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						proy.id_proyecto,
						proy.codigo,
						proy.descripcion,
						proy.estado_reg,
						proy.nombre,
						proy.fecha_reg,
						proy.id_usuario_reg,
						proy.fecha_mod,
						proy.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from segu.tproyecto proy
						inner join segu.tusuario usu1 on usu1.id_usuario = proy.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = proy.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			
			if(f_existe_parametro(p_tabla,'estado_reg')) then
			  v_consulta:=v_consulta || ' and proy.estado_reg='''||v_parametros.estado_reg||'''';
			end if;
			
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************
 	#TRANSACCION:  'SG_PROY_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:35:44
	***********************************/

	elsif(p_transaccion='SG_PROY_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_proyecto)
					    from segu.tproyecto proy
					    inner join segu.tusuario usu1 on usu1.id_usuario = proy.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = proy.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		
			v_consulta:=v_consulta||v_parametros.filtro;
			
            if(f_existe_parametro(p_tabla,'estado_reg')) then
			  v_consulta:=v_consulta || ' and proy.estado_reg='''||v_parametros.estado_reg||'''';
			end if;
			
			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					
		raise exception 'Transaccion inexistente';
					
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION segu.ft_proyecto_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 202 (class 1255 OID 16689)
-- Dependencies: 14 2435
-- Name: ft_regional_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_regional_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_regional_ime
 DESCRIPCION:   modificaciones de regional
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)	
 FECHA:		08/01/11
***************************************************************************/

DECLARE

    v_nro_requerimiento    	integer;
    v_parametros           	record;
    v_id_requerimiento     	integer;
    v_resp		            varchar;
    v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_regional			integer;


/*

 id_proyecto
 denominacion 
 descripcion
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='segu.ft_regional_ime';
     v_parametros:=f_get_record(p_tabla);
/*******************************
 #TRANSACCION:  SEG_REGION_INS
 #DESCRIPCION:	Inserta Regional
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     if(p_transaccion='SEG_REGION_INS')then

          BEGIN
               
               insert into segu.tregional(
		 nombre,
                 descripcion,
                 estado_reg
               ) values(
                v_parametros.nombre,
                v_parametros.descripcion,
                'activo'
               )RETURNING id_regional into v_id_regional;
               
               --v_mensaje_error = f1();

		v_resp = f_agrega_clave(v_resp,'mensaje','Regional almacenada con exito (id_regional'||v_id_regional||')'); 
               v_resp = f_agrega_clave(v_resp,'id_regional',v_id_regional::varchar);

               return v_resp;

         END;
/*******************************
 #TRANSACCION:  SEG_REGION_MOD
 #DESCRIPCION:	Modifica Regional
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     elsif(p_transaccion='SEG_REGION_MOD')then

          BEGIN

               update segu.tregional set
               nombre=v_parametros.nombre,
               descripcion=v_parametros.descripcion
               where id_regional=v_parametros.id_regional;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Regional modificada'); 
               v_resp = f_agrega_clave(v_resp,'id_regional',v_parametros.id_regional::varchar);
               
               return v_resp;
          END;
/*******************************
 #TRANSACCION:  SEG_REGION_ELI
 #DESCRIPCION:	Elimina Regional
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
    elsif(p_transaccion='SEG_REGION_ELI')then

          --consulta:=';
          BEGIN
               --raise exception 'Error al eliminar';
               delete from segu.tregional
               where id_regional=v_parametros.id_regional;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Regional eliminada'); 
               v_resp = f_agrega_clave(v_resp,'id_regional',v_parametros.id_regional::varchar);
              
               return v_resp;
         END;
         
     else
     
         raise exception 'Transacción inexistente: %',p_transaccion;

     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
        
END;
$$;


ALTER FUNCTION segu.ft_regional_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 203 (class 1255 OID 16690)
-- Dependencies: 14 2435
-- Name: ft_regional_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_regional_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_regional_sel
 DESCRIPCION:   consultas de regionales
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/


DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
    v_resp				varchar;

BEGIN

    v_parametros:=f_get_record(p_tabla);
    v_nombre_funcion:='segu.ft_regional_sel';

 /*******************************
 #TRANSACCION:  SEG_REGION_SEL
 #DESCRIPCION:	Selecciona Regionales
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
    if p_transaccion = 'SEG_REGION_SEL' then

    	begin
        	v_consulta:='select
            			id_regional, fecha_reg, estado_reg,
                        nombre, descripcion
            			from segu.tregional
                        where  ';
            v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            return v_consulta;
		end;

 /*******************************
 #TRANSACCION:  SEG_REGION_CONT
 #DESCRIPCION:	Cuenta Regionales
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
    elsif p_transaccion = 'SEG_REGION_CONT' then

        begin
        	v_consulta:='select count(id_regional)
            			from segu.tregional
                        where ';
            v_consulta:=v_consulta||v_parametros.filtro;
            return v_consulta;
        end;

     else
     
         raise exception 'Transaccion inexistente';
         
     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION segu.ft_regional_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 204 (class 1255 OID 16691)
-- Dependencies: 14 2435
-- Name: ft_rol_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_rol_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************

 FUNCION: 		segu.ft_rol_ime
 DESCRIPCIÓN: 	registro de roles
 AUTOR: 		KPLIAN(rac)	
 FECHA:			19/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE


v_parametros           record;
v_resp                  varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_id_rol 					integer;

BEGIN

     v_nombre_funcion:='segu.ft_rol_ime';
     v_parametros:=f_get_record(p_tabla);
/*******************************
 #TRANSACCION:  SEG_ROL_INS
 #DESCRIPCION:	Inserta Rol
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
     if(p_transaccion='SEG_ROL_INS')then

        
          BEGIN
               insert into segu.trol(descripcion,rol,id_subsistema)
               values(v_parametros.descripcion,v_parametros.rol,v_parametros.id_subsistema)
                RETURNING id_rol into v_id_rol;

                     
               v_resp = f_agrega_clave(v_resp,'mensaje','Rol insertado con exito '||v_id_rol); 
               v_resp = f_agrega_clave(v_resp,'id_rol',v_id_rol::varchar);


         END;
/*******************************
 #TRANSACCION:  SEG_ROL_MOD
 #DESCRIPCION:	Modifica Rol
 #AUTOR:		KPLIAN(rac)
 #FECHA:		08/01/11	
***********************************/
     elsif(p_transaccion='SEG_ROL_MOD')then

          
          BEGIN
               
               update segu.trol set
                      
                      descripcion=v_parametros.descripcion,
                     
                      rol=v_parametros.rol,
                      id_subsistema=v_parametros.id_subsistema
               where id_rol=v_parametros.id_rol;


           
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Rol modificado con exito '||v_parametros.id_rol); 
               v_resp = f_agrega_clave(v_resp,'id_rol',v_parametros.id_rol::varchar);

          END;
/*******************************
 #TRANSACCION:  SEG_ROL_ELI
 #DESCRIPCION:	Elimina Rol
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
    elsif(p_transaccion='SEG_ROL_ELI')then

         
          BEGIN
               update segu.trol set estado_reg='inactivo'
               where id_rol=v_parametros.id_rol;
               
                     
               v_resp = f_agrega_clave(v_resp,'mensaje','Rol eliminado con exito '||v_parametros.id_rol); 
               v_resp = f_agrega_clave(v_resp,'id_rol',v_parametros.id_rol::varchar);

               
         END;

     else

         raise exception 'No existe la transaccion: %',p_transaccion;
     end if;
 return v_resp;      
EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_rol_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 205 (class 1255 OID 16692)
-- Dependencies: 14 2435
-- Name: ft_rol_procedimiento_gui_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_rol_procedimiento_gui_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_rol_procedimiento_gui_sel
 DESCRIPCIÓN: 	listado de procesimientos asignado 
                a una intarface segun el rol especificado
 AUTOR: 		KPLIAN(rac)
 FECHA:			26/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/


DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_id_padre         integer;

v_resp                  varchar;
v_where varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_rol_procedimiento_gui_sel';


 /*******************************
 #TRANSACCION:  SEG_ROLPROGUI_SEL
 #DESCRIPCION:	Selecciona Procesos por Gui y Rol
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_ROLPROGUI_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            pg.id_procedimiento_gui,
                            pg.id_gui,
                            pg.id_procedimiento,
                            p.codigo,
                            p.descripcion,
                            (case
                             when exists (  SELECT 1
                                            FROM segu.trol_procedimiento_gui rpg
                                            WHERE rpg.id_procedimiento_gui=pg.id_procedimiento_gui
                                            and rpg.estado_reg=''activo'' and rpg.id_rol='||v_parametros.id_rol||')then
                               ''true''
                             ELSE
                                ''false''
                             end)::varchar as checked,
                             (''transaccion'')::varchar as tipo_meta,
                             (pg.id_procedimiento_gui||''_transaccion'')::varchar  as id_nodo,
                            '||v_parametros.id_rol||'::integer as id_rol
                            
                        FROM segu.tprocedimiento_gui pg
                        INNER JOIN segu.tprocedimiento p
                            ON(p.id_procedimiento=pg.id_procedimiento)
                        
                        WHERE pg.estado_reg=''activo''' ;

                    if(v_parametros.id_padre = '%') then
                        v_id_padre:=0;
                
                    else
                        v_id_padre:=v_parametros.id_padre;
                    end if;

               v_consulta:=v_consulta|| ' and pg.id_gui= '|| v_id_padre;
               

                        
             
               return v_consulta;


         END;


 /*******************************
 #TRANSACCION:  SEG_ROLPRO_CONT
 #DESCRIPCION:	Cuenta Procesos por Gui y Rol
 #AUTOR:		KPLIAN(rac)
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_ROLPRO_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(rolpro.id_rol_procedimiento)
                            FROM segu.trol_procedimiento rolpro
                            WHERE rolpro.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;
EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_rol_procedimiento_gui_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1186 (class 1255 OID 16693)
-- Dependencies: 2435 14
-- Name: ft_rol_procedimiento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_rol_procedimiento_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_rol_procedimiento_gui_ime
 DESCRIPCION:   modificaciones rol procedimiento
 AUTOR: 		KPLIAN(jrr)
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)	
 FECHA:		08/01/11
***************************************************************************/

DECLARE


v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_resp                 varchar;
v_id_rol_procedimiento  integer;

BEGIN

     v_nombre_funcion:='segu.ft_rol_procedimiento_gui_ime';
     v_parametros:=f_get_record(par_tabla);
/*******************************
 #TRANSACCION:  SEG_ROLPRO_INS
 #DESCRIPCION:	Inserta Rol Procedimiento gui
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_ROLPRO_INS')then

        
          BEGIN
               insert into segu.trol_procedimiento_gui
               (id_procedimiento,                   id_rol)
               values(
               v_parametros.id_procedimiento,       v_parametros.id_rol
               )RETURNING id_rol_procedimiento into v_id_rol_procedimiento;


               v_resp = f_agrega_clave(v_resp,'mensaje','Rol Procedimiento gui insertado con exito '||v_id_rol_procedimiento);
               v_resp = f_agrega_clave(v_resp,'id_rol_procedimiento',v_id_rol_procedimiento::varchar);



         END;
/*******************************
 #TRANSACCION:  SEG_ROLPRO_MOD
 #DESCRIPCION:	modifica Rol Procedimiento gui
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_ROLPRO_MOD')then

          
          BEGIN
               
               update segu.trol_procedimiento_gui set
                      
                      id_procedimiento=v_parametros.id_procedimiento,
                      id_rol=v_parametros.id_rol


               where id_rol_procedimiento=v_parametros.id_rol_procedimiento;

               v_resp = f_agrega_clave(v_resp,'mensaje','Rol Procedimiento gui modificado con exito '||v_parametros.id_rol_procedimiento);
               v_resp = f_agrega_clave(v_resp,'id_rol_procedimiento',v_parametros.id_rol_procedimiento::varchar);



          END;
/*******************************
 #TRANSACCION:  SEG_ROLPRO_ELI
 #DESCRIPCION:	elimina Rol Procedimiento gui
 #AUTOR:		KPLIAN(jrr)
 #FECHA:		08/01/11	
 *********************************
 #DESCRIPCION_MOD:	la eliminacion tiene que ser fisica no por estado
 					para permitir eliminar procedimientos_gui
 #AUTOR_MOD:		KPLIAN(rac)
 #FECHA_MOD:		08/02/12	
***********************************/
    elsif(par_transaccion='SEG_ROLPRO_ELI')then

         
          BEGIN
             /*
               update segu.trol_procedimiento_gui set estado_reg='inactivo'
               where id_rol_procedimiento=v_parametros.id_rol_procedimiento;
              */
              
              delete from segu.trol_procedimiento_gui 
              where id_rol_procedimiento=v_parametros.id_rol_procedimiento;
          
          
           v_resp = f_agrega_clave(v_resp,'mensaje','Rol Procedimiento gui eliminado con exito '||v_parametros.id_rol_procedimiento);
               v_resp = f_agrega_clave(v_resp,'id_rol_procedimiento',v_parametros.id_rol_procedimiento::varchar);


         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
    return v_resp;
EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_rol_procedimiento_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 249 (class 1255 OID 16694)
-- Dependencies: 14 2435
-- Name: ft_rol_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_rol_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_rol_sel
 DESCRIPCION:   
 AUTOR: 		KPLIAN(jrr)
 FECHA:	
 COMENTARIOS:	
***************************************************************************/
DECLARE


v_consulta    varchar;
v_parametros  record;
v_resp                  varchar;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(p_tabla);
     v_nombre_funcion:='segu.ft_rol_sel';


     if(p_transaccion='SEG_ROL_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            roll.id_rol,
                            roll.descripcion,
                            roll.fecha_reg,
                            roll.estado_reg,
                            roll.rol,
                            roll.id_subsistema,
                            coalesce(subsis.nombre,'' '') as desc_subsis
                        FROM segu.trol roll
                        LEFT join segu.tsubsistema subsis
                        on subsis.id_subsistema=roll.id_subsistema where roll.estado_reg = ''activo'' AND ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(p_transaccion='SEG_ROL_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(roll.id_rol)
                            FROM segu.trol roll
                        LEFT JOIN segu.tsubsistema subsis
                        on subsis.id_subsistema=roll.id_subsistema where roll.estado_reg = ''activo'' AND ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_rol_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 206 (class 1255 OID 16695)
-- Dependencies: 14 2435
-- Name: ft_sesion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_sesion_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_sesion_ime
 DESCRIPCIÓN: 	Permite registrar de sesiones activas e inectavas de un usuario
 AUTOR: 		KPLIAN(rac)
 FECHA:			19/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE


v_parametros       	record;
v_resp              varchar;
v_respuesta        	varchar;
v_nombre_funcion   	text;
v_mensaje_error    	text;
v_id_sesion			integer;

BEGIN

     v_nombre_funcion:='segu.ft_sesion_ime';
     v_parametros:=f_get_record(par_tabla);
     
 /*******************************    
 #TRANSACCION:  SEG_SESION_INS
 #DESCRIPCION:	registra sesiones  de un usuario
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		19/07/2010
***********************************/
     if(par_transaccion='SEG_SESION_INS')then

        
          BEGIN
                update segu.tsesion
                    set estado_reg='inactivo'
                where id_usuario=v_parametros.id_usuario
                    and estado_reg='activo';
               insert into segu.tsesion(
             	variable,
		        ip,
		        fecha_reg,
		        id_usuario,
		        estado_reg,
		        hora_act,
		        hora_des,
                datos,
                pid_web,
                inicio_proceso
		        ) VALUES (
		        v_parametros.variable,
		        v_parametros.ip,
		        now(),
		        v_parametros.id_usuario,
		        'activo',
		        now(),
		        NULL,
                v_parametros.datos,
                v_parametros.pid,
                now()
                		        
            )returning  id_sesion into v_id_sesion;                           
            
            v_resp = f_agrega_clave(v_resp,'mensaje','Sesion insertada con exito '||v_id_sesion); 
            v_resp = f_agrega_clave(v_resp,'id_funcion',v_id_sesion::varchar);
            return 'Sesion  insertada con exito';

         END; 
         
 /*******************************    
 #TRANSACCION:  SEG_SESION_MOD
 #DESCRIPCION:	Modifica la una variable de sesion
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		19/07/2010
***********************************/          
     elseif (par_transaccion='SEG_SESION_MOD')then      
        
          BEGIN
              UPDATE segu.tsesion
              SET datos = v_parametros.datos
              WHERE variable = v_parametros.variable
              and ip = v_parametros.ip;
              
              v_resp = f_agrega_clave(v_resp,'mensaje','Sesion modificada con exito, variable: '||v_parametros.variable); 
              v_resp = f_agrega_clave(v_resp,'variable',v_parametros.variable::varchar);  		        
           
            return 'Sesion  insertada con exito';

         END;         
         	v_resp = f_agrega_clave(v_resp,'mensaje','Sesion modificada con exito '||v_id_sesion); 
            v_resp = f_agrega_clave(v_resp,'id_funcion',v_id_sesion::varchar);
     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null,null);
         raise exception '%', v_mensaje_error;


END;
$$;


ALTER FUNCTION segu.ft_sesion_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1169 (class 1255 OID 16696)
-- Dependencies: 14 2435
-- Name: ft_sesion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: postgres
--

CREATE FUNCTION ft_sesion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************

 FUNCION: 		segu.ft_sesion_sel
 DESCRIPCIÓN: 	consultar la ultima sesion de un suario especificado
 AUTOR: 		KPLIAN(rac)
 FECHA:			19/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE                      

v_consulta    		varchar;
v_parametros  		record;
v_nombre_funcion   	text;
v_mensaje_error    	text;
v_resp 				varchar;
v_pid_web        integer;
v_id_sesion        integer;

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_sesion_sel';

/*******************************    
 #TRANSACCION:  SEG_SESION_SEL
 #DESCRIPCION:	Listado de las sesiones activas en el sistema
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		19/07/2010
***********************************/
     if(par_transaccion='SEG_SESION_SEL')then

          --consulta:=';
          BEGIN
                select pid_web,id_sesion
                into v_pid_web,v_id_sesion
                from segu.tsesion
                where id_usuario=v_parametros.id_usuario
                    and estado_reg='activo';
                    
                    raise notice 'v_pid_web: % v_id_sesion: %', v_pid_web, v_id_sesion;
                    
                --raise exception '%,%',v_pid_web,v_parametros.pid;
                if(v_pid_web!=v_parametros.pid)then
                    update segu.tsesion
                    set pid_web=v_parametros.pid,
                        inicio_proceso=now()
                    where id_sesion=v_id_sesion;
                end if;
               v_consulta:='select
                            id_usuario,
                            variable,
                            ip,
                            datos
                        from segu.tsesion 
                        where estado_reg=''activo'' 
                        and id_sesion= ';
               v_consulta:=v_consulta||v_id_sesion;
               v_consulta:=v_consulta||'  order by  id_sesion desc LIMIT 1 OFFSET 0';
	
               return v_consulta;


         END;

/*******************************    
 #TRANSACCION:  SEG_SESION_CONT
 #DESCRIPCION:	Contar  las sesiones activas en el sistema
 #AUTOR:		KPLIAN(rac)
 #FECHA:		19/07/2010
***********************************/
     elsif(par_transaccion='SEG_SESION_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(s.id_sesion)
                            from segu.tsesion s
                            where usuact.estado_reg=''activo'' and s.id_usuario = ';
               v_consulta:=v_consulta||v_parametros.id_usuario;
               return v_consulta;
         END;

     else
        
         
          raise exception 'No existe la transaccion: %',par_transaccion;

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_sesion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 295 (class 1255 OID 16697)
-- Dependencies: 14 2435
-- Name: ft_subsistema_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_subsistema_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_subsistema
 DESCRIPCIÓN: 	gestion de subsistemas
 AUTOR: 		KPLIAN(rac)
 FECHA:			16/9/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/


DECLARE

v_consulta  				varchar;
v_parametros                record;
v_nombre_funcion            text;
v_mensaje_error             text;
v_id                        integer;
v_esquema                   varchar;
v_resp 						varchar;
v_id_gui  					varchar;

BEGIN

     v_nombre_funcion:='segu.ft_subsistema_ime';
     v_parametros:=f_get_record(par_tabla);

 /*******************************    
 #TRANSACCION:  SEG_SUBSIS_INS
 #DESCRIPCION:	Inserta Subsistemas
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		16/9/2010
***********************************/
     if(par_transaccion='SEG_SUBSIS_INS')then

        
          BEGIN
            INSERT INTO segu.tsubsistema(
                      codigo,
                      nombre,
                      prefijo,
                      nombre_carpeta
                   )
             values(
                      v_parametros.codigo,
                      v_parametros.nombre,
                      v_parametros.prefijo,
                      v_parametros.nombre_carpeta)
             RETURNING id_subsistema into v_id;

               -- crear el esquema para el subsistema creado
               v_esquema:=v_parametros.codigo;
               if not exists(SELECT 1 from pg_namespace 
                             WHERE lower(nspname)=lower(v_parametros.codigo)) THEN
                  
                  v_consulta:='CREATE SCHEMA '||v_esquema||' ';--AUTHORIZATION postgres;
                  
                  execute(v_consulta);
               end if;
               
               --crear el metaproceso para el subsistema
               if not exists(SELECT 1 from segu.tgui 
                             WHERE lower(codigo_gui)=v_parametros.codigo 
                             AND id_subsistema=v_id) THEN
                             
                  INSERT INTO segu.tgui(
                            codigo_gui,
                            descripcion,
                            id_subsistema, 
                            nombre,
                            nivel
                            )
                  VALUES(
                           v_parametros.codigo,
                            '',
                           v_id,
                           upper(v_parametros.nombre),
                           1) returning  id_gui into v_id_gui;
               end if;

               --return 'Subsistema insertado con exito';
               
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Subsistema insertado con exito '||v_id_gui); 
               v_resp = f_agrega_clave(v_resp,'id_subsistema',v_id_gui::varchar);

               
         END;

 /*******************************    
 #TRANSACCION:  SEG_SUBSIS_MOD
 #DESCRIPCION:	Modifica el subsistema seleccionada 
 #AUTOR:		KPLIAN(rac)	
 #FECHA:			
***********************************/
     elsif(par_transaccion='SEG_SUBSIS_MOD')then  
          
          BEGIN
               
               UPDATE segu.tsubsistema SET
                      
                      codigo=v_parametros.codigo,
                      prefijo=v_parametros.prefijo,
                      nombre=v_parametros.nombre,
                      nombre_carpeta=v_parametros.nombre_carpeta
               WHERE id_subsistema=v_parametros.id_subsistema;

               v_resp = f_agrega_clave(v_resp,'mensaje','Subsistema modificado con exito '||v_parametros.id_subsistema); 
               v_resp = f_agrega_clave(v_resp,'id_subsistema',v_parametros.id_subsistema::varchar);

               
          END;

/*******************************    
 #TRANSACCION:   SEG_SUBSIS_ELI
 #DESCRIPCION:	Inactiva el subsistema selecionado
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		
***********************************/
    elsif(par_transaccion='SEG_SUBSIS_ELI')then

         
          BEGIN
               UPDATE segu.tsubsistema 
               SET estado_reg='inactivo'
               WHERE id_subsistema=v_parametros.id_subsistema;
             
               v_resp = f_agrega_clave(v_resp,'mensaje','Subsistema eliminado con exito '||v_parametros.id_subsistema); 
               v_resp = f_agrega_clave(v_resp,'id_subsistema',v_parametros.id_subsistema::varchar);

         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
 
--retorna respuesta en formato JSON    
 return v_resp;      

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_subsistema_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 207 (class 1255 OID 16698)
-- Dependencies: 14 2435
-- Name: ft_subsistema_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_subsistema_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.fvalidar_usuario
 DESCRIPCIÓN: 	verifica si el login y contgrasena proporcionados son correctos
                esta funcion es especial porque corre con el usario generico de conexion
                que solo tiene el privilegio de correr esta funcion
 AUTOR: 		KPLIAN (rac)
 FECHA:			26/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/
DECLARE


v_consulta    		varchar;
v_parametros  		record;
v_nombre_funcion   	text;
v_mensaje_error    	text;
v_resp 				varchar;


/*
PARAMETROS PREDEFINIDOS RECIBIDO PARA LA FUNCIONES TIPO SEL
'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN
     -- recupera datos pasados como parametros en el  servidor web
     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_subsistema_sel';

/*******************************    
 #TRANSACCION:  SEG_FUNCIO_SEL
 #DESCRIPCION:	Listado de los subsistemas registradas del sistema
 #AUTOR:		KPLIAN (rac)	
 #FECHA:		
***********************************/
     if(par_transaccion='SEG_SUBSIS_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                              subsis.id_subsistema,
                              subsis.codigo,
                              subsis.prefijo,
                              subsis.nombre,
                              subsis.fecha_reg,
                              subsis.estado_reg,
                              subsis.nombre_carpeta
                        FROM segu.tsubsistema subsis
                        WHERE subsis.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               --raise exception '%',v_consulta;

               return v_consulta;
              

         END;                          

/*******************************    
 #TRANSACCION:  SEG_SUBSIS_CONT
 #DESCRIPCION:	Contar  los subsistemas registrados del sistema
 #AUTOR:		KPLIAN (rac)	
 #FECHA:		
***********************************/
     elsif(par_transaccion='SEG_SUBSIS_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(subsis.id_subsistema)
                            FROM  segu.tsubsistema subsis
                            WHERE subsis.estado_reg=''activo'' and  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;


EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_subsistema_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 297 (class 1255 OID 16700)
-- Dependencies: 14 2435
-- Name: ft_tipo_documento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_tipo_documento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.fprocedimiento_sel
 DESCRIPCIÓN: 	Realiza el listado de procedimientos (trasacciones)
 AUTOR: 		KPLIAN (rac)
 FECHA:			17/10/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/DECLARE


v_consulta    		varchar;
v_parametros  		record;
v_nombre_funcion   	text;
v_mensaje_error    	text;
v_resp              varchar;



/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_tipo_documento_sel';

/*******************************    
 #TRANSACCION:  SEG_TIPDOC_SEL
 #DESCRIPCION:	Listado de los procedimientos de BD
 #AUTOR:		KPLIAN (rac)	
 #FECHA:		
***********************************/
     if(par_transaccion='SEG_TIPDOC_SEL')then
                        

          --consulta:=';
          BEGIN

               v_consulta:='select 
                            tipdoc.id_tipo_documento,
                            tipdoc.nombre,
                            tipdoc.fecha_reg,
                            tipdoc.estado_reg
                        from segu.ttipo_documento tipdoc
                        where tipdoc.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

/*******************************    
 #TRANSACCION:  SEG_FUNCIO_CONT
 #DESCRIPCION:	Contar  los procedimeintos de BD registradas del sistema
 #AUTOR:		KPLIAN (rac)
 #FECHA:		
***********************************/
     elsif(par_transaccion='SEG_TIPDOC_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(tipdoc.id_tipo_documento)
                            from segu.ttipo_documento tipdoc
                            where tipdoc.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_tipo_documento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 208 (class 1255 OID 16701)
-- Dependencies: 14 2435
-- Name: ft_usuario_actividad_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_usuario_actividad_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_usuario_actividad_ime
 DESCRIPCIÓN: 	gestiona las transaciones ime de usairio-actividad
 AUTOR: 		KPLIAN (jrr)
 FECHA:			28/02/2008
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/

DECLARE


v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_id_usuario_actividad		integer;
v_resp			varchar;

BEGIN

     v_nombre_funcion:='segu.f_t_usuario_actividad_ime';
     v_parametros:=f_get_record(par_tabla);

 /*******************************    
 #TRANSACCION:  SEG_USUACT_INS
 #DESCRIPCION:  Relaciona actividades con usuario
 #AUTOR:		KPLIAN (jrr)
 #FECHA:		28-02-2010	
***********************************/

     if(par_transaccion='SEG_USUACT_INS')then

        
          BEGIN
               insert into segu.tusuario_actividad(id_usuario,id_actividad)
               values(v_parametros.id_usuario,v_parametros.id_actividad)
               returning  id_usuario_actividad into v_id_usuario_actividad;

               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario actividad insertado con exito '||v_id_usuario_actividad); 
               v_resp = f_agrega_clave(v_resp,'id_usuario_actividad',v_id_usuario_actividad::varchar);


         END;
 /*******************************    
 #TRANSACCION:  SEG_USUACT_MOD
 #DESCRIPCION:  Modifica la relacion de  actividades con usuario
 #AUTOR:		KPLIAN (jrr)	
 #FECHA:		28-02-2010	
***********************************/
     elsif(par_transaccion='SEG_USUACT_MOD')then

          
          BEGIN
               
               update segu.tusuario_actividad set
                      id_usuario=v_parametros.id_usuario,
                      id_actividad=v_parametros.id_actividad
                     
               where id_usuario_actividad=v_parametros.id_usuario_actividad;

               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario actividad modificado con exito '||v_parametros.id_usuario_actividad); 
               v_resp = f_agrega_clave(v_resp,'id_usuario_actividad',v_parametros.id_usuario_actividad::varchar);

          END;
 /*******************************    
 #TRANSACCION:  SEG_USUACT_ELI
 #DESCRIPCION:  Inactivacion de la relacion de  actividades con usuario
 #AUTOR:		KPLIAN (jrr)	
 #FECHA:		28-02-2010	
***********************************/

    elsif(par_transaccion='SEG_USUACT_ELI')then

         
          BEGIN
               update segu.tusuario_actividad 
               set estado_reg='inactivo'
               where id_usuario_actividad=v_parametros.id_usuario_actividad;
            
          
               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario actividad inactivado con exito '||v_parametros.id_usuario_actividad); 
               v_resp = f_agrega_clave(v_resp,'id_usuario_actividad',v_parametros.id_usuario_actividad::varchar);

         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

return v_resp;

EXCEPTION

        WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_usuario_actividad_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 209 (class 1255 OID 16702)
-- Dependencies: 14 2435
-- Name: ft_usuario_actividad_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_usuario_actividad_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_usuario_actividad_sel
 DESCRIPCIÓN: 	manejo de actividades por usuario
 AUTOR: 		KPLIAN(jrr)
 FECHA:		    28/02/2008
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR: 		Rensi Arteaga Copari
 FECHA:			16/11/2010			
***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_usuario_actividad_sel';
     
     
 /*******************************    
 #TRANSACCION:  SEG_USUACT_SEL
 #DESCRIPCION:	lista las actividades por usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/

     if(par_transaccion='SEG_USUACT_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            usuact.id_usuario_actividad,
                            usuact.id_usuario,
                            usuact.id_actividad,
                            usuact.fecha_reg,
                            usuact.estado_reg,
                            activi.nombre as desc_actividad,
                            person.nombre_completo2 as desc_person
                        FROM segu.tusuario_actividad usuact
                        INNER JOIN segu.tusuario usuari
                        on usuari.id_usuario=usuact.id_usuario 
                        INNER JOIN segu.tactividad activi
                        on activi.id_actividad=usuact.id_actividad and activi.estado_reg=''activo''
                        INNER JOIN segu.vpersona person
                        on person.id_persona=usuari.id_persona
                        WHERE usuact.estado_reg=''activo'' and ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

 /*******************************    
 #TRANSACCION:  SEG_USUACT_CONT
 #DESCRIPCION:	Contar  las actividades por usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/
     elsif(par_transaccion='SEG_USUACT_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(usuact.id_usuario_actividad)
                            FROM segu.tusuario_actividad usuact
                            INNER JOIN segu.tusuario usuari
                            ON usuari.id_usuario=usuact.id_usuario
                            INNER JOIN segu.tactividad activi
                            ON activi.id_actividad=usuact.id_actividad
                            where usuact.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


ALTER FUNCTION segu.ft_usuario_actividad_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 251 (class 1255 OID 16703)
-- Dependencies: 14 2435
-- Name: ft_usuario_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: postgres
--

CREATE FUNCTION ft_usuario_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************

 FUNCION: 		segu.ft_usuario_ime
 DESCRIPCIÓN: 	Permite registrar de de usuarios
 AUTOR: 		KPLIAN(rac)
 FECHA:			19/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE


v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_id_usuario integer;
v_resp varchar;
v_id_roles varchar[];
v_i integer;
v_tamano integer;
--05-04-2012
v_respuesta_sinc       varchar;


v_sincronizar varchar;
v_sincronizar_user varchar;
v_sincronizar_password varchar;
v_sincronizar_base varchar;
v_sincronizar_ip varchar;
v_sincronizar_puerto varchar;





BEGIN

     v_nombre_funcion:='segu.ft_usuario_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
     
     /*
     Obtener variables globales para definir la sincronizacion
     
     */
     
    v_sincronizar = f_get_variable_global('sincronizar');
	v_sincronizar_user= f_get_variable_global('sincronizar_user');
	v_sincronizar_password = f_get_variable_global('sincronizar_password');
	v_sincronizar_base= f_get_variable_global('sincronizar_base');
	v_sincronizar_ip= f_get_variable_global('sincronizar_ip');
	v_sincronizar_puerto=f_get_variable_global('sincronizar_puerto');
    
   
     
    
     
     
 /*******************************    
 #TRANSACCION: SEG_USUARI_INS
 #DESCRIPCION:	Inserta usuarios
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		19/07/2010
 ***************************************************************************
 HISTORIA DE MODIFICACIONES:
 #DESCRIPCION_MOD:	Aumenta campo de tipo de autentificacion
 #AUTOR_MOD: RAC	
 #FECHA_MOD: 01/03/2012		
***********************************/

     if(par_transaccion='SEG_USUARI_INS')then

        
          BEGIN
            
             INSERT  INTO segu.tusuario(
               				 id_clasificador,
                              cuenta,
                              contrasena,
                              fecha_caducidad,
                              estilo,
                              contrasena_anterior,
                              id_persona,
                              autentificacion)
                              
                       VALUES( 
                       
                        v_parametros.id_clasificador,
                        v_parametros.cuenta,
                        v_parametros.contrasena,
                        v_parametros.fecha_caducidad,
                        v_parametros.estilo,
                        NULL,
                        v_parametros.id_persona,
                        v_parametros.autentificacion)
                       RETURNING id_usuario into v_id_usuario;
            
             --05-04-2012:
             IF  v_sincronizar='true' THEN
                 v_respuesta_sinc:= segu.f_sincroniza_usuario_entre_bd(v_id_usuario,v_sincronizar_ip,v_sincronizar_puerto,v_sincronizar_user,v_sincronizar_password,v_sincronizar_base,'INSERT');
    	         if(v_respuesta_sinc!='si') then   
                     raise exception 'Sincronizacion de usuario en BD externa no realizada';
                 end if;  
             
             END IF;
             --fin 05-04-2012
             
             
             
             --insertamos los roles del usuario
             v_id_roles= string_to_array(v_parametros.id_roles,',');
             v_tamano = coalesce(array_length(v_id_roles, 1),0);
             

            
             FOR v_i IN 1..v_tamano LOOP
         
              --insertamos  registro si no esta presente como activo
                  insert into segu.tusuario_rol 
                     (id_usuario, 
                     id_rol, 
                     estado_reg) 
                  values(
                  v_id_usuario,
                  v_id_roles[v_i]::integer,
                  'activo'); 
             
             END LOOP;
                      
             v_resp = f_agrega_clave(v_resp,'mensaje','Usuario insertada con exito '||v_id_usuario); 
             v_resp = f_agrega_clave(v_resp,'id_usuario',v_id_usuario::varchar);

                            

         END;
         
 /*******************************    
 #TRANSACCION:  SEG_USUARI_MOD
 #DESCRIPCION:	Modifica datos de  usuario
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		19/07/2010
***********************************/

     elsif(par_transaccion='SEG_USUARI_MOD')then

          
          BEGIN
          
         -- raise exception '%',v_parametros.id_roles;
          
          IF v_parametros.contrasena_old != v_parametros.contrasena THEN
                         
             UPDATE segu.tusuario SET
                      id_clasificador=v_parametros.id_clasificador,
                      cuenta=v_parametros.cuenta,
                      contrasena=v_parametros.contrasena,
                      fecha_caducidad=v_parametros.fecha_caducidad,                      
                      estilo=v_parametros.estilo,
                      contrasena_anterior=v_parametros.contrasena_old,
                      id_persona=v_parametros.id_persona,
                      autentificacion=v_parametros.autentificacion
             WHERE id_usuario=v_parametros.id_usuario;
            
              --05-04-2012:
                IF  v_sincronizar= 'true' THEN
                
                
                 v_respuesta_sinc:= segu.f_sincroniza_usuario_entre_bd(v_id_usuario,v_sincronizar_ip,v_sincronizar_puerto,v_sincronizar_user,v_sincronizar_password,v_sincronizar_base,'UPDATE');
    	         if(v_respuesta_sinc!='si') then   
                      raise exception 'Sincronizacion de actualizacion de usuario en BD externa no realizada';
                 end if;  
             
                END IF;
             
             --fin 05-04-2012
             
             v_resp = f_agrega_clave(v_resp,'mensaje','Contraseña de usuario modificada con exito id_usuario='||v_parametros.id_usuario); 
                  
          ELSE
               
               
               UPDATE segu.tusuario SET
                      id_clasificador=v_parametros.id_clasificador,
                      cuenta=v_parametros.cuenta,                     
                      fecha_caducidad=v_parametros.fecha_caducidad,                      
                      estilo=v_parametros.estilo,                   
                      id_persona=v_parametros.id_persona,
                      autentificacion=v_parametros.autentificacion
                     
               WHERE id_usuario=v_parametros.id_usuario;
               
               --05-04-2012:
               
               
               IF  v_sincronizar= 'true' THEN
                
                 v_respuesta_sinc:= segu.f_sincroniza_usuario_entre_bd(v_id_usuario,v_sincronizar_ip,v_sincronizar_puerto,v_sincronizar_user,v_sincronizar_password,v_sincronizar_base,'UPDATE');
    	         if(v_respuesta_sinc!='si') then   
                      raise exception 'Sincronizacion de actualizacion de usuario en BD externa no realizada';
                 end if;  
             
                END IF;
               
                
               --fin 05-04-2012
                
                v_resp = f_agrega_clave(v_resp,'mensaje','Cuenta de usuario modificada con exito id_usuario= '||v_parametros.id_usuario); 
           
            END IF;

             v_resp = f_agrega_clave(v_resp,'id_usuario',v_parametros.id_usuario::varchar); 
             
             
             --modificamos lor roles relacionados al usuario
             --partimos los datos de id_roles en un vector
             
           
             v_id_roles= string_to_array(v_parametros.id_roles,',');
             v_tamano = coalesce(array_length(v_id_roles, 1),0);
             
             
             
             -- inactivamos todos los roles que no estan hay
             
             update segu.tusuario_rol 
             set estado_reg='inactivo'
             where 
             id_usuario = v_parametros.id_usuario
             and 
             (id_rol::varchar != ANY(v_id_roles) or v_tamano=0);
            --insertamos los que faltan
  
            
            FOR v_i IN 1..v_tamano LOOP
                         
              --preguntamos si el id_rol ya se encuentra asignado si no insertamos
            IF  (NOT EXISTS (select 1 from segu.tusuario_rol 
                        where id_usuario = v_parametros.id_usuario
                        and id_rol = v_id_roles[v_i]::integer 
                        and estado_reg='activo')) THEN
              --insertamos  registro si no esta presente como activo
                  insert into segu.tusuario_rol 
                     (id_usuario, 
                     id_rol, 
                     estado_reg) 
                  values(
                  v_parametros.id_usuario,
                  v_id_roles[v_i]::integer,
                  'activo'); 
              END IF;
            END LOOP;
             
          
          END;
          
/*******************************    
 #TRANSACCION: SEG_USUARI_ELI
 #DESCRIPCION:	Eliminar Usuarios
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		19/07/2010
***********************************/
 elsif(par_transaccion='SEG_USUARI_ELI')THEN
    

         
          BEGIN
               update segu.tusuario set estado_reg='inactivo'
               where id_usuario=v_parametros.id_usuario;
               
               --05-04-2012:
             
               
                IF  v_sincronizar= 'true' THEN
                 v_respuesta_sinc:= segu.f_sincroniza_usuario_entre_bd(v_id_usuario,v_sincronizar_ip,v_sincronizar_puerto,v_sincronizar_user,v_sincronizar_password,v_sincronizar_base,'DELETE');
    	         if(v_respuesta_sinc!='si') then   
                      raise exception 'Sincronizacion de actualizacion de usuario en BD externa no realizada';
                 end if;  
             
                END IF;
               
                
               --fin 05-04-2012
                
               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario inactivado con exito '||v_parametros.id_usuario); 
               v_resp = f_agrega_clave(v_resp,'id_usuario',v_parametros.id_usuario::varchar);
               
         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     
   return v_resp;   

EXCEPTION

       WHEN OTHERS THEN

       	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


ALTER FUNCTION segu.ft_usuario_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 210 (class 1255 OID 16704)
-- Dependencies: 14 2435
-- Name: ft_usuario_proyecto_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_usuario_proyecto_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_usuario_proyecto_ime
 DESCRIPCIÓN: 	gestiona las transaciones ime de usairio-regional
 AUTOR: 		KPLIAN(jrr)
 FECHA:			28/02/2008
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/

DECLARE


v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_resp varchar;
v_id_usuario_proyecto integer;

BEGIN

     v_nombre_funcion:='segu.f_t_usuario_proyecto_ime';
     v_parametros:=f_get_record(par_tabla);
 /*******************************    
 #TRANSACCION: SEG_USUPRO_INS
 #DESCRIPCION:  Relaciona proyectos con usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/
     if(par_transaccion='SEG_USUPRO_INS')then

        
          BEGIN
               insert into segu.tusuario_proyecto(id_usuario,id_proyecto)
               values(v_parametros.id_usuario,v_parametros.id_proyecto)
               returning  id_usuario_proyecto into v_id_usuario_proyecto;

               v_resp = f_agrega_clave(v_resp,'mensaje','relacion proyecto-usuario insertado con exito '||v_id_usuario_proyecto); 
               v_resp = f_agrega_clave(v_resp,'id_usuario_proyecto',v_id_usuario_proyecto::varchar);



         END;
 /*******************************    
 #TRANSACCION:   SEG_USUPRO_MOD
 #DESCRIPCION:  Modifica la relacion de proyectos con usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/
     elsif(par_transaccion='SEG_USUPRO_MOD')then

          
          BEGIN
               
               update segu.tusuario_proyecto set
                      id_usuario=v_parametros.id_usuario,
                      id_proyecto=v_parametros.id_proyecto
                     
               where id_usuario_proyecto=v_parametros.id_usuario_proyecto;

             v_resp = f_agrega_clave(v_resp,'mensaje','Usuario proyecto modificado con exito '||v_parametros.id_usuario_proyecto); 
             v_resp = f_agrega_clave(v_resp,'id_usuario_proyecto',v_parametros.id_usuario_proyecto::varchar);
     
               
          END;
 /*******************************    
 #TRANSACCION:  SEG_USUPRO_ELI
 #DESCRIPCION:  Inactiva la relacion de proyectos con usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/
    elsif(par_transaccion='SEG_USUPRO_ELI')then

         
          BEGIN
               UPDATE segu.tusuario_proyecto 
               SET estado_reg='inactivo'
               WHERe id_usuario_proyecto=v_parametros.id_usuario_proyecto;
              
          
             v_resp = f_agrega_clave(v_resp,'mensaje','Usuario proyecto inactivado con exito '||v_parametros.id_usuario_proyecto); 
             v_resp = f_agrega_clave(v_resp,'id_usuario_proyecto',v_parametros.id_usuario_proyecto::varchar);
     
         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     
return v_resp;

EXCEPTION

        WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


ALTER FUNCTION segu.ft_usuario_proyecto_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 299 (class 1255 OID 16705)
-- Dependencies: 14 2435
-- Name: ft_usuario_proyecto_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_usuario_proyecto_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_usuario_proyecto_sel
 DESCRIPCIÓN: 	manejo de proyectos por usuario
 AUTOR: 		KPLIAN(jrr)	
 FECHA:		    28/02/2008
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR: 		Rensi Arteaga Copari
 FECHA:			16/11/2010			
***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_usuario_proyecto_sel';
 /*******************************    
 #TRANSACCION:  SEG_USUREG_SEL
 #DESCRIPCION:	lista las proyectos por usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/

     if(par_transaccion='SEG_USUPRO_SEL')then

       
          BEGIN

               v_consulta:='select 
                            usupro.id_usuario_proyecto,
                            usupro.id_usuario,
                            usupro.id_proyecto,
                            usupro.fecha_reg,
                            usupro.estado_reg,
                            proyec.nombre as desc_proyecto,
                            person.nombre_completo2 as desc_person
                        from segu.tusuario_proyecto usupro
                        inner join segu.tusuario usuari
                        on usuari.id_usuario=usupro.id_usuario
                        inner join segu.tproyecto proyec
                        on proyec.id_proyecto=usupro.id_proyecto
                        inner join segu.vpersona person
                        on person.id_persona=usuari.id_persona
                        where usupro.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;
         
 /*******************************    
 #TRANSACCION:  SEG_USUREG_SEL
 #DESCRIPCION:	contar proyectos por usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/

     elsif(par_transaccion='SEG_USUPRO_CONT')then

          --consulta:=';
          BEGIN

                 v_consulta:='SELECT 
                               count(usupro.id_usuario_proyecto)
                              FROM segu.tusuario_proyecto usupro
                              INNER JOIN segu.tusuario usuari
                                on usuari.id_usuario=usupro.id_usuario
                              INNER JOIN segu.tproyecto proyec
                                on proyec.id_proyecto=usupro.id_proyecto
                              WHERE usupro.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_usuario_proyecto_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 211 (class 1255 OID 16706)
-- Dependencies: 14 2435
-- Name: ft_usuario_regional_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_usuario_regional_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_usuario_regional_ime
 DESCRIPCIÓN: 	manejo de regionales por usario
 AUTOR: 		KPLIAN(jrr)
 FECHA:			28/02/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/

DECLARE


v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_id_usuario_regional       integer;
v_resp                varchar;

BEGIN

     v_nombre_funcion:='segu.f_t_usuario_regional_ime';
     v_parametros:=f_get_record(par_tabla);

 /*******************************    
 #TRANSACCION:  SEG_USUREG_INS
 #DESCRIPCION:	Relaciona una regional al usuario
 #AUTOR:		KPLIAN(jrr)
 #FECHA:		28/02/2010
***********************************/

     if(par_transaccion='SEG_USUREG_INS')then

        
          BEGIN
               insert into segu.tusuario_regional(id_usuario,id_regional)
               values(v_parametros.id_usuario,v_parametros.id_regional)
               returning  id_usuario_regional into v_id_usuario_regional;

               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario-Regional  insertada con exito '||v_id_usuario_regional); 
               v_resp = f_agrega_clave(v_resp,'id_usario_regional',v_id_usuario_regional::varchar);

          END;
          
/*******************************    
 #TRANSACCION:  SEG_USUREG_MOD
 #DESCRIPCION:	Modifica la relacion una regional y un  usuario
 #AUTOR:		KPLIAN(jrr)
 #FECHA:		28/02/2010
***********************************/
     elsif(par_transaccion='SEG_USUREG_MOD')then

          
          BEGIN
               
               update segu.tusuario_regional set
                      id_usuario=v_parametros.id_usuario,
                      id_regional=v_parametros.id_regional
                      
               where id_usuario_regional=v_parametros.id_usuario_regional;

             v_resp = f_agrega_clave(v_resp,'mensaje','Usuario-Regional modificados con exito '||v_parametros.id_usuario_regional); 
             v_resp = f_agrega_clave(v_resp,'id_usuario_regional',v_parametros.id_usuario_regional::varchar);
   
          END;

/*******************************    
 #TRANSACCION:  SEG_USUREG_ELI
 #DESCRIPCION:	Inactiva la relacion de una regional y un  usuario
 #AUTOR:		KPLIAN(jrr)
 #FECHA:		28/02/2010
***********************************/

    elsif(par_transaccion='SEG_USUREG_ELI')then

         
          BEGIN
               update segu.tusuario_regional set estado_reg='inactivo'
               where id_usuario_regional=v_parametros.id_usuario_regional;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario regional eliminado con exito  '||v_parametros.id_usuario_regional); 
               v_resp = f_agrega_clave(v_resp,'id_usuario_regional',v_parametros.id_usuario_regional::varchar);
  
         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

return v_resp;

EXCEPTION

        WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_usuario_regional_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 300 (class 1255 OID 16707)
-- Dependencies: 14 2435
-- Name: ft_usuario_regional_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_usuario_regional_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_usuario_regional_sel
 DESCRIPCIÓN: 	gestiona las consulta de usario-regional
 AUTOR: 		KPLIAN(jrr)
 FECHA:			28/02/2008
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_usuario_regional_sel';

 /*******************************    
 #TRANSACCION:  SEG_USUREG_SEL
 #DESCRIPCION:	lista las regionales del usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/
     if(par_transaccion='SEG_USUREG_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select 
                            usureg.id_usuario_regional,
                            usureg.id_usuario,
                            usureg.id_regional,
                            usureg.fecha_reg,
                            usureg.estado_reg,
                            region.nombre as desc_regional,
                            person.nombre_completo2 as desc_person
                        from segu.tusuario_regional usureg
                        inner join segu.tusuario usuari
                        on usuari.id_usuario=usureg.id_usuario
                        inner join segu.tregional region
                        on region.id_regional=usureg.id_regional
                        inner join segu.vpersona person
                        on person.id_persona=usuari.id_persona
                        where usureg.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;
         
 /*******************************    
 #TRANSACCION:  SEG_USUREG_CONT
 #DESCRIPCION:	cuenta las regionales del usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/

     elsif(par_transaccion='SEG_USUREG_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(usureg.id_usuario_regional)
                            from segu.tusuario_regional usureg
                        inner join segu.tusuario usuari
                        on usuari.id_usuario=usureg.id_usuario
                        inner join segu.tregional region
                        on region.id_regional=usureg.id_regional
                        where usureg.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_usuario_regional_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 213 (class 1255 OID 16708)
-- Dependencies: 14 2435
-- Name: ft_usuario_rol_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_usuario_rol_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_subsistema
 DESCRIPCIÓN: 	gestion de subsistemas
 AUTOR: 		
 FECHA:			
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	Actualizacion de version de XPH
 AUTOR: 		KPLIAN(rac)
 FECHA:			26/11/2010		
***************************************************************************/

DECLARE


v_parametros           record;
v_resp           varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_id_usuario_rol integer;

BEGIN

     v_nombre_funcion:='segu.ft_usuario_rol_ime';
     v_parametros:=f_get_record(par_tabla);
     
 /*******************************    
 #TRANSACCION:  SEG_USUROL_INS
 #DESCRIPCION:	funcion para insertar usuario 
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		16-11-2010	
***********************************/

     if(par_transaccion='SEG_USUROL_INS')then
     
        BEGIN
         --revisa si el usuario ya tiene asignado ese rol
            if(exists(select 1
                      from segu.tusuario_rol
                      where id_rol=v_parametros.id_rol 
                        and id_usuario=v_parametros.id_usuario 
                        and estado_reg='activo'))then
               
               raise exception 'El usuario ya tiene asignado ese rol';
            
            end if;
               
              --insertar el rol si no lo tiene todavia   
               insert into segu.tusuario_rol(id_rol,id_usuario)
               values(v_parametros.id_rol,v_parametros.id_usuario)
               returning id_usuario_rol into v_id_usuario_rol;
               
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario rol insertado con exito '||v_id_usuario_rol); 
               v_resp = f_agrega_clave(v_resp,'id_usuaio_rol',v_id_usuario_rol::varchar);

              
         
         END;
 /*******************************    
 #TRANSACCION:  SEG_USUROL_MOD
 #DESCRIPCION:	modifica roles de usuario
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		16-11-2010	
***********************************/
     elsif(par_transaccion='SEG_USUROL_MOD')then

         --verifica que el nuevo rol que se quiere asignar no
         --no lo este previamente 
          BEGIN
            if(exists(select 1
                      from segu.tusuario_rol
                      where id_rol=v_parametros.id_rol 
                      and id_usuario=v_parametros.id_usuario 
                      and estado_reg='activo'))then
                
                raise exception 'El usuario ya tiene asignado ese rol';
                
            end if;
            
          --modifica el rol del usario  
               update segu.tusuario_rol set
                      id_rol=v_parametros.id_rol,
                      id_usuario=v_parametros.id_usuario
               where id_usuario_rol=v_parametros.id_usuario_rol;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario rol modificado con exito '||v_parametros.id_usuario_rol); 
               v_resp = f_agrega_clave(v_resp,'id_usuaio_rol',v_parametros.id_usuario_rol::varchar);


          END;
 /*******************************    
 #TRANSACCION:  SEG_USUROL_ELI
 #DESCRIPCION:	retira  el rol asignado a un uusario
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		16-11-2010	
***********************************/
    elsif(par_transaccion='SEG_USUROL_ELI')then

         
          BEGIN
               update segu.tusuario_rol set estado_reg='inactivo'
               where id_usuario_rol=v_parametros.id_usuario_rol;
               return 'Usuario rol inactivcado con exito';
               
          v_resp = f_agrega_clave(v_resp,'mensaje','Usuario rol eliminado con exito '||v_parametros.id_usuario_rol); 
          v_resp = f_agrega_clave(v_resp,'id_usuaio_rol',v_parametros.id_usuario_rol::varchar);

               
         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     
     
     return v_resp;


EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_usuario_rol_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 301 (class 1255 OID 16709)
-- Dependencies: 14 2435
-- Name: ft_usuario_rol_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_usuario_rol_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_usuario_rol_sel
 DESCRIPCIÓN: 	listado de roles por usuario
 AUTOR: 		KPLIAN(rac)
 FECHA:			
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR: 		KPLIAN(rac)
 FECHA:			16/11/2010			
***************************************************************************/


DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp varchar;

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_usuario_rol_sel';

 /*******************************    
 #TRANSACCION:  SEG_USUROL_SEL
 #DESCRIPCION:	Lista los roles activos que corresponden al usuario
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		16-11-2010	
***********************************/


     if(par_transaccion='SEG_USUROL_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                                usurol.id_usuario_rol,
                                usurol.id_rol,
                                usurol.id_usuario,
                                usurol.fecha_reg,
                                usurol.estado_reg,
                                rol.rol,
                                person.nombre_completo2,
                                sub.nombre
                             FROM segu.tusuario_rol usurol
                             INNER JOIN segu.tusuario usuari
                                on usuari.id_usuario=usurol.id_usuario
                             INNER JOIN  segu.trol rol
                               on rol.id_rol=usurol.id_rol
                             LEFT JOIN  segu.tsubsistema sub
                               on sub.id_subsistema=rol.id_subsistema
                             INNER JOIN  segu.vpersona person
                               on person.id_persona=usuari.id_persona
                             WHERE usurol.estado_reg=''activo'' and 
                               usurol.id_usuario = '|| v_parametros.id_usuario || '  and ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

 /*******************************    
 #TRANSACCION:  SEG_USUROL_SEL
 #DESCRIPCION:	cuenta los roles activos que corresponden al usuario
 #AUTOR:		KPLIAN(rac)
 #FECHA:		16-11-2010	
***********************************/
     elsif(par_transaccion='SEG_USUROL_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select 
                				count(usurol.id_usuario_rol)
                            from segu.tusuario_rol usurol
                            inner join segu.tusuario usuari
                            	on usuari.id_usuario=usurol.id_usuario
                            inner join segu.trol rol
                            	on rol.id_rol=usurol.id_rol
                            left join segu.tsubsistema sub
                            	on sub.id_subsistema=rol.id_subsistema
                            inner join segu.vpersona person
                            	on person.id_persona=usuari.id_persona
                            where usurol.estado_reg=''activo'' and  
                          usurol.id_usuario ='|| v_parametros.id_usuario || '  and ';
              
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_usuario_rol_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 1123 (class 1255 OID 16710)
-- Dependencies: 14 2435
-- Name: ft_usuario_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_usuario_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.fvalidar_usuario
 DESCRIPCIÓN: 	verifica si el login y contgrasena proporcionados son correctos
                esta funcion es especial porque corre con el usario generico de conexion
                que solo tiene el privilegio de correr esta funcion
 AUTOR: 		KPLIAN(rac)
 FECHA:			26/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/

DECLARE
 
v_consulta              varchar;
v_parametros            record;
v_mensaje_error         text;
v_nombre_funcion        text;
v_resp varchar;

/*

'login'
'password'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN
     v_nombre_funcion:='segu.ft_usuario_sel';
     v_parametros:=f_get_record(par_tabla);
     
/*******************************    
 #TRANSACCION:  SEG_VALUSU_SEL
 #DESCRIPCION:	consulta los datos del usario segun contrasena y login
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		26/07/2010	
***********************************/

     if(par_transaccion='SEG_VALUSU_SEL')then
          --consulta:=';
          BEGIN

               v_consulta:='SELECT u.id_usuario,
                                   u.cuenta,
                                   u.contrasena 
                            FROM segu.tusuario u  
                            WHERE u.cuenta='''||v_parametros.login || '''
                            and u.contrasena=''' || v_parametros.password || ''' 
                            and u.fecha_caducidad>=now()::date 
                            and u.estado_reg=''activo''';

               return v_consulta;
               
          END;
/*******************************    
 #TRANSACCION:  SEG_USUARI_SEL
 #DESCRIPCION:	Listar usuarios activos de sistema
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		26/07/2010	
***********************************/
          
     elsif(par_transaccion='SEG_USUARI_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT USUARI.id_usuario,
                                   USUARI.id_clasificador,
                                   USUARI.cuenta,
                                   USUARI.contrasena,
                                   USUARI.fecha_caducidad,
                                   USUARI.fecha_reg,
                                   USUARI.estado_reg,
                                   USUARI.estilo,
                                   USUARI.contrasena_anterior,
                                   USUARI.id_persona,
                                   PERSON.nombre_completo2 as desc_person,
                                   CLASIF.descripcion,
                                   text_concat(UR.id_rol::text) as id_roles,
                                   USUARI.autentificacion
                            FROM segu.tusuario USUARI
                                 INNER JOIN segu.vpersona PERSON on PERSON.id_persona = USUARI.id_persona
                                 LEFT JOIN segu.tclasificador CLASIF on CLASIF.id_clasificador =
                                 USUARI.id_clasificador 
                                 LEFT JOIN segu.tusuario_rol UR on ur.estado_reg= ''activo'' 
                                 and ur.id_usuario = usuari.id_usuario
                            WHERE USUARI.estado_reg = ''activo'' and ';
                           
               v_consulta:=v_consulta||v_parametros.filtro;
              
               v_consulta:=v_consulta||'      GROUP BY USUARI.id_usuario,
                                               USUARI.id_clasificador,
                                               USUARI.cuenta,
                                               USUARI.contrasena,
                                               USUARI.fecha_caducidad,
                                               USUARI.fecha_reg,
                                               USUARI.estado_reg,
                                               USUARI.estilo,
                                               USUARI.contrasena_anterior,
                                               USUARI.id_persona,
                                               PERSON.nombre_completo2,
                                               PERSON.nombre,
                                               CLASIF.descripcion,
                                               USUARI.autentificacion';
             v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;


               return v_consulta;


         END;

/*******************************    
 #TRANSACCION:  SEG_USUARI_CONT
 #DESCRIPCION:	Contar usuarios activos de sistema
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		26/07/2010	
***********************************/
     elsif(par_transaccion='SEG_USUARI_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(USUARI.id_usuario)
                            FROM segu.tusuario USUARI
                            INNER JOIN segu.vpersona PERSON
                              ON PERSON.id_persona=USUARI.id_persona
                            LEFT JOIN segu.tclasificador CLASIF
                              ON CLASIF.id_clasificador=USUARI.id_clasificador
                            WHERE USUARI.estado_reg=''activo'' AND ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;
          
    

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION segu.ft_usuario_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 225 (class 1255 OID 16711)
-- Dependencies: 2435 14
-- Name: ft_validar_usuario_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ft_validar_usuario_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: 		segu.fvalidar_usuario
 DESCRIPCIÓN: 	verifica si el login y contgrasena proporcionados son correctos
                esta funcion es especial porque corre con el usario generico de conexion
                que solo tiene el privilegio de correr esta funcion
 AUTOR: 		KPLIAN(rac)
 FECHA:			26/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/
DECLARE

v_count integer;
v_consulta    varchar;
v_parametros  record;
v_resp          varchar;
v_nombre_funcion   text;
v_mensaje_error    text;

v_id_usuario integer;
v_cuenta varchar;
v_nombre varchar;
v_apellido_paterno varchar;
v_apellido_materno varchar;
v_estilo varchar;
v_num_fallidos integer;
v_cont_alertas integer;
v_autentificacion varchar;
v_id_persona integer;
v_id_funcionario integer;
v_contrasena varchar;

/*

'login'
'password'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN
     v_nombre_funcion:='segu.ft_validar_usuario_ime';
     v_parametros:=f_get_record(par_tabla);
     
 /*******************************    
 #TRANSACCION: SEG_VALUSU_SEG
 #DESCRIPCION:	verifica si el login y contgrasena proporcionados son correctos
                esta funcion es especial porque corre con el usario generico de conexion
                que solo tiene el privilegio de correr esta funcion
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		16-11-2010	
 *******************************    

 #DESCRIPCION_MOD:	(1) se introduce el campo de tipo de autentificacion para 
  					autentificar con tra LDAP,
                    (2) se verifica si la contrasena es ldap
                    (3) se aumenta un contador que devuelve la cantidad de alarmas para mostrar al usuario
                    
                    
 #AUTOR_MOD:		KPLIAN(rac)	
 #FECHA_MOD:		22-11-2011	
***********************************/

     if(par_transaccion='SEG_VALUSU_SEG')then
          --consulta:=';
          BEGIN

          --verifica si el usuario y contrasena introducidos estan habilitados
          
           --     
            v_id_usuario=null;
            SELECT 
                  u.id_usuario,u.cuenta,p.nombre,p.apellido_paterno,
                  p.apellido_materno,u.estilo,u.autentificacion,p.id_persona,u.contrasena
            INTO
                  v_id_usuario,v_cuenta,v_nombre,v_apellido_paterno,
                  v_apellido_materno,v_estilo,v_autentificacion,v_id_persona,v_contrasena
            FROM segu.tusuario u 
            INNER JOIN segu.tpersona p  
                	ON  p.id_persona = u.id_persona
            WHERE u.cuenta=v_parametros.login
                   -- AND u.contrasena=v_parametros.password
            AND u.fecha_caducidad >= now()::date 
            AND u.estado_reg='activo'; 
            
            
             -- VERIFICA si LA autentificacion es local o por LDAP 
            IF(v_autentificacion='local') THEN
              --SI ES LOCAL VERIFICAMOS SI LA CONTRAENIA ES CORRECTA
               IF(v_contrasena!=v_parametros.password)THEN
                       v_id_usuario=null;
               END IF;
                
            END IF; 
            
              
                        
            IF(v_id_usuario is null) THEN
                RAISE EXCEPTION 'Credenciales de Usuario Invalidas';
           END IF;
  
              --verificamos si el usuario tiene alertas
              v_cont_alertas = 0;
              
              SELECT count(id_alarma) ,ala.id_funcionario
              into v_cont_alertas,v_id_funcionario
              FROM rhum.tfuncionario fun
              INNER JOIN param.talarma ala 
              on fun.id_funcionario = ala.id_funcionario 
              and ala.estado_reg = 'activo'
              WHERE fun.id_persona = v_id_persona
              GROUP BY ala.id_funcionario, id_alarma;
              
              --obtenemos el funcionario para el usuario
              --asumimos que una persona solo puede tener un funcionario
              --este este inactivo o activo
              
              IF(v_id_funcionario is null) THEN
                    SELECT id_funcionario into  v_id_funcionario
                    FROM rhum.tfuncionario fun 
                    WHERE fun.id_persona = v_id_persona;
              END IF;
              
              
              v_cont_alertas=COALESCE(v_cont_alertas,0);
              --raise exception '%',v_id_funcionario;
                    

               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario autorizado'); 
               v_resp = f_agrega_clave(v_resp,'id_usuario',v_id_usuario::varchar);
               v_resp = f_agrega_clave(v_resp,'cuenta',v_cuenta);
               v_resp = f_agrega_clave(v_resp,'nombre',v_nombre);
               v_resp = f_agrega_clave(v_resp,'apellido_paterno',v_apellido_paterno);
               v_resp = f_agrega_clave(v_resp,'apellido_materno',v_apellido_materno);
               v_resp = f_agrega_clave(v_resp,'estilo',v_estilo);
               v_resp = f_agrega_clave(v_resp,'cont_alertas',v_cont_alertas::varchar);
               v_resp = f_agrega_clave(v_resp,'id_persona',v_id_persona::varchar);
               v_resp = f_agrega_clave(v_resp,'id_funcionario',v_id_funcionario::varchar);
               v_resp = f_agrega_clave(v_resp,'autentificacion',v_autentificacion::varchar);
               v_resp = f_agrega_clave(v_resp,'contrasena',v_contrasena::varchar);
              
              --raise exception '%',v_resp;
               return v_resp;
               
          END;
          
    
     else
         raise exception 'No existe la opcion';
      
      end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
	    v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  	    v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
  	    v_resp = f_agrega_clave(v_resp,'usuario',v_parametros.login);
	    raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION segu.ft_validar_usuario_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) OWNER TO rchumacero;

--
-- TOC entry 214 (class 1255 OID 16713)
-- Dependencies: 14 2435
-- Name: ftrig_log(); Type: FUNCTION; Schema: segu; Owner: rchumacero
--

CREATE FUNCTION ftrig_log() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	nombre_tabla   varchar;
    consulta	   varchar;
    valores			varchar;
    fecha1			date;
    fecha2 			date;
    crear_tabla		text;
	v_rol 			varchar;
    	

BEGIN

/***************************************************************************
 XPHS - PARTICIONAMIENTO LOGS
***************************************************************************
 SCRITP: 		segu.ftrig_log
 DESCRIPCION: 	Ingreso de registro de logs		(tablas particionadas)
 AUTOR: 		KPLIAN(jrr)
 FECHA:			02/02/2011
 COMENTARIOS:	
***************************************************************************
	1) Se obtiene el nombre de tabla que corresponde para la fecha actual
    2) IF: existe la tabla
    	2.1) Se registra el evento en la tabla particionada correspondiente
    3) ELSE no existe la tabla
    	3.1) Se define el rango de fechas el que se creara la tabla
        3.2) Se crea la tabla con el nombre y el rango de fechas que corresponde
        3.3) Se inserta el evento en la tabla particionada correspondiente


*/
IF (TG_OP='INSERT')then
BEGIN
 nombre_tabla='tlog_'||to_char(NEW.fecha_reg,'YYYY_MM');

 if(not exists (select 1 from pg_class where relname like nombre_tabla))then
 	
 	fecha1:=to_char(NEW.fecha_reg,'YYYY-MM-01')::date;
    fecha2:= fecha1 + interval '1 month';

    crear_tabla:='CREATE TABLE "log"."'||nombre_tabla||'" (
      			  CHECK ((fecha_reg >= '''||fecha1||'''::date) AND (fecha_reg < '''||fecha2||'''::date)),
  				  CONSTRAINT "'||nombre_tabla||'_id_log_key" UNIQUE("id_log")
  				) INHERITS ("segu"."tlog");
                CREATE INDEX "'||nombre_tabla||'_idx" ON "log"."'||nombre_tabla||'"
  				USING btree ("fecha_reg")
                ';

    execute(crear_tabla);
    --RCM 24-03-2011: se vuelve dinámico el rol del grant
    v_rol = 'rol_usuario_' || current_database();
    --execute('GRANT SELECT ON log.'||nombre_tabla||' TO rol_usuario_bdweb');
    execute('GRANT SELECT ON log.'||nombre_tabla||' TO '||v_rol);
    --FIN RCM

 end if;

    --raise notice '%',NEW.fecha_reg;
 	valores:=NEW.id_log||','||
    coalesce(''''||(NEW.id_usuario::text)||'''','null')||','||
    coalesce(''''||(NEW.id_subsistema::text)||'''','null')||','||
    coalesce(''''||(NEW.mac_maquina::text)||'''','null')||','||
    coalesce(''''||NEW.ip_maquina||'''','null')||','''||
    NEW.tipo_log||''','||
    coalesce(''''||replace (NEW.descripcion,'''','''''')||'''','null')||','''||
    NEW.fecha_reg||''','''||
    NEW.estado_reg||''','||
    coalesce(''''||NEW.procedimientos||'''','null')||','||
    coalesce(''''||NEW.transaccion||'''','null')||','||
    coalesce(''''||replace (NEW.consulta,'''','''''')||'''','null')||','||
    coalesce(''''||(NEW.tiempo_ejecucion::text)||'''','null')||','||
    coalesce(''''||NEW.usuario_base||'''','null')||','||
    coalesce(''''||NEW.codigo_error||'''','null')||','||
    coalesce(''''||(NEW.dia_semana::text)||'''','null')||','||
    NEW.pid_db||','||
    NEW.pid_web||','''||
    NEW.sid_web||''','||
    coalesce(''''||NEW.cuenta_usuario||'''','null')||','||
    coalesce(''''||NEW.descripcion_transaccion||'''','null')||','||
    coalesce(''''||NEW.codigo_subsistema||'''','null')||','||
    NEW.si_log;

    valores=replace(valores,'\\','\\\\');
 	
    consulta='INSERT INTO log.'||nombre_tabla||' VALUES ('||valores||');';
    
    EXECUTE(consulta);

END;
end if;
 RETURN NULL;
END;
$$;


ALTER FUNCTION segu.ftrig_log() OWNER TO rchumacero;

SET search_path = tesoro, pg_catalog;

--
-- TOC entry 319 (class 1255 OID 1561739)
-- Dependencies: 44 2435
-- Name: f_tts_corte_moneda_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: tesoro; Owner: postgres
--

CREATE FUNCTION f_tts_corte_moneda_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Tesoreria
 FUNCION: 		tesoro.f_tts_corte_moneda_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'tesoro.tts_corte_moneda'
 AUTOR: 		 (fprudencio)
 FECHA:	        29-09-2011 10:14:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_corte	integer;
			    
BEGIN

    v_nombre_funcion = 'tesoro.f_tts_corte_moneda_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'TS_CORMON_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 10:14:30
	***********************************/

	if(p_transaccion='TS_CORMON_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into tesoro.tts_corte_moneda(
			importe_valor,
			id_moneda,
			tipo_corte,
			descri_corte
          	) values(
			v_parametros.importe_valor,
			v_parametros.id_moneda,
			v_parametros.tipo_corte,
			v_parametros.descri_corte
			)RETURNING id_corte into v_id_corte;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Corte Moneda almacenado(a) con exito (id_corte'||v_id_corte||')'); 
            v_resp = f_agrega_clave(v_resp,'id_corte',v_id_corte::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'TS_CORMON_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 10:14:30
	***********************************/

	elsif(p_transaccion='TS_CORMON_MOD')then

		begin
			--Sentencia de la modificacion
			update tesoro.tts_corte_moneda set
			importe_valor = v_parametros.importe_valor,
			id_moneda = v_parametros.id_moneda,
			tipo_corte = v_parametros.tipo_corte,
			descri_corte = v_parametros.descri_corte
			where id_corte=v_parametros.id_corte;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Corte Moneda modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_corte',v_parametros.id_corte::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'TS_CORMON_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 10:14:30
	***********************************/

	elsif(p_transaccion='TS_CORMON_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from tesoro.tts_corte_moneda
            where id_corte=v_parametros.id_corte;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Corte Moneda eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_corte',v_parametros.id_corte::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


ALTER FUNCTION tesoro.f_tts_corte_moneda_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 322 (class 1255 OID 1561738)
-- Dependencies: 44 2435
-- Name: f_tts_corte_moneda_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: tesoro; Owner: postgres
--

CREATE FUNCTION f_tts_corte_moneda_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Tesoreria
 FUNCION: 		tesoro.f_tts_corte_moneda_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'tesoro.tts_corte_moneda'
 AUTOR: 		 (fprudencio)
 FECHA:	        29-09-2011 10:14:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'tesoro.f_tts_corte_moneda_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'TS_CORMON_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 10:14:30
	***********************************/

	if(p_transaccion='TS_CORMON_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						cormon.id_corte,
						cormon.importe_valor,
						cormon.id_moneda,
                        moneda.moneda,
						cormon.tipo_corte,
						cormon.descri_corte	
						from tesoro.tts_corte_moneda cormon
						inner join param.tmoneda moneda on moneda.id_moneda=cormon.id_moneda
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'TS_CORMON_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 10:14:30
	***********************************/

	elsif(p_transaccion='TS_CORMON_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_corte)
					    from tesoro.tts_corte_moneda cormon
                        inner join param.tmoneda moneda on moneda.id_moneda=cormon.id_moneda
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


ALTER FUNCTION tesoro.f_tts_corte_moneda_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO postgres;

--
-- TOC entry 1287 (class 1255 OID 2042149)
-- Dependencies: 44 2435
-- Name: ft_requerimientos_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: tesoro; Owner: rvasquez
--

CREATE FUNCTION ft_requerimientos_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		sast.treqado
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'sast.trequerimientos'
 AUTOR: 		rortiz
 FECHA:	        22-11-2011 15:23:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE
	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'sast.ft_requerimientos_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'ST_REQ_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			rortiz	
 	#FECHA:			22-11-2011 15:23:30
	***********************************/

	if(p_transaccion='ST_REQ_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						req.id_requerimiento,
                        req.id_funcionario,
                        req.id_tipo_requerimiento,
                        req.id_depto,
                        req.estado_actual,
                        req.estado_anterior,
                        req.descripcion,
                        req.version,
                        req.estado_reg,
                        req.id_usuario_reg,
                        req.fecha_reg,
						req.id_usuario_mod,						
						req.fecha_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod,
                        person.nombre_completo1
                        										
						from sast.trequerimientos req
                        inner join rhum.tfuncionario funcio on funcio.id_funcionario=req.id_funcionario   
                        inner join segu.vpersona person on person.id_persona=funcio.id_persona
                        inner join param.tdepto tdt on tdt.id_depto = req.id_depto
                        inner join sast.ttipo_requerimiento tipreq on tipreq.id_tipo_requerimiento = req.id_tipo_requerimiento
                        inner join segu.tusuario usu1 on usu1.id_usuario = req.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = req.id_usuario_mod                        					
				        where req.estado_reg = ''activo'' and ';
			
			--Definicion de la respureqa
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respureqa
			return v_consulta;
						
		end;   

	/*********************************    
 	#TRANSACCION:  'ST_REQ_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rortiz	
 	#FECHA:		18-11-2011 
	***********************************/

	elsif(p_transaccion='ST_REQ_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_requerimiento)
						from sast.trequerimientos req
                        inner join rhum.tfuncionario funcio on funcio.id_funcionario=req.id_funcionario   
                        inner join segu.vpersona person on person.id_persona=funcio.id_persona
                        inner join param.tdepto tdt on tdt.id_depto = req.id_depto
                        inner join sast.ttipo_requerimiento tipreq on tipreq.id_tipo_requerimiento = req.id_tipo_requerimiento
                        inner join segu.tusuario usu1 on usu1.id_usuario = req.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = req.id_usuario_mod     
					    where ';
			
			--Definicion de la respureqa		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respureqa
			return v_consulta;

		end;
					
/*******************************
 #TRANSACCION:  ST_CAPTU_SEL
 #DESCRIPCION:	Selecciona requerimientos +
 #AUTOR:		RORTIZ	
 #FECHA:		29/11/11	
***********************************/
     elsif(p_transaccion='ST_CAPTU_SEL')then

          --  Se arma la consulta de requerimientos
          BEGIN
          
               v_consulta:='SELECT 
               				r.id_requerimiento,
               				r.id_funcionario,
                            r.id_tipo_requerimiento,
                            r.id_depto,
                            r.descripcion,
               				r.estado_reg,
                        	r.id_usuario_reg,
                        	r.fecha_reg,
							r.id_usuario_mod,						
							r.fecha_mod,
                        	usu1.cuenta as usr_reg,
                        	usu2.cuenta as usr_mod,                            
                            person.nombre_completo1 as funcionario,
       						tipreq.nombre as requerimiento,
       						depto.nombre as departamento, 
                            r.extension,                     
                            r.captura               			
                        FROM sast.trequerimientos r
                        inner join rhum.tfuncionario funcio on funcio.id_funcionario=r.id_funcionario   
                        inner join segu.vpersona person on person.id_persona=funcio.id_persona
                        inner join param.tdepto depto on depto.id_depto = r.id_depto                        
                        inner join sast.ttipo_requerimiento tipreq on tipreq.id_tipo_requerimiento = r.id_tipo_requerimiento
                        inner join segu.tusuario usu1 on usu1.id_usuario = r.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = r.id_usuario_mod                        					
				        where r.estado_reg = ''activo'' and ';
                          
                         
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta || ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               raise notice '%',v_consulta;
               return v_consulta;


         END;    


/*******************************
 #TRANSACCION:  ST_CAPTU_CONT
 #DESCRIPCION:	Cuenta requerimientos con foto
 #AUTOR:		RORTIZ		
 #FECHA:		29/11/11	
***********************************/

     elsif(p_transaccion='ST_CAPTU_CONT')then

          --se arma la sonsulta que cuenta requerimientos
          BEGIN
               
               	v_consulta:='select count(r.id_requerimiento)
                from sast.trequerimientos r
                inner join rhum.tfuncionario funcio on funcio.id_funcionario=r.id_funcionario   
                inner join segu.vpersona person on person.id_persona=funcio.id_persona
                inner join param.tdepto tdt on tdt.id_depto = r.id_depto
                inner join sast.ttipo_requerimiento tipreq on tipreq.id_tipo_requerimiento = r.id_tipo_requerimiento
                inner join segu.tusuario usu1 on usu1.id_usuario = r.id_usuario_reg
				left join segu.tusuario usu2 on usu2.id_usuario = r.id_usuario_mod       
				where';
               	v_consulta:=v_consulta||v_parametros.filtro;
               	return v_consulta;
         END;
         
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


ALTER FUNCTION tesoro.ft_requerimientos_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) OWNER TO rvasquez;

SET search_path = public, pg_catalog;

--
-- TOC entry 2445 (class 1255 OID 1898574)
-- Dependencies: 5 2106 2104 395 396
-- Name: accum(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE accum(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_accum_finalfn
);


ALTER AGGREGATE public.accum(geometry) OWNER TO postgres;

--
-- TOC entry 2437 (class 1255 OID 16714)
-- Dependencies: 118 5
-- Name: aggarray(anyelement); Type: AGGREGATE; Schema: public; Owner: rchumacero
--

CREATE AGGREGATE aggarray(anyelement) (
    SFUNC = aggregate_array,
    STYPE = anyarray
);


ALTER AGGREGATE public.aggarray(anyelement) OWNER TO rchumacero;

--
-- TOC entry 2440 (class 1255 OID 1475681)
-- Dependencies: 5 118
-- Name: aggarray1(anyelement); Type: AGGREGATE; Schema: public; Owner: rac
--

CREATE AGGREGATE aggarray1(anyelement) (
    SFUNC = aggregate_array,
    STYPE = anyarray
);


ALTER AGGREGATE public.aggarray1(anyelement) OWNER TO rac;

--
-- TOC entry 2448 (class 1255 OID 1898580)
-- Dependencies: 5 2104 2104 395 398
-- Name: collect(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE collect(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_collect_finalfn
);


ALTER AGGREGATE public.collect(geometry) OWNER TO postgres;

--
-- TOC entry 2454 (class 1255 OID 1898397)
-- Dependencies: 5 2111 2104 1053
-- Name: extent(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE extent(geometry) (
    SFUNC = public.st_combine_bbox,
    STYPE = box3d_extent
);


ALTER AGGREGATE public.extent(geometry) OWNER TO postgres;

--
-- TOC entry 2456 (class 1255 OID 1898401)
-- Dependencies: 5 2107 2104 1055
-- Name: extent3d(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE extent3d(geometry) (
    SFUNC = public.combine_bbox,
    STYPE = box3d
);


ALTER AGGREGATE public.extent3d(geometry) OWNER TO postgres;

--
-- TOC entry 2458 (class 1255 OID 2958986)
-- Dependencies: 1218 5
-- Name: list(text); Type: AGGREGATE; Schema: public; Owner: rchumacero
--

CREATE AGGREGATE list(text) (
    SFUNC = comma_cat,
    STYPE = text
);


ALTER AGGREGATE public.list(text) OWNER TO rchumacero;

--
-- TOC entry 2452 (class 1255 OID 1898584)
-- Dependencies: 5 2104 2104 395 400
-- Name: makeline(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE makeline(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_makeline_finalfn
);


ALTER AGGREGATE public.makeline(geometry) OWNER TO postgres;

--
-- TOC entry 2441 (class 1255 OID 1898559)
-- Dependencies: 5 2104 2104 391
-- Name: memcollect(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE memcollect(geometry) (
    SFUNC = public.st_collect,
    STYPE = geometry
);


ALTER AGGREGATE public.memcollect(geometry) OWNER TO postgres;

--
-- TOC entry 2443 (class 1255 OID 1898562)
-- Dependencies: 5 2104 2104 388
-- Name: memgeomunion(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE memgeomunion(geometry) (
    SFUNC = geomunion,
    STYPE = geometry
);


ALTER AGGREGATE public.memgeomunion(geometry) OWNER TO postgres;

--
-- TOC entry 2450 (class 1255 OID 1898582)
-- Dependencies: 5 2104 2104 395 399
-- Name: polygonize(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE polygonize(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_polygonize_finalfn
);


ALTER AGGREGATE public.polygonize(geometry) OWNER TO postgres;

--
-- TOC entry 2446 (class 1255 OID 1898575)
-- Dependencies: 5 2106 2104 395 396
-- Name: st_accum(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_accum(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_accum_finalfn
);


ALTER AGGREGATE public.st_accum(geometry) OWNER TO postgres;

--
-- TOC entry 2449 (class 1255 OID 1898581)
-- Dependencies: 5 2104 2104 395 398
-- Name: st_collect(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_collect(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_collect_finalfn
);


ALTER AGGREGATE public.st_collect(geometry) OWNER TO postgres;

--
-- TOC entry 2455 (class 1255 OID 1898398)
-- Dependencies: 5 2111 2104 1053
-- Name: st_extent(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_extent(geometry) (
    SFUNC = public.st_combine_bbox,
    STYPE = box3d_extent
);


ALTER AGGREGATE public.st_extent(geometry) OWNER TO postgres;

--
-- TOC entry 2457 (class 1255 OID 1898402)
-- Dependencies: 5 2107 2104 1054
-- Name: st_extent3d(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_extent3d(geometry) (
    SFUNC = public.st_combine_bbox,
    STYPE = box3d
);


ALTER AGGREGATE public.st_extent3d(geometry) OWNER TO postgres;

--
-- TOC entry 2453 (class 1255 OID 1898585)
-- Dependencies: 5 2104 2104 395 400
-- Name: st_makeline(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_makeline(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_makeline_finalfn
);


ALTER AGGREGATE public.st_makeline(geometry) OWNER TO postgres;

--
-- TOC entry 2442 (class 1255 OID 1898560)
-- Dependencies: 5 2104 2104 391
-- Name: st_memcollect(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_memcollect(geometry) (
    SFUNC = public.st_collect,
    STYPE = geometry
);


ALTER AGGREGATE public.st_memcollect(geometry) OWNER TO postgres;

--
-- TOC entry 2444 (class 1255 OID 1898563)
-- Dependencies: 5 2104 2104 389
-- Name: st_memunion(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_memunion(geometry) (
    SFUNC = public.st_union,
    STYPE = geometry
);


ALTER AGGREGATE public.st_memunion(geometry) OWNER TO postgres;

--
-- TOC entry 2451 (class 1255 OID 1898583)
-- Dependencies: 5 2104 2104 395 399
-- Name: st_polygonize(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_polygonize(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_polygonize_finalfn
);


ALTER AGGREGATE public.st_polygonize(geometry) OWNER TO postgres;

--
-- TOC entry 2447 (class 1255 OID 1898579)
-- Dependencies: 5 2104 2104 395 397
-- Name: st_union(geometry); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE st_union(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_union_finalfn
);


ALTER AGGREGATE public.st_union(geometry) OWNER TO postgres;

--
-- TOC entry 2439 (class 1255 OID 1475680)
-- Dependencies: 5 302
-- Name: text_concat(text); Type: AGGREGATE; Schema: public; Owner: rac
--

CREATE AGGREGATE text_concat(text) (
    SFUNC = concat,
    STYPE = text
);


ALTER AGGREGATE public.text_concat(text) OWNER TO rac;

--
-- TOC entry 2438 (class 1255 OID 1372283)
-- Dependencies: 5
-- Name: textcat_all(text); Type: AGGREGATE; Schema: public; Owner: rac
--

CREATE AGGREGATE textcat_all(text) (
    SFUNC = textcat,
    STYPE = text
);


ALTER AGGREGATE public.textcat_all(text) OWNER TO rac;

--
-- TOC entry 3178 (class 2617 OID 2964540)
-- Dependencies: 1219 5
-- Name: #; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR # (
    PROCEDURE = icount,
    RIGHTARG = integer[]
);


ALTER OPERATOR public.# (NONE, integer[]) OWNER TO postgres;

--
-- TOC entry 3180 (class 2617 OID 2964547)
-- Dependencies: 5 1238
-- Name: #; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR # (
    PROCEDURE = idx,
    LEFTARG = integer[],
    RIGHTARG = integer
);


ALTER OPERATOR public.# (integer[], integer) OWNER TO postgres;

--
-- TOC entry 3202 (class 2617 OID 2964561)
-- Dependencies: 5 1231
-- Name: &; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR & (
    PROCEDURE = _int_inter,
    LEFTARG = integer[],
    RIGHTARG = integer[],
    COMMUTATOR = &
);


ALTER OPERATOR public.& (integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 3183 (class 2617 OID 1898201)
-- Dependencies: 872 2104 5 871 882 2104
-- Name: &&; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR && (
    PROCEDURE = geometry_overlap,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = &&,
    RESTRICT = geometry_gist_sel,
    JOIN = geometry_gist_joinsel
);


ALTER OPERATOR public.&& (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3191 (class 2617 OID 1898898)
-- Dependencies: 712 714 2131 5 2131 713
-- Name: &&; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR && (
    PROCEDURE = geography_overlaps,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = &&,
    RESTRICT = geography_gist_selectivity,
    JOIN = geography_gist_join_selectivity
);


ALTER OPERATOR public.&& (geography, geography) OWNER TO postgres;

--
-- TOC entry 3166 (class 2617 OID 2964533)
-- Dependencies: 1227 5
-- Name: &&; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR && (
    PROCEDURE = _int_overlap,
    LEFTARG = integer[],
    RIGHTARG = integer[],
    COMMUTATOR = &&,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.&& (integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 3177 (class 2617 OID 1898196)
-- Dependencies: 873 2104 2104 5
-- Name: &<; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR &< (
    PROCEDURE = geometry_overleft,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = &>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.&< (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3181 (class 2617 OID 1898200)
-- Dependencies: 2104 2104 5 876
-- Name: &<|; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR &<| (
    PROCEDURE = geometry_overbelow,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = |&>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.&<| (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3184 (class 2617 OID 1898195)
-- Dependencies: 5 2104 874 2104
-- Name: &>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR &> (
    PROCEDURE = geometry_overright,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = &<,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.&> (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3182 (class 2617 OID 2964551)
-- Dependencies: 1241 5
-- Name: +; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR + (
    PROCEDURE = intarray_push_elem,
    LEFTARG = integer[],
    RIGHTARG = integer
);


ALTER OPERATOR public.+ (integer[], integer) OWNER TO postgres;

--
-- TOC entry 3193 (class 2617 OID 2964553)
-- Dependencies: 5 1242
-- Name: +; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR + (
    PROCEDURE = intarray_push_array,
    LEFTARG = integer[],
    RIGHTARG = integer[],
    COMMUTATOR = +
);


ALTER OPERATOR public.+ (integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 3194 (class 2617 OID 2964555)
-- Dependencies: 1243 5
-- Name: -; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR - (
    PROCEDURE = intarray_del_elem,
    LEFTARG = integer[],
    RIGHTARG = integer
);


ALTER OPERATOR public.- (integer[], integer) OWNER TO postgres;

--
-- TOC entry 3201 (class 2617 OID 2964560)
-- Dependencies: 1245 5
-- Name: -; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR - (
    PROCEDURE = intset_subtract,
    LEFTARG = integer[],
    RIGHTARG = integer[]
);


ALTER OPERATOR public.- (integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 3165 (class 2617 OID 1898151)
-- Dependencies: 848 2104 2104 5
-- Name: <; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR < (
    PROCEDURE = geometry_lt,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.< (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3192 (class 2617 OID 1898917)
-- Dependencies: 2131 715 5 2131
-- Name: <; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR < (
    PROCEDURE = geography_lt,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.< (geography, geography) OWNER TO postgres;

--
-- TOC entry 3175 (class 2617 OID 1898194)
-- Dependencies: 5 2104 877 2104
-- Name: <<; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR << (
    PROCEDURE = geometry_left,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = >>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.<< (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3179 (class 2617 OID 1898198)
-- Dependencies: 2104 5 2104 880
-- Name: <<|; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <<| (
    PROCEDURE = geometry_below,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = |>>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.<<| (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3168 (class 2617 OID 1898152)
-- Dependencies: 5 2104 849 2104
-- Name: <=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <= (
    PROCEDURE = geometry_le,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.<= (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3195 (class 2617 OID 1898918)
-- Dependencies: 5 2131 2131 716
-- Name: <=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <= (
    PROCEDURE = geography_le,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.<= (geography, geography) OWNER TO postgres;

--
-- TOC entry 3171 (class 2617 OID 2964534)
-- Dependencies: 5 1226
-- Name: <@; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <@ (
    PROCEDURE = _int_contained,
    LEFTARG = integer[],
    RIGHTARG = integer[],
    COMMUTATOR = @>,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.<@ (integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 3169 (class 2617 OID 1898153)
-- Dependencies: 5 2104 2104 852
-- Name: =; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR = (
    PROCEDURE = geometry_eq,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = =,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.= (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3197 (class 2617 OID 1898919)
-- Dependencies: 719 2131 2131 5
-- Name: =; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR = (
    PROCEDURE = geography_eq,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = =,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.= (geography, geography) OWNER TO postgres;

--
-- TOC entry 3174 (class 2617 OID 1898149)
-- Dependencies: 5 2104 850 2104
-- Name: >; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR > (
    PROCEDURE = geometry_gt,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.> (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3199 (class 2617 OID 1898915)
-- Dependencies: 5 2131 2131 717
-- Name: >; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR > (
    PROCEDURE = geography_gt,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.> (geography, geography) OWNER TO postgres;

--
-- TOC entry 3173 (class 2617 OID 1898150)
-- Dependencies: 5 851 2104 2104
-- Name: >=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR >= (
    PROCEDURE = geometry_ge,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.>= (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3198 (class 2617 OID 1898916)
-- Dependencies: 2131 5 718 2131
-- Name: >=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR >= (
    PROCEDURE = geography_ge,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.>= (geography, geography) OWNER TO postgres;

--
-- TOC entry 3185 (class 2617 OID 1898193)
-- Dependencies: 5 2104 2104 878
-- Name: >>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR >> (
    PROCEDURE = geometry_right,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = <<,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.>> (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3189 (class 2617 OID 1898204)
-- Dependencies: 5 2104 885 2104
-- Name: @; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR @ (
    PROCEDURE = geometry_contained,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = ~,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.@ (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3176 (class 2617 OID 2964537)
-- Dependencies: 5 1225
-- Name: @; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR @ (
    PROCEDURE = _int_contains,
    LEFTARG = integer[],
    RIGHTARG = integer[],
    COMMUTATOR = ~,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.@ (integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 3170 (class 2617 OID 2964535)
-- Dependencies: 5 1225
-- Name: @>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR @> (
    PROCEDURE = _int_contains,
    LEFTARG = integer[],
    RIGHTARG = integer[],
    COMMUTATOR = <@,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.@> (integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 3164 (class 2617 OID 2964525)
-- Dependencies: 1223 5 2009
-- Name: @@; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR @@ (
    PROCEDURE = boolop,
    LEFTARG = integer[],
    RIGHTARG = query_int,
    COMMUTATOR = ~~,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.@@ (integer[], query_int) OWNER TO postgres;

--
-- TOC entry 3196 (class 2617 OID 2964557)
-- Dependencies: 5 1244
-- Name: |; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR | (
    PROCEDURE = intset_union_elem,
    LEFTARG = integer[],
    RIGHTARG = integer
);


ALTER OPERATOR public.| (integer[], integer) OWNER TO postgres;

--
-- TOC entry 3200 (class 2617 OID 2964558)
-- Dependencies: 1230 5
-- Name: |; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR | (
    PROCEDURE = _int_union,
    LEFTARG = integer[],
    RIGHTARG = integer[],
    COMMUTATOR = |
);


ALTER OPERATOR public.| (integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 3186 (class 2617 OID 1898199)
-- Dependencies: 2104 875 2104 5
-- Name: |&>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR |&> (
    PROCEDURE = geometry_overabove,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = &<|,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.|&> (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3187 (class 2617 OID 1898197)
-- Dependencies: 5 2104 2104 879
-- Name: |>>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR |>> (
    PROCEDURE = geometry_above,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = <<|,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.|>> (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3190 (class 2617 OID 1898203)
-- Dependencies: 5 2104 881 2104
-- Name: ~; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR ~ (
    PROCEDURE = geometry_contain,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = @,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.~ (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3172 (class 2617 OID 2964536)
-- Dependencies: 1226 5
-- Name: ~; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR ~ (
    PROCEDURE = _int_contained,
    LEFTARG = integer[],
    RIGHTARG = integer[],
    COMMUTATOR = @,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.~ (integer[], integer[]) OWNER TO postgres;

--
-- TOC entry 3188 (class 2617 OID 1898202)
-- Dependencies: 2104 883 2104 5
-- Name: ~=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR ~= (
    PROCEDURE = geometry_samebox,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = ~=,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.~= (geometry, geometry) OWNER TO postgres;

--
-- TOC entry 3167 (class 2617 OID 2964524)
-- Dependencies: 5 2009 1224
-- Name: ~~; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR ~~ (
    PROCEDURE = rboolop,
    LEFTARG = query_int,
    RIGHTARG = integer[],
    COMMUTATOR = @@,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.~~ (query_int, integer[]) OWNER TO postgres;

--
-- TOC entry 3318 (class 2616 OID 1898921)
-- Dependencies: 3432 5 2131
-- Name: btree_geography_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS btree_geography_ops
    DEFAULT FOR TYPE geography USING btree AS
    OPERATOR 1 <(geography,geography) ,
    OPERATOR 2 <=(geography,geography) ,
    OPERATOR 3 =(geography,geography) ,
    OPERATOR 4 >=(geography,geography) ,
    OPERATOR 5 >(geography,geography) ,
    FUNCTION 1 geography_cmp(geography,geography);


ALTER OPERATOR CLASS public.btree_geography_ops USING btree OWNER TO postgres;

--
-- TOC entry 3315 (class 2616 OID 1898155)
-- Dependencies: 5 3429 2104
-- Name: btree_geometry_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS btree_geometry_ops
    DEFAULT FOR TYPE geometry USING btree AS
    OPERATOR 1 <(geometry,geometry) ,
    OPERATOR 2 <=(geometry,geometry) ,
    OPERATOR 3 =(geometry,geometry) ,
    OPERATOR 4 >=(geometry,geometry) ,
    OPERATOR 5 >(geometry,geometry) ,
    FUNCTION 1 geometry_cmp(geometry,geometry);


ALTER OPERATOR CLASS public.btree_geometry_ops USING btree OWNER TO postgres;

--
-- TOC entry 3321 (class 2616 OID 2964615)
-- Dependencies: 3435 5
-- Name: gin__int_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gin__int_ops
    FOR TYPE integer[] USING gin AS
    STORAGE integer ,
    OPERATOR 3 &&(integer[],integer[]) ,
    OPERATOR 6 =(anyarray,anyarray) ,
    OPERATOR 7 @>(integer[],integer[]) ,
    OPERATOR 8 <@(integer[],integer[]) ,
    OPERATOR 13 @(integer[],integer[]) ,
    OPERATOR 14 ~(integer[],integer[]) ,
    OPERATOR 20 @@(integer[],query_int) ,
    FUNCTION 1 btint4cmp(integer,integer) ,
    FUNCTION 2 ginarrayextract(anyarray,internal) ,
    FUNCTION 3 ginint4_queryextract(internal,internal,smallint,internal,internal) ,
    FUNCTION 4 ginint4_consistent(internal,smallint,internal,integer,internal,internal);


ALTER OPERATOR CLASS public.gin__int_ops USING gin OWNER TO postgres;

--
-- TOC entry 3319 (class 2616 OID 2964570)
-- Dependencies: 3433 5
-- Name: gist__int_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist__int_ops
    DEFAULT FOR TYPE integer[] USING gist AS
    OPERATOR 3 &&(integer[],integer[]) ,
    OPERATOR 6 =(anyarray,anyarray) ,
    OPERATOR 7 @>(integer[],integer[]) ,
    OPERATOR 8 <@(integer[],integer[]) ,
    OPERATOR 13 @(integer[],integer[]) ,
    OPERATOR 14 ~(integer[],integer[]) ,
    OPERATOR 20 @@(integer[],query_int) ,
    FUNCTION 1 g_int_consistent(internal,integer[],integer,oid,internal) ,
    FUNCTION 2 g_int_union(internal,internal) ,
    FUNCTION 3 g_int_compress(internal) ,
    FUNCTION 4 g_int_decompress(internal) ,
    FUNCTION 5 g_int_penalty(internal,internal,internal) ,
    FUNCTION 6 g_int_picksplit(internal,internal) ,
    FUNCTION 7 g_int_same(integer[],integer[],internal);


ALTER OPERATOR CLASS public.gist__int_ops USING gist OWNER TO postgres;

--
-- TOC entry 3320 (class 2616 OID 2964597)
-- Dependencies: 2051 5 3434
-- Name: gist__intbig_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist__intbig_ops
    FOR TYPE integer[] USING gist AS
    STORAGE intbig_gkey ,
    OPERATOR 3 &&(integer[],integer[]) ,
    OPERATOR 6 =(anyarray,anyarray) ,
    OPERATOR 7 @>(integer[],integer[]) ,
    OPERATOR 8 <@(integer[],integer[]) ,
    OPERATOR 13 @(integer[],integer[]) ,
    OPERATOR 14 ~(integer[],integer[]) ,
    OPERATOR 20 @@(integer[],query_int) ,
    FUNCTION 1 g_intbig_consistent(internal,internal,integer,oid,internal) ,
    FUNCTION 2 g_intbig_union(internal,internal) ,
    FUNCTION 3 g_intbig_compress(internal) ,
    FUNCTION 4 g_intbig_decompress(internal) ,
    FUNCTION 5 g_intbig_penalty(internal,internal,internal) ,
    FUNCTION 6 g_intbig_picksplit(internal,internal) ,
    FUNCTION 7 g_intbig_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist__intbig_ops USING gist OWNER TO postgres;

--
-- TOC entry 3317 (class 2616 OID 1898900)
-- Dependencies: 2131 2134 5 3431
-- Name: gist_geography_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_geography_ops
    DEFAULT FOR TYPE geography USING gist AS
    STORAGE gidx ,
    OPERATOR 3 &&(geography,geography) ,
    FUNCTION 1 geography_gist_consistent(internal,geometry,integer) ,
    FUNCTION 2 geography_gist_union(bytea,internal) ,
    FUNCTION 3 geography_gist_compress(internal) ,
    FUNCTION 4 geography_gist_decompress(internal) ,
    FUNCTION 5 geography_gist_penalty(internal,internal,internal) ,
    FUNCTION 6 geography_gist_picksplit(internal,internal) ,
    FUNCTION 7 geography_gist_same(box2d,box2d,internal);


ALTER OPERATOR CLASS public.gist_geography_ops USING gist OWNER TO postgres;

--
-- TOC entry 3316 (class 2616 OID 1898213)
-- Dependencies: 2104 3430 2117 5
-- Name: gist_geometry_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_geometry_ops
    DEFAULT FOR TYPE geometry USING gist AS
    STORAGE box2d ,
    OPERATOR 1 <<(geometry,geometry) ,
    OPERATOR 2 &<(geometry,geometry) ,
    OPERATOR 3 &&(geometry,geometry) ,
    OPERATOR 4 &>(geometry,geometry) ,
    OPERATOR 5 >>(geometry,geometry) ,
    OPERATOR 6 ~=(geometry,geometry) ,
    OPERATOR 7 ~(geometry,geometry) ,
    OPERATOR 8 @(geometry,geometry) ,
    OPERATOR 9 &<|(geometry,geometry) ,
    OPERATOR 10 <<|(geometry,geometry) ,
    OPERATOR 11 |>>(geometry,geometry) ,
    OPERATOR 12 |&>(geometry,geometry) ,
    FUNCTION 1 lwgeom_gist_consistent(internal,geometry,integer) ,
    FUNCTION 2 lwgeom_gist_union(bytea,internal) ,
    FUNCTION 3 lwgeom_gist_compress(internal) ,
    FUNCTION 4 lwgeom_gist_decompress(internal) ,
    FUNCTION 5 lwgeom_gist_penalty(internal,internal,internal) ,
    FUNCTION 6 lwgeom_gist_picksplit(internal,internal) ,
    FUNCTION 7 lwgeom_gist_same(box2d,box2d,internal);


ALTER OPERATOR CLASS public.gist_geometry_ops USING gist OWNER TO postgres;

SET search_path = pg_catalog;

--
-- TOC entry 4437 (class 2605 OID 1898495)
-- Dependencies: 329 2117 2107 329
-- Name: CAST (public.box2d AS public.box3d); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.box2d AS public.box3d) WITH FUNCTION public.box3d(public.box2d) AS IMPLICIT;


--
-- TOC entry 4436 (class 2605 OID 1898496)
-- Dependencies: 333 2104 333 2117
-- Name: CAST (public.box2d AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.box2d AS public.geometry) WITH FUNCTION public.geometry(public.box2d) AS IMPLICIT;


--
-- TOC entry 4430 (class 2605 OID 1898497)
-- Dependencies: 330 2107 330
-- Name: CAST (public.box3d AS box); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.box3d AS box) WITH FUNCTION public.box(public.box3d) AS IMPLICIT;


--
-- TOC entry 4432 (class 2605 OID 1898494)
-- Dependencies: 328 2107 2117 328
-- Name: CAST (public.box3d AS public.box2d); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.box3d AS public.box2d) WITH FUNCTION public.box2d(public.box3d) AS IMPLICIT;


--
-- TOC entry 4431 (class 2605 OID 1898498)
-- Dependencies: 334 2107 2104 334
-- Name: CAST (public.box3d AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.box3d AS public.geometry) WITH FUNCTION public.geometry(public.box3d) AS IMPLICIT;


--
-- TOC entry 4435 (class 2605 OID 1898505)
-- Dependencies: 820 820 2117 2111
-- Name: CAST (public.box3d_extent AS public.box2d); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.box3d_extent AS public.box2d) WITH FUNCTION public.box2d(public.box3d_extent) AS IMPLICIT;


--
-- TOC entry 4434 (class 2605 OID 1898504)
-- Dependencies: 819 2111 819 2107
-- Name: CAST (public.box3d_extent AS public.box3d); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.box3d_extent AS public.box3d) WITH FUNCTION public.box3d_extent(public.box3d_extent) AS IMPLICIT;


--
-- TOC entry 4433 (class 2605 OID 1898506)
-- Dependencies: 821 2104 821 2111
-- Name: CAST (public.box3d_extent AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.box3d_extent AS public.geometry) WITH FUNCTION public.geometry(public.box3d_extent) AS IMPLICIT;


--
-- TOC entry 4235 (class 2605 OID 1898502)
-- Dependencies: 337 337 2104
-- Name: CAST (bytea AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (bytea AS public.geometry) WITH FUNCTION public.geometry(bytea) AS IMPLICIT;


--
-- TOC entry 4438 (class 2605 OID 1898501)
-- Dependencies: 336 336 2104 2114
-- Name: CAST (public.chip AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.chip AS public.geometry) WITH FUNCTION public.geometry(public.chip) AS IMPLICIT;


--
-- TOC entry 4440 (class 2605 OID 1898868)
-- Dependencies: 689 689 2131 2131
-- Name: CAST (public.geography AS public.geography); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geography AS public.geography) WITH FUNCTION public.geography(public.geography, integer, boolean) AS IMPLICIT;


--
-- TOC entry 4439 (class 2605 OID 1898887)
-- Dependencies: 700 700 2104 2131
-- Name: CAST (public.geography AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geography AS public.geometry) WITH FUNCTION public.geometry(public.geography);


--
-- TOC entry 4426 (class 2605 OID 1898493)
-- Dependencies: 327 327 2104
-- Name: CAST (public.geometry AS box); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geometry AS box) WITH FUNCTION public.box(public.geometry) AS IMPLICIT;


--
-- TOC entry 4428 (class 2605 OID 1898491)
-- Dependencies: 325 2104 2117 325
-- Name: CAST (public.geometry AS public.box2d); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geometry AS public.box2d) WITH FUNCTION public.box2d(public.geometry) AS IMPLICIT;


--
-- TOC entry 4427 (class 2605 OID 1898492)
-- Dependencies: 326 2107 326 2104
-- Name: CAST (public.geometry AS public.box3d); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geometry AS public.box3d) WITH FUNCTION public.box3d(public.geometry) AS IMPLICIT;


--
-- TOC entry 4424 (class 2605 OID 1898503)
-- Dependencies: 338 2104 338
-- Name: CAST (public.geometry AS bytea); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geometry AS bytea) WITH FUNCTION public.bytea(public.geometry) AS IMPLICIT;


--
-- TOC entry 4429 (class 2605 OID 1898885)
-- Dependencies: 699 2131 699 2104
-- Name: CAST (public.geometry AS public.geography); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geometry AS public.geography) WITH FUNCTION public.geography(public.geometry) AS IMPLICIT;


--
-- TOC entry 4425 (class 2605 OID 1898500)
-- Dependencies: 331 331 2104
-- Name: CAST (public.geometry AS text); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.geometry AS text) WITH FUNCTION public.text(public.geometry) AS IMPLICIT;


--
-- TOC entry 4301 (class 2605 OID 1898499)
-- Dependencies: 335 335 2104
-- Name: CAST (text AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (text AS public.geometry) WITH FUNCTION public.geometry(text) AS IMPLICIT;


SET search_path = public, pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- TOC entry 3708 (class 1259 OID 16732)
-- Dependencies: 4447 4448 4449 5
-- Name: tbase; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE tbase (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying
);


ALTER TABLE public.tbase OWNER TO postgres;

SET search_path = actif, pg_catalog;

--
-- TOC entry 4037 (class 1259 OID 3176087)
-- Dependencies: 4963 4964 4965 4967 4968 4969 4970 4971 4972 4973 4974 4975 4976 4977 4978 4979 42 3708
-- Name: taf_activo_fijo; Type: TABLE; Schema: actif; Owner: rchumacero; Tablespace: 
--

CREATE TABLE taf_activo_fijo (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone NOT NULL,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10) DEFAULT NULL::character varying,
    id_activo_fijo integer NOT NULL,
    codigo character varying,
    descripcion character varying(100) NOT NULL,
    descripcion_larga character varying(1000),
    vida_util_original integer NOT NULL,
    vida_util_restante integer NOT NULL,
    tasa_depreciacion numeric(10,4) DEFAULT 0 NOT NULL,
    fecha_ultima_deprec date,
    depreciacion_acum_ant numeric(18,6) NOT NULL,
    depreciacion_acum numeric(18,6) NOT NULL,
    depreciacion_periodo numeric(18,6) NOT NULL,
    flag_revaloriz character varying(2) DEFAULT 'no'::character varying NOT NULL,
    valor_rescate numeric(18,2) NOT NULL,
    fecha_compra date NOT NULL,
    monto_compra_mon_orig numeric(18,6) NOT NULL,
    monto_compra numeric(18,6) NOT NULL,
    monto_actual numeric(18,6) NOT NULL,
    con_garantia character varying(2) DEFAULT 'no'::character varying NOT NULL,
    num_poliza_garantia character varying(20),
    fecha_fin_gar date,
    foto_activo bytea,
    num_factura character varying(10),
    tipo_cambio numeric(10,5),
    estado character varying(20) DEFAULT 'registrado'::character varying NOT NULL,
    observaciones character varying(1000),
    id_sub_tipo_activo integer NOT NULL,
    id_moneda integer NOT NULL,
    id_moneda_original integer NOT NULL,
    id_unidad_constructiva integer,
    fecha_ini_dep date,
    ubicacion_fisica character varying(300),
    orden_compra character varying(20),
    id_estado_funcional integer,
    vida_util_2 integer,
    monto_actualiz numeric(18,2),
    id_depto integer,
    id_cotizacion integer,
    id_cotizacion_det integer,
    origen character varying,
    id_lugar integer,
    estado_anterior character varying,
    id_solicitud_compra integer,
    clonacion character varying(2) DEFAULT 'no'::character varying,
    id_clon_origen integer,
    proyecto character varying(2) DEFAULT 'no'::character varying,
    tipo_af_bien character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    id_usuario integer,
    monto_actualiz_2 numeric(18,2),
    id_deposito integer,
    codigo_ant character varying(40),
    id_sub_tipo_ant integer,
    tipo character varying(15) DEFAULT 'propio'::character varying,
    CONSTRAINT chk_taf_activo_fijo__tipo_af_bien CHECK ((((tipo_af_bien)::text = 'activo'::text) OR ((tipo_af_bien)::text = 'bien_resp'::text))),
    CONSTRAINT taf_activo_fijo_con_garantia_check CHECK ((((con_garantia)::text = 'si'::text) OR ((con_garantia)::text = 'no'::text))),
    CONSTRAINT taf_activo_fijo_estado_check CHECK ((((((((estado)::text = 'registrado'::text) OR ((estado)::text = 'alta'::text)) OR ((estado)::text = 'baja'::text)) OR ((estado)::text = 'eliminado'::text)) OR ((estado)::text = 'en_proceso'::text)) OR ((estado)::text = 'codificado'::text))),
    CONSTRAINT taf_activo_fijo_flag_revaloriz_check CHECK ((((flag_revaloriz)::text = 'si'::text) OR ((flag_revaloriz)::text = 'no'::text))),
    CONSTRAINT taf_activo_fijo_tasa_depreciacion_check CHECK ((((tasa_depreciacion)::double precision >= (0)::double precision) AND ((tasa_depreciacion)::double precision <= (100)::double precision)))
)
INHERITS (public.tbase);


ALTER TABLE actif.taf_activo_fijo OWNER TO rchumacero;

--
-- TOC entry 5977 (class 0 OID 0)
-- Dependencies: 4037
-- Name: TABLE taf_activo_fijo; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON TABLE taf_activo_fijo IS 'sistema=activos_fijos&codigo=ACTIF&prefijo=AF&titulo=Activo Fijo&desc=Activo Fijo&num_dt=2&dt_1=codigo&dt_2=descripcion';


--
-- TOC entry 5978 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.fecha_reg; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.fecha_reg IS 'nombre=fecha_reg&label=fecha_reg&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=fecha_reg';


--
-- TOC entry 5979 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.id_activo_fijo; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.id_activo_fijo IS 'nombre=id_activo_fijo&label=id_activo_fijo&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_activo_fijo';


--
-- TOC entry 5980 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.codigo; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.codigo IS 'nombre=codigo&label=Codigo&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=codigo';


--
-- TOC entry 5981 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.descripcion; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.descripcion IS 'nombre=descripcion&label=Descripcion&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=descripcion';


--
-- TOC entry 5982 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.descripcion_larga; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.descripcion_larga IS 'nombre=descripcion_larga&label=descripcion_larga&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=descripcion_larga';


--
-- TOC entry 5983 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.vida_util_original; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.vida_util_original IS 'nombre=vida_util_original&label=vida_util_original&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=vida_util_original';


--
-- TOC entry 5984 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.vida_util_restante; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.vida_util_restante IS 'nombre=vida_util_restante&label=vida_util_restante&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=vida_util_restante';


--
-- TOC entry 5985 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.tasa_depreciacion; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.tasa_depreciacion IS 'nombre=tasa_depreciacion&label=tasa_depreciacion&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=tasa_depreciacion';


--
-- TOC entry 5986 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.fecha_ultima_deprec; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.fecha_ultima_deprec IS 'nombre=fecha_ultima_deprec&label=fecha_ultima_deprec&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=fecha_ultima_deprec';


--
-- TOC entry 5987 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.depreciacion_acum_ant; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.depreciacion_acum_ant IS 'nombre=depreciacion_acum_ant&label=depreciacion_acum_ant&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=depreciacion_acum_ant';


--
-- TOC entry 5988 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.depreciacion_acum; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.depreciacion_acum IS 'nombre=depreciacion_acum&label=depreciacion_acum&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=depreciacion_acum';


--
-- TOC entry 5989 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.depreciacion_periodo; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.depreciacion_periodo IS 'nombre=depreciacion_periodo&label=depreciacion_periodo&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=depreciacion_periodo';


--
-- TOC entry 5990 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.flag_revaloriz; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.flag_revaloriz IS 'nombre=flag_revaloriz&label=flag_revaloriz&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=flag_revaloriz';


--
-- TOC entry 5991 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.valor_rescate; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.valor_rescate IS 'nombre=valor_rescate&label=valor_rescate&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=valor_rescate';


--
-- TOC entry 5992 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.fecha_compra; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.fecha_compra IS 'nombre=fecha_compra&label=fecha_compra&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=fecha_compra';


--
-- TOC entry 5993 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.monto_compra_mon_orig; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.monto_compra_mon_orig IS 'nombre=monto_compra_mon_orig&label=monto_compra_mon_orig&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=monto_compra_mon_orig';


--
-- TOC entry 5994 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.monto_compra; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.monto_compra IS 'nombre=monto_compra&label=monto_compra&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=monto_compra';


--
-- TOC entry 5995 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.monto_actual; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.monto_actual IS 'nombre=monto_actual&label=monto_actual&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=monto_actual';


--
-- TOC entry 5996 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.con_garantia; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.con_garantia IS 'nombre=con_garantia&label=con_garantia&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=con_garantia';


--
-- TOC entry 5997 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.num_poliza_garantia; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.num_poliza_garantia IS 'nombre=num_poliza_garantia&label=num_poliza_garantia&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=num_poliza_garantia';


--
-- TOC entry 5998 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.fecha_fin_gar; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.fecha_fin_gar IS 'nombre=fecha_fin_gar&label=fecha_fin_gar&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=fecha_fin_gar';


--
-- TOC entry 5999 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.foto_activo; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.foto_activo IS 'nombre=foto_activo&label=foto_activo&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=foto_activo';


--
-- TOC entry 6000 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.num_factura; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.num_factura IS 'nombre=num_factura&label=num_factura&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=num_factura';


--
-- TOC entry 6001 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.tipo_cambio; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.tipo_cambio IS 'nombre=tipo_cambio&label=tipo_cambio&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=tipo_cambio';


--
-- TOC entry 6002 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.estado; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.estado IS 'nombre=estado&label=estado&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=estado';


--
-- TOC entry 6003 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.observaciones; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.observaciones IS 'nombre=observaciones&label=observaciones&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=observaciones';


--
-- TOC entry 6004 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.id_sub_tipo_activo; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.id_sub_tipo_activo IS 'nombre=id_sub_tipo_activo&label=id_sub_tipo_activo&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_sub_tipo_activo';


--
-- TOC entry 6005 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.id_moneda; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.id_moneda IS 'nombre=id_moneda&label=id_moneda&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_moneda';


--
-- TOC entry 6006 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.id_moneda_original; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.id_moneda_original IS 'nombre=id_moneda_original&label=id_moneda_original&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_moneda_original';


--
-- TOC entry 6007 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.id_unidad_constructiva; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.id_unidad_constructiva IS 'nombre=id_unidad_constructiva&label=id_unidad_constructiva&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_unidad_constructiva';


--
-- TOC entry 6008 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.fecha_ini_dep; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.fecha_ini_dep IS 'nombre=fecha_ini_dep&label=fecha_ini_dep&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=fecha_ini_dep';


--
-- TOC entry 6009 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.ubicacion_fisica; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.ubicacion_fisica IS 'nombre=ubicacion_fisica&label=ubicacion_fisica&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=ubicacion_fisica';


--
-- TOC entry 6010 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.orden_compra; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.orden_compra IS 'nombre=orden_compra&label=orden_compra&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=orden_compra';


--
-- TOC entry 6011 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.id_estado_funcional; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.id_estado_funcional IS 'nombre=id_estado_funcional&label=id_estado_funcional&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_estado_funcional';


--
-- TOC entry 6012 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.vida_util_2; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.vida_util_2 IS 'nombre=vida_util_2&label=vida_util_2&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=Vida útil para la depreciación secundaria';


--
-- TOC entry 6013 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.monto_actualiz; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.monto_actualiz IS 'nombre=monto_actualiz&label=monto_actualiz&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=Monto Actualizado';


--
-- TOC entry 6014 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.id_depto; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.id_depto IS 'nombre=id_depto&label=id_depto&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_depto';


--
-- TOC entry 6015 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.id_cotizacion; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.id_cotizacion IS 'nombre=id_cotizacion&label=id_cotizacion&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_cotizacion';


--
-- TOC entry 6016 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.id_cotizacion_det; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.id_cotizacion_det IS 'nombre=id_cotizacion_det&label=id_cotizacion_det&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_cotizacion_det';


--
-- TOC entry 6017 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.origen; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.origen IS 'nombre=origen&label=origen&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=origen';


--
-- TOC entry 6018 (class 0 OID 0)
-- Dependencies: 4037
-- Name: COLUMN taf_activo_fijo.id_lugar; Type: COMMENT; Schema: actif; Owner: rchumacero
--

COMMENT ON COLUMN taf_activo_fijo.id_lugar IS 'nombre=id_lugar&label=id_lugar&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_lugar';


--
-- TOC entry 4036 (class 1259 OID 3176085)
-- Dependencies: 42 4037
-- Name: taf_activo_fijo_id_activo_fijo_seq; Type: SEQUENCE; Schema: actif; Owner: rchumacero
--

CREATE SEQUENCE taf_activo_fijo_id_activo_fijo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actif.taf_activo_fijo_id_activo_fijo_seq OWNER TO rchumacero;

--
-- TOC entry 6019 (class 0 OID 0)
-- Dependencies: 4036
-- Name: taf_activo_fijo_id_activo_fijo_seq; Type: SEQUENCE OWNED BY; Schema: actif; Owner: rchumacero
--

ALTER SEQUENCE taf_activo_fijo_id_activo_fijo_seq OWNED BY taf_activo_fijo.id_activo_fijo;


--
-- TOC entry 4035 (class 1259 OID 3176066)
-- Dependencies: 4958 4959 4960 4961 4962 42
-- Name: taf_sub_tipo_activo; Type: TABLE; Schema: actif; Owner: rchumacero; Tablespace: 
--

CREATE TABLE taf_sub_tipo_activo (
    id_sub_tipo_activo integer NOT NULL,
    codigo character varying(10) NOT NULL,
    descripcion character varying(100),
    vida_util integer,
    tasa_depreciacion real DEFAULT 0,
    ini_correlativo integer NOT NULL,
    correlativo_act integer NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    id_tipo_activo integer NOT NULL,
    CONSTRAINT taf_sub_tipo_activo_estado_check CHECK (((((estado)::text = 'activo'::text) OR ((estado)::text = 'inactivo'::text)) OR ((estado)::text = 'eliminado'::text))),
    CONSTRAINT taf_sub_tipo_activo_tasa_depreciacion_check CHECK (((tasa_depreciacion >= (0)::double precision) AND (tasa_depreciacion <= (100)::double precision)))
);


ALTER TABLE actif.taf_sub_tipo_activo OWNER TO rchumacero;

--
-- TOC entry 4034 (class 1259 OID 3176064)
-- Dependencies: 42 4035
-- Name: taf_sub_tipo_activo_id_sub_tipo_activo_seq; Type: SEQUENCE; Schema: actif; Owner: rchumacero
--

CREATE SEQUENCE taf_sub_tipo_activo_id_sub_tipo_activo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actif.taf_sub_tipo_activo_id_sub_tipo_activo_seq OWNER TO rchumacero;

--
-- TOC entry 6020 (class 0 OID 0)
-- Dependencies: 4034
-- Name: taf_sub_tipo_activo_id_sub_tipo_activo_seq; Type: SEQUENCE OWNED BY; Schema: actif; Owner: rchumacero
--

ALTER SEQUENCE taf_sub_tipo_activo_id_sub_tipo_activo_seq OWNED BY taf_sub_tipo_activo.id_sub_tipo_activo;


--
-- TOC entry 4033 (class 1259 OID 3175998)
-- Dependencies: 4951 4952 4953 4954 4955 4956 42
-- Name: taf_tipo_activo; Type: TABLE; Schema: actif; Owner: rchumacero; Tablespace: 
--

CREATE TABLE taf_tipo_activo (
    id_tipo_activo integer DEFAULT nextval(('actif.taf_tipo_activo_fijo_id_tipo_activo_seq'::text)::regclass) NOT NULL,
    codigo character varying(10) NOT NULL,
    descripcion character varying(100),
    flag_depreciacion character varying(2) DEFAULT 'no'::character varying NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    id_metodo_depreciacion integer,
    CONSTRAINT taf_tipo_activo_fijo_estado_check CHECK (((((estado)::text = 'activo'::text) OR ((estado)::text = 'inactivo'::text)) OR ((estado)::text = 'eliminado'::text))),
    CONSTRAINT taf_tipo_activo_fijo_flag_depreciacion_check CHECK ((((flag_depreciacion)::text = 'si'::text) OR ((flag_depreciacion)::text = 'no'::text)))
);


ALTER TABLE actif.taf_tipo_activo OWNER TO rchumacero;

SET search_path = cobra, pg_catalog;

--
-- TOC entry 3935 (class 1259 OID 1651074)
-- Dependencies: 4803 4804 4805 30 3708
-- Name: tcb_arqueo_estado; Type: TABLE; Schema: cobra; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcb_arqueo_estado (
    id_arqueo_estado integer NOT NULL,
    id_arqueo integer,
    estado_arqueo character varying
)
INHERITS (public.tbase);


ALTER TABLE cobra.tcb_arqueo_estado OWNER TO rchumacero;

--
-- TOC entry 3934 (class 1259 OID 1651072)
-- Dependencies: 30 3935
-- Name: tarqueo_estado_id_arqueo_estado_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tarqueo_estado_id_arqueo_estado_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cobra.tarqueo_estado_id_arqueo_estado_seq OWNER TO rchumacero;

--
-- TOC entry 6021 (class 0 OID 0)
-- Dependencies: 3934
-- Name: tarqueo_estado_id_arqueo_estado_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: rchumacero
--

ALTER SEQUENCE tarqueo_estado_id_arqueo_estado_seq OWNED BY tcb_arqueo_estado.id_arqueo_estado;


--
-- TOC entry 3882 (class 1259 OID 56431)
-- Dependencies: 4688 4689 4690 30 3708
-- Name: tcb_agencia; Type: TABLE; Schema: cobra; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcb_agencia (
    id_agencia integer NOT NULL,
    id_enti_fin integer,
    codigo character varying(15),
    nombre character varying(100),
    observaciones character varying(500)
)
INHERITS (public.tbase);


ALTER TABLE cobra.tcb_agencia OWNER TO rchumacero;

--
-- TOC entry 3881 (class 1259 OID 56429)
-- Dependencies: 30 3882
-- Name: tcb_agencia_id_agencia_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tcb_agencia_id_agencia_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cobra.tcb_agencia_id_agencia_seq OWNER TO rchumacero;

--
-- TOC entry 6022 (class 0 OID 0)
-- Dependencies: 3881
-- Name: tcb_agencia_id_agencia_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: rchumacero
--

ALTER SEQUENCE tcb_agencia_id_agencia_seq OWNED BY tcb_agencia.id_agencia;


--
-- TOC entry 3902 (class 1259 OID 59291)
-- Dependencies: 4725 4726 4727 30 3708
-- Name: tcb_arqueo; Type: TABLE; Schema: cobra; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcb_arqueo (
    id_arqueo integer NOT NULL,
    id_caja integer,
    fecha date,
    estado character varying(15),
    observaciones character varying(1000)
)
INHERITS (public.tbase);


ALTER TABLE cobra.tcb_arqueo OWNER TO rchumacero;

--
-- TOC entry 3903 (class 1259 OID 59308)
-- Dependencies: 4729 4730 4731 30 3708
-- Name: tcb_arqueo_det; Type: TABLE; Schema: cobra; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcb_arqueo_det (
    id_arqueo_det integer NOT NULL,
    id_arqueo integer,
    id_corte integer,
    cantidad integer,
    importe numeric(18,2)
)
INHERITS (public.tbase);


ALTER TABLE cobra.tcb_arqueo_det OWNER TO rchumacero;

--
-- TOC entry 6023 (class 0 OID 0)
-- Dependencies: 3903
-- Name: COLUMN tcb_arqueo_det.cantidad; Type: COMMENT; Schema: cobra; Owner: rchumacero
--

COMMENT ON COLUMN tcb_arqueo_det.cantidad IS 'desc=cantidad que se tiene del id_corte seleccionado';


--
-- TOC entry 3901 (class 1259 OID 59289)
-- Dependencies: 30 3902
-- Name: tcb_arqueo_id_arqueo_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tcb_arqueo_id_arqueo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cobra.tcb_arqueo_id_arqueo_seq OWNER TO rchumacero;

--
-- TOC entry 6024 (class 0 OID 0)
-- Dependencies: 3901
-- Name: tcb_arqueo_id_arqueo_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: rchumacero
--

ALTER SEQUENCE tcb_arqueo_id_arqueo_seq OWNED BY tcb_arqueo.id_arqueo;


--
-- TOC entry 3890 (class 1259 OID 59108)
-- Dependencies: 4701 4702 4703 30 3708
-- Name: tcb_caja; Type: TABLE; Schema: cobra; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcb_caja (
    id_caja integer NOT NULL,
    id_agencia integer,
    codigo character varying(15),
    observaciones character varying(500),
    estado_caja character varying(10)
)
INHERITS (public.tbase);


ALTER TABLE cobra.tcb_caja OWNER TO rchumacero;

--
-- TOC entry 3896 (class 1259 OID 59152)
-- Dependencies: 4713 4714 4715 4716 30 3708
-- Name: tcb_caja_cajero; Type: TABLE; Schema: cobra; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcb_caja_cajero (
    id_caja_cajero integer DEFAULT nextval(('"cobra"."tcb_caja_cajero_id_caja_cajero_seq"'::text)::regclass) NOT NULL,
    id_cajero integer,
    estado_cajero character varying(15),
    id_caja integer
)
INHERITS (public.tbase);


ALTER TABLE cobra.tcb_caja_cajero OWNER TO rchumacero;

--
-- TOC entry 3936 (class 1259 OID 1652079)
-- Dependencies: 30
-- Name: tcb_caja_cajero_id_caja_cajero_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tcb_caja_cajero_id_caja_cajero_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE cobra.tcb_caja_cajero_id_caja_cajero_seq OWNER TO rchumacero;

--
-- TOC entry 3894 (class 1259 OID 59138)
-- Dependencies: 4709 4710 4711 30 3708
-- Name: tcb_caja_estado; Type: TABLE; Schema: cobra; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcb_caja_estado (
    id_caja_estado integer NOT NULL,
    id_caja integer,
    estado_ant character varying,
    estado_act character varying
)
INHERITS (public.tbase);


ALTER TABLE cobra.tcb_caja_estado OWNER TO rchumacero;

--
-- TOC entry 3893 (class 1259 OID 59136)
-- Dependencies: 30 3894
-- Name: tcb_caja_estado_id_caja_estado_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tcb_caja_estado_id_caja_estado_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cobra.tcb_caja_estado_id_caja_estado_seq OWNER TO rchumacero;

--
-- TOC entry 6025 (class 0 OID 0)
-- Dependencies: 3893
-- Name: tcb_caja_estado_id_caja_estado_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: rchumacero
--

ALTER SEQUENCE tcb_caja_estado_id_caja_estado_seq OWNED BY tcb_caja_estado.id_caja_estado;


--
-- TOC entry 3889 (class 1259 OID 59106)
-- Dependencies: 30 3890
-- Name: tcb_caja_id_caja_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tcb_caja_id_caja_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cobra.tcb_caja_id_caja_seq OWNER TO rchumacero;

--
-- TOC entry 6026 (class 0 OID 0)
-- Dependencies: 3889
-- Name: tcb_caja_id_caja_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: rchumacero
--

ALTER SEQUENCE tcb_caja_id_caja_seq OWNED BY tcb_caja.id_caja;


--
-- TOC entry 3892 (class 1259 OID 59127)
-- Dependencies: 4705 4706 4707 30 3708
-- Name: tcb_cajero; Type: TABLE; Schema: cobra; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcb_cajero (
    id_cajero integer NOT NULL,
    id_caja integer,
    tipo_cajero character varying(15),
    estado_cajero character varying(10),
    id_usuario integer NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE cobra.tcb_cajero OWNER TO rchumacero;

--
-- TOC entry 3895 (class 1259 OID 59150)
-- Dependencies: 30 3896
-- Name: tcb_cajero_estado_id_cajero_estado_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tcb_cajero_estado_id_cajero_estado_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cobra.tcb_cajero_estado_id_cajero_estado_seq OWNER TO rchumacero;

--
-- TOC entry 6027 (class 0 OID 0)
-- Dependencies: 3895
-- Name: tcb_cajero_estado_id_cajero_estado_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: rchumacero
--

ALTER SEQUENCE tcb_cajero_estado_id_cajero_estado_seq OWNED BY tcb_caja_cajero.id_caja_cajero;


--
-- TOC entry 3891 (class 1259 OID 59125)
-- Dependencies: 30 3892
-- Name: tcb_cajero_id_cajero_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tcb_cajero_id_cajero_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cobra.tcb_cajero_id_cajero_seq OWNER TO rchumacero;

--
-- TOC entry 6028 (class 0 OID 0)
-- Dependencies: 3891
-- Name: tcb_cajero_id_cajero_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: rchumacero
--

ALTER SEQUENCE tcb_cajero_id_cajero_seq OWNED BY tcb_cajero.id_cajero;


SET default_with_oids = true;

--
-- TOC entry 3878 (class 1259 OID 56375)
-- Dependencies: 4680 4681 4682 4683 30 3708
-- Name: tcb_cliente; Type: TABLE; Schema: cobra; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcb_cliente (
    id_cliente integer DEFAULT nextval(('"cobra"."tcb_cliente_id_cliente_seq"'::text)::regclass) NOT NULL,
    id_sistema_dist integer NOT NULL,
    nro_cuenta character varying(20),
    nro_cuenta_ant character varying(20),
    nombre character varying(100),
    nro_nit numeric(12,0),
    id_cliente_dist integer NOT NULL,
    tipo_cliente character varying(10) NOT NULL,
    nroserie_med character varying(18)
)
INHERITS (public.tbase);


ALTER TABLE cobra.tcb_cliente OWNER TO rchumacero;

--
-- TOC entry 3930 (class 1259 OID 1515182)
-- Dependencies: 30
-- Name: tcb_cliente_id_cliente_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tcb_cliente_id_cliente_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE cobra.tcb_cliente_id_cliente_seq OWNER TO rchumacero;

SET default_with_oids = false;

--
-- TOC entry 3932 (class 1259 OID 1546320)
-- Dependencies: 4795 4796 4797 30 3708
-- Name: tcb_cobro; Type: TABLE; Schema: cobra; Owner: gvelasquez; Tablespace: 
--

CREATE TABLE tcb_cobro (
    id_cobro integer NOT NULL,
    id_cajero integer,
    id_cliente integer,
    cant_facturas integer,
    importe_cobro numeric(20,2),
    importe_recibido numeric(20,2),
    importe_cambio numeric(20,2)
)
INHERITS (public.tbase);
ALTER TABLE ONLY tcb_cobro ALTER COLUMN id_cobro SET STATISTICS 0;
ALTER TABLE ONLY tcb_cobro ALTER COLUMN id_cajero SET STATISTICS 0;
ALTER TABLE ONLY tcb_cobro ALTER COLUMN id_cliente SET STATISTICS 0;
ALTER TABLE ONLY tcb_cobro ALTER COLUMN cant_facturas SET STATISTICS 0;
ALTER TABLE ONLY tcb_cobro ALTER COLUMN importe_cobro SET STATISTICS 0;
ALTER TABLE ONLY tcb_cobro ALTER COLUMN importe_recibido SET STATISTICS 0;
ALTER TABLE ONLY tcb_cobro ALTER COLUMN importe_cambio SET STATISTICS 0;


ALTER TABLE cobra.tcb_cobro OWNER TO gvelasquez;

--
-- TOC entry 3931 (class 1259 OID 1546318)
-- Dependencies: 30 3932
-- Name: tcb_cobro_id_cobro_seq; Type: SEQUENCE; Schema: cobra; Owner: gvelasquez
--

CREATE SEQUENCE tcb_cobro_id_cobro_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cobra.tcb_cobro_id_cobro_seq OWNER TO gvelasquez;

--
-- TOC entry 6029 (class 0 OID 0)
-- Dependencies: 3931
-- Name: tcb_cobro_id_cobro_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: gvelasquez
--

ALTER SEQUENCE tcb_cobro_id_cobro_seq OWNED BY tcb_cobro.id_cobro;


--
-- TOC entry 3927 (class 1259 OID 1505640)
-- Dependencies: 4785 4786 4787 30 3708
-- Name: tcb_enti_fin; Type: TABLE; Schema: cobra; Owner: gvelasquez; Tablespace: 
--

CREATE TABLE tcb_enti_fin (
    id_enti_fin integer NOT NULL,
    id_institucion integer,
    nro_cuenta character varying(30),
    tipo_entidad character varying(30)
)
INHERITS (public.tbase);
ALTER TABLE ONLY tcb_enti_fin ALTER COLUMN id_enti_fin SET STATISTICS 0;
ALTER TABLE ONLY tcb_enti_fin ALTER COLUMN id_institucion SET STATISTICS 0;
ALTER TABLE ONLY tcb_enti_fin ALTER COLUMN nro_cuenta SET STATISTICS 0;
ALTER TABLE ONLY tcb_enti_fin ALTER COLUMN tipo_entidad SET STATISTICS 0;


ALTER TABLE cobra.tcb_enti_fin OWNER TO gvelasquez;

--
-- TOC entry 3926 (class 1259 OID 1505638)
-- Dependencies: 30 3927
-- Name: tcb_enti_fin2_id_enti_fin_seq; Type: SEQUENCE; Schema: cobra; Owner: gvelasquez
--

CREATE SEQUENCE tcb_enti_fin2_id_enti_fin_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cobra.tcb_enti_fin2_id_enti_fin_seq OWNER TO gvelasquez;

--
-- TOC entry 6030 (class 0 OID 0)
-- Dependencies: 3926
-- Name: tcb_enti_fin2_id_enti_fin_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: gvelasquez
--

ALTER SEQUENCE tcb_enti_fin2_id_enti_fin_seq OWNED BY tcb_enti_fin.id_enti_fin;


SET default_with_oids = true;

--
-- TOC entry 3888 (class 1259 OID 58201)
-- Dependencies: 4697 4698 4699 30 3708
-- Name: tcb_factura_cob; Type: TABLE; Schema: cobra; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcb_factura_cob (
    id_factura_cob integer NOT NULL,
    id_caja integer,
    id_cajero integer,
    id_cliente integer,
    id_moneda integer,
    periodo numeric(2,0),
    gestion numeric(4,0),
    fecha_pago timestamp without time zone,
    estado_fac character varying(10),
    tipo_lectura character varying(10),
    fecha_factura date,
    nro_factura character varying(20),
    cod_control character varying(15),
    nro_autorizacion character varying(15),
    nro_orden character varying(15),
    cod_alfanum character varying(15),
    importe_total numeric(18,2),
    fecha_vence date,
    fecha_ant date,
    fecha_act date,
    lectura_ant numeric(18,2),
    lectura_act numeric(18,2),
    consumo_cambio numeric(18,2),
    consumo_periodo numeric(18,2),
    consumo_total numeric(18,2),
    lectura_kw numeric(18,2),
    consumo_val numeric(18,2),
    conexion_val numeric(18,2),
    reconex_val numeric(18,2),
    importe_dev numeric(18,2),
    credito_pagado numeric(18,2),
    potencia_val numeric(18,2),
    importe_cred_fis numeric(18,2),
    multi_kwh numeric(18,2),
    fecha_prox_med date,
    consumo_libre numeric(18,2),
    num_formulario character varying(20),
    sw_deb_fis character varying(2),
    cod_ubica character varying(20),
    direccion character varying(100),
    nombre_fac character varying(100),
    nit_fact character varying(20),
    nro_medidor character varying(20),
    id_cobro integer,
    desc_categoria character varying(100),
    dias_morosidad integer,
    glosa character varying(1000),
    estado_fac_ant character varying(10)
)
INHERITS (public.tbase);


ALTER TABLE cobra.tcb_factura_cob OWNER TO rchumacero;

--
-- TOC entry 6031 (class 0 OID 0)
-- Dependencies: 3888
-- Name: COLUMN tcb_factura_cob.importe_total; Type: COMMENT; Schema: cobra; Owner: rchumacero
--

COMMENT ON COLUMN tcb_factura_cob.importe_total IS 'desc=Importe total a pagar por el cliente (líquido pagable)';


--
-- TOC entry 6032 (class 0 OID 0)
-- Dependencies: 3888
-- Name: COLUMN tcb_factura_cob.importe_cred_fis; Type: COMMENT; Schema: cobra; Owner: rchumacero
--

COMMENT ON COLUMN tcb_factura_cob.importe_cred_fis IS 'desc=Corresponde sólo al importe válido para el crédito fiscal';


--
-- TOC entry 6033 (class 0 OID 0)
-- Dependencies: 3888
-- Name: COLUMN tcb_factura_cob.sw_deb_fis; Type: COMMENT; Schema: cobra; Owner: rchumacero
--

COMMENT ON COLUMN tcb_factura_cob.sw_deb_fis IS 'desc=Bandera que indica si se cobra o no Crédito Fiscal (caso de regiones como Cobija que no incluye Crédito Fiscal)';


--
-- TOC entry 6034 (class 0 OID 0)
-- Dependencies: 3888
-- Name: COLUMN tcb_factura_cob.estado_fac_ant; Type: COMMENT; Schema: cobra; Owner: rchumacero
--

COMMENT ON COLUMN tcb_factura_cob.estado_fac_ant IS 'Estado anterior de la factura';


SET default_with_oids = false;

--
-- TOC entry 3900 (class 1259 OID 59256)
-- Dependencies: 4721 4722 4723 30 3708
-- Name: tcb_factura_cob_anulado; Type: TABLE; Schema: cobra; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcb_factura_cob_anulado (
    id_factura_cob_anulado integer NOT NULL,
    id_factura_cob integer,
    id_caja integer,
    id_cajero integer,
    id_usuario integer,
    nro_formulario integer,
    motivo character varying(1000),
    estado_fac character varying(10),
    estado_fac_ant character varying(10),
    id_cobro integer
)
INHERITS (public.tbase);


ALTER TABLE cobra.tcb_factura_cob_anulado OWNER TO rchumacero;

--
-- TOC entry 6035 (class 0 OID 0)
-- Dependencies: 3900
-- Name: COLUMN tcb_factura_cob_anulado.id_usuario; Type: COMMENT; Schema: cobra; Owner: rchumacero
--

COMMENT ON COLUMN tcb_factura_cob_anulado.id_usuario IS 'desc=Usuario que realiza la anulación que es diferente al cajero';


--
-- TOC entry 6036 (class 0 OID 0)
-- Dependencies: 3900
-- Name: COLUMN tcb_factura_cob_anulado.estado_fac; Type: COMMENT; Schema: cobra; Owner: rchumacero
--

COMMENT ON COLUMN tcb_factura_cob_anulado.estado_fac IS 'Estado de la factura a la fecha de registro';


--
-- TOC entry 6037 (class 0 OID 0)
-- Dependencies: 3900
-- Name: COLUMN tcb_factura_cob_anulado.estado_fac_ant; Type: COMMENT; Schema: cobra; Owner: rchumacero
--

COMMENT ON COLUMN tcb_factura_cob_anulado.estado_fac_ant IS 'Estado de la factura a la fecha de registro';


--
-- TOC entry 3899 (class 1259 OID 59254)
-- Dependencies: 30 3900
-- Name: tcb_factura_cob_anulado_id_factura_cob_anulado_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tcb_factura_cob_anulado_id_factura_cob_anulado_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cobra.tcb_factura_cob_anulado_id_factura_cob_anulado_seq OWNER TO rchumacero;

--
-- TOC entry 6038 (class 0 OID 0)
-- Dependencies: 3899
-- Name: tcb_factura_cob_anulado_id_factura_cob_anulado_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: rchumacero
--

ALTER SEQUENCE tcb_factura_cob_anulado_id_factura_cob_anulado_seq OWNED BY tcb_factura_cob_anulado.id_factura_cob_anulado;


--
-- TOC entry 3898 (class 1259 OID 59225)
-- Dependencies: 4717 4718 4719 30 3708
-- Name: tcb_factura_cob_det; Type: TABLE; Schema: cobra; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcb_factura_cob_det (
    id_factura_cob_det integer NOT NULL,
    id_factura_cob integer,
    id_tasa integer,
    id_descuento integer,
    importe numeric(18,2)
)
INHERITS (public.tbase);


ALTER TABLE cobra.tcb_factura_cob_det OWNER TO rchumacero;

--
-- TOC entry 3897 (class 1259 OID 59223)
-- Dependencies: 30 3898
-- Name: tcb_factura_cob_det_id_factura_cob_det_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tcb_factura_cob_det_id_factura_cob_det_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cobra.tcb_factura_cob_det_id_factura_cob_det_seq OWNER TO rchumacero;

--
-- TOC entry 6039 (class 0 OID 0)
-- Dependencies: 3897
-- Name: tcb_factura_cob_det_id_factura_cob_det_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: rchumacero
--

ALTER SEQUENCE tcb_factura_cob_det_id_factura_cob_det_seq OWNED BY tcb_factura_cob_det.id_factura_cob_det;


--
-- TOC entry 3887 (class 1259 OID 58199)
-- Dependencies: 30 3888
-- Name: tcb_factura_cob_id_factura_cob_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tcb_factura_cob_id_factura_cob_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cobra.tcb_factura_cob_id_factura_cob_seq OWNER TO rchumacero;

--
-- TOC entry 6040 (class 0 OID 0)
-- Dependencies: 3887
-- Name: tcb_factura_cob_id_factura_cob_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: rchumacero
--

ALTER SEQUENCE tcb_factura_cob_id_factura_cob_seq OWNED BY tcb_factura_cob.id_factura_cob;


--
-- TOC entry 3869 (class 1259 OID 49284)
-- Dependencies: 4660 4661 4662 4664 30 3708
-- Name: tcb_prueba; Type: TABLE; Schema: cobra; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcb_prueba (
    id_prueba integer NOT NULL,
    nombre character varying(300),
    fecha date,
    estado character varying(10),
    sueldo numeric(18,2),
    empleado boolean,
    CONSTRAINT chk_tcb_prueba__estado CHECK (((estado)::text = ANY (ARRAY[('borrador'::character varying)::text, ('aprobado'::character varying)::text])))
)
INHERITS (public.tbase);


ALTER TABLE cobra.tcb_prueba OWNER TO rchumacero;

--
-- TOC entry 3868 (class 1259 OID 49282)
-- Dependencies: 30 3869
-- Name: tcb_prueba_id_prueba_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tcb_prueba_id_prueba_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cobra.tcb_prueba_id_prueba_seq OWNER TO rchumacero;

--
-- TOC entry 6041 (class 0 OID 0)
-- Dependencies: 3868
-- Name: tcb_prueba_id_prueba_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: rchumacero
--

ALTER SEQUENCE tcb_prueba_id_prueba_seq OWNED BY tcb_prueba.id_prueba;


SET default_with_oids = true;

--
-- TOC entry 3877 (class 1259 OID 56350)
-- Dependencies: 4676 4677 4678 4679 30 3708
-- Name: tcb_sistema_dist; Type: TABLE; Schema: cobra; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcb_sistema_dist (
    nombre character varying(100) NOT NULL,
    conexion character varying(100),
    id_sistema_dist integer DEFAULT nextval(('"cobra"."tcb_sistema_dist_id_sistema_dist_seq"'::text)::regclass) NOT NULL,
    codigo character varying(10) NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE cobra.tcb_sistema_dist OWNER TO rchumacero;

SET default_with_oids = false;

--
-- TOC entry 3880 (class 1259 OID 56415)
-- Dependencies: 4684 4685 4686 30 3708
-- Name: tcb_sistema_dist_agencia; Type: TABLE; Schema: cobra; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcb_sistema_dist_agencia (
    id_sistema_dist_agencia integer NOT NULL,
    id_sistema_dist integer,
    id_agencia integer
)
INHERITS (public.tbase);


ALTER TABLE cobra.tcb_sistema_dist_agencia OWNER TO rchumacero;

--
-- TOC entry 3879 (class 1259 OID 56413)
-- Dependencies: 30 3880
-- Name: tcb_sistema_dist_agencia_id_sistema_dist_agencia_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tcb_sistema_dist_agencia_id_sistema_dist_agencia_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cobra.tcb_sistema_dist_agencia_id_sistema_dist_agencia_seq OWNER TO rchumacero;

--
-- TOC entry 6042 (class 0 OID 0)
-- Dependencies: 3879
-- Name: tcb_sistema_dist_agencia_id_sistema_dist_agencia_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: rchumacero
--

ALTER SEQUENCE tcb_sistema_dist_agencia_id_sistema_dist_agencia_seq OWNED BY tcb_sistema_dist_agencia.id_sistema_dist_agencia;


--
-- TOC entry 3925 (class 1259 OID 1503298)
-- Dependencies: 30
-- Name: tcb_sistema_dist_id_sistema_dist_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tcb_sistema_dist_id_sistema_dist_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE cobra.tcb_sistema_dist_id_sistema_dist_seq OWNER TO rchumacero;

--
-- TOC entry 3884 (class 1259 OID 56455)
-- Dependencies: 4692 4693 4694 30 3708
-- Name: tcb_sistema_dist_usuario; Type: TABLE; Schema: cobra; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcb_sistema_dist_usuario (
    id_sistema_dist_usuario integer NOT NULL,
    id_sistema_dist integer,
    id_usuario integer
)
INHERITS (public.tbase);


ALTER TABLE cobra.tcb_sistema_dist_usuario OWNER TO rchumacero;

--
-- TOC entry 3883 (class 1259 OID 56453)
-- Dependencies: 30 3884
-- Name: tcb_sistema_dist_usuario_id_sistema_dist_usuario_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tcb_sistema_dist_usuario_id_sistema_dist_usuario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cobra.tcb_sistema_dist_usuario_id_sistema_dist_usuario_seq OWNER TO rchumacero;

--
-- TOC entry 6043 (class 0 OID 0)
-- Dependencies: 3883
-- Name: tcb_sistema_dist_usuario_id_sistema_dist_usuario_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: rchumacero
--

ALTER SEQUENCE tcb_sistema_dist_usuario_id_sistema_dist_usuario_seq OWNED BY tcb_sistema_dist_usuario.id_sistema_dist_usuario;


--
-- TOC entry 3876 (class 1259 OID 56348)
-- Dependencies: 30 3877
-- Name: tcb_sistema_distribucion_id_sistema_seq; Type: SEQUENCE; Schema: cobra; Owner: rchumacero
--

CREATE SEQUENCE tcb_sistema_distribucion_id_sistema_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cobra.tcb_sistema_distribucion_id_sistema_seq OWNER TO rchumacero;

--
-- TOC entry 6044 (class 0 OID 0)
-- Dependencies: 3876
-- Name: tcb_sistema_distribucion_id_sistema_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: rchumacero
--

ALTER SEQUENCE tcb_sistema_distribucion_id_sistema_seq OWNED BY tcb_sistema_dist.id_sistema_dist;


SET search_path = conta, pg_catalog;

SET default_with_oids = true;

--
-- TOC entry 3704 (class 1259 OID 16715)
-- Dependencies: 4442 4443 8
-- Name: tauxiliar; Type: TABLE; Schema: conta; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tauxiliar (
    id_auxiliar integer NOT NULL,
    codigo character varying(50),
    nombre character varying(250),
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    fecha_reg date DEFAULT (now())::date NOT NULL
);


ALTER TABLE conta.tauxiliar OWNER TO rchumacero;

--
-- TOC entry 3705 (class 1259 OID 16720)
-- Dependencies: 3704 8
-- Name: tauxiliar_id_auxiliar_seq; Type: SEQUENCE; Schema: conta; Owner: rchumacero
--

CREATE SEQUENCE tauxiliar_id_auxiliar_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE conta.tauxiliar_id_auxiliar_seq OWNER TO rchumacero;

--
-- TOC entry 6045 (class 0 OID 0)
-- Dependencies: 3705
-- Name: tauxiliar_id_auxiliar_seq; Type: SEQUENCE OWNED BY; Schema: conta; Owner: rchumacero
--

ALTER SEQUENCE tauxiliar_id_auxiliar_seq OWNED BY tauxiliar.id_auxiliar;


--
-- TOC entry 3706 (class 1259 OID 16722)
-- Dependencies: 4445 4446 8
-- Name: tcuenta; Type: TABLE; Schema: conta; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcuenta (
    id_cuenta integer NOT NULL,
    codigo character varying(50),
    nombre character varying(250),
    estado_reg character varying DEFAULT 'activo'::character varying NOT NULL,
    fecha_reg date DEFAULT (now())::date NOT NULL
);


ALTER TABLE conta.tcuenta OWNER TO rchumacero;

--
-- TOC entry 3707 (class 1259 OID 16730)
-- Dependencies: 3706 8
-- Name: tcuenta_id_cuenta_seq; Type: SEQUENCE; Schema: conta; Owner: rchumacero
--

CREATE SEQUENCE tcuenta_id_cuenta_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE conta.tcuenta_id_cuenta_seq OWNER TO rchumacero;

--
-- TOC entry 6046 (class 0 OID 0)
-- Dependencies: 3707
-- Name: tcuenta_id_cuenta_seq; Type: SEQUENCE OWNED BY; Schema: conta; Owner: rchumacero
--

ALTER SEQUENCE tcuenta_id_cuenta_seq OWNED BY tcuenta.id_cuenta;


SET default_with_oids = false;

--
-- TOC entry 3709 (class 1259 OID 16738)
-- Dependencies: 4450 4451 4452 4453 4454 8 3708
-- Name: tdocumento; Type: TABLE; Schema: conta; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tdocumento (
    id_documento integer NOT NULL,
    id_documento_tipo integer NOT NULL,
    nit character varying(30),
    nro_autorizacion character varying(30),
    nro_orden character varying(30),
    codigo_control character varying(30),
    importe numeric(18,2) NOT NULL,
    importe_excento numeric(18,2) DEFAULT 0 NOT NULL,
    nro_documento character varying(20) NOT NULL,
    importe_ice numeric(18,2) DEFAULT 0 NOT NULL,
    id_moneda_base integer NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE conta.tdocumento OWNER TO rchumacero;

--
-- TOC entry 3710 (class 1259 OID 16746)
-- Dependencies: 4455 4456 4457 8 3708
-- Name: tdocumento_tipo; Type: TABLE; Schema: conta; Owner: postgres; Tablespace: 
--

CREATE TABLE tdocumento_tipo (
    id_documento_tipo integer NOT NULL,
    nombre character varying(50)
)
INHERITS (public.tbase);


ALTER TABLE conta.tdocumento_tipo OWNER TO postgres;

SET search_path = factur, pg_catalog;

--
-- TOC entry 3875 (class 1259 OID 56313)
-- Dependencies: 4670 4671 4672 4673 4674 4675 43
-- Name: tfv_descuento; Type: TABLE; Schema: factur; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tfv_descuento (
    id_descuento integer NOT NULL,
    id_cuenta integer,
    desc_descuento character varying(100) NOT NULL,
    porcentaje numeric(10,4) DEFAULT 0 NOT NULL,
    consumo numeric(18,0) NOT NULL,
    sw_maximo character varying(2) DEFAULT 'no'::character varying NOT NULL,
    sw_general character varying(2) DEFAULT 'no'::character varying NOT NULL,
    estado numeric(1,0) NOT NULL,
    CONSTRAINT tfv_descuento_porcentaje_check CHECK (((porcentaje >= (0)::numeric) AND (porcentaje <= (100)::numeric))),
    CONSTRAINT tfv_descuento_sw_general_check CHECK ((((sw_general)::text = 'si'::text) OR ((sw_general)::text = 'no'::text))),
    CONSTRAINT tfv_descuento_sw_maximo_check CHECK ((((sw_maximo)::text = 'si'::text) OR ((sw_maximo)::text = 'no'::text)))
);


ALTER TABLE factur.tfv_descuento OWNER TO rchumacero;

--
-- TOC entry 6047 (class 0 OID 0)
-- Dependencies: 3875
-- Name: TABLE tfv_descuento; Type: COMMENT; Schema: factur; Owner: rchumacero
--

COMMENT ON TABLE tfv_descuento IS 'Guarda los parametros de descuento por ley en las facturas del consumo electrico (descuento de vejes y descuento tarifa dignidad)';


--
-- TOC entry 3874 (class 1259 OID 56311)
-- Dependencies: 43 3875
-- Name: tfv_descuento_id_descuento_seq; Type: SEQUENCE; Schema: factur; Owner: rchumacero
--

CREATE SEQUENCE tfv_descuento_id_descuento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE factur.tfv_descuento_id_descuento_seq OWNER TO rchumacero;

--
-- TOC entry 6048 (class 0 OID 0)
-- Dependencies: 3874
-- Name: tfv_descuento_id_descuento_seq; Type: SEQUENCE OWNED BY; Schema: factur; Owner: rchumacero
--

ALTER SEQUENCE tfv_descuento_id_descuento_seq OWNED BY tfv_descuento.id_descuento;


SET default_with_oids = true;

--
-- TOC entry 3871 (class 1259 OID 56289)
-- Dependencies: 43
-- Name: tfv_entidad_fin; Type: TABLE; Schema: factur; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tfv_entidad_fin (
    id_enti_fin integer NOT NULL,
    doc_id character varying,
    tipo_doc_id character varying,
    nombre character varying,
    codigo integer,
    num_cta_dep character varying(25),
    estado character varying
);


ALTER TABLE factur.tfv_entidad_fin OWNER TO rchumacero;

--
-- TOC entry 3870 (class 1259 OID 56287)
-- Dependencies: 43 3871
-- Name: tfv_entidad_fin_id_enti_fin_seq; Type: SEQUENCE; Schema: factur; Owner: rchumacero
--

CREATE SEQUENCE tfv_entidad_fin_id_enti_fin_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE factur.tfv_entidad_fin_id_enti_fin_seq OWNER TO rchumacero;

--
-- TOC entry 6049 (class 0 OID 0)
-- Dependencies: 3870
-- Name: tfv_entidad_fin_id_enti_fin_seq; Type: SEQUENCE OWNED BY; Schema: factur; Owner: rchumacero
--

ALTER SEQUENCE tfv_entidad_fin_id_enti_fin_seq OWNED BY tfv_entidad_fin.id_enti_fin;


SET default_with_oids = false;

--
-- TOC entry 3873 (class 1259 OID 56302)
-- Dependencies: 4667 4668 43
-- Name: tfv_tasa; Type: TABLE; Schema: factur; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tfv_tasa (
    id_tasa integer NOT NULL,
    id_param integer NOT NULL,
    id_cuenta integer,
    desc_tasa character varying(100) NOT NULL,
    tasa_porcen numeric(10,4) DEFAULT 0 NOT NULL,
    estado numeric(1,0) NOT NULL,
    CONSTRAINT tfv_tasa_tasa_porcen_check CHECK (((tasa_porcen >= (0)::numeric) AND (tasa_porcen <= (100)::numeric)))
);


ALTER TABLE factur.tfv_tasa OWNER TO rchumacero;

--
-- TOC entry 6050 (class 0 OID 0)
-- Dependencies: 3873
-- Name: TABLE tfv_tasa; Type: COMMENT; Schema: factur; Owner: rchumacero
--

COMMENT ON TABLE tfv_tasa IS 'Almacena la informacion referente a las tasas que se incluyen en la facturacion del servicio electrico';


--
-- TOC entry 3872 (class 1259 OID 56300)
-- Dependencies: 43 3873
-- Name: tfv_tasa_id_tasa_seq; Type: SEQUENCE; Schema: factur; Owner: rchumacero
--

CREATE SEQUENCE tfv_tasa_id_tasa_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE factur.tfv_tasa_id_tasa_seq OWNER TO rchumacero;

--
-- TOC entry 6051 (class 0 OID 0)
-- Dependencies: 3872
-- Name: tfv_tasa_id_tasa_seq; Type: SEQUENCE OWNED BY; Schema: factur; Owner: rchumacero
--

ALTER SEQUENCE tfv_tasa_id_tasa_seq OWNED BY tfv_tasa.id_tasa;


SET search_path = gen, pg_catalog;

--
-- TOC entry 3712 (class 1259 OID 16762)
-- Dependencies: 9
-- Name: tcolumna_id_columna_seq; Type: SEQUENCE; Schema: gen; Owner: rchumacero
--

CREATE SEQUENCE tcolumna_id_columna_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE gen.tcolumna_id_columna_seq OWNER TO rchumacero;

--
-- TOC entry 3711 (class 1259 OID 16752)
-- Dependencies: 4458 4459 4460 4461 4462 4463 9 3708
-- Name: tcolumna; Type: TABLE; Schema: gen; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcolumna (
    id_columna integer DEFAULT nextval('tcolumna_id_columna_seq'::regclass) NOT NULL,
    nombre character varying(50),
    descripcion character varying(500),
    id_tabla integer NOT NULL,
    etiqueta character varying(50),
    guardar character varying(2),
    tipo_dato character varying(25),
    longitud text,
    nulo character varying(10),
    checks character varying(20),
    valor_defecto character varying(200),
    grid_ancho integer,
    grid_mostrar character varying(2),
    form_ancho_porcen integer,
    orden smallint,
    grupo smallint,
    CONSTRAINT check_tcolumna__guardar CHECK ((((guardar)::text = 'si'::text) OR ((guardar)::text = 'no'::text))),
    CONSTRAINT chk_tcolumna__grid_mostrar CHECK (((grid_mostrar)::text = ANY ((ARRAY['si'::character varying, 'no'::character varying])::text[])))
)
INHERITS (public.tbase);


ALTER TABLE gen.tcolumna OWNER TO rchumacero;

--
-- TOC entry 3713 (class 1259 OID 16766)
-- Dependencies: 4464 4465 4466 9 3708
-- Name: ttabla; Type: TABLE; Schema: gen; Owner: postgres; Tablespace: 
--

CREATE TABLE ttabla (
    estado_reg character varying(10) NOT NULL,
    id_tabla integer NOT NULL,
    esquema character varying(20),
    nombre character varying(50),
    id_subsistema integer,
    alias character varying(10),
    reemplazar character varying(2),
    menu character varying(2),
    titulo character varying(150),
    direccion character varying(200),
    cant_grupos integer
)
INHERITS (public.tbase);


ALTER TABLE gen.ttabla OWNER TO postgres;

--
-- TOC entry 3714 (class 1259 OID 16776)
-- Dependencies: 9 3713
-- Name: ttabla_id_tabla_seq1; Type: SEQUENCE; Schema: gen; Owner: postgres
--

CREATE SEQUENCE ttabla_id_tabla_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gen.ttabla_id_tabla_seq1 OWNER TO postgres;

--
-- TOC entry 6052 (class 0 OID 0)
-- Dependencies: 3714
-- Name: ttabla_id_tabla_seq1; Type: SEQUENCE OWNED BY; Schema: gen; Owner: postgres
--

ALTER SEQUENCE ttabla_id_tabla_seq1 OWNED BY ttabla.id_tabla;


--
-- TOC entry 3715 (class 1259 OID 16778)
-- Dependencies: 4212 1539 1539 1539 9
-- Name: vcolumna; Type: VIEW; Schema: gen; Owner: rchumacero
--

CREATE VIEW vcolumna AS
    SELECT col.table_schema AS esquema, col.table_name AS tabla, col.column_name AS columna, (col.ordinal_position)::integer AS posicion, (col.column_default)::character varying AS defecto, (col.is_nullable)::character varying AS blanco, (col.data_type)::character varying AS tipo, CASE WHEN ((col.data_type)::text = 'character varying'::text) THEN (col.character_maximum_length)::integer WHEN ((col.data_type)::text = 'numeric'::text) THEN (col.numeric_precision)::integer ELSE 0 END AS length, CASE WHEN ((col.data_type)::text = 'numeric'::text) THEN (col.numeric_scale)::integer ELSE 0 END AS "precision", (cons.conname)::character varying AS nombre_constraint, (cons.consrc)::character varying AS definicion_constraint FROM (((information_schema.columns col LEFT JOIN information_schema.constraint_column_usage colcon ON (((((col.table_schema)::text = (colcon.table_schema)::text) AND ((col.table_name)::text = (colcon.table_name)::text)) AND ((col.column_name)::text = (colcon.column_name)::text)))) LEFT JOIN pg_constraint cons ON (((cons.conname = (colcon.constraint_name)::name) AND (cons.contype = 'c'::"char")))) LEFT JOIN pg_class c ON (((cons.conrelid = c.oid) AND (c.relname = (col.table_name)::name)))) WHERE (((col.table_schema)::text <> 'pg_catalog'::text) AND ((col.table_schema)::text <> 'information_schema'::text));


ALTER TABLE gen.vcolumna OWNER TO rchumacero;

SET search_path = gev, pg_catalog;

--
-- TOC entry 4031 (class 1259 OID 3175966)
-- Dependencies: 4947 4948 4949 4950 3708 90
-- Name: tgv_activo_datos_tec; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_activo_datos_tec (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_activo_datos_tec integer DEFAULT nextval(('gev.tgv_activo_datos_tec_id_activo_datos_tec_seq'::text)::regclass) NOT NULL,
    id_activo_fijo integer,
    id_modelo integer,
    placa character varying NOT NULL,
    chasis character varying,
    soat character varying,
    num_motor character varying,
    cilindrada_cc numeric(18,2),
    rend_litro_km numeric(18,2),
    ult_kilometraje numeric,
    fecha_ult_km timestamp without time zone,
    modem_id character varying(50) NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_activo_datos_tec OWNER TO rchumacero;

--
-- TOC entry 4081 (class 1259 OID 3208065)
-- Dependencies: 90
-- Name: tgv_activo_datos_tec_id_activo_datos_tec_seq; Type: SEQUENCE; Schema: gev; Owner: rac
--

CREATE SEQUENCE tgv_activo_datos_tec_id_activo_datos_tec_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE gev.tgv_activo_datos_tec_id_activo_datos_tec_seq OWNER TO rac;

SET default_with_oids = true;

--
-- TOC entry 4041 (class 1259 OID 3176152)
-- Dependencies: 4980 4981 4982 3708 90
-- Name: tgv_activo_fijo_grupo_evento; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_activo_fijo_grupo_evento (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_activo_fijo_grupo_evento integer NOT NULL,
    id_activo_fijo integer NOT NULL,
    id_agrupacion integer NOT NULL,
    estado character varying(10)
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_activo_fijo_grupo_evento OWNER TO rchumacero;

--
-- TOC entry 4038 (class 1259 OID 3176146)
-- Dependencies: 90 4041
-- Name: tgv_activo_fijo_grupo_evento_id_activo_fijo_grupo_evento_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_activo_fijo_grupo_evento_id_activo_fijo_grupo_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_activo_fijo_grupo_evento_id_activo_fijo_grupo_evento_seq OWNER TO rchumacero;

--
-- TOC entry 6053 (class 0 OID 0)
-- Dependencies: 4038
-- Name: tgv_activo_fijo_grupo_evento_id_activo_fijo_grupo_evento_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_activo_fijo_grupo_evento_id_activo_fijo_grupo_evento_seq OWNED BY tgv_activo_fijo_grupo_evento.id_activo_fijo_grupo_evento;


--
-- TOC entry 4039 (class 1259 OID 3176148)
-- Dependencies: 4041 90
-- Name: tgv_activo_fijo_grupo_evento_id_activo_fijo_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_activo_fijo_grupo_evento_id_activo_fijo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_activo_fijo_grupo_evento_id_activo_fijo_seq OWNER TO rchumacero;

--
-- TOC entry 6054 (class 0 OID 0)
-- Dependencies: 4039
-- Name: tgv_activo_fijo_grupo_evento_id_activo_fijo_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_activo_fijo_grupo_evento_id_activo_fijo_seq OWNED BY tgv_activo_fijo_grupo_evento.id_activo_fijo;


--
-- TOC entry 4040 (class 1259 OID 3176150)
-- Dependencies: 4041 90
-- Name: tgv_activo_fijo_grupo_evento_id_agrupacion_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_activo_fijo_grupo_evento_id_agrupacion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_activo_fijo_grupo_evento_id_agrupacion_seq OWNER TO rchumacero;

--
-- TOC entry 6055 (class 0 OID 0)
-- Dependencies: 4040
-- Name: tgv_activo_fijo_grupo_evento_id_agrupacion_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_activo_fijo_grupo_evento_id_agrupacion_seq OWNED BY tgv_activo_fijo_grupo_evento.id_agrupacion;


--
-- TOC entry 4043 (class 1259 OID 3176177)
-- Dependencies: 4986 4987 4988 90 3708
-- Name: tgv_activo_fijo_rastreo; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_activo_fijo_rastreo (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_activo_fijo_rastreo integer NOT NULL,
    id_activo_fijo integer,
    dia integer,
    mes integer,
    anio integer,
    hora_gps numeric(19,10),
    fecha_hora integer,
    calle character varying(200),
    ciudad character varying(100),
    estado character varying(10),
    latitud numeric,
    longitud numeric,
    velocidad numeric,
    curso integer,
    altitud numeric,
    mensaje character varying(200),
    punto_cercano character varying(200),
    odometro numeric,
    numero_actualizado integer,
    fecha_servidor date,
    fecha_satelite timestamp without time zone,
    aux1 character varying(150),
    aux2 character varying(150),
    aux3 character varying(150),
    aux4 character varying(150),
    advisories character varying(30),
    events integer,
    id_funcionario integer
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_activo_fijo_rastreo OWNER TO rchumacero;

--
-- TOC entry 4042 (class 1259 OID 3176175)
-- Dependencies: 90 4043
-- Name: tgv_activo_fijo_rastreo_id_activo_fijo_rastreo_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_activo_fijo_rastreo_id_activo_fijo_rastreo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_activo_fijo_rastreo_id_activo_fijo_rastreo_seq OWNER TO rchumacero;

--
-- TOC entry 6056 (class 0 OID 0)
-- Dependencies: 4042
-- Name: tgv_activo_fijo_rastreo_id_activo_fijo_rastreo_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_activo_fijo_rastreo_id_activo_fijo_rastreo_seq OWNED BY tgv_activo_fijo_rastreo.id_activo_fijo_rastreo;


SET default_with_oids = false;

--
-- TOC entry 4045 (class 1259 OID 3176209)
-- Dependencies: 4990 4991 4992 90 3708
-- Name: tgv_activo_fijo_ultimo_registro; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_activo_fijo_ultimo_registro (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_ultimo_registro integer NOT NULL,
    fecha_satelite timestamp without time zone,
    latitud numeric,
    longitud numeric,
    velocidad numeric,
    curso integer,
    id_funcionario integer,
    chofer character varying(100),
    id_activo_fijo integer,
    aux1 character varying(150),
    aux2 character varying(150),
    aux3 character varying(150),
    aux4 character varying(150),
    punto_cercano character varying(100)
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_activo_fijo_ultimo_registro OWNER TO rchumacero;

--
-- TOC entry 4044 (class 1259 OID 3176207)
-- Dependencies: 90 4045
-- Name: tgv_activo_fijo_ultimo_registro_id_ultimo_registro_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_activo_fijo_ultimo_registro_id_ultimo_registro_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_activo_fijo_ultimo_registro_id_ultimo_registro_seq OWNER TO rchumacero;

--
-- TOC entry 6057 (class 0 OID 0)
-- Dependencies: 4044
-- Name: tgv_activo_fijo_ultimo_registro_id_ultimo_registro_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_activo_fijo_ultimo_registro_id_ultimo_registro_seq OWNED BY tgv_activo_fijo_ultimo_registro.id_ultimo_registro;


SET default_with_oids = true;

--
-- TOC entry 4047 (class 1259 OID 3176243)
-- Dependencies: 4994 4995 4996 90 3708
-- Name: tgv_agrupacion; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_agrupacion (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_agrupacion integer NOT NULL,
    nombre character varying(80)
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_agrupacion OWNER TO rchumacero;

--
-- TOC entry 4052 (class 1259 OID 3176289)
-- Dependencies: 5003 5004 5005 90 3708
-- Name: tgv_agrupacion_evento; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_agrupacion_evento (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_agrupacion_evento integer NOT NULL,
    id_evento integer NOT NULL,
    id_agrupacion integer NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_agrupacion_evento OWNER TO rchumacero;

--
-- TOC entry 4051 (class 1259 OID 3176287)
-- Dependencies: 90 4052
-- Name: tgv_agrupacion_evento_id_agrupacion_evento_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_agrupacion_evento_id_agrupacion_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_agrupacion_evento_id_agrupacion_evento_seq OWNER TO rchumacero;

--
-- TOC entry 6058 (class 0 OID 0)
-- Dependencies: 4051
-- Name: tgv_agrupacion_evento_id_agrupacion_evento_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_agrupacion_evento_id_agrupacion_evento_seq OWNED BY tgv_agrupacion_evento.id_agrupacion_evento;


--
-- TOC entry 4082 (class 1259 OID 3208067)
-- Dependencies: 90
-- Name: tgv_agrupacion_evento_id_evento_seq; Type: SEQUENCE; Schema: gev; Owner: rac
--

CREATE SEQUENCE tgv_agrupacion_evento_id_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_agrupacion_evento_id_evento_seq OWNER TO rac;

--
-- TOC entry 4083 (class 1259 OID 3208069)
-- Dependencies: 90
-- Name: tgv_agrupacion_evento_id_grupo_evento_seq; Type: SEQUENCE; Schema: gev; Owner: rac
--

CREATE SEQUENCE tgv_agrupacion_evento_id_grupo_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_agrupacion_evento_id_grupo_evento_seq OWNER TO rac;

--
-- TOC entry 4046 (class 1259 OID 3176241)
-- Dependencies: 90 4047
-- Name: tgv_agrupacion_id_agrupacion_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_agrupacion_id_agrupacion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_agrupacion_id_agrupacion_seq OWNER TO rchumacero;

--
-- TOC entry 6059 (class 0 OID 0)
-- Dependencies: 4046
-- Name: tgv_agrupacion_id_agrupacion_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_agrupacion_id_agrupacion_seq OWNED BY tgv_agrupacion.id_agrupacion;


--
-- TOC entry 4055 (class 1259 OID 3176324)
-- Dependencies: 5007 5008 5009 3708 90
-- Name: tgv_bitacora; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_bitacora (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_bitacora integer NOT NULL,
    id_servicio_det integer NOT NULL,
    fecha date,
    combustible_lts numeric(18,2),
    combustible character varying(255),
    num_factura character varying(40),
    importe numeric(18,2),
    observaciones character varying(500),
    origen character varying(100),
    destino character varying(100)
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_bitacora OWNER TO rchumacero;

--
-- TOC entry 4053 (class 1259 OID 3176320)
-- Dependencies: 90 4055
-- Name: tgv_bitacora_id_bitacora_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_bitacora_id_bitacora_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_bitacora_id_bitacora_seq OWNER TO rchumacero;

--
-- TOC entry 6060 (class 0 OID 0)
-- Dependencies: 4053
-- Name: tgv_bitacora_id_bitacora_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_bitacora_id_bitacora_seq OWNED BY tgv_bitacora.id_bitacora;


--
-- TOC entry 4054 (class 1259 OID 3176322)
-- Dependencies: 90 4055
-- Name: tgv_bitacora_id_servicio_det_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_bitacora_id_servicio_det_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_bitacora_id_servicio_det_seq OWNER TO rchumacero;

--
-- TOC entry 6061 (class 0 OID 0)
-- Dependencies: 4054
-- Name: tgv_bitacora_id_servicio_det_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_bitacora_id_servicio_det_seq OWNED BY tgv_bitacora.id_servicio_det;


--
-- TOC entry 4061 (class 1259 OID 3176401)
-- Dependencies: 5020 5021 5022 3708 90
-- Name: tgv_datos_tec; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_datos_tec (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_datos_tec integer NOT NULL,
    id_activo_fijo integer NOT NULL,
    id_modelo integer,
    num_chasis character varying(50),
    soat character varying(30),
    num_motor character varying(50),
    cilindrada_cc numeric(18,2),
    rend_litro_km numeric(18,2),
    ult_kilometraje numeric(18,2),
    fecha_ult_km date,
    modem_id character varying(32)
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_datos_tec OWNER TO rchumacero;

--
-- TOC entry 4060 (class 1259 OID 3176399)
-- Dependencies: 4061 90
-- Name: tgv_datos_tec_id_datos_tec_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_datos_tec_id_datos_tec_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_datos_tec_id_datos_tec_seq OWNER TO rchumacero;

--
-- TOC entry 6062 (class 0 OID 0)
-- Dependencies: 4060
-- Name: tgv_datos_tec_id_datos_tec_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_datos_tec_id_datos_tec_seq OWNED BY tgv_datos_tec.id_datos_tec;


--
-- TOC entry 4050 (class 1259 OID 3176264)
-- Dependencies: 4998 4999 5000 3708 90
-- Name: tgv_evento; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_evento (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_evento integer NOT NULL,
    id_tipo_evento integer NOT NULL,
    nombre character varying(100) NOT NULL,
    descripcion character varying(500) NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_evento OWNER TO rchumacero;

--
-- TOC entry 4048 (class 1259 OID 3176260)
-- Dependencies: 90 4050
-- Name: tgv_evento_id_evento_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_evento_id_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_evento_id_evento_seq OWNER TO rchumacero;

--
-- TOC entry 6063 (class 0 OID 0)
-- Dependencies: 4048
-- Name: tgv_evento_id_evento_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_evento_id_evento_seq OWNED BY tgv_evento.id_evento;


--
-- TOC entry 4049 (class 1259 OID 3176262)
-- Dependencies: 90 4050
-- Name: tgv_evento_id_tipo_evento_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_evento_id_tipo_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_evento_id_tipo_evento_seq OWNER TO rchumacero;

--
-- TOC entry 6064 (class 0 OID 0)
-- Dependencies: 4049
-- Name: tgv_evento_id_tipo_evento_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_evento_id_tipo_evento_seq OWNED BY tgv_evento.id_tipo_evento;


SET default_with_oids = false;

--
-- TOC entry 4063 (class 1259 OID 3176417)
-- Dependencies: 5024 5025 5026 3708 90
-- Name: tgv_iboton; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_iboton (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_iboton integer NOT NULL,
    codigo character varying(50) NOT NULL,
    id_funcionario integer NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_iboton OWNER TO rchumacero;

--
-- TOC entry 4062 (class 1259 OID 3176415)
-- Dependencies: 4063 90
-- Name: tgv_iboton_id_iboton_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_iboton_id_iboton_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_iboton_id_iboton_seq OWNER TO rchumacero;

--
-- TOC entry 6065 (class 0 OID 0)
-- Dependencies: 4062
-- Name: tgv_iboton_id_iboton_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_iboton_id_iboton_seq OWNED BY tgv_iboton.id_iboton;


SET default_with_oids = true;

--
-- TOC entry 4067 (class 1259 OID 3176448)
-- Dependencies: 5032 5033 5034 3708 90
-- Name: tgv_mantenimiento; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_mantenimiento (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_mantenimiento integer NOT NULL,
    id_proveedor integer NOT NULL,
    fecha_ini date NOT NULL,
    fecha_fin date NOT NULL,
    descripcion character varying(2000) NOT NULL,
    id_funcionario integer NOT NULL,
    id_tipo_evento integer NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_mantenimiento OWNER TO rchumacero;

--
-- TOC entry 4069 (class 1259 OID 3176477)
-- Dependencies: 5036 5037 5038 5040 5041 3708 90
-- Name: tgv_mantenimiento_det; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_mantenimiento_det (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_mantenimiento_det integer NOT NULL,
    id_mantenimiento integer NOT NULL,
    id_activo_fijo integer NOT NULL,
    id_evento integer NOT NULL,
    descripcion character varying(1000) NOT NULL,
    estado character varying(15) DEFAULT 'pendiente'::character varying NOT NULL,
    CONSTRAINT chk_tgv_mantenimiento_det__estado CHECK (((estado)::text = ANY (ARRAY[('pendiente'::character varying)::text, ('concluido'::character varying)::text])))
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_mantenimiento_det OWNER TO rchumacero;

--
-- TOC entry 4084 (class 1259 OID 3208071)
-- Dependencies: 90
-- Name: tgv_mantenimiento_det_id_activo_fijo_seq; Type: SEQUENCE; Schema: gev; Owner: rac
--

CREATE SEQUENCE tgv_mantenimiento_det_id_activo_fijo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_mantenimiento_det_id_activo_fijo_seq OWNER TO rac;

--
-- TOC entry 4085 (class 1259 OID 3208073)
-- Dependencies: 90
-- Name: tgv_mantenimiento_det_id_evento_seq; Type: SEQUENCE; Schema: gev; Owner: rac
--

CREATE SEQUENCE tgv_mantenimiento_det_id_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_mantenimiento_det_id_evento_seq OWNER TO rac;

--
-- TOC entry 4068 (class 1259 OID 3176475)
-- Dependencies: 90 4069
-- Name: tgv_mantenimiento_det_id_mantenimiento_det_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_mantenimiento_det_id_mantenimiento_det_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_mantenimiento_det_id_mantenimiento_det_seq OWNER TO rchumacero;

--
-- TOC entry 6066 (class 0 OID 0)
-- Dependencies: 4068
-- Name: tgv_mantenimiento_det_id_mantenimiento_det_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_mantenimiento_det_id_mantenimiento_det_seq OWNED BY tgv_mantenimiento_det.id_mantenimiento_det;


--
-- TOC entry 4086 (class 1259 OID 3208075)
-- Dependencies: 90
-- Name: tgv_mantenimiento_det_id_mantenimiento_seq; Type: SEQUENCE; Schema: gev; Owner: rac
--

CREATE SEQUENCE tgv_mantenimiento_det_id_mantenimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_mantenimiento_det_id_mantenimiento_seq OWNER TO rac;

--
-- TOC entry 4066 (class 1259 OID 3176446)
-- Dependencies: 4067 90
-- Name: tgv_mantenimiento_id_mantenimiento_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_mantenimiento_id_mantenimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_mantenimiento_id_mantenimiento_seq OWNER TO rchumacero;

--
-- TOC entry 6067 (class 0 OID 0)
-- Dependencies: 4066
-- Name: tgv_mantenimiento_id_mantenimiento_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_mantenimiento_id_mantenimiento_seq OWNED BY tgv_mantenimiento.id_mantenimiento;


--
-- TOC entry 4087 (class 1259 OID 3208077)
-- Dependencies: 90
-- Name: tgv_mantenimiento_id_movimiento_seq; Type: SEQUENCE; Schema: gev; Owner: rac
--

CREATE SEQUENCE tgv_mantenimiento_id_movimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_mantenimiento_id_movimiento_seq OWNER TO rac;

--
-- TOC entry 4088 (class 1259 OID 3208079)
-- Dependencies: 90
-- Name: tgv_mantenimiento_id_proveedor_seq; Type: SEQUENCE; Schema: gev; Owner: rac
--

CREATE SEQUENCE tgv_mantenimiento_id_proveedor_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_mantenimiento_id_proveedor_seq OWNER TO rac;

--
-- TOC entry 4057 (class 1259 OID 3176349)
-- Dependencies: 5012 5013 5014 3708 90
-- Name: tgv_marca; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_marca (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_marca integer NOT NULL,
    marca character varying(80),
    procedencia character varying(100)
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_marca OWNER TO rchumacero;

--
-- TOC entry 4056 (class 1259 OID 3176347)
-- Dependencies: 4057 90
-- Name: tgv_marca_id_marca_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_marca_id_marca_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_marca_id_marca_seq OWNER TO rchumacero;

--
-- TOC entry 6068 (class 0 OID 0)
-- Dependencies: 4056
-- Name: tgv_marca_id_marca_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_marca_id_marca_seq OWNED BY tgv_marca.id_marca;


--
-- TOC entry 4059 (class 1259 OID 3176368)
-- Dependencies: 5016 5017 5018 3708 90
-- Name: tgv_modelo; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_modelo (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_modelo integer NOT NULL,
    id_marca integer NOT NULL,
    modelo character varying(100),
    anio integer,
    descripcion character varying(500)
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_modelo OWNER TO rchumacero;

--
-- TOC entry 4058 (class 1259 OID 3176366)
-- Dependencies: 4059 90
-- Name: tgv_modelo_id_modelo_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_modelo_id_modelo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_modelo_id_modelo_seq OWNER TO rchumacero;

--
-- TOC entry 6069 (class 0 OID 0)
-- Dependencies: 4058
-- Name: tgv_modelo_id_modelo_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_modelo_id_modelo_seq OWNED BY tgv_modelo.id_modelo;


--
-- TOC entry 4071 (class 1259 OID 3176508)
-- Dependencies: 5042 5043 5044 3708 90
-- Name: tgv_servicio; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_servicio (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_servicio integer NOT NULL,
    id_lugar_origen integer NOT NULL,
    id_lugar_destino integer NOT NULL,
    estado character varying(10) NOT NULL,
    descripcion character varying(1000) NOT NULL,
    cant_personas integer NOT NULL,
    fecha_sol_ini date NOT NULL,
    fecha_sol_fin date NOT NULL,
    id_ep integer,
    fecha_asig_ini date,
    fecha_asig_fin date,
    id_funcionario integer,
    id_funcionario_autoriz integer NOT NULL,
    observaciones character varying(2000)
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_servicio OWNER TO rchumacero;

--
-- TOC entry 4073 (class 1259 OID 3176537)
-- Dependencies: 5046 5047 5048 90 3708
-- Name: tgv_servicio_det; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_servicio_det (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_servicio_det integer NOT NULL,
    id_activo_fijo integer NOT NULL,
    id_funcionario integer NOT NULL,
    id_servicio integer NOT NULL,
    kilometraje_ini numeric(18,2) NOT NULL,
    kilometraje_fin numeric(18,2) NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_servicio_det OWNER TO rchumacero;

--
-- TOC entry 4075 (class 1259 OID 3176559)
-- Dependencies: 5050 5051 5052 90 3708
-- Name: tgv_servicio_det_evento; Type: TABLE; Schema: gev; Owner: rac; Tablespace: 
--

CREATE TABLE tgv_servicio_det_evento (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_servicio_det_evento integer NOT NULL,
    id_evento integer NOT NULL,
    id_servicio_det integer NOT NULL,
    descripcion character varying(1000) NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_servicio_det_evento OWNER TO rac;

--
-- TOC entry 4089 (class 1259 OID 3208081)
-- Dependencies: 90
-- Name: tgv_servicio_det_evento_id_evento_seq; Type: SEQUENCE; Schema: gev; Owner: rac
--

CREATE SEQUENCE tgv_servicio_det_evento_id_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_servicio_det_evento_id_evento_seq OWNER TO rac;

--
-- TOC entry 4090 (class 1259 OID 3208083)
-- Dependencies: 90
-- Name: tgv_servicio_det_evento_id_servicio_det_event_seq; Type: SEQUENCE; Schema: gev; Owner: rac
--

CREATE SEQUENCE tgv_servicio_det_evento_id_servicio_det_event_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_servicio_det_evento_id_servicio_det_event_seq OWNER TO rac;

--
-- TOC entry 4074 (class 1259 OID 3176557)
-- Dependencies: 90 4075
-- Name: tgv_servicio_det_evento_id_servicio_det_evento_seq; Type: SEQUENCE; Schema: gev; Owner: rac
--

CREATE SEQUENCE tgv_servicio_det_evento_id_servicio_det_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_servicio_det_evento_id_servicio_det_evento_seq OWNER TO rac;

--
-- TOC entry 6070 (class 0 OID 0)
-- Dependencies: 4074
-- Name: tgv_servicio_det_evento_id_servicio_det_evento_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rac
--

ALTER SEQUENCE tgv_servicio_det_evento_id_servicio_det_evento_seq OWNED BY tgv_servicio_det_evento.id_servicio_det_evento;


--
-- TOC entry 4091 (class 1259 OID 3208085)
-- Dependencies: 90
-- Name: tgv_servicio_det_evento_id_servicio_det_seq; Type: SEQUENCE; Schema: gev; Owner: rac
--

CREATE SEQUENCE tgv_servicio_det_evento_id_servicio_det_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_servicio_det_evento_id_servicio_det_seq OWNER TO rac;

--
-- TOC entry 4092 (class 1259 OID 3208087)
-- Dependencies: 90
-- Name: tgv_servicio_det_id_activo_fijo_seq; Type: SEQUENCE; Schema: gev; Owner: rac
--

CREATE SEQUENCE tgv_servicio_det_id_activo_fijo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_servicio_det_id_activo_fijo_seq OWNER TO rac;

--
-- TOC entry 4093 (class 1259 OID 3208089)
-- Dependencies: 90
-- Name: tgv_servicio_det_id_empleado_seq; Type: SEQUENCE; Schema: gev; Owner: rac
--

CREATE SEQUENCE tgv_servicio_det_id_empleado_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_servicio_det_id_empleado_seq OWNER TO rac;

--
-- TOC entry 4072 (class 1259 OID 3176535)
-- Dependencies: 4073 90
-- Name: tgv_servicio_det_id_servicio_det_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_servicio_det_id_servicio_det_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_servicio_det_id_servicio_det_seq OWNER TO rchumacero;

--
-- TOC entry 6071 (class 0 OID 0)
-- Dependencies: 4072
-- Name: tgv_servicio_det_id_servicio_det_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_servicio_det_id_servicio_det_seq OWNED BY tgv_servicio_det.id_servicio_det;


--
-- TOC entry 4094 (class 1259 OID 3208091)
-- Dependencies: 90
-- Name: tgv_servicio_det_id_servicio_seq; Type: SEQUENCE; Schema: gev; Owner: rac
--

CREATE SEQUENCE tgv_servicio_det_id_servicio_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_servicio_det_id_servicio_seq OWNER TO rac;

--
-- TOC entry 4070 (class 1259 OID 3176506)
-- Dependencies: 90 4071
-- Name: tgv_servicio_id_servicio_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_servicio_id_servicio_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_servicio_id_servicio_seq OWNER TO rchumacero;

--
-- TOC entry 6072 (class 0 OID 0)
-- Dependencies: 4070
-- Name: tgv_servicio_id_servicio_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_servicio_id_servicio_seq OWNED BY tgv_servicio.id_servicio;


--
-- TOC entry 4065 (class 1259 OID 3176437)
-- Dependencies: 5028 5029 5030 90 3708
-- Name: tgv_tipo_evento; Type: TABLE; Schema: gev; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tgv_tipo_evento (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    id_tipo_evento integer NOT NULL,
    codigo character varying(10),
    nombre character varying(50)
)
INHERITS (public.tbase);


ALTER TABLE gev.tgv_tipo_evento OWNER TO rchumacero;

--
-- TOC entry 4064 (class 1259 OID 3176435)
-- Dependencies: 90 4065
-- Name: tgv_tipo_evento_id_tipo_evento_seq; Type: SEQUENCE; Schema: gev; Owner: rchumacero
--

CREATE SEQUENCE tgv_tipo_evento_id_tipo_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE gev.tgv_tipo_evento_id_tipo_evento_seq OWNER TO rchumacero;

--
-- TOC entry 6073 (class 0 OID 0)
-- Dependencies: 4064
-- Name: tgv_tipo_evento_id_tipo_evento_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: rchumacero
--

ALTER SEQUENCE tgv_tipo_evento_id_tipo_evento_seq OWNED BY tgv_tipo_evento.id_tipo_evento;


SET search_path = segu, pg_catalog;

SET default_with_oids = false;

--
-- TOC entry 3845 (class 1259 OID 17374)
-- Dependencies: 4623 4624 4625 4626 1608 14
-- Name: tusuario; Type: TABLE; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tusuario (
    id_usuario integer DEFAULT nextval(('"segu"."usuario_id_usuario_seq"'::text)::regclass) NOT NULL,
    id_clasificador integer,
    cuenta character varying(100) NOT NULL,
    contrasena character varying(100) NOT NULL,
    fecha_caducidad date,
    fecha_reg date DEFAULT now() NOT NULL,
    estilo character varying(100),
    contrasena_anterior character varying(100),
    id_persona integer NOT NULL,
    estado_reg public.estado_reg DEFAULT 'activo'::public.estado_reg,
    autentificacion character varying(20) DEFAULT 'local'::character varying
);


ALTER TABLE segu.tusuario OWNER TO rchumacero;

SET search_path = gev, pg_catalog;

--
-- TOC entry 4076 (class 1259 OID 3176571)
-- Dependencies: 4230 90
-- Name: vgv_activo_datos_tec; Type: VIEW; Schema: gev; Owner: rchumacero
--

CREATE VIEW vgv_activo_datos_tec AS
    SELECT vehic.id_activo_datos_tec, vehic.rend_litro_km, vehic.fecha_ult_km, vehic.estado_reg, vehic.id_activo_fijo, vehic.chasis, vehic.num_motor, vehic.ult_kilometraje, vehic.placa, vehic.cilindrada_cc, vehic.modem_id, vehic.soat, vehic.id_modelo, vehic.id_usuario_reg, vehic.fecha_reg, vehic.id_usuario_mod, vehic.fecha_mod, usu1.cuenta AS usr_reg, usu2.cuenta AS usr_mod, ((((actif.codigo)::text || ' - '::text) || (actif.descripcion)::text))::character varying AS desc_activo_fijo, model.modelo, marca.marca, marca.id_marca FROM (((((tgv_activo_datos_tec vehic JOIN actif.taf_activo_fijo actif ON ((actif.id_activo_fijo = vehic.id_activo_fijo))) JOIN tgv_modelo model ON ((model.id_modelo = vehic.id_modelo))) JOIN tgv_marca marca ON ((marca.id_marca = model.id_marca))) JOIN segu.tusuario usu1 ON ((usu1.id_usuario = vehic.id_usuario_reg))) LEFT JOIN segu.tusuario usu2 ON ((usu2.id_usuario = vehic.id_usuario_mod)));


ALTER TABLE gev.vgv_activo_datos_tec OWNER TO rchumacero;

SET search_path = hidro, pg_catalog;

--
-- TOC entry 3913 (class 1259 OID 1379045)
-- Dependencies: 4759 4760 4761 45 3708
-- Name: thd_administrador_hidro; Type: TABLE; Schema: hidro; Owner: rac; Tablespace: 
--

CREATE TABLE thd_administrador_hidro (
    id_administrador integer NOT NULL,
    codigo character varying(24) NOT NULL,
    nombre character varying NOT NULL,
    meteo boolean,
    hidro boolean
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_administrador_hidro OWNER TO rac;

--
-- TOC entry 3912 (class 1259 OID 1379043)
-- Dependencies: 45 3913
-- Name: thd_administrador_hidro_id_administrador_hidro_seq; Type: SEQUENCE; Schema: hidro; Owner: rac
--

CREATE SEQUENCE thd_administrador_hidro_id_administrador_hidro_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_administrador_hidro_id_administrador_hidro_seq OWNER TO rac;

--
-- TOC entry 6074 (class 0 OID 0)
-- Dependencies: 3912
-- Name: thd_administrador_hidro_id_administrador_hidro_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: rac
--

ALTER SEQUENCE thd_administrador_hidro_id_administrador_hidro_seq OWNED BY thd_administrador_hidro.id_administrador;


--
-- TOC entry 3990 (class 1259 OID 2048985)
-- Dependencies: 5133 5134 5135 3708 45
-- Name: thd_archivo; Type: TABLE; Schema: hidro; Owner: rac; Tablespace: 
--

CREATE TABLE thd_archivo (
    id_archivo integer NOT NULL,
    id_operador integer NOT NULL,
    id_tipo_archivo integer NOT NULL,
    fecha date,
    nombre_archivo_real character varying(250),
    obs text,
    archivo_temp bytea,
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT NULL,
    fecha_mod timestamp without time zone DEFAULT NULL,
    estado_reg character varying(10) DEFAULT NULL
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_archivo OWNER TO rac;

--
-- TOC entry 3989 (class 1259 OID 2048983)
-- Dependencies: 45 3990
-- Name: thd_archivo_id_archivo_seq; Type: SEQUENCE; Schema: hidro; Owner: rac
--

CREATE SEQUENCE thd_archivo_id_archivo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_archivo_id_archivo_seq OWNER TO rac;

--
-- TOC entry 6075 (class 0 OID 0)
-- Dependencies: 3989
-- Name: thd_archivo_id_archivo_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: rac
--

ALTER SEQUENCE thd_archivo_id_archivo_seq OWNED BY thd_archivo.id_archivo;


--
-- TOC entry 3988 (class 1259 OID 2048553)
-- Dependencies: 5130 5131 5132 3708 45
-- Name: thd_archivo_sensor; Type: TABLE; Schema: hidro; Owner: rac; Tablespace: 
--

CREATE TABLE thd_archivo_sensor (
    id_archivo_sensor integer NOT NULL,
    id_tipo_archivo integer NOT NULL,
    id_sensor integer NOT NULL,
    orden integer,
    nombre_col_file character varying(50),
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT NULL,
    fecha_mod timestamp without time zone DEFAULT NULL,
    estado_reg character varying(10) DEFAULT NULL,
    orden_col_fecha integer,
    nombre_col_fecha character varying(50),
    orden_col_hora integer,
    nombre_col_hora character varying(50)
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_archivo_sensor OWNER TO rac;

--
-- TOC entry 3986 (class 1259 OID 2048549)
-- Dependencies: 45 3988
-- Name: thd_archivo_sensor_id_archivo_sensor_seq; Type: SEQUENCE; Schema: hidro; Owner: rac
--

CREATE SEQUENCE thd_archivo_sensor_id_archivo_sensor_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_archivo_sensor_id_archivo_sensor_seq OWNER TO rac;

--
-- TOC entry 6076 (class 0 OID 0)
-- Dependencies: 3986
-- Name: thd_archivo_sensor_id_archivo_sensor_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: rac
--

ALTER SEQUENCE thd_archivo_sensor_id_archivo_sensor_seq OWNED BY thd_archivo_sensor.id_archivo_sensor;


--
-- TOC entry 3987 (class 1259 OID 2048551)
-- Dependencies: 45 3988
-- Name: thd_archivo_sensor_id_sensor_seq; Type: SEQUENCE; Schema: hidro; Owner: rac
--

CREATE SEQUENCE thd_archivo_sensor_id_sensor_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_archivo_sensor_id_sensor_seq OWNER TO rac;

--
-- TOC entry 6077 (class 0 OID 0)
-- Dependencies: 3987
-- Name: thd_archivo_sensor_id_sensor_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: rac
--

ALTER SEQUENCE thd_archivo_sensor_id_sensor_seq OWNED BY thd_archivo_sensor.id_sensor;


SET default_with_oids = true;

--
-- TOC entry 3908 (class 1259 OID 1365684)
-- Dependencies: 4751 4752 4753 4754 45 3708
-- Name: thd_cuenca; Type: TABLE; Schema: hidro; Owner: mflores; Tablespace: 
--

CREATE TABLE thd_cuenca (
    id_cuenca integer DEFAULT nextval(('hidro.thd_cuenca_id_cuenca_seq'::text)::regclass) NOT NULL,
    id_cuenca_fk integer,
    tipo_cuenca character varying(255),
    nombre character varying(255),
    codigo character varying(255),
    codigo_largo character varying(255)
)
INHERITS (public.tbase);
ALTER TABLE ONLY thd_cuenca ALTER COLUMN id_cuenca SET STATISTICS 0;
ALTER TABLE ONLY thd_cuenca ALTER COLUMN id_cuenca_fk SET STATISTICS 0;
ALTER TABLE ONLY thd_cuenca ALTER COLUMN tipo_cuenca SET STATISTICS 0;
ALTER TABLE ONLY thd_cuenca ALTER COLUMN nombre SET STATISTICS 0;


ALTER TABLE hidro.thd_cuenca OWNER TO mflores;

--
-- TOC entry 3914 (class 1259 OID 1379261)
-- Dependencies: 45
-- Name: thd_cuenca_id_cuenca_seq; Type: SEQUENCE; Schema: hidro; Owner: mflores
--

CREATE SEQUENCE thd_cuenca_id_cuenca_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE hidro.thd_cuenca_id_cuenca_seq OWNER TO mflores;

SET default_with_oids = false;

--
-- TOC entry 3906 (class 1259 OID 1364930)
-- Dependencies: 4740 4741 4742 4743 45 3708
-- Name: thd_estacion; Type: TABLE; Schema: hidro; Owner: rac; Tablespace: 
--

CREATE TABLE thd_estacion (
    id_estacion integer DEFAULT nextval(('hidro.thd_estacion_id_estacion_seq'::text)::regclass) NOT NULL,
    codigo character varying(255),
    tipo character varying(255),
    id_cuenca integer NOT NULL,
    id_lugar integer NOT NULL,
    id_rio integer NOT NULL,
    fecha_ini timestamp(0) without time zone,
    fecha_fin timestamp(0) without time zone,
    latitud numeric,
    longitud numeric,
    altitud numeric,
    comentario character varying(10),
    id_administrador integer NOT NULL,
    superficie_cuenca integer,
    estado character varying(255),
    observador character varying(255),
    direccion character varying(10),
    teletransmision boolean,
    latitud_carto text,
    longitud_carto text,
    foto bytea,
    extension character varying(4)
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_estacion OWNER TO rac;

--
-- TOC entry 3920 (class 1259 OID 1406856)
-- Dependencies: 45
-- Name: thd_estacion_id_estacion_seq; Type: SEQUENCE; Schema: hidro; Owner: mflores
--

CREATE SEQUENCE thd_estacion_id_estacion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE hidro.thd_estacion_id_estacion_seq OWNER TO mflores;

--
-- TOC entry 3946 (class 1259 OID 1872091)
-- Dependencies: 45
-- Name: thd_estacion_proyecto; Type: TABLE; Schema: hidro; Owner: rac; Tablespace: 
--

CREATE TABLE thd_estacion_proyecto (
    id_estacion_proyecto integer NOT NULL,
    id_proyecto integer,
    id_estacion integer
);


ALTER TABLE hidro.thd_estacion_proyecto OWNER TO rac;

--
-- TOC entry 3945 (class 1259 OID 1872089)
-- Dependencies: 45 3946
-- Name: thd_estacion_proyecto_id_estacion_proyecto_seq; Type: SEQUENCE; Schema: hidro; Owner: rac
--

CREATE SEQUENCE thd_estacion_proyecto_id_estacion_proyecto_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_estacion_proyecto_id_estacion_proyecto_seq OWNER TO rac;

--
-- TOC entry 6078 (class 0 OID 0)
-- Dependencies: 3945
-- Name: thd_estacion_proyecto_id_estacion_proyecto_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: rac
--

ALTER SEQUENCE thd_estacion_proyecto_id_estacion_proyecto_seq OWNED BY thd_estacion_proyecto.id_estacion_proyecto;


--
-- TOC entry 3924 (class 1259 OID 1427556)
-- Dependencies: 4781 4782 4783 45 3708
-- Name: thd_medicion; Type: TABLE; Schema: hidro; Owner: mflores; Tablespace: 
--

CREATE TABLE thd_medicion (
    id_medicion integer NOT NULL,
    id_sensor integer NOT NULL,
    id_operador integer,
    h integer,
    q integer,
    fecha_medida date,
    fecha_fin date,
    h_ini numeric(20,2),
    h_fin numeric(20,2),
    h_mini numeric(20,2),
    h_maxi numeric(20,2),
    h_original numeric(20,2),
    q_original numeric(20,2),
    hora_medida time without time zone,
    valor_numeric numeric(20,4),
    valor_varchar character varying(255),
    id_archivo integer
)
INHERITS (public.tbase);
ALTER TABLE ONLY thd_medicion ALTER COLUMN id_medicion SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN id_sensor SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN id_operador SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN h SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN q SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN fecha_medida SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN fecha_fin SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN h_ini SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN h_fin SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN h_mini SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN h_maxi SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN h_original SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN q_original SET STATISTICS 0;


ALTER TABLE hidro.thd_medicion OWNER TO mflores;

--
-- TOC entry 3923 (class 1259 OID 1427554)
-- Dependencies: 45 3924
-- Name: thd_medicion_id_medicion_seq; Type: SEQUENCE; Schema: hidro; Owner: mflores
--

CREATE SEQUENCE thd_medicion_id_medicion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_medicion_id_medicion_seq OWNER TO mflores;

--
-- TOC entry 6079 (class 0 OID 0)
-- Dependencies: 3923
-- Name: thd_medicion_id_medicion_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: mflores
--

ALTER SEQUENCE thd_medicion_id_medicion_seq OWNED BY thd_medicion.id_medicion;


--
-- TOC entry 3916 (class 1259 OID 1399244)
-- Dependencies: 4767 4768 4769 4770 45 3708
-- Name: thd_operador; Type: TABLE; Schema: hidro; Owner: mflores; Tablespace: 
--

CREATE TABLE thd_operador (
    id_operador integer DEFAULT nextval(('hidro.thd_operador_id_operador_seq'::text)::regclass) NOT NULL,
    id_persona integer NOT NULL,
    id_proyecto integer NOT NULL,
    fecha_presentacion date,
    codigo character varying(20)
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_operador OWNER TO mflores;

--
-- TOC entry 3919 (class 1259 OID 1400298)
-- Dependencies: 45
-- Name: thd_operador_id_operador_seq; Type: SEQUENCE; Schema: hidro; Owner: mflores
--

CREATE SEQUENCE thd_operador_id_operador_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE hidro.thd_operador_id_operador_seq OWNER TO mflores;

--
-- TOC entry 3911 (class 1259 OID 1379032)
-- Dependencies: 4755 4756 4757 3708 45
-- Name: thd_rio; Type: TABLE; Schema: hidro; Owner: rac; Tablespace: 
--

CREATE TABLE thd_rio (
    id_rio integer NOT NULL,
    codigo character varying(15) NOT NULL,
    nombre character varying(255) NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_rio OWNER TO rac;

--
-- TOC entry 3910 (class 1259 OID 1379030)
-- Dependencies: 45 3911
-- Name: thd_rio_id_rio_seq; Type: SEQUENCE; Schema: hidro; Owner: rac
--

CREATE SEQUENCE thd_rio_id_rio_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_rio_id_rio_seq OWNER TO rac;

--
-- TOC entry 6080 (class 0 OID 0)
-- Dependencies: 3910
-- Name: thd_rio_id_rio_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: rac
--

ALTER SEQUENCE thd_rio_id_rio_seq OWNED BY thd_rio.id_rio;


--
-- TOC entry 3922 (class 1259 OID 1419950)
-- Dependencies: 4776 4777 4778 4780 45 3708
-- Name: thd_sensor; Type: TABLE; Schema: hidro; Owner: mflores; Tablespace: 
--

CREATE TABLE thd_sensor (
    id_sensor integer NOT NULL,
    id_estacion integer NOT NULL,
    fecha_ini date,
    fecha_fin date,
    ficticio boolean,
    estado character varying(20),
    id_tipo_sensor integer NOT NULL,
    id_tipo_muestra integer,
    codigo character varying(20),
    id_sensor_fk integer,
    CONSTRAINT thd_sensor_estado_chk CHECK ((((estado)::text = 'borrador'::text) OR ((estado)::text = 'validado'::text)))
)
INHERITS (public.tbase);
ALTER TABLE ONLY thd_sensor ALTER COLUMN id_sensor SET STATISTICS 0;
ALTER TABLE ONLY thd_sensor ALTER COLUMN id_estacion SET STATISTICS 0;
ALTER TABLE ONLY thd_sensor ALTER COLUMN fecha_ini SET STATISTICS 0;
ALTER TABLE ONLY thd_sensor ALTER COLUMN fecha_fin SET STATISTICS 0;
ALTER TABLE ONLY thd_sensor ALTER COLUMN ficticio SET STATISTICS 0;
ALTER TABLE ONLY thd_sensor ALTER COLUMN estado SET STATISTICS 0;


ALTER TABLE hidro.thd_sensor OWNER TO mflores;

--
-- TOC entry 3921 (class 1259 OID 1419948)
-- Dependencies: 45 3922
-- Name: thd_sensores_id_sensor_seq; Type: SEQUENCE; Schema: hidro; Owner: mflores
--

CREATE SEQUENCE thd_sensores_id_sensor_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_sensores_id_sensor_seq OWNER TO mflores;

--
-- TOC entry 6081 (class 0 OID 0)
-- Dependencies: 3921
-- Name: thd_sensores_id_sensor_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: mflores
--

ALTER SEQUENCE thd_sensores_id_sensor_seq OWNED BY thd_sensor.id_sensor;


--
-- TOC entry 3985 (class 1259 OID 2048333)
-- Dependencies: 5127 5128 5129 3708 45
-- Name: thd_tipo_archivo; Type: TABLE; Schema: hidro; Owner: rac; Tablespace: 
--

CREATE TABLE thd_tipo_archivo (
    id_tipo_archivo integer NOT NULL,
    id_estacion integer NOT NULL,
    fecha_ini date,
    fecha_fin date,
    periodo character varying(40),
    patron_nombre_archivo character varying(500),
    num_file_ini integer,
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT NULL,
    fecha_mod timestamp without time zone DEFAULT NULL,
    estado_reg character varying(10) DEFAULT NULL
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_tipo_archivo OWNER TO rac;

--
-- TOC entry 3984 (class 1259 OID 2048331)
-- Dependencies: 45 3985
-- Name: thd_tipo_archivo_id_tipo_archivo_seq; Type: SEQUENCE; Schema: hidro; Owner: rac
--

CREATE SEQUENCE thd_tipo_archivo_id_tipo_archivo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_tipo_archivo_id_tipo_archivo_seq OWNER TO rac;

--
-- TOC entry 6082 (class 0 OID 0)
-- Dependencies: 3984
-- Name: thd_tipo_archivo_id_tipo_archivo_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: rac
--

ALTER SEQUENCE thd_tipo_archivo_id_tipo_archivo_seq OWNED BY thd_tipo_archivo.id_tipo_archivo;


--
-- TOC entry 4077 (class 1259 OID 3198733)
-- Dependencies: 5054 5055 5056 3708 45
-- Name: thd_tipo_columna; Type: TABLE; Schema: hidro; Owner: mflores; Tablespace: 
--

CREATE TABLE thd_tipo_columna (
    id_tipo_columna integer NOT NULL,
    codigo character varying(20) NOT NULL,
    tipo_dato character varying(50),
    tipo_columna character varying(50) NOT NULL,
    nombre_columna character varying(255)
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_tipo_columna OWNER TO mflores;

--
-- TOC entry 4078 (class 1259 OID 3198739)
-- Dependencies: 45 4077
-- Name: thd_tipo_columna_id_tipo_columna_seq; Type: SEQUENCE; Schema: hidro; Owner: mflores
--

CREATE SEQUENCE thd_tipo_columna_id_tipo_columna_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_tipo_columna_id_tipo_columna_seq OWNER TO mflores;

--
-- TOC entry 6083 (class 0 OID 0)
-- Dependencies: 4078
-- Name: thd_tipo_columna_id_tipo_columna_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: mflores
--

ALTER SEQUENCE thd_tipo_columna_id_tipo_columna_seq OWNED BY thd_tipo_columna.id_tipo_columna;


--
-- TOC entry 4079 (class 1259 OID 3207304)
-- Dependencies: 5058 5059 5060 5062 3708 45
-- Name: thd_tipo_columna_sensor; Type: TABLE; Schema: hidro; Owner: mflores; Tablespace: 
--

CREATE TABLE thd_tipo_columna_sensor (
    id_tipo_columna_sensor integer NOT NULL,
    id_tipo_sensor integer NOT NULL,
    orden numeric,
    prioridad numeric,
    unidad_medida character varying(30),
    codigo_columna character varying(25) NOT NULL,
    nombre_columna character varying(200) NOT NULL,
    tipo_dato character varying(30) DEFAULT 'varchar'::character varying NOT NULL,
    mapeo_archivo character varying(400)
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_tipo_columna_sensor OWNER TO mflores;

--
-- TOC entry 4080 (class 1259 OID 3207732)
-- Dependencies: 45 4079
-- Name: thd_tipo_columna_sensor_id_tipo_sensor_columna_seq; Type: SEQUENCE; Schema: hidro; Owner: mflores
--

CREATE SEQUENCE thd_tipo_columna_sensor_id_tipo_sensor_columna_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_tipo_columna_sensor_id_tipo_sensor_columna_seq OWNER TO mflores;

--
-- TOC entry 6084 (class 0 OID 0)
-- Dependencies: 4080
-- Name: thd_tipo_columna_sensor_id_tipo_sensor_columna_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: mflores
--

ALTER SEQUENCE thd_tipo_columna_sensor_id_tipo_sensor_columna_seq OWNED BY thd_tipo_columna_sensor.id_tipo_columna_sensor;


--
-- TOC entry 4108 (class 1259 OID 3322517)
-- Dependencies: 5091 5092 5093 45 3708
-- Name: thd_tipo_dato; Type: TABLE; Schema: hidro; Owner: mflores; Tablespace: 
--

CREATE TABLE thd_tipo_dato (
    id_tipo_dato integer NOT NULL,
    tipo_dato character varying(250) NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_tipo_dato OWNER TO mflores;

--
-- TOC entry 4109 (class 1259 OID 3322523)
-- Dependencies: 45 4108
-- Name: thd_tipo_dato_id_tipo_dato_seq; Type: SEQUENCE; Schema: hidro; Owner: mflores
--

CREATE SEQUENCE thd_tipo_dato_id_tipo_dato_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_tipo_dato_id_tipo_dato_seq OWNER TO mflores;

--
-- TOC entry 6085 (class 0 OID 0)
-- Dependencies: 4109
-- Name: thd_tipo_dato_id_tipo_dato_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: mflores
--

ALTER SEQUENCE thd_tipo_dato_id_tipo_dato_seq OWNED BY thd_tipo_dato.id_tipo_dato;


--
-- TOC entry 3918 (class 1259 OID 1400220)
-- Dependencies: 4771 4772 4773 4775 1985 45 3708
-- Name: thd_tipo_sensor; Type: TABLE; Schema: hidro; Owner: rac; Tablespace: 
--

CREATE TABLE thd_tipo_sensor (
    id_tipo_sensor integer NOT NULL,
    nombre_sensor character varying(255),
    descrip text,
    tipo_dato public.enum_tipo_dato,
    equivalente_hidra character varying(50),
    abreviacion character varying(20),
    codigo character varying(50) NOT NULL,
    estado_ts character varying(25) DEFAULT 'borrador'::character varying
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_tipo_sensor OWNER TO rac;

--
-- TOC entry 3917 (class 1259 OID 1400218)
-- Dependencies: 45 3918
-- Name: thd_tipo_medicion_id_tipo_medicion_seq; Type: SEQUENCE; Schema: hidro; Owner: rac
--

CREATE SEQUENCE thd_tipo_medicion_id_tipo_medicion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_tipo_medicion_id_tipo_medicion_seq OWNER TO rac;

--
-- TOC entry 6086 (class 0 OID 0)
-- Dependencies: 3917
-- Name: thd_tipo_medicion_id_tipo_medicion_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: rac
--

ALTER SEQUENCE thd_tipo_medicion_id_tipo_medicion_seq OWNED BY thd_tipo_sensor.id_tipo_sensor;


--
-- TOC entry 3992 (class 1259 OID 2050759)
-- Dependencies: 45
-- Name: thd_tipo_muestra; Type: TABLE; Schema: hidro; Owner: rac; Tablespace: 
--

CREATE TABLE thd_tipo_muestra (
    id_tipo_muestra integer NOT NULL,
    nombre character varying(100),
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10)
);


ALTER TABLE hidro.thd_tipo_muestra OWNER TO rac;

--
-- TOC entry 3991 (class 1259 OID 2050757)
-- Dependencies: 45 3992
-- Name: thd_tipo_muestra_id_tipo_muestra_seq; Type: SEQUENCE; Schema: hidro; Owner: rac
--

CREATE SEQUENCE thd_tipo_muestra_id_tipo_muestra_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_tipo_muestra_id_tipo_muestra_seq OWNER TO rac;

--
-- TOC entry 6087 (class 0 OID 0)
-- Dependencies: 3991
-- Name: thd_tipo_muestra_id_tipo_muestra_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: rac
--

ALTER SEQUENCE thd_tipo_muestra_id_tipo_muestra_seq OWNED BY thd_tipo_muestra.id_tipo_muestra;


--
-- TOC entry 4100 (class 1259 OID 3276663)
-- Dependencies: 5071 5072 5073 3708 45
-- Name: thd_tipo_sensor_22; Type: TABLE; Schema: hidro; Owner: dbendesis_cobra_rac; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_22 (
    id_tipo_sensor_22 integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    aaaaa numeric,
    bbbbbbb character varying,
    cccccccccc timestamp without time zone,
    dddd character varying,
    fffffffffff character varying
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_tipo_sensor_22 OWNER TO dbendesis_cobra_rac;

--
-- TOC entry 4099 (class 1259 OID 3276661)
-- Dependencies: 45 4100
-- Name: thd_tipo_sensor_22_id_tipo_sensor_22_seq; Type: SEQUENCE; Schema: hidro; Owner: dbendesis_cobra_rac
--

CREATE SEQUENCE thd_tipo_sensor_22_id_tipo_sensor_22_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_tipo_sensor_22_id_tipo_sensor_22_seq OWNER TO dbendesis_cobra_rac;

--
-- TOC entry 6089 (class 0 OID 0)
-- Dependencies: 4099
-- Name: thd_tipo_sensor_22_id_tipo_sensor_22_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER SEQUENCE thd_tipo_sensor_22_id_tipo_sensor_22_seq OWNED BY thd_tipo_sensor_22.id_tipo_sensor_22;


--
-- TOC entry 4096 (class 1259 OID 3270706)
-- Dependencies: 5063 5064 5065 3708 45
-- Name: thd_tipo_sensor_33; Type: TABLE; Schema: hidro; Owner: dbendesis_cobra_rac; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_33 (
    id_tipo_sensor_33 integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    lectura numeric,
    lectura_pro numeric,
    fecha_lec timestamp without time zone,
    aaaaaaa character varying
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_tipo_sensor_33 OWNER TO dbendesis_cobra_rac;

--
-- TOC entry 4095 (class 1259 OID 3270704)
-- Dependencies: 4096 45
-- Name: thd_tipo_sensor_33_id_tipo_sensor_33_seq; Type: SEQUENCE; Schema: hidro; Owner: dbendesis_cobra_rac
--

CREATE SEQUENCE thd_tipo_sensor_33_id_tipo_sensor_33_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_tipo_sensor_33_id_tipo_sensor_33_seq OWNER TO dbendesis_cobra_rac;

--
-- TOC entry 6091 (class 0 OID 0)
-- Dependencies: 4095
-- Name: thd_tipo_sensor_33_id_tipo_sensor_33_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER SEQUENCE thd_tipo_sensor_33_id_tipo_sensor_33_seq OWNED BY thd_tipo_sensor_33.id_tipo_sensor_33;


--
-- TOC entry 4098 (class 1259 OID 3271718)
-- Dependencies: 5067 5068 5069 3708 45
-- Name: thd_tipo_sensor_44; Type: TABLE; Schema: hidro; Owner: dbendesis_cobra_rac; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_44 (
    id_tipo_sensor_44 integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    lectura_c numeric,
    lectura_2 character varying,
    lectura_3 timestamp without time zone
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_tipo_sensor_44 OWNER TO dbendesis_cobra_rac;

--
-- TOC entry 4097 (class 1259 OID 3271716)
-- Dependencies: 45 4098
-- Name: thd_tipo_sensor_44_id_tipo_sensor_44_seq; Type: SEQUENCE; Schema: hidro; Owner: dbendesis_cobra_rac
--

CREATE SEQUENCE thd_tipo_sensor_44_id_tipo_sensor_44_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_tipo_sensor_44_id_tipo_sensor_44_seq OWNER TO dbendesis_cobra_rac;

--
-- TOC entry 6093 (class 0 OID 0)
-- Dependencies: 4097
-- Name: thd_tipo_sensor_44_id_tipo_sensor_44_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER SEQUENCE thd_tipo_sensor_44_id_tipo_sensor_44_seq OWNED BY thd_tipo_sensor_44.id_tipo_sensor_44;


--
-- TOC entry 4113 (class 1259 OID 3367541)
-- Dependencies: 5098 5099 5100 3708 45
-- Name: thd_tipo_sensor_anemometro; Type: TABLE; Schema: hidro; Owner: dbendesis_cobra_rac; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_anemometro (
    id_tipo_sensor_anemometro integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    hora time without time zone,
    wind_v_hr_max numeric,
    cur_temp numeric,
    precip_hr_acu numeric,
    total_hrs_rad numeric,
    rad_hr_avg numeric,
    min_hr_temp numeric,
    max_hr_temp numeric,
    ob_time timestamp without time zone,
    press_hr_avg numeric,
    wind_u_10_avg numeric,
    wind_u_10_max numeric,
    wind_u_hr_max numeric,
    wind_v_10_avg numeric,
    wind_v_10_max numeric,
    wind_v_hr_avg numeric
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_tipo_sensor_anemometro OWNER TO dbendesis_cobra_rac;

--
-- TOC entry 4112 (class 1259 OID 3367539)
-- Dependencies: 45 4113
-- Name: thd_tipo_sensor_anemometro_id_tipo_sensor_anemometro_seq; Type: SEQUENCE; Schema: hidro; Owner: dbendesis_cobra_rac
--

CREATE SEQUENCE thd_tipo_sensor_anemometro_id_tipo_sensor_anemometro_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_tipo_sensor_anemometro_id_tipo_sensor_anemometro_seq OWNER TO dbendesis_cobra_rac;

--
-- TOC entry 6095 (class 0 OID 0)
-- Dependencies: 4112
-- Name: thd_tipo_sensor_anemometro_id_tipo_sensor_anemometro_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER SEQUENCE thd_tipo_sensor_anemometro_id_tipo_sensor_anemometro_seq OWNED BY thd_tipo_sensor_anemometro.id_tipo_sensor_anemometro;


--
-- TOC entry 4104 (class 1259 OID 3285666)
-- Dependencies: 5079 5080 5081 45 3708
-- Name: thd_tipo_sensor_caudal; Type: TABLE; Schema: hidro; Owner: dbendesis_cobra_rac; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_caudal (
    id_tipo_sensor_caudal integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    fecha timestamp without time zone,
    lectura_instantania numeric,
    caudal numeric,
    tipo character varying
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_tipo_sensor_caudal OWNER TO dbendesis_cobra_rac;

--
-- TOC entry 4103 (class 1259 OID 3285664)
-- Dependencies: 45 4104
-- Name: thd_tipo_sensor_caudal_id_tipo_sensor_caudal_seq; Type: SEQUENCE; Schema: hidro; Owner: dbendesis_cobra_rac
--

CREATE SEQUENCE thd_tipo_sensor_caudal_id_tipo_sensor_caudal_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_tipo_sensor_caudal_id_tipo_sensor_caudal_seq OWNER TO dbendesis_cobra_rac;

--
-- TOC entry 6097 (class 0 OID 0)
-- Dependencies: 4103
-- Name: thd_tipo_sensor_caudal_id_tipo_sensor_caudal_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER SEQUENCE thd_tipo_sensor_caudal_id_tipo_sensor_caudal_seq OWNED BY thd_tipo_sensor_caudal.id_tipo_sensor_caudal;


--
-- TOC entry 4102 (class 1259 OID 3282955)
-- Dependencies: 5075 5076 5077 45 3708
-- Name: thd_tipo_sensor_limnimetrica; Type: TABLE; Schema: hidro; Owner: dbendesis_cobra_rac; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_limnimetrica (
    id_tipo_sensor_limnimetrica integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    lectura numeric,
    fecha timestamp without time zone
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_tipo_sensor_limnimetrica OWNER TO dbendesis_cobra_rac;

--
-- TOC entry 4101 (class 1259 OID 3282953)
-- Dependencies: 45 4102
-- Name: thd_tipo_sensor_limnimetrica_id_tipo_sensor_limnimetrica_seq; Type: SEQUENCE; Schema: hidro; Owner: dbendesis_cobra_rac
--

CREATE SEQUENCE thd_tipo_sensor_limnimetrica_id_tipo_sensor_limnimetrica_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_tipo_sensor_limnimetrica_id_tipo_sensor_limnimetrica_seq OWNER TO dbendesis_cobra_rac;

--
-- TOC entry 6099 (class 0 OID 0)
-- Dependencies: 4101
-- Name: thd_tipo_sensor_limnimetrica_id_tipo_sensor_limnimetrica_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER SEQUENCE thd_tipo_sensor_limnimetrica_id_tipo_sensor_limnimetrica_seq OWNED BY thd_tipo_sensor_limnimetrica.id_tipo_sensor_limnimetrica;


--
-- TOC entry 4106 (class 1259 OID 3318863)
-- Dependencies: 5083 5084 5085 45 3708
-- Name: thd_tipo_sensor_presion; Type: TABLE; Schema: hidro; Owner: dbendesis_cobra_mflores; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_presion (
    id_tipo_sensor_presion integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    fecha_medida numeric,
    hora_medida timestamp without time zone,
    valor_medida numeric,
    operador character varying
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_tipo_sensor_presion OWNER TO dbendesis_cobra_mflores;

--
-- TOC entry 4105 (class 1259 OID 3318861)
-- Dependencies: 4106 45
-- Name: thd_tipo_sensor_presion_id_tipo_sensor_presion_seq; Type: SEQUENCE; Schema: hidro; Owner: dbendesis_cobra_mflores
--

CREATE SEQUENCE thd_tipo_sensor_presion_id_tipo_sensor_presion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_tipo_sensor_presion_id_tipo_sensor_presion_seq OWNER TO dbendesis_cobra_mflores;

--
-- TOC entry 6101 (class 0 OID 0)
-- Dependencies: 4105
-- Name: thd_tipo_sensor_presion_id_tipo_sensor_presion_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: dbendesis_cobra_mflores
--

ALTER SEQUENCE thd_tipo_sensor_presion_id_tipo_sensor_presion_seq OWNED BY thd_tipo_sensor_presion.id_tipo_sensor_presion;


--
-- TOC entry 4116 (class 1259 OID 3461591)
-- Dependencies: 5106 5107 5108 45 3708
-- Name: thd_tipo_sensor_pru; Type: TABLE; Schema: hidro; Owner: dbendesis_cobra_mflores; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_pru (
    id_tipo_sensor_pru integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    fecha2 timestamp without time zone,
    lectura numeric,
    fecha1 timestamp without time zone
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_tipo_sensor_pru OWNER TO dbendesis_cobra_mflores;

--
-- TOC entry 4115 (class 1259 OID 3461589)
-- Dependencies: 45 4116
-- Name: thd_tipo_sensor_pru_id_tipo_sensor_pru_seq; Type: SEQUENCE; Schema: hidro; Owner: dbendesis_cobra_mflores
--

CREATE SEQUENCE thd_tipo_sensor_pru_id_tipo_sensor_pru_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_tipo_sensor_pru_id_tipo_sensor_pru_seq OWNER TO dbendesis_cobra_mflores;

--
-- TOC entry 6103 (class 0 OID 0)
-- Dependencies: 4115
-- Name: thd_tipo_sensor_pru_id_tipo_sensor_pru_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: dbendesis_cobra_mflores
--

ALTER SEQUENCE thd_tipo_sensor_pru_id_tipo_sensor_pru_seq OWNED BY thd_tipo_sensor_pru.id_tipo_sensor_pru;


--
-- TOC entry 4120 (class 1259 OID 3470609)
-- Dependencies: 5114 5115 5116 3708 45
-- Name: thd_tipo_sensor_prue; Type: TABLE; Schema: hidro; Owner: dbendesis_cobra_mflores; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_prue (
    id_tipo_sensor_prue integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    fecha timestamp without time zone,
    lectura numeric
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_tipo_sensor_prue OWNER TO dbendesis_cobra_mflores;

--
-- TOC entry 4119 (class 1259 OID 3470607)
-- Dependencies: 45 4120
-- Name: thd_tipo_sensor_prue_id_tipo_sensor_prue_seq; Type: SEQUENCE; Schema: hidro; Owner: dbendesis_cobra_mflores
--

CREATE SEQUENCE thd_tipo_sensor_prue_id_tipo_sensor_prue_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_tipo_sensor_prue_id_tipo_sensor_prue_seq OWNER TO dbendesis_cobra_mflores;

--
-- TOC entry 6105 (class 0 OID 0)
-- Dependencies: 4119
-- Name: thd_tipo_sensor_prue_id_tipo_sensor_prue_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: dbendesis_cobra_mflores
--

ALTER SEQUENCE thd_tipo_sensor_prue_id_tipo_sensor_prue_seq OWNED BY thd_tipo_sensor_prue.id_tipo_sensor_prue;


--
-- TOC entry 4118 (class 1259 OID 3464004)
-- Dependencies: 5110 5111 5112 3708 45
-- Name: thd_tipo_sensor_termo; Type: TABLE; Schema: hidro; Owner: dbendesis_cobra_mflores; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_termo (
    id_tipo_sensor_termo integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    fecha1 timestamp without time zone,
    fecha2 timestamp without time zone,
    fecha3 timestamp without time zone,
    lecturas numeric
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_tipo_sensor_termo OWNER TO dbendesis_cobra_mflores;

--
-- TOC entry 4117 (class 1259 OID 3464002)
-- Dependencies: 45 4118
-- Name: thd_tipo_sensor_termo_id_tipo_sensor_termo_seq; Type: SEQUENCE; Schema: hidro; Owner: dbendesis_cobra_mflores
--

CREATE SEQUENCE thd_tipo_sensor_termo_id_tipo_sensor_termo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hidro.thd_tipo_sensor_termo_id_tipo_sensor_termo_seq OWNER TO dbendesis_cobra_mflores;

--
-- TOC entry 6107 (class 0 OID 0)
-- Dependencies: 4117
-- Name: thd_tipo_sensor_termo_id_tipo_sensor_termo_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: dbendesis_cobra_mflores
--

ALTER SEQUENCE thd_tipo_sensor_termo_id_tipo_sensor_termo_seq OWNED BY thd_tipo_sensor_termo.id_tipo_sensor_termo;


--
-- TOC entry 4110 (class 1259 OID 3322536)
-- Dependencies: 5095 5096 5097 3708 45
-- Name: thd_unidad_medida; Type: TABLE; Schema: hidro; Owner: mflores; Tablespace: 
--

CREATE TABLE thd_unidad_medida (
    unidad_medida character varying(250) NOT NULL,
    simbolo character varying(20) NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE hidro.thd_unidad_medida OWNER TO mflores;

--
-- TOC entry 4021 (class 1259 OID 2827458)
-- Dependencies: 45
-- Name: tmp_aaaa; Type: TABLE; Schema: hidro; Owner: rac; Tablespace: 
--

CREATE TABLE tmp_aaaa (
    fecha_medida date,
    valor_numeric numeric(20,4)
);


ALTER TABLE hidro.tmp_aaaa OWNER TO rac;

SET search_path = segu, pg_catalog;

--
-- TOC entry 3716 (class 1259 OID 16783)
-- Dependencies: 4468 4469 4470 1610 14
-- Name: tlog; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tlog (
    id_log integer DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass) NOT NULL,
    id_usuario integer,
    id_subsistema integer,
    mac_maquina character varying(30),
    ip_maquina character varying(30),
    tipo_log character varying(30) NOT NULL,
    descripcion text,
    fecha_reg timestamp(0) without time zone DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL,
    procedimientos text NOT NULL,
    transaccion character varying(20),
    consulta character varying,
    tiempo_ejecucion integer,
    usuario_base character varying(100),
    codigo_error character varying,
    dia_semana integer NOT NULL,
    pid_db integer,
    pid_web integer,
    sid_web character varying(100),
    cuenta_usuario character varying,
    descripcion_transaccion text,
    codigo_subsistema character varying(30),
    si_log integer
);


ALTER TABLE segu.tlog OWNER TO postgres;

SET search_path = log, pg_catalog;

--
-- TOC entry 3717 (class 1259 OID 16792)
-- Dependencies: 4471 4472 4473 4474 1610 10 3716
-- Name: tlog_2011_02; Type: TABLE; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_2011_02 (
    CONSTRAINT tlog_2011_02_fecha_reg_check CHECK (((fecha_reg >= '2011-02-01'::date) AND (fecha_reg < '2011-03-01'::date)))
)
INHERITS (segu.tlog);


ALTER TABLE log.tlog_2011_02 OWNER TO rchumacero;

--
-- TOC entry 3718 (class 1259 OID 16802)
-- Dependencies: 4475 4476 4477 4478 1610 10 3716
-- Name: tlog_2011_04; Type: TABLE; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_2011_04 (
    CONSTRAINT tlog_2011_04_fecha_reg_check CHECK (((fecha_reg >= '2011-04-01'::date) AND (fecha_reg < '2011-05-01'::date)))
)
INHERITS (segu.tlog);


ALTER TABLE log.tlog_2011_04 OWNER TO rchumacero;

--
-- TOC entry 3719 (class 1259 OID 16812)
-- Dependencies: 4479 4480 4481 4482 1610 10 3716
-- Name: tlog_2011_05; Type: TABLE; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_2011_05 (
    CONSTRAINT tlog_2011_05_fecha_reg_check CHECK (((fecha_reg >= '2011-05-01'::date) AND (fecha_reg < '2011-06-01'::date)))
)
INHERITS (segu.tlog);


ALTER TABLE log.tlog_2011_05 OWNER TO rchumacero;

--
-- TOC entry 3867 (class 1259 OID 43514)
-- Dependencies: 4656 4657 4658 4659 1610 10 3716
-- Name: tlog_2011_06; Type: TABLE; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_2011_06 (
    CONSTRAINT tlog_2011_06_fecha_reg_check CHECK (((fecha_reg >= '2011-06-01'::date) AND (fecha_reg < '2011-07-01'::date)))
)
INHERITS (segu.tlog);


ALTER TABLE log.tlog_2011_06 OWNER TO rchumacero;

--
-- TOC entry 3904 (class 1259 OID 1352252)
-- Dependencies: 4732 4733 4734 4735 1610 10 3716
-- Name: tlog_2011_07; Type: TABLE; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_2011_07 (
    CONSTRAINT tlog_2011_07_fecha_reg_check CHECK (((fecha_reg >= '2011-07-01'::date) AND (fecha_reg < '2011-08-01'::date)))
)
INHERITS (segu.tlog);


ALTER TABLE log.tlog_2011_07 OWNER TO rchumacero;

--
-- TOC entry 3905 (class 1259 OID 1361186)
-- Dependencies: 4736 4737 4738 4739 1610 10 3716
-- Name: tlog_2011_08; Type: TABLE; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_2011_08 (
    CONSTRAINT tlog_2011_08_fecha_reg_check CHECK (((fecha_reg >= '2011-08-01'::date) AND (fecha_reg < '2011-09-01'::date)))
)
INHERITS (segu.tlog);


ALTER TABLE log.tlog_2011_08 OWNER TO rchumacero;

--
-- TOC entry 3915 (class 1259 OID 1384714)
-- Dependencies: 4763 4764 4765 4766 1610 10 3716
-- Name: tlog_2011_09; Type: TABLE; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_2011_09 (
    CONSTRAINT tlog_2011_09_fecha_reg_check CHECK (((fecha_reg >= '2011-09-01'::date) AND (fecha_reg < '2011-10-01'::date)))
)
INHERITS (segu.tlog);


ALTER TABLE log.tlog_2011_09 OWNER TO rchumacero;

--
-- TOC entry 3933 (class 1259 OID 1578813)
-- Dependencies: 4799 4800 4801 4802 1610 10 3716
-- Name: tlog_2011_10; Type: TABLE; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_2011_10 (
    CONSTRAINT tlog_2011_10_fecha_reg_check CHECK (((fecha_reg >= '2011-10-01'::date) AND (fecha_reg < '2011-11-01'::date)))
)
INHERITS (segu.tlog);


ALTER TABLE log.tlog_2011_10 OWNER TO rchumacero;

--
-- TOC entry 3951 (class 1259 OID 1914224)
-- Dependencies: 4823 4824 4825 4826 1610 10 3716
-- Name: tlog_2011_11; Type: TABLE; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_2011_11 (
    CONSTRAINT tlog_2011_11_fecha_reg_check CHECK (((fecha_reg >= '2011-11-01'::date) AND (fecha_reg < '2011-12-01'::date)))
)
INHERITS (segu.tlog);


ALTER TABLE log.tlog_2011_11 OWNER TO rchumacero;

--
-- TOC entry 4014 (class 1259 OID 2181239)
-- Dependencies: 4927 4928 4929 4930 1610 10 3716
-- Name: tlog_2011_12; Type: TABLE; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_2011_12 (
    CONSTRAINT tlog_2011_12_fecha_reg_check CHECK (((fecha_reg >= '2011-12-01'::date) AND (fecha_reg < '2012-01-01'::date)))
)
INHERITS (segu.tlog);


ALTER TABLE log.tlog_2011_12 OWNER TO rchumacero;

--
-- TOC entry 4017 (class 1259 OID 2395690)
-- Dependencies: 4935 4936 4937 4938 1610 10 3716
-- Name: tlog_2012_01; Type: TABLE; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_2012_01 (
    CONSTRAINT tlog_2012_01_fecha_reg_check CHECK (((fecha_reg >= '2012-01-01'::date) AND (fecha_reg < '2012-02-01'::date)))
)
INHERITS (segu.tlog);


ALTER TABLE log.tlog_2012_01 OWNER TO rchumacero;

--
-- TOC entry 4019 (class 1259 OID 2549426)
-- Dependencies: 4939 4940 4941 4942 3716 10 1610
-- Name: tlog_2012_02; Type: TABLE; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_2012_02 (
    CONSTRAINT tlog_2012_02_fecha_reg_check CHECK (((fecha_reg >= '2012-02-01'::date) AND (fecha_reg < '2012-03-01'::date)))
)
INHERITS (segu.tlog);


ALTER TABLE log.tlog_2012_02 OWNER TO rchumacero;

--
-- TOC entry 4022 (class 1259 OID 2928805)
-- Dependencies: 4943 4944 4945 4946 10 1610 3716
-- Name: tlog_2012_03; Type: TABLE; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_2012_03 (
    CONSTRAINT tlog_2012_03_fecha_reg_check CHECK (((fecha_reg >= '2012-03-01'::date) AND (fecha_reg < '2012-04-01'::date)))
)
INHERITS (segu.tlog);


ALTER TABLE log.tlog_2012_03 OWNER TO rchumacero;

--
-- TOC entry 4107 (class 1259 OID 3320357)
-- Dependencies: 5087 5088 5089 5090 10 1610 3716
-- Name: tlog_2012_04; Type: TABLE; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_2012_04 (
    CONSTRAINT tlog_2012_04_fecha_reg_check CHECK (((fecha_reg >= '2012-04-01'::date) AND (fecha_reg < '2012-05-01'::date)))
)
INHERITS (segu.tlog);


ALTER TABLE log.tlog_2012_04 OWNER TO rchumacero;

--
-- TOC entry 4114 (class 1259 OID 3440753)
-- Dependencies: 5102 5103 5104 5105 3716 1610 10
-- Name: tlog_2012_05; Type: TABLE; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_2012_05 (
    CONSTRAINT tlog_2012_05_fecha_reg_check CHECK (((fecha_reg >= '2012-05-01'::date) AND (fecha_reg < '2012-06-01'::date)))
)
INHERITS (segu.tlog);


ALTER TABLE log.tlog_2012_05 OWNER TO rchumacero;

--
-- TOC entry 4121 (class 1259 OID 3502028)
-- Dependencies: 5118 5119 5120 5121 1610 10 3716
-- Name: tlog_2012_06; Type: TABLE; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_2012_06 (
    CONSTRAINT tlog_2012_06_fecha_reg_check CHECK (((fecha_reg >= '2012-06-01'::date) AND (fecha_reg < '2012-07-01'::date)))
)
INHERITS (segu.tlog);


ALTER TABLE log.tlog_2012_06 OWNER TO rchumacero;

SET search_path = param, pg_catalog;

--
-- TOC entry 3975 (class 1259 OID 1987197)
-- Dependencies: 4861 4862 4863 3708 11
-- Name: table1; Type: TABLE; Schema: param; Owner: rvasquez; Tablespace: 
--

CREATE TABLE table1 (
    oid_depto integer,
    id_depto_usuario integer NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE param.table1 OWNER TO rvasquez;

--
-- TOC entry 3974 (class 1259 OID 1987195)
-- Dependencies: 3975 11
-- Name: table1_id_depto_usuario_seq; Type: SEQUENCE; Schema: param; Owner: rvasquez
--

CREATE SEQUENCE table1_id_depto_usuario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.table1_id_depto_usuario_seq OWNER TO rvasquez;

--
-- TOC entry 6121 (class 0 OID 0)
-- Dependencies: 3974
-- Name: table1_id_depto_usuario_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: rvasquez
--

ALTER SEQUENCE table1_id_depto_usuario_seq OWNED BY table1.id_depto_usuario;


SET default_with_oids = true;

--
-- TOC entry 3969 (class 1259 OID 1951824)
-- Dependencies: 4856 4857 11
-- Name: talarma; Type: TABLE; Schema: param; Owner: mzambrana; Tablespace: 
--

CREATE TABLE talarma (
    id_alarma integer NOT NULL,
    descripcion character varying,
    acceso_directo character varying,
    fecha date,
    id_funcionario integer,
    estado_reg character varying(10),
    fecha_reg date,
    id_usuario_reg integer,
    fecha_mod date,
    id_usuario_mod integer,
    tipo character varying(50),
    obs character varying(300),
    clase character varying(150),
    parametros character varying DEFAULT '{}'::character varying NOT NULL,
    titulo character varying(200),
    sw_correo integer DEFAULT 0 NOT NULL
);


ALTER TABLE param.talarma OWNER TO mzambrana;

--
-- TOC entry 3968 (class 1259 OID 1951822)
-- Dependencies: 11 3969
-- Name: talarma_id_alarma_seq; Type: SEQUENCE; Schema: param; Owner: mzambrana
--

CREATE SEQUENCE talarma_id_alarma_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.talarma_id_alarma_seq OWNER TO mzambrana;

--
-- TOC entry 6122 (class 0 OID 0)
-- Dependencies: 3968
-- Name: talarma_id_alarma_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: mzambrana
--

ALTER SEQUENCE talarma_id_alarma_seq OWNED BY talarma.id_alarma;


--
-- TOC entry 4005 (class 1259 OID 2115168)
-- Dependencies: 4910 4911 4912 3708 11
-- Name: tconfig_alarma; Type: TABLE; Schema: param; Owner: fprudencio; Tablespace: 
--

CREATE TABLE tconfig_alarma (
    id_config_alarma integer NOT NULL,
    codigo character varying(50) NOT NULL,
    descripcion character varying(300),
    dias integer NOT NULL,
    id_subsistema integer NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE param.tconfig_alarma OWNER TO fprudencio;

--
-- TOC entry 4004 (class 1259 OID 2115166)
-- Dependencies: 11 4005
-- Name: tconfig_alarma_id_config_alarma_seq; Type: SEQUENCE; Schema: param; Owner: fprudencio
--

CREATE SEQUENCE tconfig_alarma_id_config_alarma_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.tconfig_alarma_id_config_alarma_seq OWNER TO fprudencio;

--
-- TOC entry 6123 (class 0 OID 0)
-- Dependencies: 4004
-- Name: tconfig_alarma_id_config_alarma_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: fprudencio
--

ALTER SEQUENCE tconfig_alarma_id_config_alarma_seq OWNED BY tconfig_alarma.id_config_alarma;


--
-- TOC entry 4016 (class 1259 OID 2188416)
-- Dependencies: 4931 4932 4933 11 3708
-- Name: tcorrelativo; Type: TABLE; Schema: param; Owner: rac; Tablespace: 
--

CREATE TABLE tcorrelativo (
    id_correlativo integer NOT NULL,
    num_actual integer NOT NULL,
    num_siguiente integer NOT NULL,
    id_periodo integer,
    id_gestion integer,
    id_documento integer,
    id_uo integer,
    id_depto integer
)
INHERITS (public.tbase);


ALTER TABLE param.tcorrelativo OWNER TO rac;

--
-- TOC entry 4015 (class 1259 OID 2188414)
-- Dependencies: 11 4016
-- Name: tcorrelativo_id_correlativo_seq; Type: SEQUENCE; Schema: param; Owner: rac
--

CREATE SEQUENCE tcorrelativo_id_correlativo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.tcorrelativo_id_correlativo_seq OWNER TO rac;

--
-- TOC entry 6124 (class 0 OID 0)
-- Dependencies: 4015
-- Name: tcorrelativo_id_correlativo_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: rac
--

ALTER SEQUENCE tcorrelativo_id_correlativo_seq OWNED BY tcorrelativo.id_correlativo;


SET default_with_oids = false;

--
-- TOC entry 3995 (class 1259 OID 2091654)
-- Dependencies: 4889 4890 4891 11 3708
-- Name: tdepto; Type: TABLE; Schema: param; Owner: postgres; Tablespace: 
--

CREATE TABLE tdepto (
    estado_reg character varying(10) NOT NULL,
    id_depto integer NOT NULL,
    nombre character varying(200),
    nombre_corto character varying(100),
    id_subsistema integer,
    codigo character varying(15)
)
INHERITS (public.tbase);


ALTER TABLE param.tdepto OWNER TO postgres;

--
-- TOC entry 3994 (class 1259 OID 2091652)
-- Dependencies: 11 3995
-- Name: tdepto_id_depto_seq; Type: SEQUENCE; Schema: param; Owner: postgres
--

CREATE SEQUENCE tdepto_id_depto_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.tdepto_id_depto_seq OWNER TO postgres;

--
-- TOC entry 6125 (class 0 OID 0)
-- Dependencies: 3994
-- Name: tdepto_id_depto_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: postgres
--

ALTER SEQUENCE tdepto_id_depto_seq OWNED BY tdepto.id_depto;


SET default_with_oids = true;

--
-- TOC entry 4003 (class 1259 OID 2109337)
-- Dependencies: 4906 4907 4908 11 3708
-- Name: tdepto_usuario; Type: TABLE; Schema: param; Owner: mzambrana; Tablespace: 
--

CREATE TABLE tdepto_usuario (
    id_depto_usuario integer NOT NULL,
    id_depto integer,
    id_usuario integer,
    cargo character varying(300)
)
INHERITS (public.tbase);


ALTER TABLE param.tdepto_usuario OWNER TO mzambrana;

--
-- TOC entry 4002 (class 1259 OID 2109335)
-- Dependencies: 11 4003
-- Name: tdepto_usuairo_id_depto_usuario_seq; Type: SEQUENCE; Schema: param; Owner: mzambrana
--

CREATE SEQUENCE tdepto_usuairo_id_depto_usuario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.tdepto_usuairo_id_depto_usuario_seq OWNER TO mzambrana;

--
-- TOC entry 6126 (class 0 OID 0)
-- Dependencies: 4002
-- Name: tdepto_usuairo_id_depto_usuario_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: mzambrana
--

ALTER SEQUENCE tdepto_usuairo_id_depto_usuario_seq OWNED BY tdepto_usuario.id_depto_usuario;


--
-- TOC entry 4011 (class 1259 OID 2132175)
-- Dependencies: 4922 4923 4924 4926 11 3708
-- Name: tdocumento; Type: TABLE; Schema: param; Owner: mzambrana; Tablespace: 
--

CREATE TABLE tdocumento (
    id_documento integer NOT NULL,
    id_subsistema integer,
    codigo character varying(10),
    descripcion character varying(200),
    periodo_gestion character varying(10) DEFAULT 'periodo'::character varying NOT NULL,
    tipo character varying(20),
    tipo_numeracion character varying(10) NOT NULL,
    formato character varying(300)
)
INHERITS (public.tbase);


ALTER TABLE param.tdocumento OWNER TO mzambrana;

--
-- TOC entry 4010 (class 1259 OID 2132173)
-- Dependencies: 11 4011
-- Name: tdocumento_id_documento_seq; Type: SEQUENCE; Schema: param; Owner: mzambrana
--

CREATE SEQUENCE tdocumento_id_documento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.tdocumento_id_documento_seq OWNER TO mzambrana;

--
-- TOC entry 6127 (class 0 OID 0)
-- Dependencies: 4010
-- Name: tdocumento_id_documento_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: mzambrana
--

ALTER SEQUENCE tdocumento_id_documento_seq OWNED BY tdocumento.id_documento;


SET default_with_oids = false;

--
-- TOC entry 3720 (class 1259 OID 16822)
-- Dependencies: 4484 4485 4486 11
-- Name: tgestion; Type: TABLE; Schema: param; Owner: postgres; Tablespace: 
--

CREATE TABLE tgestion (
    id_gestion integer NOT NULL,
    gestion integer,
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    fecha_reg timestamp(0) without time zone DEFAULT now(),
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_mod timestamp(0) without time zone DEFAULT now(),
    estado character varying(15)
);


ALTER TABLE param.tgestion OWNER TO postgres;

--
-- TOC entry 3721 (class 1259 OID 16827)
-- Dependencies: 11 3720
-- Name: tgestion_id_gestion_seq; Type: SEQUENCE; Schema: param; Owner: postgres
--

CREATE SEQUENCE tgestion_id_gestion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.tgestion_id_gestion_seq OWNER TO postgres;

--
-- TOC entry 6128 (class 0 OID 0)
-- Dependencies: 3721
-- Name: tgestion_id_gestion_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: postgres
--

ALTER SEQUENCE tgestion_id_gestion_seq OWNED BY tgestion.id_gestion;


--
-- TOC entry 3929 (class 1259 OID 1512519)
-- Dependencies: 4789 4790 4791 4793 4794 11 3708
-- Name: tinstitucion; Type: TABLE; Schema: param; Owner: gvelasquez; Tablespace: 
--

CREATE TABLE tinstitucion (
    id_institucion integer NOT NULL,
    doc_id character varying(50),
    nombre character varying(100) NOT NULL,
    casilla character varying(50),
    telefono1 character varying(50),
    telefono2 character varying(50),
    celular1 character varying(50),
    celular2 character varying(50),
    fax character varying(50),
    email1 character varying(100),
    email2 character varying(100),
    pag_web character varying(100),
    observaciones text,
    id_persona integer,
    direccion character varying(200),
    codigo_banco character varying(10),
    es_banco character varying(2) DEFAULT 'NO'::character varying NOT NULL,
    codigo character varying(25) NOT NULL,
    cargo_representante character varying DEFAULT 'Representante Legal'::character varying
)
INHERITS (public.tbase);


ALTER TABLE param.tinstitucion OWNER TO gvelasquez;

--
-- TOC entry 3928 (class 1259 OID 1512517)
-- Dependencies: 11 3929
-- Name: tinstitucion_id_institucion_seq; Type: SEQUENCE; Schema: param; Owner: gvelasquez
--

CREATE SEQUENCE tinstitucion_id_institucion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.tinstitucion_id_institucion_seq OWNER TO gvelasquez;

--
-- TOC entry 6129 (class 0 OID 0)
-- Dependencies: 3928
-- Name: tinstitucion_id_institucion_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: gvelasquez
--

ALTER SEQUENCE tinstitucion_id_institucion_seq OWNED BY tinstitucion.id_institucion;


--
-- TOC entry 3907 (class 1259 OID 1364938)
-- Dependencies: 4744 4745 4746 4747 4748 4749 4750 11 3708
-- Name: tlugar; Type: TABLE; Schema: param; Owner: postgres; Tablespace: 
--

CREATE TABLE tlugar (
    estado_reg character varying(10) NOT NULL,
    id_lugar integer DEFAULT nextval(('param.tlugar_id_lugar_seq'::text)::regclass) NOT NULL,
    id_lugar_fk integer,
    codigo character varying(25),
    nombre character varying(100),
    tipo character varying(25) DEFAULT 'pais'::character varying NOT NULL,
    sw_municipio character varying(2) DEFAULT 'no'::character varying NOT NULL,
    sw_impuesto character varying(2) DEFAULT 'si'::character varying NOT NULL,
    codigo_largo character varying(100)
)
INHERITS (public.tbase);


ALTER TABLE param.tlugar OWNER TO postgres;

--
-- TOC entry 6130 (class 0 OID 0)
-- Dependencies: 3907
-- Name: COLUMN tlugar.tipo; Type: COMMENT; Schema: param; Owner: postgres
--

COMMENT ON COLUMN tlugar.tipo IS 'El tipo puede ser : pais, departamento, provincia, localidad, zona';


--
-- TOC entry 3909 (class 1259 OID 1371153)
-- Dependencies: 11
-- Name: tlugar_id_lugar_seq; Type: SEQUENCE; Schema: param; Owner: rac
--

CREATE SEQUENCE tlugar_id_lugar_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE param.tlugar_id_lugar_seq OWNER TO rac;

--
-- TOC entry 3722 (class 1259 OID 16829)
-- Dependencies: 4487 4488 4489 11 3708
-- Name: tmoneda; Type: TABLE; Schema: param; Owner: postgres; Tablespace: 
--

CREATE TABLE tmoneda (
    estado_reg character varying(10) NOT NULL,
    moneda character varying(30),
    codigo character varying(5),
    id_moneda integer NOT NULL,
    tipo_moneda character varying(25)
)
INHERITS (public.tbase);


ALTER TABLE param.tmoneda OWNER TO postgres;

--
-- TOC entry 3723 (class 1259 OID 16835)
-- Dependencies: 11 3722
-- Name: tmoneda_id_moneda_seq; Type: SEQUENCE; Schema: param; Owner: postgres
--

CREATE SEQUENCE tmoneda_id_moneda_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.tmoneda_id_moneda_seq OWNER TO postgres;

--
-- TOC entry 6131 (class 0 OID 0)
-- Dependencies: 3723
-- Name: tmoneda_id_moneda_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: postgres
--

ALTER SEQUENCE tmoneda_id_moneda_seq OWNED BY tmoneda.id_moneda;


--
-- TOC entry 3724 (class 1259 OID 16837)
-- Dependencies: 4492 4493 4494 11
-- Name: tperiodo; Type: TABLE; Schema: param; Owner: postgres; Tablespace: 
--

CREATE TABLE tperiodo (
    id_periodo integer NOT NULL,
    periodo integer,
    id_gestion integer,
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    fecha_reg timestamp(0) without time zone DEFAULT now(),
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_mod timestamp(0) without time zone DEFAULT now(),
    fecha_ini date,
    fecha_fin date
);


ALTER TABLE param.tperiodo OWNER TO postgres;

--
-- TOC entry 3725 (class 1259 OID 16845)
-- Dependencies: 3724 11
-- Name: tperiodo_id_periodo_seq; Type: SEQUENCE; Schema: param; Owner: postgres
--

CREATE SEQUENCE tperiodo_id_periodo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.tperiodo_id_periodo_seq OWNER TO postgres;

--
-- TOC entry 6132 (class 0 OID 0)
-- Dependencies: 3725
-- Name: tperiodo_id_periodo_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: postgres
--

ALTER SEQUENCE tperiodo_id_periodo_seq OWNED BY tperiodo.id_periodo;


--
-- TOC entry 3938 (class 1259 OID 1687695)
-- Dependencies: 4808 4809 4810 4811 11
-- Name: tpm_financiador; Type: TABLE; Schema: param; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tpm_financiador (
    id_financiador integer NOT NULL,
    codigo_financiador character varying(10) NOT NULL,
    nombre_financiador character varying(100),
    descripcion_financiador text,
    fecha_registro date DEFAULT now() NOT NULL,
    hora_registro time without time zone DEFAULT now() NOT NULL,
    fecha_ultima_modificacion date DEFAULT now(),
    hora_ultima_modificacion time without time zone DEFAULT now(),
    id_usuario integer,
    id_financiador_actif integer
);


ALTER TABLE param.tpm_financiador OWNER TO rchumacero;

--
-- TOC entry 6133 (class 0 OID 0)
-- Dependencies: 3938
-- Name: TABLE tpm_financiador; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON TABLE tpm_financiador IS 'sistema=parametros&codigo=FINANC&prefijo=PM&titulo=Financiadores&num_dt=2&dt_1=descripcion_financiador&dt_2=codigo_financiador&desc=Almacena los Financiadores';


--
-- TOC entry 6134 (class 0 OID 0)
-- Dependencies: 3938
-- Name: COLUMN tpm_financiador.id_financiador; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_financiador.id_financiador IS 'label=Id Financiador&disable=no';


--
-- TOC entry 6135 (class 0 OID 0)
-- Dependencies: 3938
-- Name: COLUMN tpm_financiador.codigo_financiador; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_financiador.codigo_financiador IS 'label=Codigo de Financiador&disable=no';


--
-- TOC entry 6136 (class 0 OID 0)
-- Dependencies: 3938
-- Name: COLUMN tpm_financiador.nombre_financiador; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_financiador.nombre_financiador IS 'label=Financiador&disable=no';


--
-- TOC entry 6137 (class 0 OID 0)
-- Dependencies: 3938
-- Name: COLUMN tpm_financiador.descripcion_financiador; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_financiador.descripcion_financiador IS 'label=Descripcion&disable=no';


--
-- TOC entry 6138 (class 0 OID 0)
-- Dependencies: 3938
-- Name: COLUMN tpm_financiador.fecha_registro; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_financiador.fecha_registro IS 'label=Fecha de Registro&disable=no';


--
-- TOC entry 6139 (class 0 OID 0)
-- Dependencies: 3938
-- Name: COLUMN tpm_financiador.hora_registro; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_financiador.hora_registro IS 'label=Hora de Registro&disable=no';


--
-- TOC entry 6140 (class 0 OID 0)
-- Dependencies: 3938
-- Name: COLUMN tpm_financiador.fecha_ultima_modificacion; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_financiador.fecha_ultima_modificacion IS 'label=Fecha de Modificación&disable=no';


--
-- TOC entry 6141 (class 0 OID 0)
-- Dependencies: 3938
-- Name: COLUMN tpm_financiador.hora_ultima_modificacion; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_financiador.hora_ultima_modificacion IS 'label=Hora de Modificación&disable=no';


--
-- TOC entry 6142 (class 0 OID 0)
-- Dependencies: 3938
-- Name: COLUMN tpm_financiador.id_financiador_actif; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_financiador.id_financiador_actif IS 'para actualización de activos fijos';


--
-- TOC entry 3937 (class 1259 OID 1687693)
-- Dependencies: 11 3938
-- Name: tpm_financiador_id_financiador_seq; Type: SEQUENCE; Schema: param; Owner: rchumacero
--

CREATE SEQUENCE tpm_financiador_id_financiador_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.tpm_financiador_id_financiador_seq OWNER TO rchumacero;

--
-- TOC entry 6143 (class 0 OID 0)
-- Dependencies: 3937
-- Name: tpm_financiador_id_financiador_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: rchumacero
--

ALTER SEQUENCE tpm_financiador_id_financiador_seq OWNED BY tpm_financiador.id_financiador;


--
-- TOC entry 3942 (class 1259 OID 1687752)
-- Dependencies: 4816 4817 11
-- Name: tpm_programa; Type: TABLE; Schema: param; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tpm_programa (
    id_programa integer NOT NULL,
    codigo_programa character varying(10) NOT NULL,
    nombre_programa character varying(100),
    descripcion_programa text,
    fecha_registro date DEFAULT now() NOT NULL,
    hora_registro time without time zone DEFAULT now() NOT NULL,
    fecha_ultima_modificacion date,
    hora_ultima_modificacion time without time zone,
    id_usuario integer,
    id_programa_actif integer
);


ALTER TABLE param.tpm_programa OWNER TO rchumacero;

--
-- TOC entry 6144 (class 0 OID 0)
-- Dependencies: 3942
-- Name: TABLE tpm_programa; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON TABLE tpm_programa IS 'sistema=parametros&codigo=PROGRA&prefijo=PM&titulo=Programas&num_dt=2&dt_1=descripcion_programa&dt_2=codigo_programa&desc=Almacena los Programas';


--
-- TOC entry 6145 (class 0 OID 0)
-- Dependencies: 3942
-- Name: COLUMN tpm_programa.id_programa; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_programa.id_programa IS 'label=Id Programa&disable=no';


--
-- TOC entry 6146 (class 0 OID 0)
-- Dependencies: 3942
-- Name: COLUMN tpm_programa.codigo_programa; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_programa.codigo_programa IS 'label=Código&disable=no';


--
-- TOC entry 6147 (class 0 OID 0)
-- Dependencies: 3942
-- Name: COLUMN tpm_programa.nombre_programa; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_programa.nombre_programa IS 'label=Nombre&disable=no';


--
-- TOC entry 6148 (class 0 OID 0)
-- Dependencies: 3942
-- Name: COLUMN tpm_programa.descripcion_programa; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_programa.descripcion_programa IS 'label=Descripción&disable=no';


--
-- TOC entry 6149 (class 0 OID 0)
-- Dependencies: 3942
-- Name: COLUMN tpm_programa.fecha_registro; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_programa.fecha_registro IS 'label=Fecha de Registro&disable=no';


--
-- TOC entry 6150 (class 0 OID 0)
-- Dependencies: 3942
-- Name: COLUMN tpm_programa.hora_registro; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_programa.hora_registro IS 'label=Hora de Registro&disable=no';


--
-- TOC entry 6151 (class 0 OID 0)
-- Dependencies: 3942
-- Name: COLUMN tpm_programa.fecha_ultima_modificacion; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_programa.fecha_ultima_modificacion IS 'label=Fecha de Modificación&disable=no';


--
-- TOC entry 6152 (class 0 OID 0)
-- Dependencies: 3942
-- Name: COLUMN tpm_programa.hora_ultima_modificacion; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_programa.hora_ultima_modificacion IS 'label=Hora de Modificación&disable=no';


--
-- TOC entry 6153 (class 0 OID 0)
-- Dependencies: 3942
-- Name: COLUMN tpm_programa.id_programa_actif; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_programa.id_programa_actif IS 'para actualización de activos fijos';


--
-- TOC entry 3941 (class 1259 OID 1687750)
-- Dependencies: 11 3942
-- Name: tpm_programa_id_programa_seq; Type: SEQUENCE; Schema: param; Owner: rchumacero
--

CREATE SEQUENCE tpm_programa_id_programa_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.tpm_programa_id_programa_seq OWNER TO rchumacero;

--
-- TOC entry 6154 (class 0 OID 0)
-- Dependencies: 3941
-- Name: tpm_programa_id_programa_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: rchumacero
--

ALTER SEQUENCE tpm_programa_id_programa_seq OWNED BY tpm_programa.id_programa;


--
-- TOC entry 3944 (class 1259 OID 1687772)
-- Dependencies: 4819 4820 4821 11
-- Name: tpm_proyecto; Type: TABLE; Schema: param; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tpm_proyecto (
    id_proyecto integer NOT NULL,
    codigo_proyecto character varying(10) NOT NULL,
    nombre_proyecto character varying(100),
    descripcion_proyecto text,
    fecha_registro date DEFAULT now() NOT NULL,
    hora_registro time without time zone DEFAULT now() NOT NULL,
    fecha_ultima_modificacion date,
    hora_ultima_modificacion time without time zone,
    id_usuario integer,
    id_proyecto_actif integer,
    nombre_corto character varying(100),
    codigo_sisin bigint,
    hidro character varying(2) DEFAULT 'no'::character varying NOT NULL
);


ALTER TABLE param.tpm_proyecto OWNER TO rchumacero;

--
-- TOC entry 6155 (class 0 OID 0)
-- Dependencies: 3944
-- Name: TABLE tpm_proyecto; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON TABLE tpm_proyecto IS 'sistema=parametros&codigo=PROYEC&prefijo=PM&titulo=Proyectos&num_dt=2&dt_1=descripcion_proyecto&dt_2=codigo_proyecto&desc=Almacena los Proyectos';


--
-- TOC entry 6156 (class 0 OID 0)
-- Dependencies: 3944
-- Name: COLUMN tpm_proyecto.id_proyecto; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_proyecto.id_proyecto IS 'label=Id Proyecto&disable=no';


--
-- TOC entry 6157 (class 0 OID 0)
-- Dependencies: 3944
-- Name: COLUMN tpm_proyecto.codigo_proyecto; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_proyecto.codigo_proyecto IS 'label=Código&disable=no';


--
-- TOC entry 6158 (class 0 OID 0)
-- Dependencies: 3944
-- Name: COLUMN tpm_proyecto.nombre_proyecto; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_proyecto.nombre_proyecto IS 'label=Proyecto&disable=no';


--
-- TOC entry 6159 (class 0 OID 0)
-- Dependencies: 3944
-- Name: COLUMN tpm_proyecto.descripcion_proyecto; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_proyecto.descripcion_proyecto IS 'label=Descripción&disable=no';


--
-- TOC entry 6160 (class 0 OID 0)
-- Dependencies: 3944
-- Name: COLUMN tpm_proyecto.fecha_registro; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_proyecto.fecha_registro IS 'label=Fecha de Registro&disable=no';


--
-- TOC entry 6161 (class 0 OID 0)
-- Dependencies: 3944
-- Name: COLUMN tpm_proyecto.hora_registro; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_proyecto.hora_registro IS 'label=Hora de Registro&disable=no';


--
-- TOC entry 6162 (class 0 OID 0)
-- Dependencies: 3944
-- Name: COLUMN tpm_proyecto.fecha_ultima_modificacion; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_proyecto.fecha_ultima_modificacion IS 'label=Fecha de Modificación&disable=no';


--
-- TOC entry 6163 (class 0 OID 0)
-- Dependencies: 3944
-- Name: COLUMN tpm_proyecto.hora_ultima_modificacion; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_proyecto.hora_ultima_modificacion IS 'label=Hora de Modificación&disable=no';


--
-- TOC entry 6164 (class 0 OID 0)
-- Dependencies: 3944
-- Name: COLUMN tpm_proyecto.id_proyecto_actif; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_proyecto.id_proyecto_actif IS 'para actualización de activos fijos';


--
-- TOC entry 3943 (class 1259 OID 1687770)
-- Dependencies: 11 3944
-- Name: tpm_proyecto_id_proyecto_seq; Type: SEQUENCE; Schema: param; Owner: rchumacero
--

CREATE SEQUENCE tpm_proyecto_id_proyecto_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.tpm_proyecto_id_proyecto_seq OWNER TO rchumacero;

--
-- TOC entry 6165 (class 0 OID 0)
-- Dependencies: 3943
-- Name: tpm_proyecto_id_proyecto_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: rchumacero
--

ALTER SEQUENCE tpm_proyecto_id_proyecto_seq OWNED BY tpm_proyecto.id_proyecto;


--
-- TOC entry 3940 (class 1259 OID 1687732)
-- Dependencies: 4813 4814 11
-- Name: tpm_regional; Type: TABLE; Schema: param; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tpm_regional (
    id_regional integer NOT NULL,
    codigo_regional character varying(10) NOT NULL,
    nombre_regional character varying(100),
    descripcion_regional text,
    fecha_registro date DEFAULT now() NOT NULL,
    hora_registro time without time zone DEFAULT now() NOT NULL,
    fecha_ultima_modificacion date,
    hora_ultima_modificacion time without time zone,
    id_usuario integer,
    id_regional_actif integer
);


ALTER TABLE param.tpm_regional OWNER TO rchumacero;

--
-- TOC entry 6166 (class 0 OID 0)
-- Dependencies: 3940
-- Name: TABLE tpm_regional; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON TABLE tpm_regional IS 'sistema=parametros&codigo=REGION&prefijo=PM&titulo=Regional&num_dt=2&dt_1=codigo_regional&dt_2=nombre_regional&desc=Almacena informacion referente a las Regionales';


--
-- TOC entry 6167 (class 0 OID 0)
-- Dependencies: 3940
-- Name: COLUMN tpm_regional.id_regional; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_regional.id_regional IS 'label=Id Regional&disable=no';


--
-- TOC entry 6168 (class 0 OID 0)
-- Dependencies: 3940
-- Name: COLUMN tpm_regional.codigo_regional; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_regional.codigo_regional IS 'label=Código Regional&disable=no';


--
-- TOC entry 6169 (class 0 OID 0)
-- Dependencies: 3940
-- Name: COLUMN tpm_regional.nombre_regional; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_regional.nombre_regional IS 'label=Nombre Regional&disable=no';


--
-- TOC entry 6170 (class 0 OID 0)
-- Dependencies: 3940
-- Name: COLUMN tpm_regional.descripcion_regional; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_regional.descripcion_regional IS 'label=Descripción Regional&disable=no';


--
-- TOC entry 6171 (class 0 OID 0)
-- Dependencies: 3940
-- Name: COLUMN tpm_regional.fecha_registro; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_regional.fecha_registro IS 'label=Fecha Registro&disable=no';


--
-- TOC entry 6172 (class 0 OID 0)
-- Dependencies: 3940
-- Name: COLUMN tpm_regional.hora_registro; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_regional.hora_registro IS 'label=Hora Registro&disable=no';


--
-- TOC entry 6173 (class 0 OID 0)
-- Dependencies: 3940
-- Name: COLUMN tpm_regional.fecha_ultima_modificacion; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_regional.fecha_ultima_modificacion IS 'label=Fecha Ultima Mod&disable=no';


--
-- TOC entry 6174 (class 0 OID 0)
-- Dependencies: 3940
-- Name: COLUMN tpm_regional.hora_ultima_modificacion; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_regional.hora_ultima_modificacion IS 'label=Hora Ultima Mod&disable=no';


--
-- TOC entry 6175 (class 0 OID 0)
-- Dependencies: 3940
-- Name: COLUMN tpm_regional.id_regional_actif; Type: COMMENT; Schema: param; Owner: rchumacero
--

COMMENT ON COLUMN tpm_regional.id_regional_actif IS 'para actualización de activos fijos';


--
-- TOC entry 3939 (class 1259 OID 1687730)
-- Dependencies: 11 3940
-- Name: tpm_regional_id_regional_seq; Type: SEQUENCE; Schema: param; Owner: rchumacero
--

CREATE SEQUENCE tpm_regional_id_regional_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.tpm_regional_id_regional_seq OWNER TO rchumacero;

--
-- TOC entry 6176 (class 0 OID 0)
-- Dependencies: 3939
-- Name: tpm_regional_id_regional_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: rchumacero
--

ALTER SEQUENCE tpm_regional_id_regional_seq OWNED BY tpm_regional.id_regional;


SET default_with_oids = true;

--
-- TOC entry 3971 (class 1259 OID 1952153)
-- Dependencies: 4859 4860 11
-- Name: tproveedor; Type: TABLE; Schema: param; Owner: mzambrana; Tablespace: 
--

CREATE TABLE tproveedor (
    id_proveedor integer NOT NULL,
    id_institucion integer,
    id_persona integer,
    tipo character varying,
    numero_sigma character varying,
    codigo character varying,
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer,
    fecha_mod date,
    id_usuario_mod integer,
    nit character varying(100)
);


ALTER TABLE param.tproveedor OWNER TO mzambrana;

--
-- TOC entry 3970 (class 1259 OID 1952151)
-- Dependencies: 11 3971
-- Name: tproveedor_id_proveedor_seq; Type: SEQUENCE; Schema: param; Owner: mzambrana
--

CREATE SEQUENCE tproveedor_id_proveedor_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.tproveedor_id_proveedor_seq OWNER TO mzambrana;

--
-- TOC entry 6177 (class 0 OID 0)
-- Dependencies: 3970
-- Name: tproveedor_id_proveedor_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: mzambrana
--

ALTER SEQUENCE tproveedor_id_proveedor_seq OWNED BY tproveedor.id_proveedor;


SET default_with_oids = false;

--
-- TOC entry 4007 (class 1259 OID 2131430)
-- Dependencies: 4914 4915 4916 3708 11
-- Name: tusuario_uo; Type: TABLE; Schema: param; Owner: rac; Tablespace: 
--

CREATE TABLE tusuario_uo (
    id_usuario_uo integer NOT NULL,
    id_usuario integer,
    id_uo integer
)
INHERITS (public.tbase);


ALTER TABLE param.tusuario_uo OWNER TO rac;

--
-- TOC entry 4006 (class 1259 OID 2131428)
-- Dependencies: 11 4007
-- Name: tusuario_uo_id_usuario_uo_seq; Type: SEQUENCE; Schema: param; Owner: rac
--

CREATE SEQUENCE tusuario_uo_id_usuario_uo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE param.tusuario_uo_id_usuario_uo_seq OWNER TO rac;

--
-- TOC entry 6178 (class 0 OID 0)
-- Dependencies: 4006
-- Name: tusuario_uo_id_usuario_uo_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: rac
--

ALTER SEQUENCE tusuario_uo_id_usuario_uo_seq OWNED BY tusuario_uo.id_usuario_uo;


SET search_path = segu, pg_catalog;

--
-- TOC entry 3791 (class 1259 OID 17118)
-- Dependencies: 4556 4557 4558 14 3708
-- Name: tpersona; Type: TABLE; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tpersona (
    id_persona integer NOT NULL,
    nombre character varying(150),
    apellido_paterno character varying(100),
    apellido_materno character varying(100),
    ci character varying(20),
    correo character varying(50),
    celular1 character varying(15),
    num_documento integer,
    telefono1 character varying(15),
    telefono2 character varying(15),
    celular2 character varying(15),
    foto bytea,
    extension character varying(5),
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10),
    genero character varying(1),
    fecha_nacimiento date,
    direccion character varying
)
INHERITS (public.tbase);


ALTER TABLE segu.tpersona OWNER TO rchumacero;

--
-- TOC entry 4024 (class 1259 OID 2990215)
-- Dependencies: 4223 14
-- Name: vpersona; Type: VIEW; Schema: segu; Owner: mzambrana
--

CREATE VIEW vpersona AS
    SELECT p.id_persona, p.apellido_materno AS ap_materno, p.apellido_paterno AS ap_paterno, p.nombre, (((((COALESCE(p.nombre, ''::character varying))::text || ' '::text) || (COALESCE(p.apellido_paterno, ''::character varying))::text) || ' '::text) || (COALESCE(p.apellido_materno, ''::character varying))::text) AS nombre_completo1, (((((COALESCE(p.apellido_paterno, ''::character varying))::text || ' '::text) || (COALESCE(p.apellido_materno, ''::character varying))::text) || ' '::text) || (COALESCE(p.nombre, ''::character varying))::text) AS nombre_completo2, p.ci, p.correo, p.celular1, p.num_documento, p.telefono1, p.telefono2, p.celular2 FROM tpersona p;


ALTER TABLE segu.vpersona OWNER TO mzambrana;

SET search_path = param, pg_catalog;

--
-- TOC entry 4029 (class 1259 OID 2990238)
-- Dependencies: 4228 11
-- Name: vproveedor; Type: VIEW; Schema: param; Owner: mzambrana
--

CREATE VIEW vproveedor AS
    SELECT provee.id_proveedor, provee.id_persona, provee.codigo, provee.numero_sigma, provee.tipo, provee.id_institucion, public.f_iif((provee.id_persona IS NOT NULL), (person.nombre_completo1)::character varying, ((((instit.codigo)::text || '-'::text) || (instit.nombre)::text))::character varying) AS desc_proveedor, provee.nit FROM ((tproveedor provee LEFT JOIN segu.vpersona person ON ((person.id_persona = provee.id_persona))) LEFT JOIN tinstitucion instit ON ((instit.id_institucion = provee.id_institucion))) WHERE ((provee.estado_reg)::text = 'activo'::text);


ALTER TABLE param.vproveedor OWNER TO mzambrana;

SET search_path = public, pg_catalog;

--
-- TOC entry 3726 (class 1259 OID 16847)
-- Dependencies: 5
-- Name: file_store; Type: TABLE; Schema: public; Owner: rchumacero; Tablespace: 
--

CREATE TABLE file_store (
    id integer NOT NULL,
    data text
);


ALTER TABLE public.file_store OWNER TO rchumacero;

--
-- TOC entry 3727 (class 1259 OID 16853)
-- Dependencies: 5 3726
-- Name: file_store_id_seq; Type: SEQUENCE; Schema: public; Owner: rchumacero
--

CREATE SEQUENCE file_store_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.file_store_id_seq OWNER TO rchumacero;

--
-- TOC entry 6179 (class 0 OID 0)
-- Dependencies: 3727
-- Name: file_store_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: rchumacero
--

ALTER SEQUENCE file_store_id_seq OWNED BY file_store.id;


--
-- TOC entry 3950 (class 1259 OID 1898879)
-- Dependencies: 4222 5
-- Name: geography_columns; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW geography_columns AS
    SELECT current_database() AS f_table_catalog, n.nspname AS f_table_schema, c.relname AS f_table_name, a.attname AS f_geography_column, geography_typmod_dims(a.atttypmod) AS coord_dimension, geography_typmod_srid(a.atttypmod) AS srid, geography_typmod_type(a.atttypmod) AS type FROM pg_class c, pg_attribute a, pg_type t, pg_namespace n WHERE ((((((t.typname = 'geography'::name) AND (a.attisdropped = false)) AND (a.atttypid = t.oid)) AND (a.attrelid = c.oid)) AND (c.relnamespace = n.oid)) AND (NOT pg_is_other_temp_schema(c.relnamespace)));


ALTER TABLE public.geography_columns OWNER TO postgres;

SET default_with_oids = true;

--
-- TOC entry 3949 (class 1259 OID 1898419)
-- Dependencies: 5
-- Name: geometry_columns; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE geometry_columns (
    f_table_catalog character varying(256) NOT NULL,
    f_table_schema character varying(256) NOT NULL,
    f_table_name character varying(256) NOT NULL,
    f_geometry_column character varying(256) NOT NULL,
    coord_dimension integer NOT NULL,
    srid integer NOT NULL,
    type character varying(30) NOT NULL
);


ALTER TABLE public.geometry_columns OWNER TO postgres;

--
-- TOC entry 3728 (class 1259 OID 16855)
-- Dependencies: 5
-- Name: monitor; Type: TABLE; Schema: public; Owner: rchumacero; Tablespace: 
--

CREATE TABLE monitor (
    pid character varying(30),
    comando character varying(200),
    usuario character varying(100),
    por_procesador character varying(5),
    por_memoria character varying(5),
    memoria_virtual character varying(50)
);
ALTER TABLE ONLY monitor ALTER COLUMN pid SET STATISTICS 0;


ALTER TABLE public.monitor OWNER TO rchumacero;

--
-- TOC entry 3729 (class 1259 OID 16858)
-- Dependencies: 5
-- Name: monitor2; Type: TABLE; Schema: public; Owner: rchumacero; Tablespace: 
--

CREATE TABLE monitor2 (
    pid integer,
    comando character varying(200),
    usuario character varying(100),
    por_procesador character varying,
    por_memoria character varying,
    memoria_virtual character varying(50)
);


ALTER TABLE public.monitor2 OWNER TO rchumacero;

--
-- TOC entry 3730 (class 1259 OID 16864)
-- Dependencies: 5
-- Name: monitor3; Type: TABLE; Schema: public; Owner: rchumacero; Tablespace: 
--

CREATE TABLE monitor3 (
    pid integer,
    comando character varying(200),
    usuario character varying(100),
    por_procesador numeric(5,2),
    por_memoria numeric(5,2),
    memoria_virtual numeric(40,2)
);


ALTER TABLE public.monitor3 OWNER TO rchumacero;

--
-- TOC entry 3731 (class 1259 OID 16867)
-- Dependencies: 5
-- Name: parametro; Type: SEQUENCE; Schema: public; Owner: rchumacero
--

CREATE SEQUENCE parametro
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.parametro OWNER TO rchumacero;

SET default_with_oids = false;

--
-- TOC entry 4032 (class 1259 OID 3175991)
-- Dependencies: 5
-- Name: pempleado; Type: TABLE; Schema: public; Owner: rchumacero; Tablespace: 
--

CREATE TABLE pempleado (
    "?column?" text
);


ALTER TABLE public.pempleado OWNER TO rchumacero;

--
-- TOC entry 4111 (class 1259 OID 3352284)
-- Dependencies: 5
-- Name: prueba_sast; Type: TABLE; Schema: public; Owner: rac; Tablespace: 
--

CREATE TABLE prueba_sast (
    id_estado_requerimiento integer,
    id_requerimiento integer,
    observaciones text,
    fecha_ini date,
    responsable text,
    fecha_fin date,
    vigente character varying(100),
    estado_reg character varying(10),
    fecha_reg timestamp without time zone,
    id_usuario_reg integer,
    fecha_mod timestamp without time zone,
    id_usuario_mod integer,
    usr_reg character varying(100),
    usr_mod character varying(100)
);


ALTER TABLE public.prueba_sast OWNER TO rac;

--
-- TOC entry 3972 (class 1259 OID 1952220)
-- Dependencies: 5
-- Name: resum; Type: TABLE; Schema: public; Owner: jmita; Tablespace: 
--

CREATE TABLE resum (
    periodo numeric(2,0),
    gestion numeric(4,0),
    cant_clientes bigint,
    importe_total numeric
);


ALTER TABLE public.resum OWNER TO jmita;

--
-- TOC entry 3948 (class 1259 OID 1898411)
-- Dependencies: 5
-- Name: spatial_ref_sys; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE spatial_ref_sys (
    srid integer NOT NULL,
    auth_name character varying(256),
    auth_srid integer,
    srtext character varying(2048),
    proj4text character varying(2048)
);


ALTER TABLE public.spatial_ref_sys OWNER TO postgres;

--
-- TOC entry 4013 (class 1259 OID 2152115)
-- Dependencies: 1539 1539 5
-- Name: sssss; Type: TABLE; Schema: public; Owner: fprudencio; Tablespace: 
--

CREATE TABLE sssss (
    table_schema information_schema.sql_identifier,
    table_name information_schema.sql_identifier
);


ALTER TABLE public.sssss OWNER TO fprudencio;

--
-- TOC entry 4018 (class 1259 OID 2424734)
-- Dependencies: 5
-- Name: temporal_gvc; Type: TABLE; Schema: public; Owner: gvelasquez; Tablespace: 
--

CREATE TABLE temporal_gvc (
    id_cajero integer,
    cajero text,
    cantidad_facturas bigint,
    sum numeric
);


ALTER TABLE public.temporal_gvc OWNER TO gvelasquez;

--
-- TOC entry 4012 (class 1259 OID 2149886)
-- Dependencies: 5
-- Name: ttttttt; Type: TABLE; Schema: public; Owner: rac; Tablespace: 
--

CREATE TABLE ttttttt (
    id_config_alarma integer,
    codigo character varying(50),
    descripcion character varying(300),
    dias integer,
    id_subsistema integer,
    desc_subsis text,
    id_usuario_reg integer,
    estado_reg character varying(10),
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    id_usuario_mod integer,
    desc_usuario_reg text,
    desc_usuario_mod text
);


ALTER TABLE public.ttttttt OWNER TO rac;

--
-- TOC entry 3732 (class 1259 OID 16869)
-- Dependencies: 5
-- Name: v_num_fallidos; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE v_num_fallidos (
    count bigint
);


ALTER TABLE public.v_num_fallidos OWNER TO postgres;

--
-- TOC entry 4023 (class 1259 OID 2943497)
-- Dependencies: 5
-- Name: v_orden_logico; Type: TABLE; Schema: public; Owner: rac; Tablespace: 
--

CREATE TABLE v_orden_logico (
    orden_logico integer
);


ALTER TABLE public.v_orden_logico OWNER TO rac;

SET default_with_oids = true;

--
-- TOC entry 3733 (class 1259 OID 16872)
-- Dependencies: 5
-- Name: variable_global; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE variable_global (
    id_variable_global integer NOT NULL,
    variable character varying NOT NULL,
    valor character varying(200) NOT NULL,
    descripcion character varying
);
ALTER TABLE ONLY variable_global ALTER COLUMN id_variable_global SET STATISTICS 0;
ALTER TABLE ONLY variable_global ALTER COLUMN valor SET STATISTICS 0;


ALTER TABLE public.variable_global OWNER TO postgres;

--
-- TOC entry 3734 (class 1259 OID 16878)
-- Dependencies: 5 3733
-- Name: variable_global_id_variable_global_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE variable_global_id_variable_global_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.variable_global_id_variable_global_seq OWNER TO postgres;

--
-- TOC entry 6180 (class 0 OID 0)
-- Dependencies: 3734
-- Name: variable_global_id_variable_global_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE variable_global_id_variable_global_seq OWNED BY variable_global.id_variable_global;


SET search_path = rhum, pg_catalog;

SET default_with_oids = false;

--
-- TOC entry 3735 (class 1259 OID 16880)
-- Dependencies: 4498 4499 4500 4501 4502 4503 12
-- Name: tcolumna; Type: TABLE; Schema: rhum; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcolumna (
    id_columna integer NOT NULL,
    codigo character varying(30),
    formula character varying(200),
    valor_defecto numeric(18,2),
    formula_original character varying(200),
    en_reporte character varying DEFAULT 'si'::character varying,
    orden_reporte integer,
    total character varying(2) DEFAULT 'no'::character varying,
    auxiliar character varying(2) DEFAULT 'no'::character varying,
    id_tipo_planilla integer,
    id_tipo_columna integer,
    estado_reg character varying(15) NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer NOT NULL,
    CONSTRAINT chk_tcolumna__estado_reg CHECK ((((estado_reg)::text = 'activo'::text) OR ((estado_reg)::text = 'inactivo'::text))),
    CONSTRAINT chk_tcolumna__valor_defecto__formula CHECK (((((valor_defecto IS NOT NULL) AND (formula IS NULL)) OR ((valor_defecto IS NULL) AND (formula IS NOT NULL))) OR ((valor_defecto IS NULL) AND (formula IS NULL))))
);


ALTER TABLE rhum.tcolumna OWNER TO rchumacero;

--
-- TOC entry 3736 (class 1259 OID 16892)
-- Dependencies: 3735 12
-- Name: tcolumna_id_columna_seq; Type: SEQUENCE; Schema: rhum; Owner: rchumacero
--

CREATE SEQUENCE tcolumna_id_columna_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rhum.tcolumna_id_columna_seq OWNER TO rchumacero;

--
-- TOC entry 6181 (class 0 OID 0)
-- Dependencies: 3736
-- Name: tcolumna_id_columna_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: rchumacero
--

ALTER SEQUENCE tcolumna_id_columna_seq OWNED BY tcolumna.id_columna;


SET default_with_oids = true;

--
-- TOC entry 3997 (class 1259 OID 2106142)
-- Dependencies: 4893 4894 4895 12 3708
-- Name: testructura_uo; Type: TABLE; Schema: rhum; Owner: postgres; Tablespace: 
--

CREATE TABLE testructura_uo (
    estado_reg character varying(10) NOT NULL,
    id_estructura_uo integer NOT NULL,
    id_uo_padre integer,
    id_uo_hijo integer
)
INHERITS (public.tbase);


ALTER TABLE rhum.testructura_uo OWNER TO postgres;

--
-- TOC entry 3996 (class 1259 OID 2106140)
-- Dependencies: 12 3997
-- Name: testructura_uo_id_estructura_uo_seq; Type: SEQUENCE; Schema: rhum; Owner: postgres
--

CREATE SEQUENCE testructura_uo_id_estructura_uo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rhum.testructura_uo_id_estructura_uo_seq OWNER TO postgres;

--
-- TOC entry 6182 (class 0 OID 0)
-- Dependencies: 3996
-- Name: testructura_uo_id_estructura_uo_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: postgres
--

ALTER SEQUENCE testructura_uo_id_estructura_uo_seq OWNED BY testructura_uo.id_estructura_uo;


SET default_with_oids = false;

--
-- TOC entry 3737 (class 1259 OID 16894)
-- Dependencies: 4504 4505 4506 4508 12
-- Name: tfuncionario; Type: TABLE; Schema: rhum; Owner: postgres; Tablespace: 
--

CREATE TABLE tfuncionario (
    id_persona integer NOT NULL,
    codigo character varying(20),
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    fecha_reg date DEFAULT (now())::date NOT NULL,
    id_usuario_reg integer,
    fecha_mod date DEFAULT (now())::date,
    id_usuario_mod integer,
    id_funcionario integer NOT NULL,
    email_empresa character varying(40),
    interno character varying(9),
    fecha_ingreso date DEFAULT now() NOT NULL
);


ALTER TABLE rhum.tfuncionario OWNER TO postgres;

--
-- TOC entry 6183 (class 0 OID 0)
-- Dependencies: 3737
-- Name: COLUMN tfuncionario.email_empresa; Type: COMMENT; Schema: rhum; Owner: postgres
--

COMMENT ON COLUMN tfuncionario.email_empresa IS 'correo corporativo  asignado por la empresa';


--
-- TOC entry 6184 (class 0 OID 0)
-- Dependencies: 3737
-- Name: COLUMN tfuncionario.interno; Type: COMMENT; Schema: rhum; Owner: postgres
--

COMMENT ON COLUMN tfuncionario.interno IS 'numero telefonico interno de la empresa';


--
-- TOC entry 3738 (class 1259 OID 16900)
-- Dependencies: 12
-- Name: tfuncionario_horario; Type: TABLE; Schema: rhum; Owner: postgres; Tablespace: 
--

CREATE TABLE tfuncionario_horario (
    id_funcionario_horario integer NOT NULL,
    id_funcionario integer,
    id_horario integer,
    estado_reg character varying(255),
    id_usuario_reg integer,
    fecha_reg date
);


ALTER TABLE rhum.tfuncionario_horario OWNER TO postgres;

--
-- TOC entry 3739 (class 1259 OID 16903)
-- Dependencies: 3738 12
-- Name: tfuncionario_horario_id_funcionario_horario_seq; Type: SEQUENCE; Schema: rhum; Owner: postgres
--

CREATE SEQUENCE tfuncionario_horario_id_funcionario_horario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rhum.tfuncionario_horario_id_funcionario_horario_seq OWNER TO postgres;

--
-- TOC entry 6185 (class 0 OID 0)
-- Dependencies: 3739
-- Name: tfuncionario_horario_id_funcionario_horario_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: postgres
--

ALTER SEQUENCE tfuncionario_horario_id_funcionario_horario_seq OWNED BY tfuncionario_horario.id_funcionario_horario;


--
-- TOC entry 3740 (class 1259 OID 16905)
-- Dependencies: 3737 12
-- Name: tfuncionario_id_funcionario_seq; Type: SEQUENCE; Schema: rhum; Owner: postgres
--

CREATE SEQUENCE tfuncionario_id_funcionario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rhum.tfuncionario_id_funcionario_seq OWNER TO postgres;

--
-- TOC entry 6186 (class 0 OID 0)
-- Dependencies: 3740
-- Name: tfuncionario_id_funcionario_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: postgres
--

ALTER SEQUENCE tfuncionario_id_funcionario_seq OWNED BY tfuncionario.id_funcionario;


--
-- TOC entry 3741 (class 1259 OID 16907)
-- Dependencies: 12
-- Name: thorario; Type: TABLE; Schema: rhum; Owner: postgres; Tablespace: 
--

CREATE TABLE thorario (
    id_horario integer NOT NULL,
    numero_periodo integer,
    fecha_inicio date NOT NULL,
    fecha_fin date,
    horas_por_dia numeric(2,0),
    hora_ini_p1 time(6) without time zone,
    hora_fin_p1 time(6) without time zone,
    hora_ini_p2 time(6) without time zone,
    hora_fin_p2 time(6) without time zone,
    tipo_periodo character varying(255),
    observaciones character varying(255),
    repite_anualmente character varying(255),
    estado_reg character varying(255),
    id_tipo_horario integer,
    id_vacacion integer,
    id_usuario_reg integer,
    fecha_reg date,
    id_usuario_mod integer,
    fecha_mod date
);


ALTER TABLE rhum.thorario OWNER TO postgres;

--
-- TOC entry 3742 (class 1259 OID 16913)
-- Dependencies: 3741 12
-- Name: thorario_id_horario_seq; Type: SEQUENCE; Schema: rhum; Owner: postgres
--

CREATE SEQUENCE thorario_id_horario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rhum.thorario_id_horario_seq OWNER TO postgres;

--
-- TOC entry 6187 (class 0 OID 0)
-- Dependencies: 3742
-- Name: thorario_id_horario_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: postgres
--

ALTER SEQUENCE thorario_id_horario_seq OWNED BY thorario.id_horario;


--
-- TOC entry 4009 (class 1259 OID 2131540)
-- Dependencies: 4918 4919 4920 12 3708
-- Name: tnivel_organizacional; Type: TABLE; Schema: rhum; Owner: rac; Tablespace: 
--

CREATE TABLE tnivel_organizacional (
    id_nivel_organizacional integer NOT NULL,
    nombre_nivel character varying(50) NOT NULL,
    numero_nivel integer NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE rhum.tnivel_organizacional OWNER TO rac;

--
-- TOC entry 4008 (class 1259 OID 2131538)
-- Dependencies: 12 4009
-- Name: tnivel_organizacional_id_nivel_organizacional_seq; Type: SEQUENCE; Schema: rhum; Owner: rac
--

CREATE SEQUENCE tnivel_organizacional_id_nivel_organizacional_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rhum.tnivel_organizacional_id_nivel_organizacional_seq OWNER TO rac;

--
-- TOC entry 6188 (class 0 OID 0)
-- Dependencies: 4008
-- Name: tnivel_organizacional_id_nivel_organizacional_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: rac
--

ALTER SEQUENCE tnivel_organizacional_id_nivel_organizacional_seq OWNED BY tnivel_organizacional.id_nivel_organizacional;


--
-- TOC entry 3743 (class 1259 OID 16915)
-- Dependencies: 4512 4513 4514 12
-- Name: tobligacion; Type: TABLE; Schema: rhum; Owner: postgres; Tablespace: 
--

CREATE TABLE tobligacion (
    id_obligacion integer NOT NULL,
    observaciones text,
    monto numeric,
    tipo_pago character varying,
    estado_reg character varying,
    id_tipo_obligacion integer,
    id_planilla integer,
    id_usuario_reg integer,
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_mod integer,
    fecha_mod date DEFAULT now(),
    CONSTRAINT tkp_obligacion__tipo_pago__check CHECK ((((tipo_pago)::text = 'cheque'::text) OR ((tipo_pago)::text = 'transferencia'::text)))
);


ALTER TABLE rhum.tobligacion OWNER TO postgres;

--
-- TOC entry 3744 (class 1259 OID 16924)
-- Dependencies: 12 3743
-- Name: tobligacion_id_obligacion_seq; Type: SEQUENCE; Schema: rhum; Owner: postgres
--

CREATE SEQUENCE tobligacion_id_obligacion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rhum.tobligacion_id_obligacion_seq OWNER TO postgres;

--
-- TOC entry 6189 (class 0 OID 0)
-- Dependencies: 3744
-- Name: tobligacion_id_obligacion_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: postgres
--

ALTER SEQUENCE tobligacion_id_obligacion_seq OWNED BY tobligacion.id_obligacion;


SET default_with_oids = true;

--
-- TOC entry 3745 (class 1259 OID 16926)
-- Dependencies: 4516 12
-- Name: tparametro_rhum; Type: TABLE; Schema: rhum; Owner: postgres; Tablespace: 
--

CREATE TABLE tparametro_rhum (
    id_parametro integer NOT NULL,
    id_gestion integer,
    salario_min_nal numeric,
    id_moneda_sal_min_nal integer,
    estado_reg character varying,
    fecha_reg date,
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_mod date DEFAULT now()
);


ALTER TABLE rhum.tparametro_rhum OWNER TO postgres;

--
-- TOC entry 3746 (class 1259 OID 16933)
-- Dependencies: 12 3745
-- Name: tparametro_rhum_id_parametro_seq; Type: SEQUENCE; Schema: rhum; Owner: postgres
--

CREATE SEQUENCE tparametro_rhum_id_parametro_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rhum.tparametro_rhum_id_parametro_seq OWNER TO postgres;

--
-- TOC entry 6190 (class 0 OID 0)
-- Dependencies: 3746
-- Name: tparametro_rhum_id_parametro_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: postgres
--

ALTER SEQUENCE tparametro_rhum_id_parametro_seq OWNED BY tparametro_rhum.id_parametro;


--
-- TOC entry 3747 (class 1259 OID 16935)
-- Dependencies: 12
-- Name: tplanilla; Type: TABLE; Schema: rhum; Owner: postgres; Tablespace: 
--

CREATE TABLE tplanilla (
    id_planilla integer NOT NULL
);


ALTER TABLE rhum.tplanilla OWNER TO postgres;

--
-- TOC entry 3748 (class 1259 OID 16938)
-- Dependencies: 12 3747
-- Name: tplanilla_id_planilla_seq; Type: SEQUENCE; Schema: rhum; Owner: postgres
--

CREATE SEQUENCE tplanilla_id_planilla_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rhum.tplanilla_id_planilla_seq OWNER TO postgres;

--
-- TOC entry 6191 (class 0 OID 0)
-- Dependencies: 3748
-- Name: tplanilla_id_planilla_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: postgres
--

ALTER SEQUENCE tplanilla_id_planilla_seq OWNED BY tplanilla.id_planilla;


SET default_with_oids = false;

--
-- TOC entry 3749 (class 1259 OID 16940)
-- Dependencies: 4519 4520 4521 4522 4523 4524 12
-- Name: ttipo_columna; Type: TABLE; Schema: rhum; Owner: rchumacero; Tablespace: 
--

CREATE TABLE ttipo_columna (
    id_tipo_columna integer NOT NULL,
    codigo character varying(15),
    nombre character varying(255),
    descripcion character varying(255),
    valor numeric(20,6),
    tipo_dato character varying(255),
    compromete character varying(5) DEFAULT 'no'::character varying NOT NULL,
    tipo_aporte character varying(255),
    descuento_incremento character varying(20),
    observacion character varying(255),
    formula character varying(500),
    movimiento_contable character varying DEFAULT 'haber'::character varying NOT NULL,
    prorratea character varying(2) DEFAULT 'no'::character varying NOT NULL,
    estado_reg character varying(255) DEFAULT 'activo'::character varying,
    fecha_reg date DEFAULT (now())::date,
    id_parametro_rhum integer,
    id_moneda integer,
    id_tipo_descuento_bono integer,
    id_cuenta_pasivo integer,
    id_auxiliar_pasivo integer,
    id_tipo_obligacion integer,
    id_usuario_reg integer,
    CONSTRAINT ttipo_columna__descuento_incremento__chk CHECK (((((descuento_incremento)::text = 'aumentar'::text) OR ((descuento_incremento)::text = 'descontar'::text)) OR ((descuento_incremento)::text = 'ninguno'::text)))
);


ALTER TABLE rhum.ttipo_columna OWNER TO rchumacero;

--
-- TOC entry 3750 (class 1259 OID 16952)
-- Dependencies: 12 3749
-- Name: ttipo_columna_id_tipo_columna_seq; Type: SEQUENCE; Schema: rhum; Owner: rchumacero
--

CREATE SEQUENCE ttipo_columna_id_tipo_columna_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rhum.ttipo_columna_id_tipo_columna_seq OWNER TO rchumacero;

--
-- TOC entry 6192 (class 0 OID 0)
-- Dependencies: 3750
-- Name: ttipo_columna_id_tipo_columna_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: rchumacero
--

ALTER SEQUENCE ttipo_columna_id_tipo_columna_seq OWNED BY ttipo_columna.id_tipo_columna;


--
-- TOC entry 3751 (class 1259 OID 16954)
-- Dependencies: 4526 4527 12
-- Name: ttipo_horario; Type: TABLE; Schema: rhum; Owner: rchumacero; Tablespace: 
--

CREATE TABLE ttipo_horario (
    id_tipo_horario integer NOT NULL,
    codigo character varying(255),
    nombre character varying(255),
    estado_reg character varying(10),
    id_usuario_reg integer,
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_mod integer,
    fecha_mod date DEFAULT now()
);


ALTER TABLE rhum.ttipo_horario OWNER TO rchumacero;

--
-- TOC entry 3752 (class 1259 OID 16962)
-- Dependencies: 3751 12
-- Name: ttipo_horario_id_tipo_horario_seq; Type: SEQUENCE; Schema: rhum; Owner: rchumacero
--

CREATE SEQUENCE ttipo_horario_id_tipo_horario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rhum.ttipo_horario_id_tipo_horario_seq OWNER TO rchumacero;

--
-- TOC entry 6193 (class 0 OID 0)
-- Dependencies: 3752
-- Name: ttipo_horario_id_tipo_horario_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: rchumacero
--

ALTER SEQUENCE ttipo_horario_id_tipo_horario_seq OWNED BY ttipo_horario.id_tipo_horario;


--
-- TOC entry 3753 (class 1259 OID 16964)
-- Dependencies: 4529 4530 12
-- Name: ttipo_obligacion; Type: TABLE; Schema: rhum; Owner: rchumacero; Tablespace: 
--

CREATE TABLE ttipo_obligacion (
    id_tipo_obligacion integer NOT NULL,
    codigo character varying(20) NOT NULL,
    nombre character varying(150) NOT NULL,
    estado_reg character varying(20),
    id_usuario_reg integer,
    fecha_reg date DEFAULT now(),
    id_usuario_mod integer,
    fecha_mod date DEFAULT now()
);


ALTER TABLE rhum.ttipo_obligacion OWNER TO rchumacero;

--
-- TOC entry 3754 (class 1259 OID 16969)
-- Dependencies: 12 3753
-- Name: ttipo_obligacion_id_tipo_obligacion_seq; Type: SEQUENCE; Schema: rhum; Owner: rchumacero
--

CREATE SEQUENCE ttipo_obligacion_id_tipo_obligacion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rhum.ttipo_obligacion_id_tipo_obligacion_seq OWNER TO rchumacero;

--
-- TOC entry 6194 (class 0 OID 0)
-- Dependencies: 3754
-- Name: ttipo_obligacion_id_tipo_obligacion_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: rchumacero
--

ALTER SEQUENCE ttipo_obligacion_id_tipo_obligacion_seq OWNED BY ttipo_obligacion.id_tipo_obligacion;


SET default_with_oids = true;

--
-- TOC entry 3755 (class 1259 OID 16971)
-- Dependencies: 4532 4533 4534 4535 4536 12
-- Name: ttipo_planilla; Type: TABLE; Schema: rhum; Owner: rchumacero; Tablespace: 
--

CREATE TABLE ttipo_planilla (
    id_tipo_planilla integer NOT NULL,
    nombre character varying(50),
    descripcion character varying(300),
    tipo character varying(10) DEFAULT 'sueldo'::character varying,
    basica character varying(2) DEFAULT 'no'::character varying,
    estado_reg character varying DEFAULT 'activo'::character varying,
    id_moneda integer NOT NULL,
    id_usuario_reg integer,
    fecha_reg date DEFAULT (now())::date,
    id_usuario_mod integer,
    fecha_mod date DEFAULT (now())::date
);


ALTER TABLE rhum.ttipo_planilla OWNER TO rchumacero;

--
-- TOC entry 3756 (class 1259 OID 16982)
-- Dependencies: 12 3755
-- Name: ttipo_planilla_id_tipo_planilla_seq; Type: SEQUENCE; Schema: rhum; Owner: rchumacero
--

CREATE SEQUENCE ttipo_planilla_id_tipo_planilla_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rhum.ttipo_planilla_id_tipo_planilla_seq OWNER TO rchumacero;

--
-- TOC entry 6195 (class 0 OID 0)
-- Dependencies: 3756
-- Name: ttipo_planilla_id_tipo_planilla_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: rchumacero
--

ALTER SEQUENCE ttipo_planilla_id_tipo_planilla_seq OWNED BY ttipo_planilla.id_tipo_planilla;


--
-- TOC entry 4001 (class 1259 OID 2106634)
-- Dependencies: 4901 4902 4903 4905 12 3708
-- Name: tuo; Type: TABLE; Schema: rhum; Owner: mzambrana; Tablespace: 
--

CREATE TABLE tuo (
    id_uo integer NOT NULL,
    nombre_unidad character varying(100),
    nombre_cargo character varying(50),
    cargo_individual character varying(2),
    descripcion character varying(100),
    presupuesta character varying(2),
    codigo character varying(15),
    nodo_base character varying(2) DEFAULT 'no'::character varying NOT NULL,
    gerencia character varying(2),
    correspondencia character varying(2)
)
INHERITS (public.tbase)
WITH (fillfactor=10);


ALTER TABLE rhum.tuo OWNER TO mzambrana;

--
-- TOC entry 6196 (class 0 OID 0)
-- Dependencies: 4001
-- Name: COLUMN tuo.nodo_base; Type: COMMENT; Schema: rhum; Owner: mzambrana
--

COMMENT ON COLUMN tuo.nodo_base IS 'Identifica la raiz del organigrama';


--
-- TOC entry 3999 (class 1259 OID 2106193)
-- Dependencies: 4897 4898 4899 12 3708
-- Name: tuo_funcionario; Type: TABLE; Schema: rhum; Owner: mzambrana; Tablespace: 
--

CREATE TABLE tuo_funcionario (
    estado_reg character varying(10) NOT NULL,
    id_uo_funcionario integer NOT NULL,
    id_uo integer,
    id_funcionario integer,
    fecha_asignacion date,
    fecha_finalizacion date
)
INHERITS (public.tbase)
WITH (fillfactor=10);
ALTER TABLE ONLY tuo_funcionario ALTER COLUMN id_uo SET STATISTICS 0;


ALTER TABLE rhum.tuo_funcionario OWNER TO mzambrana;

--
-- TOC entry 6197 (class 0 OID 0)
-- Dependencies: 3999
-- Name: COLUMN tuo_funcionario.estado_reg; Type: COMMENT; Schema: rhum; Owner: mzambrana
--

COMMENT ON COLUMN tuo_funcionario.estado_reg IS 'activo :  relacion vigente
eliminado: relacion eliminada no se tiene que considerar 
finalizada: el funcionario se le cambiio el cargo, se tiene que considerar como historico 
finalizado:';


--
-- TOC entry 3998 (class 1259 OID 2106191)
-- Dependencies: 3999 12
-- Name: tuo_funcionario_id_uo_funcionario_seq; Type: SEQUENCE; Schema: rhum; Owner: mzambrana
--

CREATE SEQUENCE tuo_funcionario_id_uo_funcionario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rhum.tuo_funcionario_id_uo_funcionario_seq OWNER TO mzambrana;

--
-- TOC entry 6198 (class 0 OID 0)
-- Dependencies: 3998
-- Name: tuo_funcionario_id_uo_funcionario_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: mzambrana
--

ALTER SEQUENCE tuo_funcionario_id_uo_funcionario_seq OWNED BY tuo_funcionario.id_uo_funcionario;


--
-- TOC entry 4000 (class 1259 OID 2106632)
-- Dependencies: 12 4001
-- Name: tuo_id_uo_seq; Type: SEQUENCE; Schema: rhum; Owner: mzambrana
--

CREATE SEQUENCE tuo_id_uo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rhum.tuo_id_uo_seq OWNER TO mzambrana;

--
-- TOC entry 6199 (class 0 OID 0)
-- Dependencies: 4000
-- Name: tuo_id_uo_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: mzambrana
--

ALTER SEQUENCE tuo_id_uo_seq OWNED BY tuo.id_uo;


--
-- TOC entry 4025 (class 1259 OID 2990219)
-- Dependencies: 4224 12
-- Name: vfuncionario; Type: VIEW; Schema: rhum; Owner: mzambrana
--

CREATE VIEW vfuncionario AS
    SELECT funcio.id_funcionario, person.nombre_completo1 AS desc_funcionario1, person.nombre_completo2 AS desc_funcionario2, person.num_documento AS num_doc, person.ci, funcio.codigo, funcio.estado_reg FROM (tfuncionario funcio JOIN segu.vpersona person ON ((funcio.id_persona = person.id_persona)));


ALTER TABLE rhum.vfuncionario OWNER TO mzambrana;

--
-- TOC entry 4026 (class 1259 OID 2990223)
-- Dependencies: 4225 12
-- Name: vfuncionario_cargo; Type: VIEW; Schema: rhum; Owner: mzambrana
--

CREATE VIEW vfuncionario_cargo AS
    SELECT uof.id_uo_funcionario, funcio.id_funcionario, person.nombre_completo1 AS desc_funcionario1, person.nombre_completo2 AS desc_funcionario2, uo.id_uo, uo.nombre_cargo, uof.fecha_asignacion, uof.fecha_finalizacion, person.num_documento AS num_doc, person.ci, funcio.codigo, funcio.email_empresa, funcio.estado_reg AS estado_reg_fun, uof.estado_reg AS estado_reg_asi FROM (((tfuncionario funcio JOIN segu.vpersona person ON ((funcio.id_persona = person.id_persona))) JOIN tuo_funcionario uof ON ((uof.id_funcionario = funcio.id_funcionario))) JOIN tuo uo ON ((uo.id_uo = uof.id_funcionario)));


ALTER TABLE rhum.vfuncionario_cargo OWNER TO mzambrana;

SET search_path = saj, pg_catalog;

--
-- TOC entry 3967 (class 1259 OID 1951733)
-- Dependencies: 4853 4854 91
-- Name: tboleta; Type: TABLE; Schema: saj; Owner: mzambrana; Tablespace: 
--

CREATE TABLE tboleta (
    id_boleta integer NOT NULL,
    id_proceso_contrato integer,
    id_moneda integer,
    id_institucion_banco integer,
    doc_garantia character varying,
    extension character varying,
    version integer DEFAULT 0 NOT NULL,
    tipo character varying,
    fecha_ini date,
    fecha_fin date,
    estado character varying,
    numero character varying(40),
    monto numeric(18,2),
    fecha_suscripcion date,
    fecha_vencimiento date,
    observaciones character varying,
    orden integer,
    estado_reg character varying(10),
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer,
    fecha_mod date,
    id_usuario_mod integer,
    id_alarma integer[],
    id_boleta_fk integer,
    "aA" bigint
);
ALTER TABLE ONLY tboleta ALTER COLUMN id_moneda SET STATISTICS 0;


ALTER TABLE saj.tboleta OWNER TO mzambrana;

--
-- TOC entry 3966 (class 1259 OID 1951731)
-- Dependencies: 91 3967
-- Name: tboleta_id_boleta_seq; Type: SEQUENCE; Schema: saj; Owner: mzambrana
--

CREATE SEQUENCE tboleta_id_boleta_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE saj.tboleta_id_boleta_seq OWNER TO mzambrana;

--
-- TOC entry 6200 (class 0 OID 0)
-- Dependencies: 3966
-- Name: tboleta_id_boleta_seq; Type: SEQUENCE OWNED BY; Schema: saj; Owner: mzambrana
--

ALTER SEQUENCE tboleta_id_boleta_seq OWNED BY tboleta.id_boleta;


--
-- TOC entry 3993 (class 1259 OID 2066628)
-- Dependencies: 91
-- Name: tconfig_alerta_id_config_alerta_seq; Type: SEQUENCE; Schema: saj; Owner: rac
--

CREATE SEQUENCE tconfig_alerta_id_config_alerta_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE saj.tconfig_alerta_id_config_alerta_seq OWNER TO rac;

--
-- TOC entry 3965 (class 1259 OID 1951256)
-- Dependencies: 4851 91
-- Name: tdocumento_anexo; Type: TABLE; Schema: saj; Owner: mzambrana; Tablespace: 
--

CREATE TABLE tdocumento_anexo (
    id_documento_anexo integer NOT NULL,
    id_proceso_contrato integer,
    estado_reg character varying(10),
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer,
    fecha_mod date,
    id_usuario_mod integer
);
ALTER TABLE ONLY tdocumento_anexo ALTER COLUMN id_proceso_contrato SET STATISTICS 0;


ALTER TABLE saj.tdocumento_anexo OWNER TO mzambrana;

--
-- TOC entry 3964 (class 1259 OID 1951254)
-- Dependencies: 91 3965
-- Name: tdocumento_anexo_id_documento_anexo_seq; Type: SEQUENCE; Schema: saj; Owner: mzambrana
--

CREATE SEQUENCE tdocumento_anexo_id_documento_anexo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE saj.tdocumento_anexo_id_documento_anexo_seq OWNER TO mzambrana;

--
-- TOC entry 6201 (class 0 OID 0)
-- Dependencies: 3964
-- Name: tdocumento_anexo_id_documento_anexo_seq; Type: SEQUENCE OWNED BY; Schema: saj; Owner: mzambrana
--

ALTER SEQUENCE tdocumento_anexo_id_documento_anexo_seq OWNED BY tdocumento_anexo.id_documento_anexo;


--
-- TOC entry 3957 (class 1259 OID 1945718)
-- Dependencies: 4835 4836 91
-- Name: testado; Type: TABLE; Schema: saj; Owner: mzambrana; Tablespace: 
--

CREATE TABLE testado (
    id_estado integer NOT NULL,
    codigo character varying(20) NOT NULL,
    nombre character varying(255) NOT NULL,
    orden integer NOT NULL,
    dias numeric(18,2),
    admite_boleta character varying(2),
    admite_anexo character varying(2),
    estado_reg character varying(10),
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer NOT NULL,
    id_usuario_mod integer,
    fecha_mod date DEFAULT now()
);


ALTER TABLE saj.testado OWNER TO mzambrana;

--
-- TOC entry 3956 (class 1259 OID 1945716)
-- Dependencies: 91 3957
-- Name: testado_id_estado_seq; Type: SEQUENCE; Schema: saj; Owner: mzambrana
--

CREATE SEQUENCE testado_id_estado_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE saj.testado_id_estado_seq OWNER TO mzambrana;

--
-- TOC entry 6202 (class 0 OID 0)
-- Dependencies: 3956
-- Name: testado_id_estado_seq; Type: SEQUENCE OWNED BY; Schema: saj; Owner: mzambrana
--

ALTER SEQUENCE testado_id_estado_seq OWNED BY testado.id_estado;


--
-- TOC entry 3963 (class 1259 OID 1951108)
-- Dependencies: 4846 4847 4848 4849 91
-- Name: testado_proceso; Type: TABLE; Schema: saj; Owner: mzambrana; Tablespace: 
--

CREATE TABLE testado_proceso (
    id_estado_proceso integer NOT NULL,
    id_proceso_contrato integer,
    observaciones character varying,
    fecha_ini date DEFAULT now(),
    id_responsable_proceso integer,
    fecha_fin date,
    estado_vigente character varying(30),
    estado_anterior character varying(30),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer,
    fecha_mod date,
    id_usuario_mod integer,
    hora time(0) without time zone DEFAULT now() NOT NULL
);


ALTER TABLE saj.testado_proceso OWNER TO mzambrana;

--
-- TOC entry 3962 (class 1259 OID 1951106)
-- Dependencies: 91 3963
-- Name: testado_proceso_id_estado_proceso_seq; Type: SEQUENCE; Schema: saj; Owner: mzambrana
--

CREATE SEQUENCE testado_proceso_id_estado_proceso_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE saj.testado_proceso_id_estado_proceso_seq OWNER TO mzambrana;

--
-- TOC entry 6203 (class 0 OID 0)
-- Dependencies: 3962
-- Name: testado_proceso_id_estado_proceso_seq; Type: SEQUENCE OWNED BY; Schema: saj; Owner: mzambrana
--

ALTER SEQUENCE testado_proceso_id_estado_proceso_seq OWNED BY testado_proceso.id_estado_proceso;


--
-- TOC entry 3953 (class 1259 OID 1944513)
-- Dependencies: 4828 4829 91
-- Name: ttipo_contrato; Type: TABLE; Schema: saj; Owner: mzambrana; Tablespace: 
--

CREATE TABLE ttipo_contrato (
    id_tipo_contrato integer NOT NULL,
    nombre character varying,
    estado_reg character varying(10),
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer,
    fecha_mod date DEFAULT now(),
    id_usuario_mod integer
);
ALTER TABLE ONLY ttipo_contrato ALTER COLUMN id_tipo_contrato SET STATISTICS 0;


ALTER TABLE saj.ttipo_contrato OWNER TO mzambrana;

--
-- TOC entry 3952 (class 1259 OID 1944511)
-- Dependencies: 91 3953
-- Name: tipo_contrato_id_tipo_contrato_seq; Type: SEQUENCE; Schema: saj; Owner: mzambrana
--

CREATE SEQUENCE tipo_contrato_id_tipo_contrato_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE saj.tipo_contrato_id_tipo_contrato_seq OWNER TO mzambrana;

--
-- TOC entry 6204 (class 0 OID 0)
-- Dependencies: 3952
-- Name: tipo_contrato_id_tipo_contrato_seq; Type: SEQUENCE OWNED BY; Schema: saj; Owner: mzambrana
--

ALTER SEQUENCE tipo_contrato_id_tipo_contrato_seq OWNED BY ttipo_contrato.id_tipo_contrato;


--
-- TOC entry 3955 (class 1259 OID 1945286)
-- Dependencies: 4831 4832 4833 91
-- Name: tmodalidad; Type: TABLE; Schema: saj; Owner: mzambrana; Tablespace: 
--

CREATE TABLE tmodalidad (
    id_modalidad integer NOT NULL,
    nombre character varying,
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer,
    fecha_mod date DEFAULT now(),
    id_usuario_mod integer
);


ALTER TABLE saj.tmodalidad OWNER TO mzambrana;

--
-- TOC entry 3954 (class 1259 OID 1945284)
-- Dependencies: 3955 91
-- Name: tmodalidad_id_modalidad_seq; Type: SEQUENCE; Schema: saj; Owner: mzambrana
--

CREATE SEQUENCE tmodalidad_id_modalidad_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE saj.tmodalidad_id_modalidad_seq OWNER TO mzambrana;

--
-- TOC entry 6205 (class 0 OID 0)
-- Dependencies: 3954
-- Name: tmodalidad_id_modalidad_seq; Type: SEQUENCE OWNED BY; Schema: saj; Owner: mzambrana
--

ALTER SEQUENCE tmodalidad_id_modalidad_seq OWNED BY tmodalidad.id_modalidad;


--
-- TOC entry 3961 (class 1259 OID 1950322)
-- Dependencies: 4842 4843 4844 91
-- Name: tproceso_contrato; Type: TABLE; Schema: saj; Owner: mzambrana; Tablespace: 
--

CREATE TABLE tproceso_contrato (
    id_proceso_contrato integer NOT NULL,
    id_funcionario integer,
    id_uo integer,
    id_proyecto integer,
    id_modalidad integer,
    id_proveedor integer,
    id_rpc integer,
    id_supervisor integer,
    id_representante_legal integer,
    id_moneda integer,
    id_gestion integer,
    id_depto integer,
    id_lugar_suscripcion integer,
    id_tipo_contrato integer,
    doc_contrato character varying(500),
    extension character varying(100),
    version integer DEFAULT 0 NOT NULL,
    numero_contrato character varying,
    numero_cuce character varying(300),
    numero_licitacion character varying,
    numero_oc character varying(50),
    id_oc integer,
    beneficiario character varying,
    fecha_ini date,
    fecha_fin date,
    fecha_suscripcion date,
    objeto_contrato character varying,
    numero_requerimiento character varying,
    multas character varying,
    plazo character varying,
    testimonio character varying,
    fecha_testimonio date,
    origen_recursos character varying,
    forma_pago character varying,
    notario character varying,
    fecha_convocatoria date,
    fecha_aprobacion date,
    fecha_ap_acta date,
    observaciones character varying,
    id_usuario_reg integer,
    fecha_reg date DEFAULT (now())::date NOT NULL,
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    id_usuario_mod integer,
    fecha_mod date,
    estado_proceso character varying(30),
    monto_contrato numeric(18,2),
    id_alarma integer[]
);
ALTER TABLE ONLY tproceso_contrato ALTER COLUMN id_funcionario SET STATISTICS 0;


ALTER TABLE saj.tproceso_contrato OWNER TO mzambrana;

--
-- TOC entry 6206 (class 0 OID 0)
-- Dependencies: 3961
-- Name: COLUMN tproceso_contrato.doc_contrato; Type: COMMENT; Schema: saj; Owner: mzambrana
--

COMMENT ON COLUMN tproceso_contrato.doc_contrato IS 'ruta url del archivo';


--
-- TOC entry 3960 (class 1259 OID 1950320)
-- Dependencies: 3961 91
-- Name: tproceso_contrato_id_proceso_contrato_seq; Type: SEQUENCE; Schema: saj; Owner: mzambrana
--

CREATE SEQUENCE tproceso_contrato_id_proceso_contrato_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE saj.tproceso_contrato_id_proceso_contrato_seq OWNER TO mzambrana;

--
-- TOC entry 6207 (class 0 OID 0)
-- Dependencies: 3960
-- Name: tproceso_contrato_id_proceso_contrato_seq; Type: SEQUENCE OWNED BY; Schema: saj; Owner: mzambrana
--

ALTER SEQUENCE tproceso_contrato_id_proceso_contrato_seq OWNED BY tproceso_contrato.id_proceso_contrato;


--
-- TOC entry 3959 (class 1259 OID 1946225)
-- Dependencies: 4838 4839 4840 91
-- Name: tresponsable_proceso; Type: TABLE; Schema: saj; Owner: mzambrana; Tablespace: 
--

CREATE TABLE tresponsable_proceso (
    id_responsable_proceso integer NOT NULL,
    tipo character varying(30),
    id_funcionario integer,
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer,
    fecha_mod date DEFAULT now(),
    id_usuario_mod integer,
    id_responsable_proceso_anterior integer
);


ALTER TABLE saj.tresponsable_proceso OWNER TO mzambrana;

--
-- TOC entry 3958 (class 1259 OID 1946223)
-- Dependencies: 91 3959
-- Name: tresponsable_proceso_id_responsable_proceso_seq; Type: SEQUENCE; Schema: saj; Owner: mzambrana
--

CREATE SEQUENCE tresponsable_proceso_id_responsable_proceso_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE saj.tresponsable_proceso_id_responsable_proceso_seq OWNER TO mzambrana;

--
-- TOC entry 6208 (class 0 OID 0)
-- Dependencies: 3958
-- Name: tresponsable_proceso_id_responsable_proceso_seq; Type: SEQUENCE OWNED BY; Schema: saj; Owner: mzambrana
--

ALTER SEQUENCE tresponsable_proceso_id_responsable_proceso_seq OWNED BY tresponsable_proceso.id_responsable_proceso;


--
-- TOC entry 4027 (class 1259 OID 2990228)
-- Dependencies: 4226 91
-- Name: vresponsable_proceso; Type: VIEW; Schema: saj; Owner: mzambrana
--

CREATE VIEW vresponsable_proceso AS
    SELECT respro.id_responsable_proceso, respro.tipo, respro.id_funcionario, person.nombre_completo1 AS desc_responsable_proceso FROM ((tresponsable_proceso respro JOIN rhum.tfuncionario funcio ON ((funcio.id_funcionario = respro.id_funcionario))) JOIN segu.vpersona person ON ((person.id_persona = funcio.id_persona)));


ALTER TABLE saj.vresponsable_proceso OWNER TO mzambrana;

SET search_path = sast, pg_catalog;

SET default_with_oids = false;

--
-- TOC entry 3981 (class 1259 OID 1993308)
-- Dependencies: 4877 4878 4879 92 3708
-- Name: testado; Type: TABLE; Schema: sast; Owner: rvasquez; Tablespace: 
--

CREATE TABLE testado (
    id_estado integer NOT NULL,
    nombre character varying(100) NOT NULL,
    orden integer NOT NULL,
    codigo character varying(20) NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE sast.testado OWNER TO rvasquez;

--
-- TOC entry 3980 (class 1259 OID 1993306)
-- Dependencies: 92 3981
-- Name: testado_id_estado_seq; Type: SEQUENCE; Schema: sast; Owner: rvasquez
--

CREATE SEQUENCE testado_id_estado_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sast.testado_id_estado_seq OWNER TO rvasquez;

--
-- TOC entry 6209 (class 0 OID 0)
-- Dependencies: 3980
-- Name: testado_id_estado_seq; Type: SEQUENCE OWNED BY; Schema: sast; Owner: rvasquez
--

ALTER SEQUENCE testado_id_estado_seq OWNED BY testado.id_estado;


--
-- TOC entry 3979 (class 1259 OID 1993294)
-- Dependencies: 4872 4873 4874 4876 92 3708
-- Name: testado_requerimiento; Type: TABLE; Schema: sast; Owner: rvasquez; Tablespace: 
--

CREATE TABLE testado_requerimiento (
    id_estado_requerimiento integer NOT NULL,
    id_requerimiento integer NOT NULL,
    id_depto_usuario integer,
    fecha_ini date,
    hora time(0) without time zone DEFAULT now() NOT NULL,
    observaciones text,
    estado_vigente character varying(100),
    estado_anterior character varying(100),
    fecha_fin date
)
INHERITS (public.tbase);


ALTER TABLE sast.testado_requerimiento OWNER TO rvasquez;

--
-- TOC entry 3978 (class 1259 OID 1993292)
-- Dependencies: 92 3979
-- Name: testado_requerimiento_id_estado_requerimiento_seq; Type: SEQUENCE; Schema: sast; Owner: rvasquez
--

CREATE SEQUENCE testado_requerimiento_id_estado_requerimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sast.testado_requerimiento_id_estado_requerimiento_seq OWNER TO rvasquez;

--
-- TOC entry 6210 (class 0 OID 0)
-- Dependencies: 3978
-- Name: testado_requerimiento_id_estado_requerimiento_seq; Type: SEQUENCE OWNED BY; Schema: sast; Owner: rvasquez
--

ALTER SEQUENCE testado_requerimiento_id_estado_requerimiento_seq OWNED BY testado_requerimiento.id_estado_requerimiento;


--
-- TOC entry 3983 (class 1259 OID 1993322)
-- Dependencies: 4881 4882 4883 3708 92
-- Name: ttipo_requerimiento; Type: TABLE; Schema: sast; Owner: rvasquez; Tablespace: 
--

CREATE TABLE ttipo_requerimiento (
    id_tipo_requerimiento integer NOT NULL,
    nombre character varying(100)
)
INHERITS (public.tbase);


ALTER TABLE sast.ttipo_requerimiento OWNER TO rvasquez;

--
-- TOC entry 3982 (class 1259 OID 1993320)
-- Dependencies: 92 3983
-- Name: tipo_requerimiento_id_tipo_requerimiento_seq; Type: SEQUENCE; Schema: sast; Owner: rvasquez
--

CREATE SEQUENCE tipo_requerimiento_id_tipo_requerimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sast.tipo_requerimiento_id_tipo_requerimiento_seq OWNER TO rvasquez;

--
-- TOC entry 6211 (class 0 OID 0)
-- Dependencies: 3982
-- Name: tipo_requerimiento_id_tipo_requerimiento_seq; Type: SEQUENCE OWNED BY; Schema: sast; Owner: rvasquez
--

ALTER SEQUENCE tipo_requerimiento_id_tipo_requerimiento_seq OWNED BY ttipo_requerimiento.id_tipo_requerimiento;


--
-- TOC entry 3973 (class 1259 OID 1986002)
-- Dependencies: 92
-- Name: trequerimiento_id_requerimiento_seq; Type: SEQUENCE; Schema: sast; Owner: rvasquez
--

CREATE SEQUENCE trequerimiento_id_requerimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE sast.trequerimiento_id_requerimiento_seq OWNER TO rvasquez;

--
-- TOC entry 3977 (class 1259 OID 1993280)
-- Dependencies: 4865 4866 4867 4869 4870 4871 92 3708
-- Name: trequerimientos; Type: TABLE; Schema: sast; Owner: rvasquez; Tablespace: 
--

CREATE TABLE trequerimientos (
    id_requerimiento integer NOT NULL,
    id_funcionario integer NOT NULL,
    id_tipo_requerimiento integer NOT NULL,
    id_depto integer NOT NULL,
    estado_requerimiento character varying(30),
    descripcion text,
    extension character varying(3),
    version integer DEFAULT 0 NOT NULL,
    id_gestion integer,
    numero_requerimiento character varying,
    solucion character varying(5000),
    hora_requer time(0) without time zone DEFAULT now(),
    fecha_requer date DEFAULT now(),
    captura1 character varying(5000)
)
INHERITS (public.tbase);


ALTER TABLE sast.trequerimientos OWNER TO rvasquez;

--
-- TOC entry 6212 (class 0 OID 0)
-- Dependencies: 3977
-- Name: COLUMN trequerimientos.captura1; Type: COMMENT; Schema: sast; Owner: rvasquez
--

COMMENT ON COLUMN trequerimientos.captura1 IS 'ruta url del archivo';


--
-- TOC entry 3976 (class 1259 OID 1993278)
-- Dependencies: 92 3977
-- Name: trequerimientos_id_requerimiento_seq; Type: SEQUENCE; Schema: sast; Owner: rvasquez
--

CREATE SEQUENCE trequerimientos_id_requerimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sast.trequerimientos_id_requerimiento_seq OWNER TO rvasquez;

--
-- TOC entry 6213 (class 0 OID 0)
-- Dependencies: 3976
-- Name: trequerimientos_id_requerimiento_seq; Type: SEQUENCE OWNED BY; Schema: sast; Owner: rvasquez
--

ALTER SEQUENCE trequerimientos_id_requerimiento_seq OWNED BY trequerimientos.id_requerimiento;


--
-- TOC entry 4030 (class 1259 OID 2990243)
-- Dependencies: 4229 92
-- Name: vdepto_usuario; Type: VIEW; Schema: sast; Owner: mzambrana
--

CREATE VIEW vdepto_usuario AS
    SELECT depusu.id_depto_usuario, depusu.cargo AS funcion, depusu.id_usuario, person.nombre_completo1 AS desc_depto_usuario FROM ((param.tdepto_usuario depusu JOIN segu.tusuario usuario ON ((usuario.id_usuario = depusu.id_usuario))) JOIN segu.vpersona person ON ((person.id_persona = usuario.id_persona)));


ALTER TABLE sast.vdepto_usuario OWNER TO mzambrana;

SET search_path = secont, pg_catalog;

--
-- TOC entry 3757 (class 1259 OID 16984)
-- Dependencies: 13
-- Name: alarma; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE alarma (
    id_alarma integer NOT NULL,
    id_proyecto integer,
    alarma_contrato boolean,
    alarma_garantia boolean,
    dias_contrato integer,
    dias_garantia integer,
    dias_proceso integer,
    fecha_reg date,
    estado_reg character varying(15),
    fecha_cambio date
);


ALTER TABLE secont.alarma OWNER TO rchumacero;

--
-- TOC entry 3758 (class 1259 OID 16987)
-- Dependencies: 13
-- Name: contratista; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE contratista (
    id_contratista integer NOT NULL,
    id_persona_juridica integer,
    id_persona integer,
    nit character varying(20),
    tipo text,
    obs text,
    estado_reg character varying(15)
);


ALTER TABLE secont.contratista OWNER TO rchumacero;

--
-- TOC entry 3759 (class 1259 OID 16993)
-- Dependencies: 13 3758
-- Name: contratista_id_contratista_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE contratista_id_contratista_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.contratista_id_contratista_seq OWNER TO rchumacero;

--
-- TOC entry 6214 (class 0 OID 0)
-- Dependencies: 3759
-- Name: contratista_id_contratista_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE contratista_id_contratista_seq OWNED BY contratista.id_contratista;


--
-- TOC entry 3760 (class 1259 OID 16995)
-- Dependencies: 13
-- Name: contrato; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE contrato (
    id_contrato integer NOT NULL,
    id_representante integer,
    id_empleado integer,
    id_proyecto integer,
    emp_id_empleado integer,
    numero character varying(10),
    objeto text,
    gerencia text,
    moneda character varying(50),
    monto_cifra double precision,
    multas double precision,
    forma_pago text,
    origen_recursos text,
    fecha_ini date,
    fecha_fin date,
    forma_contratacion text,
    tipo_contrato text,
    doc_contrato text,
    numero_licitacion character varying(50),
    numero_cuce character varying(50),
    lugar_sus text,
    fecha_sus date,
    obs text,
    intermediario text,
    estado_reg character varying(15),
    beneficiario text,
    id_requerimiento integer NOT NULL
);


ALTER TABLE secont.contrato OWNER TO rchumacero;

--
-- TOC entry 3761 (class 1259 OID 17001)
-- Dependencies: 13 3760
-- Name: contrato_id_contrato_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE contrato_id_contrato_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.contrato_id_contrato_seq OWNER TO rchumacero;

--
-- TOC entry 6215 (class 0 OID 0)
-- Dependencies: 3761
-- Name: contrato_id_contrato_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE contrato_id_contrato_seq OWNED BY contrato.id_contrato;


--
-- TOC entry 3762 (class 1259 OID 17003)
-- Dependencies: 13
-- Name: correspondencia; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE correspondencia (
    id_correspondencia integer NOT NULL,
    id_contrato integer,
    cite character varying(50),
    tipo_correspondencia text,
    remite text,
    recibe text,
    fecha_emision date,
    fecha_recepcion date,
    lugar_archivo text,
    doc_correspondencia text,
    contenido text,
    estado_reg character varying(15),
    obs text
);


ALTER TABLE secont.correspondencia OWNER TO rchumacero;

--
-- TOC entry 3763 (class 1259 OID 17009)
-- Dependencies: 13 3762
-- Name: correspondencia_id_correspondencia_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE correspondencia_id_correspondencia_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.correspondencia_id_correspondencia_seq OWNER TO rchumacero;

--
-- TOC entry 6216 (class 0 OID 0)
-- Dependencies: 3763
-- Name: correspondencia_id_correspondencia_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE correspondencia_id_correspondencia_seq OWNED BY correspondencia.id_correspondencia;


--
-- TOC entry 3764 (class 1259 OID 17011)
-- Dependencies: 13
-- Name: doc_anexo; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE doc_anexo (
    id_documento integer NOT NULL,
    id_contrato integer,
    denominacion_doc text,
    desc_archivo text,
    doc_archivo text,
    obs text,
    estado_reg character varying(15)
);


ALTER TABLE secont.doc_anexo OWNER TO rchumacero;

--
-- TOC entry 3765 (class 1259 OID 17017)
-- Dependencies: 13 3764
-- Name: doc_anexo_id_documento_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE doc_anexo_id_documento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.doc_anexo_id_documento_seq OWNER TO rchumacero;

--
-- TOC entry 6217 (class 0 OID 0)
-- Dependencies: 3765
-- Name: doc_anexo_id_documento_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE doc_anexo_id_documento_seq OWNED BY doc_anexo.id_documento;


--
-- TOC entry 3766 (class 1259 OID 17019)
-- Dependencies: 13
-- Name: empleado; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE empleado (
    id_personal integer NOT NULL,
    id_persona integer NOT NULL,
    id_unidad integer,
    cod_empleado character varying(150),
    oficina text,
    regional text,
    gerencia text,
    cargo text,
    obs text,
    estado_reg character varying(15)
);


ALTER TABLE secont.empleado OWNER TO rchumacero;

--
-- TOC entry 3767 (class 1259 OID 17025)
-- Dependencies: 13 3766
-- Name: empleado_id_personal_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE empleado_id_personal_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.empleado_id_personal_seq OWNER TO rchumacero;

--
-- TOC entry 6218 (class 0 OID 0)
-- Dependencies: 3767
-- Name: empleado_id_personal_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE empleado_id_personal_seq OWNED BY empleado.id_personal;


--
-- TOC entry 3768 (class 1259 OID 17027)
-- Dependencies: 4544 13
-- Name: estado; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE estado (
    id_estado integer NOT NULL,
    nombre_estado character varying(100) NOT NULL,
    desc_estado character varying NOT NULL,
    orden integer NOT NULL,
    rango_inf integer NOT NULL,
    rango_sup integer NOT NULL,
    estado_reg character varying(15) DEFAULT 'activo'::character varying NOT NULL
);


ALTER TABLE secont.estado OWNER TO rchumacero;

--
-- TOC entry 3769 (class 1259 OID 17034)
-- Dependencies: 13 3768
-- Name: estado_id_estado_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE estado_id_estado_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.estado_id_estado_seq OWNER TO rchumacero;

--
-- TOC entry 6219 (class 0 OID 0)
-- Dependencies: 3769
-- Name: estado_id_estado_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE estado_id_estado_seq OWNED BY estado.id_estado;


--
-- TOC entry 3770 (class 1259 OID 17036)
-- Dependencies: 13
-- Name: estado_requerimiento; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE estado_requerimiento (
    id_estado_requerimiento integer NOT NULL,
    id_requerimiento integer,
    id_estado integer,
    fecha_ini date,
    fecha_fin date,
    estado_reg character varying(15),
    observaciones text
);


ALTER TABLE secont.estado_requerimiento OWNER TO rchumacero;

--
-- TOC entry 3771 (class 1259 OID 17042)
-- Dependencies: 13 3770
-- Name: estado_requerimiento_id_estado_requerimiento_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE estado_requerimiento_id_estado_requerimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.estado_requerimiento_id_estado_requerimiento_seq OWNER TO rchumacero;

--
-- TOC entry 6220 (class 0 OID 0)
-- Dependencies: 3771
-- Name: estado_requerimiento_id_estado_requerimiento_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE estado_requerimiento_id_estado_requerimiento_seq OWNED BY estado_requerimiento.id_estado_requerimiento;


--
-- TOC entry 3772 (class 1259 OID 17044)
-- Dependencies: 13
-- Name: garantia; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE garantia (
    id_garantia integer NOT NULL,
    id_contrato integer,
    tipo text,
    numero character varying(10),
    orden character varying(20),
    moneda character varying(50),
    monto_cifra double precision,
    fecha_vencimiento date,
    banco text,
    fecha_sus date,
    lugar_suc text,
    obs text,
    doc_garantia text,
    estado_reg character varying(15)
);


ALTER TABLE secont.garantia OWNER TO rchumacero;

--
-- TOC entry 3773 (class 1259 OID 17050)
-- Dependencies: 13 3772
-- Name: garantia_id_garantia_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE garantia_id_garantia_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.garantia_id_garantia_seq OWNER TO rchumacero;

--
-- TOC entry 6221 (class 0 OID 0)
-- Dependencies: 3773
-- Name: garantia_id_garantia_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE garantia_id_garantia_seq OWNED BY garantia.id_garantia;


--
-- TOC entry 3774 (class 1259 OID 17052)
-- Dependencies: 13
-- Name: informe; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE informe (
    id_informe integer NOT NULL,
    id_contrato integer,
    contenido text,
    cod_informe character varying(50),
    remite text,
    recibido_por text,
    fecha_emision date,
    fecha_recepcion date,
    lugar_archivo text,
    doc_informe text,
    obs text,
    tipo_informe text,
    estado_reg character varying(15)
);


ALTER TABLE secont.informe OWNER TO rchumacero;

--
-- TOC entry 3775 (class 1259 OID 17058)
-- Dependencies: 13 3774
-- Name: informe_id_informe_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE informe_id_informe_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.informe_id_informe_seq OWNER TO rchumacero;

--
-- TOC entry 6222 (class 0 OID 0)
-- Dependencies: 3775
-- Name: informe_id_informe_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE informe_id_informe_seq OWNED BY informe.id_informe;


--
-- TOC entry 3776 (class 1259 OID 17060)
-- Dependencies: 13 3757
-- Name: leg_alarma_id_alarma_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE leg_alarma_id_alarma_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.leg_alarma_id_alarma_seq OWNER TO rchumacero;

--
-- TOC entry 6223 (class 0 OID 0)
-- Dependencies: 3776
-- Name: leg_alarma_id_alarma_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE leg_alarma_id_alarma_seq OWNED BY alarma.id_alarma;


--
-- TOC entry 3777 (class 1259 OID 17062)
-- Dependencies: 13
-- Name: oferta; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE oferta (
    id_oferta integer NOT NULL,
    id_contrato integer,
    nombre_ofertante text,
    descripcion_oferta text,
    fecha_emision date,
    lugar_archivo text,
    doc_oferta text,
    tomos integer,
    obs text,
    estado_reg character varying(15)
);


ALTER TABLE secont.oferta OWNER TO rchumacero;

--
-- TOC entry 3778 (class 1259 OID 17068)
-- Dependencies: 13 3777
-- Name: oferta_id_oferta_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE oferta_id_oferta_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.oferta_id_oferta_seq OWNER TO rchumacero;

--
-- TOC entry 6224 (class 0 OID 0)
-- Dependencies: 3778
-- Name: oferta_id_oferta_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE oferta_id_oferta_seq OWNED BY oferta.id_oferta;


--
-- TOC entry 3779 (class 1259 OID 17070)
-- Dependencies: 13
-- Name: persona_juridica; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE persona_juridica (
    id_persona_juridica integer NOT NULL,
    nombre character varying(150),
    domicilio character varying(300),
    telefono character varying(100),
    correo character varying(100),
    pag_web character varying(150),
    obs text,
    estado_reg character varying(15)
);


ALTER TABLE secont.persona_juridica OWNER TO rchumacero;

--
-- TOC entry 3780 (class 1259 OID 17076)
-- Dependencies: 13 3779
-- Name: persona_juridica_id_persona_juridica_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE persona_juridica_id_persona_juridica_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.persona_juridica_id_persona_juridica_seq OWNER TO rchumacero;

--
-- TOC entry 6225 (class 0 OID 0)
-- Dependencies: 3780
-- Name: persona_juridica_id_persona_juridica_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE persona_juridica_id_persona_juridica_seq OWNED BY persona_juridica.id_persona_juridica;


--
-- TOC entry 3781 (class 1259 OID 17078)
-- Dependencies: 13
-- Name: proyecto; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE proyecto (
    id_proyecto integer NOT NULL,
    denominacion text,
    descripcion text,
    estado_reg character varying(15)
);


ALTER TABLE secont.proyecto OWNER TO rchumacero;

--
-- TOC entry 3782 (class 1259 OID 17084)
-- Dependencies: 13 3781
-- Name: proyecto_id_proyecto_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE proyecto_id_proyecto_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.proyecto_id_proyecto_seq OWNER TO rchumacero;

--
-- TOC entry 6226 (class 0 OID 0)
-- Dependencies: 3782
-- Name: proyecto_id_proyecto_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE proyecto_id_proyecto_seq OWNED BY proyecto.id_proyecto;


--
-- TOC entry 3783 (class 1259 OID 17086)
-- Dependencies: 13
-- Name: representante; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE representante (
    id_representante integer NOT NULL,
    id_contratista integer NOT NULL,
    cargo text,
    respaldo text,
    estado_reg character varying(15),
    obs text,
    id_persona integer NOT NULL
);


ALTER TABLE secont.representante OWNER TO rchumacero;

--
-- TOC entry 3784 (class 1259 OID 17092)
-- Dependencies: 3783 13
-- Name: representante_id_representante_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE representante_id_representante_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.representante_id_representante_seq OWNER TO rchumacero;

--
-- TOC entry 6227 (class 0 OID 0)
-- Dependencies: 3784
-- Name: representante_id_representante_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE representante_id_representante_seq OWNED BY representante.id_representante;


--
-- TOC entry 3785 (class 1259 OID 17094)
-- Dependencies: 13
-- Name: requerimiento; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE requerimiento (
    id_requerimiento integer NOT NULL,
    id_personal integer NOT NULL,
    emp_id_personal integer,
    fecha_requerimiento date NOT NULL,
    hora_requerimiento time without time zone NOT NULL,
    descripcion text NOT NULL,
    estado_reg character varying(15) NOT NULL,
    num_contrato numeric(10,0),
    id_unidad integer NOT NULL,
    nro_requerimiento integer NOT NULL
);


ALTER TABLE secont.requerimiento OWNER TO rchumacero;

--
-- TOC entry 6228 (class 0 OID 0)
-- Dependencies: 3785
-- Name: COLUMN requerimiento.id_personal; Type: COMMENT; Schema: secont; Owner: rchumacero
--

COMMENT ON COLUMN requerimiento.id_personal IS 'solicitante';


--
-- TOC entry 6229 (class 0 OID 0)
-- Dependencies: 3785
-- Name: COLUMN requerimiento.emp_id_personal; Type: COMMENT; Schema: secont; Owner: rchumacero
--

COMMENT ON COLUMN requerimiento.emp_id_personal IS 'abogado';


--
-- TOC entry 3786 (class 1259 OID 17100)
-- Dependencies: 13 3785
-- Name: requerimiento_id_requerimiento_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE requerimiento_id_requerimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.requerimiento_id_requerimiento_seq OWNER TO rchumacero;

--
-- TOC entry 6230 (class 0 OID 0)
-- Dependencies: 3786
-- Name: requerimiento_id_requerimiento_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE requerimiento_id_requerimiento_seq OWNED BY requerimiento.id_requerimiento;


--
-- TOC entry 3787 (class 1259 OID 17102)
-- Dependencies: 13
-- Name: resolucion; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE resolucion (
    id_resolucion integer NOT NULL,
    id_contrato integer,
    numero_resolucion character varying(20),
    fecha_emision date,
    lugar_archivo text,
    doc_resolucion text,
    contenido text,
    obs text,
    tipo_resolucion text,
    estado_reg character varying(15)
);


ALTER TABLE secont.resolucion OWNER TO rchumacero;

--
-- TOC entry 3788 (class 1259 OID 17108)
-- Dependencies: 13 3787
-- Name: resolucion_id_resolucion_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE resolucion_id_resolucion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.resolucion_id_resolucion_seq OWNER TO rchumacero;

--
-- TOC entry 6231 (class 0 OID 0)
-- Dependencies: 3788
-- Name: resolucion_id_resolucion_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE resolucion_id_resolucion_seq OWNED BY resolucion.id_resolucion;


--
-- TOC entry 3789 (class 1259 OID 17110)
-- Dependencies: 13
-- Name: unidad; Type: TABLE; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE TABLE unidad (
    id_unidad integer NOT NULL,
    cod_unidad character varying(50),
    nombre_unidad text,
    gerencia_unidad text,
    estado_reg character varying(15)
);


ALTER TABLE secont.unidad OWNER TO rchumacero;

--
-- TOC entry 3790 (class 1259 OID 17116)
-- Dependencies: 13 3789
-- Name: unidad_id_unidad_seq; Type: SEQUENCE; Schema: secont; Owner: rchumacero
--

CREATE SEQUENCE unidad_id_unidad_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE secont.unidad_id_unidad_seq OWNER TO rchumacero;

--
-- TOC entry 6232 (class 0 OID 0)
-- Dependencies: 3790
-- Name: unidad_id_unidad_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: rchumacero
--

ALTER SEQUENCE unidad_id_unidad_seq OWNED BY unidad.id_unidad;


--
-- TOC entry 4028 (class 1259 OID 2990233)
-- Dependencies: 4227 13
-- Name: v_contratista; Type: VIEW; Schema: secont; Owner: mzambrana
--

CREATE VIEW v_contratista AS
    SELECT c.id_contratista, c.id_persona_juridica, c.id_persona, c.nit, c.tipo, c.obs, c.estado_reg, (CASE WHEN (c.tipo = 'Persona Natural'::text) THEN (p.nombre_completo1)::character varying ELSE pj.nombre END)::text AS nombre, pj.nombre AS nombre_institucion, p.nombre_completo1 AS nombre_persona FROM ((contratista c LEFT JOIN persona_juridica pj ON ((pj.id_persona_juridica = c.id_persona_juridica))) LEFT JOIN segu.vpersona p ON ((c.id_persona = p.id_persona)));


ALTER TABLE secont.v_contratista OWNER TO mzambrana;

--
-- TOC entry 3792 (class 1259 OID 17130)
-- Dependencies: 4213 13
-- Name: v_empleado; Type: VIEW; Schema: secont; Owner: rchumacero
--

CREATE VIEW v_empleado AS
    SELECT p.id_persona, p.apellido_materno AS ap_materno, p.apellido_paterno AS ap_paterno, p.nombre, p.ci, e.id_personal, e.cod_empleado, e.cargo, e.estado_reg, e.gerencia, e.oficina, e.regional, e.obs, (((((COALESCE(p.nombre, ''::character varying))::text || ' '::text) || (COALESCE(p.apellido_paterno, ''::character varying))::text) || ' '::text) || (COALESCE(p.apellido_materno, ''::character varying))::text) AS nombre_completo1, (((((COALESCE(p.apellido_paterno, ''::character varying))::text || ' '::text) || (COALESCE(p.apellido_materno, ''::character varying))::text) || ' '::text) || (COALESCE(p.nombre, ''::character varying))::text) AS nombre_completo2, e.id_unidad, u.nombre_unidad FROM ((empleado e JOIN segu.tpersona p ON ((p.id_persona = e.id_persona))) LEFT JOIN unidad u ON ((e.id_unidad = u.id_unidad)));


ALTER TABLE secont.v_empleado OWNER TO rchumacero;

--
-- TOC entry 3793 (class 1259 OID 17135)
-- Dependencies: 4214 13
-- Name: v_estado_requerimiento; Type: VIEW; Schema: secont; Owner: rchumacero
--

CREATE VIEW v_estado_requerimiento AS
    SELECT er.id_estado_requerimiento, er.id_requerimiento, e.nombre_estado, er.fecha_ini, er.fecha_fin, er.observaciones, er.estado_reg FROM (estado_requerimiento er JOIN estado e ON ((er.id_estado = e.id_estado))) ORDER BY er.id_requerimiento, er.id_estado_requerimiento DESC;


ALTER TABLE secont.v_estado_requerimiento OWNER TO rchumacero;

--
-- TOC entry 3794 (class 1259 OID 17139)
-- Dependencies: 4215 13
-- Name: v_requerimiento; Type: VIEW; Schema: secont; Owner: rchumacero
--

CREATE VIEW v_requerimiento AS
    SELECT req.id_requerimiento, req.fecha_requerimiento, req.estado_reg, req.descripcion, req.num_contrato, abo.id_personal AS id_personal_abo, abo.id_persona AS id_persona_abo, abo.nombre_completo2 AS nombre_completo_abo, sol.id_personal AS id_personal_sol, sol.id_persona AS id_persona_sol, sol.nombre_completo2 AS nombre_completo_sol, uni.id_unidad, uni.nombre_unidad, er.fecha_ini, er.id_estado, e.nombre_estado, e.orden, er.observaciones, req.nro_requerimiento FROM (((((requerimiento req JOIN v_empleado sol ON ((sol.id_personal = req.id_personal))) LEFT JOIN v_empleado abo ON ((abo.id_personal = req.id_personal))) JOIN unidad uni ON ((uni.id_unidad = req.id_unidad))) JOIN estado_requerimiento er ON (((er.id_requerimiento = req.id_requerimiento) AND ((er.estado_reg)::text = 'activo'::text)))) JOIN estado e ON ((e.id_estado = er.id_estado)));


ALTER TABLE secont.v_requerimiento OWNER TO rchumacero;

SET search_path = segu, pg_catalog;

--
-- TOC entry 3795 (class 1259 OID 17144)
-- Dependencies: 4560 4561 1610 14
-- Name: tactividad; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tactividad (
    id_actividad integer NOT NULL,
    nombre character varying(150) NOT NULL,
    descripcion character varying(500),
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL,
    codigo character varying
);


ALTER TABLE segu.tactividad OWNER TO postgres;

--
-- TOC entry 3796 (class 1259 OID 17152)
-- Dependencies: 14 3795
-- Name: actividad_id_actividad_seq; Type: SEQUENCE; Schema: segu; Owner: postgres
--

CREATE SEQUENCE actividad_id_actividad_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.actividad_id_actividad_seq OWNER TO postgres;

--
-- TOC entry 6233 (class 0 OID 0)
-- Dependencies: 3796
-- Name: actividad_id_actividad_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: postgres
--

ALTER SEQUENCE actividad_id_actividad_seq OWNED BY tactividad.id_actividad;


--
-- TOC entry 3797 (class 1259 OID 17154)
-- Dependencies: 14
-- Name: clasificador_id_clasificador_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE clasificador_id_clasificador_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE segu.clasificador_id_clasificador_seq OWNER TO rchumacero;

--
-- TOC entry 3798 (class 1259 OID 17156)
-- Dependencies: 4563 4564 1614 1614 1610 14
-- Name: testructura_dato; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE testructura_dato (
    id_estructura_dato integer NOT NULL,
    id_subsistema integer NOT NULL,
    nombre character varying(50),
    descripcion text,
    encripta si_no,
    log si_no,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL,
    tipo character varying(30) NOT NULL
);


ALTER TABLE segu.testructura_dato OWNER TO postgres;

--
-- TOC entry 3799 (class 1259 OID 17164)
-- Dependencies: 14 3798
-- Name: estructura_dato_id_estructura_dato_seq; Type: SEQUENCE; Schema: segu; Owner: postgres
--

CREATE SEQUENCE estructura_dato_id_estructura_dato_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.estructura_dato_id_estructura_dato_seq OWNER TO postgres;

--
-- TOC entry 6234 (class 0 OID 0)
-- Dependencies: 3799
-- Name: estructura_dato_id_estructura_dato_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: postgres
--

ALTER SEQUENCE estructura_dato_id_estructura_dato_seq OWNED BY testructura_dato.id_estructura_dato;


--
-- TOC entry 3800 (class 1259 OID 17166)
-- Dependencies: 4566 4567 1610 14
-- Name: testructura_gui; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE testructura_gui (
    id_estructura_gui integer NOT NULL,
    id_gui integer NOT NULL,
    fk_id_gui integer NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL
);


ALTER TABLE segu.testructura_gui OWNER TO postgres;

--
-- TOC entry 3801 (class 1259 OID 17174)
-- Dependencies: 14 3800
-- Name: estructura_gui_id_estructura_gui_seq; Type: SEQUENCE; Schema: segu; Owner: postgres
--

CREATE SEQUENCE estructura_gui_id_estructura_gui_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.estructura_gui_id_estructura_gui_seq OWNER TO postgres;

--
-- TOC entry 6235 (class 0 OID 0)
-- Dependencies: 3801
-- Name: estructura_gui_id_estructura_gui_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: postgres
--

ALTER SEQUENCE estructura_gui_id_estructura_gui_seq OWNED BY testructura_gui.id_estructura_gui;


--
-- TOC entry 3802 (class 1259 OID 17176)
-- Dependencies: 14
-- Name: funcion_id_funcion_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE funcion_id_funcion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE segu.funcion_id_funcion_seq OWNER TO rchumacero;

--
-- TOC entry 3803 (class 1259 OID 17178)
-- Dependencies: 4569 1610 14
-- Name: tgui_rol; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tgui_rol (
    id_gui_rol integer NOT NULL,
    id_rol integer NOT NULL,
    id_gui integer NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo NOT NULL
);


ALTER TABLE segu.tgui_rol OWNER TO postgres;

--
-- TOC entry 3804 (class 1259 OID 17185)
-- Dependencies: 14 3803
-- Name: gui_rol_id_gui_rol_seq; Type: SEQUENCE; Schema: segu; Owner: postgres
--

CREATE SEQUENCE gui_rol_id_gui_rol_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.gui_rol_id_gui_rol_seq OWNER TO postgres;

--
-- TOC entry 6236 (class 0 OID 0)
-- Dependencies: 3804
-- Name: gui_rol_id_gui_rol_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: postgres
--

ALTER SEQUENCE gui_rol_id_gui_rol_seq OWNED BY tgui_rol.id_gui_rol;


--
-- TOC entry 4123 (class 1259 OID 3511231)
-- Dependencies: 14
-- Name: libreta; Type: TABLE; Schema: segu; Owner: rac; Tablespace: 
--

CREATE TABLE libreta (
    id_libreta integer NOT NULL,
    nombre character varying(15),
    telefono integer,
    obs text
);


ALTER TABLE segu.libreta OWNER TO rac;

--
-- TOC entry 4125 (class 1259 OID 3512003)
-- Dependencies: 5123 5124 5125 14 3708
-- Name: libreta_her; Type: TABLE; Schema: segu; Owner: rac; Tablespace: 
--

CREATE TABLE libreta_her (
    id_libreta_her integer NOT NULL,
    nombre character varying(12),
    telefono integer,
    obs text
)
INHERITS (public.tbase);


ALTER TABLE segu.libreta_her OWNER TO rac;

--
-- TOC entry 4124 (class 1259 OID 3512001)
-- Dependencies: 4125 14
-- Name: libreta_her_id_libreta_her_seq; Type: SEQUENCE; Schema: segu; Owner: rac
--

CREATE SEQUENCE libreta_her_id_libreta_her_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.libreta_her_id_libreta_her_seq OWNER TO rac;

--
-- TOC entry 6237 (class 0 OID 0)
-- Dependencies: 4124
-- Name: libreta_her_id_libreta_her_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: rac
--

ALTER SEQUENCE libreta_her_id_libreta_her_seq OWNED BY libreta_her.id_libreta_her;


--
-- TOC entry 4122 (class 1259 OID 3511229)
-- Dependencies: 4123 14
-- Name: libreta_id_libreta_seq; Type: SEQUENCE; Schema: segu; Owner: rac
--

CREATE SEQUENCE libreta_id_libreta_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.libreta_id_libreta_seq OWNER TO rac;

--
-- TOC entry 6238 (class 0 OID 0)
-- Dependencies: 4122
-- Name: libreta_id_libreta_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: rac
--

ALTER SEQUENCE libreta_id_libreta_seq OWNED BY libreta.id_libreta;


--
-- TOC entry 3805 (class 1259 OID 17187)
-- Dependencies: 14
-- Name: log_id_log_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE log_id_log_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE segu.log_id_log_seq OWNER TO rchumacero;

--
-- TOC entry 3806 (class 1259 OID 17189)
-- Dependencies: 4571 4572 1614 1610 14
-- Name: tpermiso; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tpermiso (
    id_permiso integer NOT NULL,
    id_procedimiento integer NOT NULL,
    id_estructura integer NOT NULL,
    permiso character varying(30),
    acceso si_no DEFAULT 'no'::character varying,
    descripcion text,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo NOT NULL
);


ALTER TABLE segu.tpermiso OWNER TO postgres;

--
-- TOC entry 3807 (class 1259 OID 17197)
-- Dependencies: 14 3806
-- Name: permiso_id_permiso_seq; Type: SEQUENCE; Schema: segu; Owner: postgres
--

CREATE SEQUENCE permiso_id_permiso_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.permiso_id_permiso_seq OWNER TO postgres;

--
-- TOC entry 6239 (class 0 OID 0)
-- Dependencies: 3807
-- Name: permiso_id_permiso_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: postgres
--

ALTER SEQUENCE permiso_id_permiso_seq OWNED BY tpermiso.id_permiso;


--
-- TOC entry 3808 (class 1259 OID 17199)
-- Dependencies: 14
-- Name: primo_id_primo_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE primo_id_primo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE segu.primo_id_primo_seq OWNER TO rchumacero;

--
-- TOC entry 3809 (class 1259 OID 17201)
-- Dependencies: 4574 4575 1614 1608 14
-- Name: tprocedimiento_gui; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tprocedimiento_gui (
    id_procedimiento_gui integer NOT NULL,
    id_procedimiento integer NOT NULL,
    id_gui integer NOT NULL,
    boton si_no NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg public.estado_reg DEFAULT 'activo'::public.estado_reg NOT NULL
);


ALTER TABLE segu.tprocedimiento_gui OWNER TO postgres;

--
-- TOC entry 3810 (class 1259 OID 17209)
-- Dependencies: 14 3809
-- Name: procedimiento_gui_id_procedimiento_gui_seq; Type: SEQUENCE; Schema: segu; Owner: postgres
--

CREATE SEQUENCE procedimiento_gui_id_procedimiento_gui_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.procedimiento_gui_id_procedimiento_gui_seq OWNER TO postgres;

--
-- TOC entry 6240 (class 0 OID 0)
-- Dependencies: 3810
-- Name: procedimiento_gui_id_procedimiento_gui_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: postgres
--

ALTER SEQUENCE procedimiento_gui_id_procedimiento_gui_seq OWNED BY tprocedimiento_gui.id_procedimiento_gui;


--
-- TOC entry 3811 (class 1259 OID 17211)
-- Dependencies: 14
-- Name: procedimiento_id_procedimiento_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE procedimiento_id_procedimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE segu.procedimiento_id_procedimiento_seq OWNER TO rchumacero;

--
-- TOC entry 3812 (class 1259 OID 17213)
-- Dependencies: 4577 4578 4579 14
-- Name: tproyecto; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tproyecto (
    id_proyecto integer NOT NULL,
    nombre character varying(150) NOT NULL,
    descripcion character varying(500),
    fecha_reg timestamp(0) without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    codigo character varying(20),
    id_usuario_reg integer,
    fecha_mod timestamp(0) without time zone DEFAULT now(),
    id_usuario_mod integer
);


ALTER TABLE segu.tproyecto OWNER TO postgres;

--
-- TOC entry 3813 (class 1259 OID 17220)
-- Dependencies: 14 3812
-- Name: proyecto_id_proyecto_seq; Type: SEQUENCE; Schema: segu; Owner: postgres
--

CREATE SEQUENCE proyecto_id_proyecto_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.proyecto_id_proyecto_seq OWNER TO postgres;

--
-- TOC entry 6241 (class 0 OID 0)
-- Dependencies: 3813
-- Name: proyecto_id_proyecto_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: postgres
--

ALTER SEQUENCE proyecto_id_proyecto_seq OWNED BY tproyecto.id_proyecto;


--
-- TOC entry 3814 (class 1259 OID 17222)
-- Dependencies: 4216 14
-- Name: prueba; Type: VIEW; Schema: segu; Owner: rchumacero
--

CREATE VIEW prueba AS
    SELECT pg_stat_activity.datid, pg_stat_activity.datname, pg_stat_activity.procpid, pg_stat_activity.usesysid, pg_stat_activity.usename, pg_stat_activity.application_name, pg_stat_activity.client_addr, pg_stat_activity.client_port, pg_stat_activity.backend_start, pg_stat_activity.xact_start, pg_stat_activity.query_start, pg_stat_activity.waiting, pg_stat_activity.current_query FROM pg_stat_activity;


ALTER TABLE segu.prueba OWNER TO rchumacero;

--
-- TOC entry 3815 (class 1259 OID 17226)
-- Dependencies: 4581 1610 14
-- Name: trecurso; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE trecurso (
    id_recurso integer NOT NULL,
    nombre character varying(50),
    valor character varying(50) NOT NULL,
    observaciones text,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo NOT NULL
);


ALTER TABLE segu.trecurso OWNER TO postgres;

--
-- TOC entry 3816 (class 1259 OID 17233)
-- Dependencies: 14 3815
-- Name: recurso_id_recurso_seq; Type: SEQUENCE; Schema: segu; Owner: postgres
--

CREATE SEQUENCE recurso_id_recurso_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.recurso_id_recurso_seq OWNER TO postgres;

--
-- TOC entry 6242 (class 0 OID 0)
-- Dependencies: 3816
-- Name: recurso_id_recurso_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: postgres
--

ALTER SEQUENCE recurso_id_recurso_seq OWNED BY trecurso.id_recurso;


--
-- TOC entry 3817 (class 1259 OID 17235)
-- Dependencies: 14
-- Name: regional_id_regional_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE regional_id_regional_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE segu.regional_id_regional_seq OWNER TO rchumacero;

--
-- TOC entry 3818 (class 1259 OID 17237)
-- Dependencies: 14
-- Name: rol_id_rol_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE rol_id_rol_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE segu.rol_id_rol_seq OWNER TO rchumacero;

--
-- TOC entry 3819 (class 1259 OID 17239)
-- Dependencies: 4583 1610 14
-- Name: trol_procedimiento_gui; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE trol_procedimiento_gui (
    id_rol_procedimiento integer NOT NULL,
    id_procedimiento_gui integer NOT NULL,
    id_rol integer,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo NOT NULL
);


ALTER TABLE segu.trol_procedimiento_gui OWNER TO postgres;

--
-- TOC entry 3820 (class 1259 OID 17246)
-- Dependencies: 14 3819
-- Name: rol_procedimiento_id_rol_procedimiento_seq; Type: SEQUENCE; Schema: segu; Owner: postgres
--

CREATE SEQUENCE rol_procedimiento_id_rol_procedimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.rol_procedimiento_id_rol_procedimiento_seq OWNER TO postgres;

--
-- TOC entry 6243 (class 0 OID 0)
-- Dependencies: 3820
-- Name: rol_procedimiento_id_rol_procedimiento_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: postgres
--

ALTER SEQUENCE rol_procedimiento_id_rol_procedimiento_seq OWNED BY trol_procedimiento_gui.id_rol_procedimiento;


--
-- TOC entry 3821 (class 1259 OID 17248)
-- Dependencies: 14
-- Name: subsistema_id_subsistema_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE subsistema_id_subsistema_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE segu.subsistema_id_subsistema_seq OWNER TO rchumacero;

SET default_with_oids = true;

--
-- TOC entry 3822 (class 1259 OID 17250)
-- Dependencies: 14
-- Name: tbloqueo_notificacion; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tbloqueo_notificacion (
    id_bloqueo_notificacion integer NOT NULL,
    id_patron_evento integer NOT NULL,
    nombre_patron character varying(100) NOT NULL,
    fecha_hora_ini timestamp(0) without time zone NOT NULL,
    fecha_hora_fin timestamp(0) without time zone NOT NULL,
    estado_reg character varying(10) NOT NULL,
    id_usuario integer,
    usuario character varying(50),
    ip character varying(50) NOT NULL,
    tipo character varying(15) NOT NULL,
    aplicacion character varying(15) NOT NULL,
    tipo_evento character varying(35)
);
ALTER TABLE ONLY tbloqueo_notificacion ALTER COLUMN id_bloqueo_notificacion SET STATISTICS 0;


ALTER TABLE segu.tbloqueo_notificacion OWNER TO postgres;

--
-- TOC entry 3823 (class 1259 OID 17253)
-- Dependencies: 14 3822
-- Name: tbloqueo_notificacion_id_bloqueo_notificacion_seq; Type: SEQUENCE; Schema: segu; Owner: postgres
--

CREATE SEQUENCE tbloqueo_notificacion_id_bloqueo_notificacion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.tbloqueo_notificacion_id_bloqueo_notificacion_seq OWNER TO postgres;

--
-- TOC entry 6244 (class 0 OID 0)
-- Dependencies: 3823
-- Name: tbloqueo_notificacion_id_bloqueo_notificacion_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: postgres
--

ALTER SEQUENCE tbloqueo_notificacion_id_bloqueo_notificacion_seq OWNED BY tbloqueo_notificacion.id_bloqueo_notificacion;


SET default_with_oids = false;

--
-- TOC entry 3824 (class 1259 OID 17255)
-- Dependencies: 4585 4586 4587 1610 14
-- Name: tclasificador; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tclasificador (
    id_clasificador integer DEFAULT nextval(('"segu"."clasificador_id_clasificador_seq"'::text)::regclass) NOT NULL,
    codigo character varying(20),
    descripcion text,
    prioridad integer,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL
);


ALTER TABLE segu.tclasificador OWNER TO postgres;

--
-- TOC entry 4020 (class 1259 OID 2581827)
-- Dependencies: 14
-- Name: temp_menu_prueba; Type: TABLE; Schema: segu; Owner: rac; Tablespace: 
--

CREATE TABLE temp_menu_prueba (
    id_gui integer,
    nombre character varying(50),
    descripcion text,
    nivel integer,
    orden_logico integer,
    ruta_archivo text,
    clase_vista character varying(100),
    "case" character varying
);


ALTER TABLE segu.temp_menu_prueba OWNER TO rac;

--
-- TOC entry 3825 (class 1259 OID 17264)
-- Dependencies: 4588 4589 4590 4591 1610 14
-- Name: tfuncion; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tfuncion (
    id_funcion integer DEFAULT nextval(('"segu"."funcion_id_funcion_seq"'::text)::regclass) NOT NULL,
    nombre character varying(50),
    descripcion text,
    fecha_reg date DEFAULT now() NOT NULL,
    id_subsistema integer NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::public.estado_reg NOT NULL,
    CONSTRAINT chk_id_subsistema CHECK ((id_subsistema > 0))
);


ALTER TABLE segu.tfuncion OWNER TO postgres;

--
-- TOC entry 3826 (class 1259 OID 17273)
-- Dependencies: 4592 4593 4594 1614 1608 14
-- Name: tgui; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tgui (
    id_gui integer DEFAULT nextval(('"segu"."tgui_id_gui_seq"'::text)::regclass) NOT NULL,
    nombre character varying(50),
    descripcion text,
    fecha_reg date DEFAULT now() NOT NULL,
    codigo_gui character varying(30),
    visible si_no,
    orden_logico integer,
    ruta_archivo text,
    nivel integer,
    icono character varying(50),
    id_subsistema integer,
    clase_vista character varying(100),
    estado_reg public.estado_reg DEFAULT 'activo'::public.estado_reg NOT NULL
);


ALTER TABLE segu.tgui OWNER TO postgres;

--
-- TOC entry 6245 (class 0 OID 0)
-- Dependencies: 3826
-- Name: COLUMN tgui.clase_vista; Type: COMMENT; Schema: segu; Owner: postgres
--

COMMENT ON COLUMN tgui.clase_vista IS 'para las interfaces de nivel 2, que corren llamadas directamente por el menu, se necesita el nombre de la clase de la interface en la capa de vista';


--
-- TOC entry 3827 (class 1259 OID 17282)
-- Dependencies: 14
-- Name: tgui_id_gui_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE tgui_id_gui_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE segu.tgui_id_gui_seq OWNER TO rchumacero;

SET default_with_oids = true;

--
-- TOC entry 3828 (class 1259 OID 17284)
-- Dependencies: 14
-- Name: thorario_trabajo; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE thorario_trabajo (
    id_horario_trabajo integer NOT NULL,
    dia_semana integer,
    hora_ini time(0) without time zone,
    hora_fin time(0) without time zone
);
ALTER TABLE ONLY thorario_trabajo ALTER COLUMN dia_semana SET STATISTICS 0;


ALTER TABLE segu.thorario_trabajo OWNER TO postgres;

--
-- TOC entry 3829 (class 1259 OID 17287)
-- Dependencies: 3828 14
-- Name: thorario_trabajo_id_horario_trabajo_seq; Type: SEQUENCE; Schema: segu; Owner: postgres
--

CREATE SEQUENCE thorario_trabajo_id_horario_trabajo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.thorario_trabajo_id_horario_trabajo_seq OWNER TO postgres;

--
-- TOC entry 6246 (class 0 OID 0)
-- Dependencies: 3829
-- Name: thorario_trabajo_id_horario_trabajo_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: postgres
--

ALTER SEQUENCE thorario_trabajo_id_horario_trabajo_seq OWNED BY thorario_trabajo.id_horario_trabajo;


SET default_with_oids = false;

--
-- TOC entry 3830 (class 1259 OID 17289)
-- Dependencies: 4597 4598 1608 14
-- Name: ttipo_documento; Type: TABLE; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE TABLE ttipo_documento (
    id_tipo_documento integer NOT NULL,
    nombre character varying(15) NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg public.estado_reg DEFAULT 'activo'::public.estado_reg NOT NULL
);


ALTER TABLE segu.ttipo_documento OWNER TO rchumacero;

--
-- TOC entry 3831 (class 1259 OID 17294)
-- Dependencies: 14 3830
-- Name: tipo_documento_id_tipo_documento_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE tipo_documento_id_tipo_documento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.tipo_documento_id_tipo_documento_seq OWNER TO rchumacero;

--
-- TOC entry 6247 (class 0 OID 0)
-- Dependencies: 3831
-- Name: tipo_documento_id_tipo_documento_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: rchumacero
--

ALTER SEQUENCE tipo_documento_id_tipo_documento_seq OWNED BY ttipo_documento.id_tipo_documento;


--
-- TOC entry 3832 (class 1259 OID 17296)
-- Dependencies: 4599 4600 4601 1611 1610 14
-- Name: tlog_; Type: TABLE; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tlog_ (
    id_log integer DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass) NOT NULL,
    id_usuario integer,
    id_subsistema integer,
    id_procedimiento integer,
    mac_maquina character varying(30),
    ip_maquina character varying(30) NOT NULL,
    tipo_log error_advertencia_informativo,
    descripcion text,
    fecha_reg timestamp(0) without time zone DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL,
    procedimientos text NOT NULL,
    transaccion character varying(20) NOT NULL,
    consulta character varying
);


ALTER TABLE segu.tlog_ OWNER TO rchumacero;

SET default_with_oids = true;

--
-- TOC entry 3833 (class 1259 OID 17305)
-- Dependencies: 4603 4604 14
-- Name: tpatron_evento; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tpatron_evento (
    id_patron_evento integer NOT NULL,
    tipo_evento character varying(20) NOT NULL,
    operacion character varying,
    aplicacion character varying,
    cantidad_intentos integer,
    periodo_intentos numeric,
    tiempo_bloqueo numeric,
    email character varying,
    nombre_patron character varying(100),
    estado_reg character varying(20),
    CONSTRAINT tpatron_evento__aplicacion__chk CHECK ((((aplicacion)::text = 'usuario'::text) OR ((aplicacion)::text = 'ip'::text))),
    CONSTRAINT tpatron_evento__operacion__chk CHECK ((((operacion)::text = 'bloqueo'::text) OR ((operacion)::text = 'notificacion'::text)))
);


ALTER TABLE segu.tpatron_evento OWNER TO postgres;

--
-- TOC entry 3834 (class 1259 OID 17313)
-- Dependencies: 14 3833
-- Name: tpatron_evento_id_patron_evento_seq; Type: SEQUENCE; Schema: segu; Owner: postgres
--

CREATE SEQUENCE tpatron_evento_id_patron_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.tpatron_evento_id_patron_evento_seq OWNER TO postgres;

--
-- TOC entry 6248 (class 0 OID 0)
-- Dependencies: 3834
-- Name: tpatron_evento_id_patron_evento_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: postgres
--

ALTER SEQUENCE tpatron_evento_id_patron_evento_seq OWNED BY tpatron_evento.id_patron_evento;


SET default_with_oids = false;

--
-- TOC entry 3835 (class 1259 OID 17315)
-- Dependencies: 4605 4606 4607 1610 1614 14
-- Name: tperfil; Type: TABLE; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tperfil (
    id_perfil integer NOT NULL,
    perfil character varying(30),
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL,
    defecto si_no DEFAULT 'si'::character varying NOT NULL,
    id_recurso integer
);


ALTER TABLE segu.tperfil OWNER TO rchumacero;

--
-- TOC entry 3836 (class 1259 OID 17324)
-- Dependencies: 14 3791
-- Name: tpersona_id_persona_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE tpersona_id_persona_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.tpersona_id_persona_seq OWNER TO rchumacero;

--
-- TOC entry 6249 (class 0 OID 0)
-- Dependencies: 3836
-- Name: tpersona_id_persona_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: rchumacero
--

ALTER SEQUENCE tpersona_id_persona_seq OWNED BY tpersona.id_persona;


--
-- TOC entry 3837 (class 1259 OID 17326)
-- Dependencies: 4608 14
-- Name: tprimo; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tprimo (
    id_primo integer DEFAULT nextval(('"segu"."primo_id_primo_seq"'::text)::regclass) NOT NULL,
    numero integer
);


ALTER TABLE segu.tprimo OWNER TO postgres;

--
-- TOC entry 3838 (class 1259 OID 17330)
-- Dependencies: 4609 4610 4611 4612 1614 1608 14
-- Name: tprocedimiento; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tprocedimiento (
    id_procedimiento integer DEFAULT nextval(('"segu"."procedimiento_id_procedimiento_seq"'::text)::regclass) NOT NULL,
    id_funcion integer,
    codigo character varying(20) NOT NULL,
    descripcion text NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    habilita_log si_no DEFAULT 'si'::character varying NOT NULL,
    estado_reg public.estado_reg DEFAULT 'activo'::public.estado_reg NOT NULL,
    autor character varying(100),
    fecha_creacion character varying(40)
);


ALTER TABLE segu.tprocedimiento OWNER TO postgres;

--
-- TOC entry 3839 (class 1259 OID 17340)
-- Dependencies: 4613 4614 1608 14
-- Name: tregional; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tregional (
    id_regional integer DEFAULT nextval(('"segu"."regional_id_regional_seq"'::text)::regclass) NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    nombre character varying(150) NOT NULL,
    descripcion character varying(500),
    estado_reg public.estado_reg
);


ALTER TABLE segu.tregional OWNER TO postgres;

--
-- TOC entry 3840 (class 1259 OID 17348)
-- Dependencies: 4615 4616 4617 1610 14
-- Name: trol; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE trol (
    id_rol integer DEFAULT nextval(('"segu"."rol_id_rol_seq"'::text)::regclass) NOT NULL,
    descripcion text,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL,
    rol character varying(150),
    id_subsistema integer
);


ALTER TABLE segu.trol OWNER TO postgres;

SET default_with_oids = true;

--
-- TOC entry 3841 (class 1259 OID 17357)
-- Dependencies: 4619 1608 14
-- Name: tsesion; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tsesion (
    id_sesion bigint NOT NULL,
    variable text NOT NULL,
    ip character varying(20) NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario integer,
    estado_reg public.estado_reg,
    hora_act time(0) without time zone NOT NULL,
    hora_des time(0) without time zone,
    datos text,
    pid_web integer,
    pid_bd integer,
    transaccion_actual character varying,
    funcion_actual character varying,
    inicio_proceso timestamp(0) without time zone
);
ALTER TABLE ONLY tsesion ALTER COLUMN fecha_reg SET STATISTICS 0;


ALTER TABLE segu.tsesion OWNER TO postgres;

--
-- TOC entry 3842 (class 1259 OID 17364)
-- Dependencies: 14 3841
-- Name: tsesion_id_sesion_seq; Type: SEQUENCE; Schema: segu; Owner: postgres
--

CREATE SEQUENCE tsesion_id_sesion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.tsesion_id_sesion_seq OWNER TO postgres;

--
-- TOC entry 6250 (class 0 OID 0)
-- Dependencies: 3842
-- Name: tsesion_id_sesion_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: postgres
--

ALTER SEQUENCE tsesion_id_sesion_seq OWNED BY tsesion.id_sesion;


SET default_with_oids = false;

--
-- TOC entry 3843 (class 1259 OID 17366)
-- Dependencies: 4620 4621 4622 1608 14
-- Name: tsubsistema; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tsubsistema (
    id_subsistema integer DEFAULT nextval(('"segu"."tsubsistema_id_subsistema_seq"'::text)::regclass) NOT NULL,
    codigo character varying(20) NOT NULL,
    nombre character varying(50) NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    prefijo character varying(10) NOT NULL,
    estado_reg public.estado_reg DEFAULT 'activo'::public.estado_reg NOT NULL,
    nombre_carpeta character varying(50),
    id_subsis_orig integer
);


ALTER TABLE segu.tsubsistema OWNER TO postgres;

--
-- TOC entry 3844 (class 1259 OID 17372)
-- Dependencies: 14
-- Name: tsubsistema_id_subsistema_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE tsubsistema_id_subsistema_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE segu.tsubsistema_id_subsistema_seq OWNER TO rchumacero;

--
-- TOC entry 3846 (class 1259 OID 17380)
-- Dependencies: 4628 1610 14
-- Name: tusuario_actividad; Type: TABLE; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tusuario_actividad (
    id_usuario_actividad integer NOT NULL,
    id_usuario integer NOT NULL,
    id_actividad integer NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo NOT NULL
);


ALTER TABLE segu.tusuario_actividad OWNER TO rchumacero;

--
-- TOC entry 3847 (class 1259 OID 17387)
-- Dependencies: 4629 4630 1610 14
-- Name: tusuario_perfil; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tusuario_perfil (
    id_usuario_perfil integer NOT NULL,
    id_usuario integer,
    id_perfil integer,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL
);


ALTER TABLE segu.tusuario_perfil OWNER TO postgres;

--
-- TOC entry 3848 (class 1259 OID 17395)
-- Dependencies: 4632 1610 14
-- Name: tusuario_proyecto; Type: TABLE; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tusuario_proyecto (
    id_usuario_proyecto integer NOT NULL,
    id_usuario integer NOT NULL,
    id_proyecto integer NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo NOT NULL
);


ALTER TABLE segu.tusuario_proyecto OWNER TO rchumacero;

--
-- TOC entry 3849 (class 1259 OID 17402)
-- Dependencies: 4633 4634 4635 1610 14
-- Name: tusuario_regional; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tusuario_regional (
    id_usuario_regional integer DEFAULT nextval(('"segu"."usuario_regional_id_usuario_regional_seq"'::text)::regclass) NOT NULL,
    id_regional integer NOT NULL,
    id_usuario integer NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL
);


ALTER TABLE segu.tusuario_regional OWNER TO postgres;

--
-- TOC entry 3850 (class 1259 OID 17411)
-- Dependencies: 4636 4637 1608 14
-- Name: tusuario_rol; Type: TABLE; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE TABLE tusuario_rol (
    id_usuario_rol integer DEFAULT nextval(('"segu"."usuario_rol_id_usuario_rol_seq"'::text)::regclass) NOT NULL,
    id_rol integer NOT NULL,
    id_usuario integer NOT NULL,
    fecha_reg date,
    estado_reg public.estado_reg DEFAULT 'activo'::public.estado_reg NOT NULL
);


ALTER TABLE segu.tusuario_rol OWNER TO postgres;

--
-- TOC entry 3851 (class 1259 OID 17416)
-- Dependencies: 14 3846
-- Name: usuario_actividad_id_usuario_actividad_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE usuario_actividad_id_usuario_actividad_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.usuario_actividad_id_usuario_actividad_seq OWNER TO rchumacero;

--
-- TOC entry 6251 (class 0 OID 0)
-- Dependencies: 3851
-- Name: usuario_actividad_id_usuario_actividad_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: rchumacero
--

ALTER SEQUENCE usuario_actividad_id_usuario_actividad_seq OWNED BY tusuario_actividad.id_usuario_actividad;


--
-- TOC entry 3852 (class 1259 OID 17418)
-- Dependencies: 14
-- Name: usuario_id_usuario_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE usuario_id_usuario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE segu.usuario_id_usuario_seq OWNER TO rchumacero;

--
-- TOC entry 3853 (class 1259 OID 17420)
-- Dependencies: 14 3848
-- Name: usuario_proyecto_id_usuario_proyecto_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE usuario_proyecto_id_usuario_proyecto_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE segu.usuario_proyecto_id_usuario_proyecto_seq OWNER TO rchumacero;

--
-- TOC entry 6252 (class 0 OID 0)
-- Dependencies: 3853
-- Name: usuario_proyecto_id_usuario_proyecto_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: rchumacero
--

ALTER SEQUENCE usuario_proyecto_id_usuario_proyecto_seq OWNED BY tusuario_proyecto.id_usuario_proyecto;


--
-- TOC entry 3854 (class 1259 OID 17422)
-- Dependencies: 14
-- Name: usuario_regional_id_usuario_regional_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE usuario_regional_id_usuario_regional_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE segu.usuario_regional_id_usuario_regional_seq OWNER TO rchumacero;

--
-- TOC entry 3855 (class 1259 OID 17424)
-- Dependencies: 14
-- Name: usuario_rol_id_usuario_rol_seq; Type: SEQUENCE; Schema: segu; Owner: rchumacero
--

CREATE SEQUENCE usuario_rol_id_usuario_rol_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE segu.usuario_rol_id_usuario_rol_seq OWNER TO rchumacero;

--
-- TOC entry 3856 (class 1259 OID 17426)
-- Dependencies: 4217 1610 14
-- Name: vlog; Type: VIEW; Schema: segu; Owner: rchumacero
--

CREATE VIEW vlog AS
    SELECT tlog.id_log, tlog.id_usuario, tlog.id_subsistema, tlog.mac_maquina, tlog.ip_maquina, tlog.tipo_log, tlog.descripcion, tlog.fecha_reg, tlog.estado_reg, tlog.procedimientos, tlog.transaccion, tlog.consulta, tlog.tiempo_ejecucion, tlog.usuario_base, tlog.codigo_error, tlog.dia_semana, tlog.pid_db, tlog.pid_web, tlog.sid_web, tlog.cuenta_usuario, tlog.descripcion_transaccion, tlog.codigo_subsistema FROM tlog WHERE ((tlog.fecha_reg >= (now() - '24:00:00'::interval)) AND (tlog.fecha_reg <= now()));


ALTER TABLE segu.vlog OWNER TO rchumacero;

--
-- TOC entry 3857 (class 1259 OID 17431)
-- Dependencies: 4218 14
-- Name: vmonitor_bd_esquema; Type: VIEW; Schema: segu; Owner: rchumacero
--

CREATE VIEW vmonitor_bd_esquema AS
    SELECT (n.oid)::integer AS nspoid, (ut.schemaname)::character varying AS schemaname, (u.usename)::character varying AS usename, (SELECT count(pg_class.oid) AS count FROM pg_class WHERE ((pg_class.relnamespace = n.oid) AND (pg_class.relkind = 'r'::"char"))) AS cantidad_tablas, count(i.indexrelid) AS cantidad_indices, sum(ut.seq_scan) AS scaneos_secuenciales, sum(ut.seq_tup_read) AS tuplas_seq_leidas, sum(ut.idx_scan) AS indices_scaneados, sum(ut.idx_tup_fetch) AS tuplas_idx_leidas, sum(ut.n_tup_ins) AS tuplas_insertadas, sum(ut.n_tup_upd) AS tuplas_actualizadas, sum(ut.n_tup_del) AS tuplas_borradas, sum(ut.n_tup_hot_upd) AS tuplas_actualizadas_hot, sum(ut.n_live_tup) AS tuplas_vivas, sum(ut.n_dead_tup) AS tuplas_muertas, sum(uiot.heap_blks_read) AS bloques_leidos_disco_tabla, sum(uiot.heap_blks_hit) AS bloques_leidos_buffer_tabla, sum(uiot.idx_blks_read) AS bloques_leidos_disco_indice, sum(uiot.idx_blks_hit) AS bloques_leidos_buffer_indice, sum(uiot.toast_blks_read) AS bloques_leidos_disco_toast, sum(uiot.toast_blks_hit) AS bloques_leidos_buffer_toast, sum(uiot.tidx_blks_read) AS bloques_leidos_disco_toast_indice, sum(uiot.tidx_blks_hit) AS bloques_leidos_buffer_toast_indice, sum((c.relpages * 8)) AS kb_tablas, sum((ci.relpages * 8)) AS kb_indices FROM ((((((pg_stat_user_tables ut JOIN pg_statio_user_tables uiot ON ((ut.relid = uiot.relid))) JOIN pg_class c ON ((c.oid = ut.relid))) JOIN pg_namespace n ON ((n.oid = c.relnamespace))) JOIN pg_user u ON ((n.nspowner = u.usesysid))) LEFT JOIN pg_index i ON ((i.indrelid = c.oid))) LEFT JOIN pg_class ci ON ((ci.oid = i.indexrelid))) WHERE (ut.schemaname !~~ 'pg_temp%'::text) GROUP BY n.oid, ut.schemaname, u.usename;


ALTER TABLE segu.vmonitor_bd_esquema OWNER TO rchumacero;

--
-- TOC entry 3858 (class 1259 OID 17436)
-- Dependencies: 4219 14
-- Name: vmonitor_bd_funcion; Type: VIEW; Schema: segu; Owner: rchumacero
--

CREATE VIEW vmonitor_bd_funcion AS
    SELECT (pro.oid)::integer AS oid, (pro.pronamespace)::integer AS pronamespace, (pro.proname)::character varying AS proname, (CASE WHEN pro.prosecdef THEN 'si'::text ELSE 'no'::text END)::character varying AS setuid, (u.usename)::character varying AS usename FROM (pg_proc pro JOIN pg_user u ON ((pro.proowner = u.usesysid)));


ALTER TABLE segu.vmonitor_bd_funcion OWNER TO rchumacero;

--
-- TOC entry 3859 (class 1259 OID 17441)
-- Dependencies: 4220 14
-- Name: vmonitor_bd_indice; Type: VIEW; Schema: segu; Owner: rchumacero
--

CREATE VIEW vmonitor_bd_indice AS
    SELECT (ui.relid)::integer AS relid, (ui.indexrelid)::integer AS indexrelid, (ui.indexrelname)::character varying AS indexrelname, ui.idx_scan AS numero_index_scan, ui.idx_tup_read AS numero_indices_devueltos, ui.idx_tup_fetch AS numero_tuplas_vivas, ioi.idx_blks_read AS bloques_disco_leidos, ioi.idx_blks_hit AS bloques_buffer_leidos FROM (pg_stat_user_indexes ui JOIN pg_statio_user_indexes ioi ON ((ui.indexrelid = ioi.indexrelid)));


ALTER TABLE segu.vmonitor_bd_indice OWNER TO rchumacero;

--
-- TOC entry 3860 (class 1259 OID 17445)
-- Dependencies: 4221 14
-- Name: vmonitor_bd_tabla; Type: VIEW; Schema: segu; Owner: rchumacero
--

CREATE VIEW vmonitor_bd_tabla AS
    SELECT (c.oid)::integer AS oid, (c.relnamespace)::integer AS relnamespace, (c.relname)::character varying AS relname, (u.usename)::character varying AS usename, to_char(ut.last_vacuum, 'DD/MM/YYYY HH24:MI'::text) AS last_vacuum, to_char(ut.last_autovacuum, 'DD/MM/YYYY HH24:MI'::text) AS last_autovacuum, to_char(ut.last_analyze, 'DD/MM/YYYY HH24:MI'::text) AS last_analyze, to_char(ut.last_autoanalyze, 'DD/MM/YYYY HH24:MI'::text) AS last_autoanalyze, count(i.indexrelid) AS cantidad_indices, (SELECT count(*) AS count FROM pg_trigger WHERE ((pg_trigger.tgrelid = c.oid) AND (pg_trigger.tgisinternal = false))) AS cantidad_triggers, (ut.seq_scan)::numeric AS scaneos_secuenciales, (ut.seq_tup_read)::numeric AS tuplas_seq_leidas, (ut.idx_scan)::numeric AS indices_scaneados, (ut.idx_tup_fetch)::numeric AS tuplas_idx_leidas, (ut.n_tup_ins)::numeric AS tuplas_insertadas, (ut.n_tup_upd)::numeric AS tuplas_actualizadas, (ut.n_tup_del)::numeric AS tuplas_borradas, (ut.n_tup_hot_upd)::numeric AS tuplas_actualizadas_hot, (ut.n_live_tup)::numeric AS tuplas_vivas, (ut.n_dead_tup)::numeric AS tuplas_muertas, (uiot.heap_blks_read)::numeric AS bloques_leidos_disco_tabla, (uiot.heap_blks_hit)::numeric AS bloques_leidos_buffer_tabla, (uiot.idx_blks_read)::numeric AS bloques_leidos_disco_indice, (uiot.idx_blks_hit)::numeric AS bloques_leidos_buffer_indice, (uiot.toast_blks_read)::numeric AS bloques_leidos_disco_toast, (uiot.toast_blks_hit)::numeric AS bloques_leidos_buffer_toast, (uiot.tidx_blks_read)::numeric AS bloques_leidos_disco_toast_indice, (uiot.tidx_blks_hit)::numeric AS bloques_leidos_buffer_toast_indice, ((c.relpages * 8))::numeric AS kb_tabla, (sum((ci.relpages * 8)))::numeric AS kb_indices FROM (((((pg_stat_user_tables ut JOIN pg_statio_user_tables uiot ON ((ut.relid = uiot.relid))) JOIN pg_class c ON ((c.oid = ut.relid))) JOIN pg_user u ON ((c.relowner = u.usesysid))) LEFT JOIN pg_index i ON ((i.indrelid = c.oid))) LEFT JOIN pg_class ci ON ((ci.oid = i.indexrelid))) GROUP BY c.oid, c.relnamespace, c.relname, u.usename, c.relhastriggers, ut.last_vacuum, ut.last_autovacuum, ut.last_analyze, ut.last_autoanalyze, ut.seq_scan, ut.seq_tup_read, ut.idx_scan, ut.idx_tup_fetch, ut.n_tup_ins, ut.n_tup_upd, ut.n_tup_del, ut.n_tup_hot_upd, ut.n_live_tup, ut.n_dead_tup, uiot.heap_blks_read, uiot.heap_blks_hit, uiot.idx_blks_read, uiot.idx_blks_hit, uiot.toast_blks_read, uiot.toast_blks_hit, uiot.tidx_blks_read, uiot.tidx_blks_hit, (c.relpages * 8);


ALTER TABLE segu.vmonitor_bd_tabla OWNER TO rchumacero;

SET search_path = tesor, pg_catalog;

--
-- TOC entry 3861 (class 1259 OID 17450)
-- Dependencies: 4638 4639 4640 15 3708
-- Name: tcaja; Type: TABLE; Schema: tesor; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcaja (
    id_caja integer NOT NULL,
    codigo character varying(20) NOT NULL,
    descripcion character varying(200) NOT NULL,
    estado_caja character varying(15)
)
INHERITS (public.tbase);


ALTER TABLE tesor.tcaja OWNER TO rchumacero;

--
-- TOC entry 3862 (class 1259 OID 17456)
-- Dependencies: 4641 4642 4643 15 3708
-- Name: tcaja_mov; Type: TABLE; Schema: tesor; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcaja_mov (
    id_caja_mov integer NOT NULL,
    tipo_mov character varying(15),
    estado_mov character varying(15),
    importe numeric,
    id_caja integer
)
INHERITS (public.tbase);


ALTER TABLE tesor.tcaja_mov OWNER TO rchumacero;

--
-- TOC entry 3863 (class 1259 OID 17465)
-- Dependencies: 4644 4645 4646 4647 15 3708
-- Name: tcajero; Type: TABLE; Schema: tesor; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tcajero (
    id_cajero integer DEFAULT nextval(('"tesor"."tcajero_id_cajero_seq"'::text)::regclass) NOT NULL,
    id_caja integer,
    id_funcionario integer,
    estado_cajero character varying
)
INHERITS (public.tbase);


ALTER TABLE tesor.tcajero OWNER TO rchumacero;

--
-- TOC entry 3864 (class 1259 OID 17475)
-- Dependencies: 15
-- Name: tcajero_id_cajero_seq; Type: SEQUENCE; Schema: tesor; Owner: rchumacero
--

CREATE SEQUENCE tcajero_id_cajero_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE tesor.tcajero_id_cajero_seq OWNER TO rchumacero;

--
-- TOC entry 3865 (class 1259 OID 17477)
-- Dependencies: 4648 4649 4650 4651 4652 15 3708
-- Name: trecibo; Type: TABLE; Schema: tesor; Owner: rchumacero; Tablespace: 
--

CREATE TABLE trecibo (
    id_recibo integer NOT NULL,
    id_cajero integer,
    tipo_recibo character varying(20),
    importe numeric(18,2) NOT NULL,
    id_moneda integer,
    descripcion character varying(500),
    id_funcionario integer,
    codigo character varying(20),
    estado_recibo character varying(15) NOT NULL,
    tipo_ingreso_salida character varying(25) NOT NULL,
    nombre_recibo character varying(150) NOT NULL,
    CONSTRAINT chk__trecibo__tipo_ingreso_salida CHECK ((((((((tipo_ingreso_salida)::text = 'repocision'::text) OR ((tipo_ingreso_salida)::text = 'venta'::text)) OR ((tipo_ingreso_salida)::text = 'reposicion_recibo'::text)) OR ((tipo_ingreso_salida)::text = 'recibo_provisorio'::text)) OR ((tipo_ingreso_salida)::text = 'recibo_pago'::text)) OR ((tipo_ingreso_salida)::text = 'recibo_pago_cliente'::text))),
    CONSTRAINT chk__trecibo__tipo_recibo CHECK ((((tipo_recibo)::text = 'ingreso'::text) OR ((tipo_recibo)::text = 'salida'::text)))
)
INHERITS (public.tbase);


ALTER TABLE tesor.trecibo OWNER TO rchumacero;

--
-- TOC entry 3866 (class 1259 OID 17488)
-- Dependencies: 4653 4654 4655 15 3708
-- Name: trendicion; Type: TABLE; Schema: tesor; Owner: rchumacero; Tablespace: 
--

CREATE TABLE trendicion (
    id_rendicion integer NOT NULL,
    id_recibo integer NOT NULL,
    id_documento integer NOT NULL
)
INHERITS (public.tbase);


ALTER TABLE tesor.trendicion OWNER TO rchumacero;

SET search_path = tesoro, pg_catalog;

--
-- TOC entry 3886 (class 1259 OID 56468)
-- Dependencies: 44
-- Name: tts_corte_moneda; Type: TABLE; Schema: tesoro; Owner: rchumacero; Tablespace: 
--

CREATE TABLE tts_corte_moneda (
    id_corte integer NOT NULL,
    id_moneda integer NOT NULL,
    descri_corte character varying(50) NOT NULL,
    importe_valor numeric(18,2) NOT NULL,
    tipo_corte numeric(1,0) NOT NULL
);


ALTER TABLE tesoro.tts_corte_moneda OWNER TO rchumacero;

--
-- TOC entry 6253 (class 0 OID 0)
-- Dependencies: 3886
-- Name: TABLE tts_corte_moneda; Type: COMMENT; Schema: tesoro; Owner: rchumacero
--

COMMENT ON TABLE tts_corte_moneda IS 'sistema=Tesoreria&codigo=CORMON&prefijo=TS&titulo=Corte Moneda&desc=Corte Moneda&num_dt=3&dt_1=id_moneda&dt_2=importe_valor&dt_3=tipo_corte';


--
-- TOC entry 6254 (class 0 OID 0)
-- Dependencies: 3886
-- Name: COLUMN tts_corte_moneda.id_corte; Type: COMMENT; Schema: tesoro; Owner: rchumacero
--

COMMENT ON COLUMN tts_corte_moneda.id_corte IS 'nombre=id_corte&label=id_corte&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_corte';


--
-- TOC entry 6255 (class 0 OID 0)
-- Dependencies: 3886
-- Name: COLUMN tts_corte_moneda.id_moneda; Type: COMMENT; Schema: tesoro; Owner: rchumacero
--

COMMENT ON COLUMN tts_corte_moneda.id_moneda IS 'nombre=id_moneda&label=Moneda&grid_visible=si&grid_editable=no&disabled=no&width_grid=90&width=100%&filtro=si&defecto=&desc=id_moneda';


--
-- TOC entry 6256 (class 0 OID 0)
-- Dependencies: 3886
-- Name: COLUMN tts_corte_moneda.descri_corte; Type: COMMENT; Schema: tesoro; Owner: rchumacero
--

COMMENT ON COLUMN tts_corte_moneda.descri_corte IS 'nombre=descri_corte&label=Descripción&grid_visible=si&grid_editable=no&disabled=no&width_grid=150&width=100%&filtro=si&defecto=&desc=descri_corte';


--
-- TOC entry 6257 (class 0 OID 0)
-- Dependencies: 3886
-- Name: COLUMN tts_corte_moneda.importe_valor; Type: COMMENT; Schema: tesoro; Owner: rchumacero
--

COMMENT ON COLUMN tts_corte_moneda.importe_valor IS 'nombre=importe_valor&label=Valor&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=importe_valor';


--
-- TOC entry 6258 (class 0 OID 0)
-- Dependencies: 3886
-- Name: COLUMN tts_corte_moneda.tipo_corte; Type: COMMENT; Schema: tesoro; Owner: rchumacero
--

COMMENT ON COLUMN tts_corte_moneda.tipo_corte IS 'nombre=tipo_corte&label=Tipo&grid_visible=si&grid_editable=no&disabled=no&width_grid=120&width=100%&filtro=si&defecto=&desc=tipo_corte';


--
-- TOC entry 3885 (class 1259 OID 56466)
-- Dependencies: 44 3886
-- Name: tts_corte_moneda_id_corte_seq; Type: SEQUENCE; Schema: tesoro; Owner: rchumacero
--

CREATE SEQUENCE tts_corte_moneda_id_corte_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tesoro.tts_corte_moneda_id_corte_seq OWNER TO rchumacero;

--
-- TOC entry 6259 (class 0 OID 0)
-- Dependencies: 3885
-- Name: tts_corte_moneda_id_corte_seq; Type: SEQUENCE OWNED BY; Schema: tesoro; Owner: rchumacero
--

ALTER SEQUENCE tts_corte_moneda_id_corte_seq OWNED BY tts_corte_moneda.id_corte;


SET search_path = actif, pg_catalog;

--
-- TOC entry 4966 (class 2604 OID 3176093)
-- Dependencies: 4037 4036 4037
-- Name: id_activo_fijo; Type: DEFAULT; Schema: actif; Owner: rchumacero
--

ALTER TABLE taf_activo_fijo ALTER COLUMN id_activo_fijo SET DEFAULT nextval('taf_activo_fijo_id_activo_fijo_seq'::regclass);


--
-- TOC entry 4957 (class 2604 OID 3176069)
-- Dependencies: 4034 4035 4035
-- Name: id_sub_tipo_activo; Type: DEFAULT; Schema: actif; Owner: rchumacero
--

ALTER TABLE taf_sub_tipo_activo ALTER COLUMN id_sub_tipo_activo SET DEFAULT nextval('taf_sub_tipo_activo_id_sub_tipo_activo_seq'::regclass);


SET search_path = cobra, pg_catalog;

--
-- TOC entry 4691 (class 2604 OID 56437)
-- Dependencies: 3882 3881 3882
-- Name: id_agencia; Type: DEFAULT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE tcb_agencia ALTER COLUMN id_agencia SET DEFAULT nextval('tcb_agencia_id_agencia_seq'::regclass);


--
-- TOC entry 4728 (class 2604 OID 59297)
-- Dependencies: 3902 3901 3902
-- Name: id_arqueo; Type: DEFAULT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE tcb_arqueo ALTER COLUMN id_arqueo SET DEFAULT nextval('tcb_arqueo_id_arqueo_seq'::regclass);


--
-- TOC entry 4806 (class 2604 OID 1651080)
-- Dependencies: 3934 3935 3935
-- Name: id_arqueo_estado; Type: DEFAULT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE tcb_arqueo_estado ALTER COLUMN id_arqueo_estado SET DEFAULT nextval('tarqueo_estado_id_arqueo_estado_seq'::regclass);


--
-- TOC entry 4704 (class 2604 OID 59114)
-- Dependencies: 3890 3889 3890
-- Name: id_caja; Type: DEFAULT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE tcb_caja ALTER COLUMN id_caja SET DEFAULT nextval('tcb_caja_id_caja_seq'::regclass);


--
-- TOC entry 4712 (class 2604 OID 59144)
-- Dependencies: 3894 3893 3894
-- Name: id_caja_estado; Type: DEFAULT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE tcb_caja_estado ALTER COLUMN id_caja_estado SET DEFAULT nextval('tcb_caja_estado_id_caja_estado_seq'::regclass);


--
-- TOC entry 4708 (class 2604 OID 59133)
-- Dependencies: 3892 3891 3892
-- Name: id_cajero; Type: DEFAULT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE tcb_cajero ALTER COLUMN id_cajero SET DEFAULT nextval('tcb_cajero_id_cajero_seq'::regclass);


--
-- TOC entry 4798 (class 2604 OID 1546326)
-- Dependencies: 3931 3932 3932
-- Name: id_cobro; Type: DEFAULT; Schema: cobra; Owner: gvelasquez
--

ALTER TABLE tcb_cobro ALTER COLUMN id_cobro SET DEFAULT nextval('tcb_cobro_id_cobro_seq'::regclass);


--
-- TOC entry 4788 (class 2604 OID 1505646)
-- Dependencies: 3926 3927 3927
-- Name: id_enti_fin; Type: DEFAULT; Schema: cobra; Owner: gvelasquez
--

ALTER TABLE tcb_enti_fin ALTER COLUMN id_enti_fin SET DEFAULT nextval('tcb_enti_fin2_id_enti_fin_seq'::regclass);


--
-- TOC entry 4700 (class 2604 OID 58207)
-- Dependencies: 3887 3888 3888
-- Name: id_factura_cob; Type: DEFAULT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE tcb_factura_cob ALTER COLUMN id_factura_cob SET DEFAULT nextval('tcb_factura_cob_id_factura_cob_seq'::regclass);


--
-- TOC entry 4724 (class 2604 OID 59262)
-- Dependencies: 3899 3900 3900
-- Name: id_factura_cob_anulado; Type: DEFAULT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE tcb_factura_cob_anulado ALTER COLUMN id_factura_cob_anulado SET DEFAULT nextval('tcb_factura_cob_anulado_id_factura_cob_anulado_seq'::regclass);


--
-- TOC entry 4720 (class 2604 OID 59231)
-- Dependencies: 3898 3897 3898
-- Name: id_factura_cob_det; Type: DEFAULT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE tcb_factura_cob_det ALTER COLUMN id_factura_cob_det SET DEFAULT nextval('tcb_factura_cob_det_id_factura_cob_det_seq'::regclass);


--
-- TOC entry 4663 (class 2604 OID 49290)
-- Dependencies: 3868 3869 3869
-- Name: id_prueba; Type: DEFAULT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE tcb_prueba ALTER COLUMN id_prueba SET DEFAULT nextval('tcb_prueba_id_prueba_seq'::regclass);


--
-- TOC entry 4687 (class 2604 OID 56421)
-- Dependencies: 3880 3879 3880
-- Name: id_sistema_dist_agencia; Type: DEFAULT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE tcb_sistema_dist_agencia ALTER COLUMN id_sistema_dist_agencia SET DEFAULT nextval('tcb_sistema_dist_agencia_id_sistema_dist_agencia_seq'::regclass);


--
-- TOC entry 4695 (class 2604 OID 56461)
-- Dependencies: 3883 3884 3884
-- Name: id_sistema_dist_usuario; Type: DEFAULT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE tcb_sistema_dist_usuario ALTER COLUMN id_sistema_dist_usuario SET DEFAULT nextval('tcb_sistema_dist_usuario_id_sistema_dist_usuario_seq'::regclass);


SET search_path = conta, pg_catalog;

--
-- TOC entry 4441 (class 2604 OID 17494)
-- Dependencies: 3705 3704
-- Name: id_auxiliar; Type: DEFAULT; Schema: conta; Owner: rchumacero
--

ALTER TABLE tauxiliar ALTER COLUMN id_auxiliar SET DEFAULT nextval('tauxiliar_id_auxiliar_seq'::regclass);


--
-- TOC entry 4444 (class 2604 OID 17495)
-- Dependencies: 3707 3706
-- Name: id_cuenta; Type: DEFAULT; Schema: conta; Owner: rchumacero
--

ALTER TABLE tcuenta ALTER COLUMN id_cuenta SET DEFAULT nextval('tcuenta_id_cuenta_seq'::regclass);


SET search_path = factur, pg_catalog;

--
-- TOC entry 4669 (class 2604 OID 56316)
-- Dependencies: 3875 3874 3875
-- Name: id_descuento; Type: DEFAULT; Schema: factur; Owner: rchumacero
--

ALTER TABLE tfv_descuento ALTER COLUMN id_descuento SET DEFAULT nextval('tfv_descuento_id_descuento_seq'::regclass);


--
-- TOC entry 4665 (class 2604 OID 56292)
-- Dependencies: 3871 3870 3871
-- Name: id_enti_fin; Type: DEFAULT; Schema: factur; Owner: rchumacero
--

ALTER TABLE tfv_entidad_fin ALTER COLUMN id_enti_fin SET DEFAULT nextval('tfv_entidad_fin_id_enti_fin_seq'::regclass);


--
-- TOC entry 4666 (class 2604 OID 56305)
-- Dependencies: 3873 3872 3873
-- Name: id_tasa; Type: DEFAULT; Schema: factur; Owner: rchumacero
--

ALTER TABLE tfv_tasa ALTER COLUMN id_tasa SET DEFAULT nextval('tfv_tasa_id_tasa_seq'::regclass);


SET search_path = gen, pg_catalog;

--
-- TOC entry 4467 (class 2604 OID 17497)
-- Dependencies: 3714 3713
-- Name: id_tabla; Type: DEFAULT; Schema: gen; Owner: postgres
--

ALTER TABLE ttabla ALTER COLUMN id_tabla SET DEFAULT nextval('ttabla_id_tabla_seq1'::regclass);


SET search_path = gev, pg_catalog;

--
-- TOC entry 4983 (class 2604 OID 3176158)
-- Dependencies: 4041 4038 4041
-- Name: id_activo_fijo_grupo_evento; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_activo_fijo_grupo_evento ALTER COLUMN id_activo_fijo_grupo_evento SET DEFAULT nextval('tgv_activo_fijo_grupo_evento_id_activo_fijo_grupo_evento_seq'::regclass);


--
-- TOC entry 4984 (class 2604 OID 3176159)
-- Dependencies: 4041 4039 4041
-- Name: id_activo_fijo; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_activo_fijo_grupo_evento ALTER COLUMN id_activo_fijo SET DEFAULT nextval('tgv_activo_fijo_grupo_evento_id_activo_fijo_seq'::regclass);


--
-- TOC entry 4985 (class 2604 OID 3176160)
-- Dependencies: 4041 4040 4041
-- Name: id_agrupacion; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_activo_fijo_grupo_evento ALTER COLUMN id_agrupacion SET DEFAULT nextval('tgv_activo_fijo_grupo_evento_id_agrupacion_seq'::regclass);


--
-- TOC entry 4989 (class 2604 OID 3176183)
-- Dependencies: 4042 4043 4043
-- Name: id_activo_fijo_rastreo; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_activo_fijo_rastreo ALTER COLUMN id_activo_fijo_rastreo SET DEFAULT nextval('tgv_activo_fijo_rastreo_id_activo_fijo_rastreo_seq'::regclass);


--
-- TOC entry 4993 (class 2604 OID 3176215)
-- Dependencies: 4044 4045 4045
-- Name: id_ultimo_registro; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_activo_fijo_ultimo_registro ALTER COLUMN id_ultimo_registro SET DEFAULT nextval('tgv_activo_fijo_ultimo_registro_id_ultimo_registro_seq'::regclass);


--
-- TOC entry 4997 (class 2604 OID 3176249)
-- Dependencies: 4047 4046 4047
-- Name: id_agrupacion; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_agrupacion ALTER COLUMN id_agrupacion SET DEFAULT nextval('tgv_agrupacion_id_agrupacion_seq'::regclass);


--
-- TOC entry 5006 (class 2604 OID 3176295)
-- Dependencies: 4052 4051 4052
-- Name: id_agrupacion_evento; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_agrupacion_evento ALTER COLUMN id_agrupacion_evento SET DEFAULT nextval('tgv_agrupacion_evento_id_agrupacion_evento_seq'::regclass);


--
-- TOC entry 5010 (class 2604 OID 3176330)
-- Dependencies: 4055 4053 4055
-- Name: id_bitacora; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_bitacora ALTER COLUMN id_bitacora SET DEFAULT nextval('tgv_bitacora_id_bitacora_seq'::regclass);


--
-- TOC entry 5011 (class 2604 OID 3176331)
-- Dependencies: 4054 4055 4055
-- Name: id_servicio_det; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_bitacora ALTER COLUMN id_servicio_det SET DEFAULT nextval('tgv_bitacora_id_servicio_det_seq'::regclass);


--
-- TOC entry 5023 (class 2604 OID 3176407)
-- Dependencies: 4061 4060 4061
-- Name: id_datos_tec; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_datos_tec ALTER COLUMN id_datos_tec SET DEFAULT nextval('tgv_datos_tec_id_datos_tec_seq'::regclass);


--
-- TOC entry 5001 (class 2604 OID 3176270)
-- Dependencies: 4050 4048 4050
-- Name: id_evento; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_evento ALTER COLUMN id_evento SET DEFAULT nextval('tgv_evento_id_evento_seq'::regclass);


--
-- TOC entry 5002 (class 2604 OID 3176271)
-- Dependencies: 4049 4050 4050
-- Name: id_tipo_evento; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_evento ALTER COLUMN id_tipo_evento SET DEFAULT nextval('tgv_evento_id_tipo_evento_seq'::regclass);


--
-- TOC entry 5027 (class 2604 OID 3176423)
-- Dependencies: 4062 4063 4063
-- Name: id_iboton; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_iboton ALTER COLUMN id_iboton SET DEFAULT nextval('tgv_iboton_id_iboton_seq'::regclass);


--
-- TOC entry 5035 (class 2604 OID 3176454)
-- Dependencies: 4067 4066 4067
-- Name: id_mantenimiento; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_mantenimiento ALTER COLUMN id_mantenimiento SET DEFAULT nextval('tgv_mantenimiento_id_mantenimiento_seq'::regclass);


--
-- TOC entry 5039 (class 2604 OID 3176483)
-- Dependencies: 4069 4068 4069
-- Name: id_mantenimiento_det; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_mantenimiento_det ALTER COLUMN id_mantenimiento_det SET DEFAULT nextval('tgv_mantenimiento_det_id_mantenimiento_det_seq'::regclass);


--
-- TOC entry 5015 (class 2604 OID 3176355)
-- Dependencies: 4057 4056 4057
-- Name: id_marca; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_marca ALTER COLUMN id_marca SET DEFAULT nextval('tgv_marca_id_marca_seq'::regclass);


--
-- TOC entry 5019 (class 2604 OID 3176374)
-- Dependencies: 4059 4058 4059
-- Name: id_modelo; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_modelo ALTER COLUMN id_modelo SET DEFAULT nextval('tgv_modelo_id_modelo_seq'::regclass);


--
-- TOC entry 5045 (class 2604 OID 3176514)
-- Dependencies: 4071 4070 4071
-- Name: id_servicio; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_servicio ALTER COLUMN id_servicio SET DEFAULT nextval('tgv_servicio_id_servicio_seq'::regclass);


--
-- TOC entry 5049 (class 2604 OID 3176543)
-- Dependencies: 4073 4072 4073
-- Name: id_servicio_det; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_servicio_det ALTER COLUMN id_servicio_det SET DEFAULT nextval('tgv_servicio_det_id_servicio_det_seq'::regclass);


--
-- TOC entry 5053 (class 2604 OID 3176565)
-- Dependencies: 4074 4075 4075
-- Name: id_servicio_det_evento; Type: DEFAULT; Schema: gev; Owner: rac
--

ALTER TABLE tgv_servicio_det_evento ALTER COLUMN id_servicio_det_evento SET DEFAULT nextval('tgv_servicio_det_evento_id_servicio_det_evento_seq'::regclass);


--
-- TOC entry 5031 (class 2604 OID 3176443)
-- Dependencies: 4065 4064 4065
-- Name: id_tipo_evento; Type: DEFAULT; Schema: gev; Owner: rchumacero
--

ALTER TABLE tgv_tipo_evento ALTER COLUMN id_tipo_evento SET DEFAULT nextval('tgv_tipo_evento_id_tipo_evento_seq'::regclass);


SET search_path = hidro, pg_catalog;

--
-- TOC entry 4762 (class 2604 OID 1379051)
-- Dependencies: 3913 3912 3913
-- Name: id_administrador; Type: DEFAULT; Schema: hidro; Owner: rac
--

ALTER TABLE thd_administrador_hidro ALTER COLUMN id_administrador SET DEFAULT nextval('thd_administrador_hidro_id_administrador_hidro_seq'::regclass);


--
-- TOC entry 4887 (class 2604 OID 2048988)
-- Dependencies: 3989 3990 3990
-- Name: id_archivo; Type: DEFAULT; Schema: hidro; Owner: rac
--

ALTER TABLE thd_archivo ALTER COLUMN id_archivo SET DEFAULT nextval('thd_archivo_id_archivo_seq'::regclass);


--
-- TOC entry 4886 (class 2604 OID 2048556)
-- Dependencies: 3988 3986 3988
-- Name: id_archivo_sensor; Type: DEFAULT; Schema: hidro; Owner: rac
--

ALTER TABLE thd_archivo_sensor ALTER COLUMN id_archivo_sensor SET DEFAULT nextval('thd_archivo_sensor_id_archivo_sensor_seq'::regclass);


--
-- TOC entry 4822 (class 2604 OID 1872094)
-- Dependencies: 3946 3945 3946
-- Name: id_estacion_proyecto; Type: DEFAULT; Schema: hidro; Owner: rac
--

ALTER TABLE thd_estacion_proyecto ALTER COLUMN id_estacion_proyecto SET DEFAULT nextval('thd_estacion_proyecto_id_estacion_proyecto_seq'::regclass);


--
-- TOC entry 4784 (class 2604 OID 1427562)
-- Dependencies: 3924 3923 3924
-- Name: id_medicion; Type: DEFAULT; Schema: hidro; Owner: mflores
--

ALTER TABLE thd_medicion ALTER COLUMN id_medicion SET DEFAULT nextval('thd_medicion_id_medicion_seq'::regclass);


--
-- TOC entry 4758 (class 2604 OID 1379038)
-- Dependencies: 3911 3910 3911
-- Name: id_rio; Type: DEFAULT; Schema: hidro; Owner: rac
--

ALTER TABLE thd_rio ALTER COLUMN id_rio SET DEFAULT nextval('thd_rio_id_rio_seq'::regclass);


--
-- TOC entry 4779 (class 2604 OID 1419956)
-- Dependencies: 3922 3921 3922
-- Name: id_sensor; Type: DEFAULT; Schema: hidro; Owner: mflores
--

ALTER TABLE thd_sensor ALTER COLUMN id_sensor SET DEFAULT nextval('thd_sensores_id_sensor_seq'::regclass);


--
-- TOC entry 4885 (class 2604 OID 2048336)
-- Dependencies: 3985 3984 3985
-- Name: id_tipo_archivo; Type: DEFAULT; Schema: hidro; Owner: rac
--

ALTER TABLE thd_tipo_archivo ALTER COLUMN id_tipo_archivo SET DEFAULT nextval('thd_tipo_archivo_id_tipo_archivo_seq'::regclass);


--
-- TOC entry 5057 (class 2604 OID 3198741)
-- Dependencies: 4078 4077
-- Name: id_tipo_columna; Type: DEFAULT; Schema: hidro; Owner: mflores
--

ALTER TABLE thd_tipo_columna ALTER COLUMN id_tipo_columna SET DEFAULT nextval('thd_tipo_columna_id_tipo_columna_seq'::regclass);


--
-- TOC entry 5061 (class 2604 OID 3207734)
-- Dependencies: 4080 4079
-- Name: id_tipo_columna_sensor; Type: DEFAULT; Schema: hidro; Owner: mflores
--

ALTER TABLE thd_tipo_columna_sensor ALTER COLUMN id_tipo_columna_sensor SET DEFAULT nextval('thd_tipo_columna_sensor_id_tipo_sensor_columna_seq'::regclass);


--
-- TOC entry 5094 (class 2604 OID 3322525)
-- Dependencies: 4109 4108
-- Name: id_tipo_dato; Type: DEFAULT; Schema: hidro; Owner: mflores
--

ALTER TABLE thd_tipo_dato ALTER COLUMN id_tipo_dato SET DEFAULT nextval('thd_tipo_dato_id_tipo_dato_seq'::regclass);


--
-- TOC entry 4888 (class 2604 OID 2050762)
-- Dependencies: 3991 3992 3992
-- Name: id_tipo_muestra; Type: DEFAULT; Schema: hidro; Owner: rac
--

ALTER TABLE thd_tipo_muestra ALTER COLUMN id_tipo_muestra SET DEFAULT nextval('thd_tipo_muestra_id_tipo_muestra_seq'::regclass);


--
-- TOC entry 4774 (class 2604 OID 1400226)
-- Dependencies: 3918 3917 3918
-- Name: id_tipo_sensor; Type: DEFAULT; Schema: hidro; Owner: rac
--

ALTER TABLE thd_tipo_sensor ALTER COLUMN id_tipo_sensor SET DEFAULT nextval('thd_tipo_medicion_id_tipo_medicion_seq'::regclass);


--
-- TOC entry 5074 (class 2604 OID 3276669)
-- Dependencies: 4100 4099 4100
-- Name: id_tipo_sensor_22; Type: DEFAULT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE thd_tipo_sensor_22 ALTER COLUMN id_tipo_sensor_22 SET DEFAULT nextval('thd_tipo_sensor_22_id_tipo_sensor_22_seq'::regclass);


--
-- TOC entry 5066 (class 2604 OID 3270712)
-- Dependencies: 4096 4095 4096
-- Name: id_tipo_sensor_33; Type: DEFAULT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE thd_tipo_sensor_33 ALTER COLUMN id_tipo_sensor_33 SET DEFAULT nextval('thd_tipo_sensor_33_id_tipo_sensor_33_seq'::regclass);


--
-- TOC entry 5070 (class 2604 OID 3271724)
-- Dependencies: 4098 4097 4098
-- Name: id_tipo_sensor_44; Type: DEFAULT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE thd_tipo_sensor_44 ALTER COLUMN id_tipo_sensor_44 SET DEFAULT nextval('thd_tipo_sensor_44_id_tipo_sensor_44_seq'::regclass);


--
-- TOC entry 5101 (class 2604 OID 3367547)
-- Dependencies: 4113 4112 4113
-- Name: id_tipo_sensor_anemometro; Type: DEFAULT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE thd_tipo_sensor_anemometro ALTER COLUMN id_tipo_sensor_anemometro SET DEFAULT nextval('thd_tipo_sensor_anemometro_id_tipo_sensor_anemometro_seq'::regclass);


--
-- TOC entry 5082 (class 2604 OID 3285672)
-- Dependencies: 4104 4103 4104
-- Name: id_tipo_sensor_caudal; Type: DEFAULT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE thd_tipo_sensor_caudal ALTER COLUMN id_tipo_sensor_caudal SET DEFAULT nextval('thd_tipo_sensor_caudal_id_tipo_sensor_caudal_seq'::regclass);


--
-- TOC entry 5078 (class 2604 OID 3282961)
-- Dependencies: 4101 4102 4102
-- Name: id_tipo_sensor_limnimetrica; Type: DEFAULT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE thd_tipo_sensor_limnimetrica ALTER COLUMN id_tipo_sensor_limnimetrica SET DEFAULT nextval('thd_tipo_sensor_limnimetrica_id_tipo_sensor_limnimetrica_seq'::regclass);


--
-- TOC entry 5086 (class 2604 OID 3318869)
-- Dependencies: 4106 4105 4106
-- Name: id_tipo_sensor_presion; Type: DEFAULT; Schema: hidro; Owner: dbendesis_cobra_mflores
--

ALTER TABLE thd_tipo_sensor_presion ALTER COLUMN id_tipo_sensor_presion SET DEFAULT nextval('thd_tipo_sensor_presion_id_tipo_sensor_presion_seq'::regclass);


--
-- TOC entry 5109 (class 2604 OID 3461597)
-- Dependencies: 4116 4115 4116
-- Name: id_tipo_sensor_pru; Type: DEFAULT; Schema: hidro; Owner: dbendesis_cobra_mflores
--

ALTER TABLE thd_tipo_sensor_pru ALTER COLUMN id_tipo_sensor_pru SET DEFAULT nextval('thd_tipo_sensor_pru_id_tipo_sensor_pru_seq'::regclass);


--
-- TOC entry 5117 (class 2604 OID 3470615)
-- Dependencies: 4120 4119 4120
-- Name: id_tipo_sensor_prue; Type: DEFAULT; Schema: hidro; Owner: dbendesis_cobra_mflores
--

ALTER TABLE thd_tipo_sensor_prue ALTER COLUMN id_tipo_sensor_prue SET DEFAULT nextval('thd_tipo_sensor_prue_id_tipo_sensor_prue_seq'::regclass);


--
-- TOC entry 5113 (class 2604 OID 3464010)
-- Dependencies: 4117 4118 4118
-- Name: id_tipo_sensor_termo; Type: DEFAULT; Schema: hidro; Owner: dbendesis_cobra_mflores
--

ALTER TABLE thd_tipo_sensor_termo ALTER COLUMN id_tipo_sensor_termo SET DEFAULT nextval('thd_tipo_sensor_termo_id_tipo_sensor_termo_seq'::regclass);


SET search_path = param, pg_catalog;

--
-- TOC entry 4864 (class 2604 OID 1987203)
-- Dependencies: 3975 3974 3975
-- Name: id_depto_usuario; Type: DEFAULT; Schema: param; Owner: rvasquez
--

ALTER TABLE table1 ALTER COLUMN id_depto_usuario SET DEFAULT nextval('table1_id_depto_usuario_seq'::regclass);


--
-- TOC entry 4855 (class 2604 OID 1951827)
-- Dependencies: 3968 3969 3969
-- Name: id_alarma; Type: DEFAULT; Schema: param; Owner: mzambrana
--

ALTER TABLE talarma ALTER COLUMN id_alarma SET DEFAULT nextval('talarma_id_alarma_seq'::regclass);


--
-- TOC entry 4913 (class 2604 OID 2115174)
-- Dependencies: 4004 4005 4005
-- Name: id_config_alarma; Type: DEFAULT; Schema: param; Owner: fprudencio
--

ALTER TABLE tconfig_alarma ALTER COLUMN id_config_alarma SET DEFAULT nextval('tconfig_alarma_id_config_alarma_seq'::regclass);


--
-- TOC entry 4934 (class 2604 OID 2188422)
-- Dependencies: 4015 4016 4016
-- Name: id_correlativo; Type: DEFAULT; Schema: param; Owner: rac
--

ALTER TABLE tcorrelativo ALTER COLUMN id_correlativo SET DEFAULT nextval('tcorrelativo_id_correlativo_seq'::regclass);


--
-- TOC entry 4892 (class 2604 OID 2091660)
-- Dependencies: 3995 3994 3995
-- Name: id_depto; Type: DEFAULT; Schema: param; Owner: postgres
--

ALTER TABLE tdepto ALTER COLUMN id_depto SET DEFAULT nextval('tdepto_id_depto_seq'::regclass);


--
-- TOC entry 4909 (class 2604 OID 2109343)
-- Dependencies: 4003 4002 4003
-- Name: id_depto_usuario; Type: DEFAULT; Schema: param; Owner: mzambrana
--

ALTER TABLE tdepto_usuario ALTER COLUMN id_depto_usuario SET DEFAULT nextval('tdepto_usuairo_id_depto_usuario_seq'::regclass);


--
-- TOC entry 4925 (class 2604 OID 2132181)
-- Dependencies: 4011 4010 4011
-- Name: id_documento; Type: DEFAULT; Schema: param; Owner: mzambrana
--

ALTER TABLE tdocumento ALTER COLUMN id_documento SET DEFAULT nextval('tdocumento_id_documento_seq'::regclass);


--
-- TOC entry 4483 (class 2604 OID 17498)
-- Dependencies: 3721 3720
-- Name: id_gestion; Type: DEFAULT; Schema: param; Owner: postgres
--

ALTER TABLE tgestion ALTER COLUMN id_gestion SET DEFAULT nextval('tgestion_id_gestion_seq'::regclass);


--
-- TOC entry 4792 (class 2604 OID 1512525)
-- Dependencies: 3929 3928 3929
-- Name: id_institucion; Type: DEFAULT; Schema: param; Owner: gvelasquez
--

ALTER TABLE tinstitucion ALTER COLUMN id_institucion SET DEFAULT nextval('tinstitucion_id_institucion_seq'::regclass);


--
-- TOC entry 4490 (class 2604 OID 17499)
-- Dependencies: 3723 3722
-- Name: id_moneda; Type: DEFAULT; Schema: param; Owner: postgres
--

ALTER TABLE tmoneda ALTER COLUMN id_moneda SET DEFAULT nextval('tmoneda_id_moneda_seq'::regclass);


--
-- TOC entry 4491 (class 2604 OID 17500)
-- Dependencies: 3725 3724
-- Name: id_periodo; Type: DEFAULT; Schema: param; Owner: postgres
--

ALTER TABLE tperiodo ALTER COLUMN id_periodo SET DEFAULT nextval('tperiodo_id_periodo_seq'::regclass);


--
-- TOC entry 4807 (class 2604 OID 1687698)
-- Dependencies: 3938 3937 3938
-- Name: id_financiador; Type: DEFAULT; Schema: param; Owner: rchumacero
--

ALTER TABLE tpm_financiador ALTER COLUMN id_financiador SET DEFAULT nextval('tpm_financiador_id_financiador_seq'::regclass);


--
-- TOC entry 4815 (class 2604 OID 1687755)
-- Dependencies: 3941 3942 3942
-- Name: id_programa; Type: DEFAULT; Schema: param; Owner: rchumacero
--

ALTER TABLE tpm_programa ALTER COLUMN id_programa SET DEFAULT nextval('tpm_programa_id_programa_seq'::regclass);


--
-- TOC entry 4818 (class 2604 OID 1687775)
-- Dependencies: 3943 3944 3944
-- Name: id_proyecto; Type: DEFAULT; Schema: param; Owner: rchumacero
--

ALTER TABLE tpm_proyecto ALTER COLUMN id_proyecto SET DEFAULT nextval('tpm_proyecto_id_proyecto_seq'::regclass);


--
-- TOC entry 4812 (class 2604 OID 1687735)
-- Dependencies: 3940 3939 3940
-- Name: id_regional; Type: DEFAULT; Schema: param; Owner: rchumacero
--

ALTER TABLE tpm_regional ALTER COLUMN id_regional SET DEFAULT nextval('tpm_regional_id_regional_seq'::regclass);


--
-- TOC entry 4858 (class 2604 OID 1952156)
-- Dependencies: 3971 3970 3971
-- Name: id_proveedor; Type: DEFAULT; Schema: param; Owner: mzambrana
--

ALTER TABLE tproveedor ALTER COLUMN id_proveedor SET DEFAULT nextval('tproveedor_id_proveedor_seq'::regclass);


--
-- TOC entry 4917 (class 2604 OID 2131436)
-- Dependencies: 4006 4007 4007
-- Name: id_usuario_uo; Type: DEFAULT; Schema: param; Owner: rac
--

ALTER TABLE tusuario_uo ALTER COLUMN id_usuario_uo SET DEFAULT nextval('tusuario_uo_id_usuario_uo_seq'::regclass);


SET search_path = public, pg_catalog;

--
-- TOC entry 4495 (class 2604 OID 17501)
-- Dependencies: 3727 3726
-- Name: id; Type: DEFAULT; Schema: public; Owner: rchumacero
--

ALTER TABLE file_store ALTER COLUMN id SET DEFAULT nextval('file_store_id_seq'::regclass);


--
-- TOC entry 4496 (class 2604 OID 17502)
-- Dependencies: 3734 3733
-- Name: id_variable_global; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE variable_global ALTER COLUMN id_variable_global SET DEFAULT nextval('variable_global_id_variable_global_seq'::regclass);


SET search_path = rhum, pg_catalog;

--
-- TOC entry 4497 (class 2604 OID 17503)
-- Dependencies: 3736 3735
-- Name: id_columna; Type: DEFAULT; Schema: rhum; Owner: rchumacero
--

ALTER TABLE tcolumna ALTER COLUMN id_columna SET DEFAULT nextval('tcolumna_id_columna_seq'::regclass);


--
-- TOC entry 4896 (class 2604 OID 2106148)
-- Dependencies: 3997 3996 3997
-- Name: id_estructura_uo; Type: DEFAULT; Schema: rhum; Owner: postgres
--

ALTER TABLE testructura_uo ALTER COLUMN id_estructura_uo SET DEFAULT nextval('testructura_uo_id_estructura_uo_seq'::regclass);


--
-- TOC entry 4507 (class 2604 OID 17504)
-- Dependencies: 3740 3737
-- Name: id_funcionario; Type: DEFAULT; Schema: rhum; Owner: postgres
--

ALTER TABLE tfuncionario ALTER COLUMN id_funcionario SET DEFAULT nextval('tfuncionario_id_funcionario_seq'::regclass);


--
-- TOC entry 4509 (class 2604 OID 17505)
-- Dependencies: 3739 3738
-- Name: id_funcionario_horario; Type: DEFAULT; Schema: rhum; Owner: postgres
--

ALTER TABLE tfuncionario_horario ALTER COLUMN id_funcionario_horario SET DEFAULT nextval('tfuncionario_horario_id_funcionario_horario_seq'::regclass);


--
-- TOC entry 4510 (class 2604 OID 17506)
-- Dependencies: 3742 3741
-- Name: id_horario; Type: DEFAULT; Schema: rhum; Owner: postgres
--

ALTER TABLE thorario ALTER COLUMN id_horario SET DEFAULT nextval('thorario_id_horario_seq'::regclass);


--
-- TOC entry 4921 (class 2604 OID 2131546)
-- Dependencies: 4009 4008 4009
-- Name: id_nivel_organizacional; Type: DEFAULT; Schema: rhum; Owner: rac
--

ALTER TABLE tnivel_organizacional ALTER COLUMN id_nivel_organizacional SET DEFAULT nextval('tnivel_organizacional_id_nivel_organizacional_seq'::regclass);


--
-- TOC entry 4511 (class 2604 OID 17507)
-- Dependencies: 3744 3743
-- Name: id_obligacion; Type: DEFAULT; Schema: rhum; Owner: postgres
--

ALTER TABLE tobligacion ALTER COLUMN id_obligacion SET DEFAULT nextval('tobligacion_id_obligacion_seq'::regclass);


--
-- TOC entry 4515 (class 2604 OID 17508)
-- Dependencies: 3746 3745
-- Name: id_parametro; Type: DEFAULT; Schema: rhum; Owner: postgres
--

ALTER TABLE tparametro_rhum ALTER COLUMN id_parametro SET DEFAULT nextval('tparametro_rhum_id_parametro_seq'::regclass);


--
-- TOC entry 4517 (class 2604 OID 17509)
-- Dependencies: 3748 3747
-- Name: id_planilla; Type: DEFAULT; Schema: rhum; Owner: postgres
--

ALTER TABLE tplanilla ALTER COLUMN id_planilla SET DEFAULT nextval('tplanilla_id_planilla_seq'::regclass);


--
-- TOC entry 4518 (class 2604 OID 17510)
-- Dependencies: 3750 3749
-- Name: id_tipo_columna; Type: DEFAULT; Schema: rhum; Owner: rchumacero
--

ALTER TABLE ttipo_columna ALTER COLUMN id_tipo_columna SET DEFAULT nextval('ttipo_columna_id_tipo_columna_seq'::regclass);


--
-- TOC entry 4525 (class 2604 OID 17511)
-- Dependencies: 3752 3751
-- Name: id_tipo_horario; Type: DEFAULT; Schema: rhum; Owner: rchumacero
--

ALTER TABLE ttipo_horario ALTER COLUMN id_tipo_horario SET DEFAULT nextval('ttipo_horario_id_tipo_horario_seq'::regclass);


--
-- TOC entry 4528 (class 2604 OID 17512)
-- Dependencies: 3754 3753
-- Name: id_tipo_obligacion; Type: DEFAULT; Schema: rhum; Owner: rchumacero
--

ALTER TABLE ttipo_obligacion ALTER COLUMN id_tipo_obligacion SET DEFAULT nextval('ttipo_obligacion_id_tipo_obligacion_seq'::regclass);


--
-- TOC entry 4531 (class 2604 OID 17513)
-- Dependencies: 3756 3755
-- Name: id_tipo_planilla; Type: DEFAULT; Schema: rhum; Owner: rchumacero
--

ALTER TABLE ttipo_planilla ALTER COLUMN id_tipo_planilla SET DEFAULT nextval('ttipo_planilla_id_tipo_planilla_seq'::regclass);


--
-- TOC entry 4904 (class 2604 OID 2106640)
-- Dependencies: 4001 4000 4001
-- Name: id_uo; Type: DEFAULT; Schema: rhum; Owner: mzambrana
--

ALTER TABLE tuo ALTER COLUMN id_uo SET DEFAULT nextval('tuo_id_uo_seq'::regclass);


--
-- TOC entry 4900 (class 2604 OID 2106199)
-- Dependencies: 3998 3999 3999
-- Name: id_uo_funcionario; Type: DEFAULT; Schema: rhum; Owner: mzambrana
--

ALTER TABLE tuo_funcionario ALTER COLUMN id_uo_funcionario SET DEFAULT nextval('tuo_funcionario_id_uo_funcionario_seq'::regclass);


SET search_path = saj, pg_catalog;

--
-- TOC entry 4852 (class 2604 OID 1951736)
-- Dependencies: 3966 3967 3967
-- Name: id_boleta; Type: DEFAULT; Schema: saj; Owner: mzambrana
--

ALTER TABLE tboleta ALTER COLUMN id_boleta SET DEFAULT nextval('tboleta_id_boleta_seq'::regclass);


--
-- TOC entry 4850 (class 2604 OID 1951259)
-- Dependencies: 3965 3964 3965
-- Name: id_documento_anexo; Type: DEFAULT; Schema: saj; Owner: mzambrana
--

ALTER TABLE tdocumento_anexo ALTER COLUMN id_documento_anexo SET DEFAULT nextval('tdocumento_anexo_id_documento_anexo_seq'::regclass);


--
-- TOC entry 4834 (class 2604 OID 1945721)
-- Dependencies: 3957 3956 3957
-- Name: id_estado; Type: DEFAULT; Schema: saj; Owner: mzambrana
--

ALTER TABLE testado ALTER COLUMN id_estado SET DEFAULT nextval('testado_id_estado_seq'::regclass);


--
-- TOC entry 4845 (class 2604 OID 1951111)
-- Dependencies: 3962 3963 3963
-- Name: id_estado_proceso; Type: DEFAULT; Schema: saj; Owner: mzambrana
--

ALTER TABLE testado_proceso ALTER COLUMN id_estado_proceso SET DEFAULT nextval('testado_proceso_id_estado_proceso_seq'::regclass);


--
-- TOC entry 4830 (class 2604 OID 1945289)
-- Dependencies: 3954 3955 3955
-- Name: id_modalidad; Type: DEFAULT; Schema: saj; Owner: mzambrana
--

ALTER TABLE tmodalidad ALTER COLUMN id_modalidad SET DEFAULT nextval('tmodalidad_id_modalidad_seq'::regclass);


--
-- TOC entry 4841 (class 2604 OID 1950325)
-- Dependencies: 3961 3960 3961
-- Name: id_proceso_contrato; Type: DEFAULT; Schema: saj; Owner: mzambrana
--

ALTER TABLE tproceso_contrato ALTER COLUMN id_proceso_contrato SET DEFAULT nextval('tproceso_contrato_id_proceso_contrato_seq'::regclass);


--
-- TOC entry 4837 (class 2604 OID 1946228)
-- Dependencies: 3959 3958 3959
-- Name: id_responsable_proceso; Type: DEFAULT; Schema: saj; Owner: mzambrana
--

ALTER TABLE tresponsable_proceso ALTER COLUMN id_responsable_proceso SET DEFAULT nextval('tresponsable_proceso_id_responsable_proceso_seq'::regclass);


--
-- TOC entry 4827 (class 2604 OID 1944516)
-- Dependencies: 3953 3952 3953
-- Name: id_tipo_contrato; Type: DEFAULT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ttipo_contrato ALTER COLUMN id_tipo_contrato SET DEFAULT nextval('tipo_contrato_id_tipo_contrato_seq'::regclass);


SET search_path = sast, pg_catalog;

--
-- TOC entry 4880 (class 2604 OID 1993314)
-- Dependencies: 3980 3981 3981
-- Name: id_estado; Type: DEFAULT; Schema: sast; Owner: rvasquez
--

ALTER TABLE testado ALTER COLUMN id_estado SET DEFAULT nextval('testado_id_estado_seq'::regclass);


--
-- TOC entry 4875 (class 2604 OID 1993300)
-- Dependencies: 3979 3978 3979
-- Name: id_estado_requerimiento; Type: DEFAULT; Schema: sast; Owner: rvasquez
--

ALTER TABLE testado_requerimiento ALTER COLUMN id_estado_requerimiento SET DEFAULT nextval('testado_requerimiento_id_estado_requerimiento_seq'::regclass);


--
-- TOC entry 4868 (class 2604 OID 1993286)
-- Dependencies: 3977 3976 3977
-- Name: id_requerimiento; Type: DEFAULT; Schema: sast; Owner: rvasquez
--

ALTER TABLE trequerimientos ALTER COLUMN id_requerimiento SET DEFAULT nextval('trequerimientos_id_requerimiento_seq'::regclass);


--
-- TOC entry 4884 (class 2604 OID 1993328)
-- Dependencies: 3982 3983 3983
-- Name: id_tipo_requerimiento; Type: DEFAULT; Schema: sast; Owner: rvasquez
--

ALTER TABLE ttipo_requerimiento ALTER COLUMN id_tipo_requerimiento SET DEFAULT nextval('tipo_requerimiento_id_tipo_requerimiento_seq'::regclass);


SET search_path = secont, pg_catalog;

--
-- TOC entry 4537 (class 2604 OID 17514)
-- Dependencies: 3776 3757
-- Name: id_alarma; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE alarma ALTER COLUMN id_alarma SET DEFAULT nextval('leg_alarma_id_alarma_seq'::regclass);


--
-- TOC entry 4538 (class 2604 OID 17515)
-- Dependencies: 3759 3758
-- Name: id_contratista; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE contratista ALTER COLUMN id_contratista SET DEFAULT nextval('contratista_id_contratista_seq'::regclass);


--
-- TOC entry 4539 (class 2604 OID 17516)
-- Dependencies: 3761 3760
-- Name: id_contrato; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE contrato ALTER COLUMN id_contrato SET DEFAULT nextval('contrato_id_contrato_seq'::regclass);


--
-- TOC entry 4540 (class 2604 OID 17517)
-- Dependencies: 3763 3762
-- Name: id_correspondencia; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE correspondencia ALTER COLUMN id_correspondencia SET DEFAULT nextval('correspondencia_id_correspondencia_seq'::regclass);


--
-- TOC entry 4541 (class 2604 OID 17518)
-- Dependencies: 3765 3764
-- Name: id_documento; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE doc_anexo ALTER COLUMN id_documento SET DEFAULT nextval('doc_anexo_id_documento_seq'::regclass);


--
-- TOC entry 4542 (class 2604 OID 17519)
-- Dependencies: 3767 3766
-- Name: id_personal; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE empleado ALTER COLUMN id_personal SET DEFAULT nextval('empleado_id_personal_seq'::regclass);


--
-- TOC entry 4543 (class 2604 OID 17520)
-- Dependencies: 3769 3768
-- Name: id_estado; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE estado ALTER COLUMN id_estado SET DEFAULT nextval('estado_id_estado_seq'::regclass);


--
-- TOC entry 4545 (class 2604 OID 17521)
-- Dependencies: 3771 3770
-- Name: id_estado_requerimiento; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE estado_requerimiento ALTER COLUMN id_estado_requerimiento SET DEFAULT nextval('estado_requerimiento_id_estado_requerimiento_seq'::regclass);


--
-- TOC entry 4546 (class 2604 OID 17522)
-- Dependencies: 3773 3772
-- Name: id_garantia; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE garantia ALTER COLUMN id_garantia SET DEFAULT nextval('garantia_id_garantia_seq'::regclass);


--
-- TOC entry 4547 (class 2604 OID 17523)
-- Dependencies: 3775 3774
-- Name: id_informe; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE informe ALTER COLUMN id_informe SET DEFAULT nextval('informe_id_informe_seq'::regclass);


--
-- TOC entry 4548 (class 2604 OID 17524)
-- Dependencies: 3778 3777
-- Name: id_oferta; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE oferta ALTER COLUMN id_oferta SET DEFAULT nextval('oferta_id_oferta_seq'::regclass);


--
-- TOC entry 4549 (class 2604 OID 17525)
-- Dependencies: 3780 3779
-- Name: id_persona_juridica; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE persona_juridica ALTER COLUMN id_persona_juridica SET DEFAULT nextval('persona_juridica_id_persona_juridica_seq'::regclass);


--
-- TOC entry 4550 (class 2604 OID 17526)
-- Dependencies: 3782 3781
-- Name: id_proyecto; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE proyecto ALTER COLUMN id_proyecto SET DEFAULT nextval('proyecto_id_proyecto_seq'::regclass);


--
-- TOC entry 4551 (class 2604 OID 17527)
-- Dependencies: 3784 3783
-- Name: id_representante; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE representante ALTER COLUMN id_representante SET DEFAULT nextval('representante_id_representante_seq'::regclass);


--
-- TOC entry 4552 (class 2604 OID 17528)
-- Dependencies: 3786 3785
-- Name: id_requerimiento; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE requerimiento ALTER COLUMN id_requerimiento SET DEFAULT nextval('requerimiento_id_requerimiento_seq'::regclass);


--
-- TOC entry 4553 (class 2604 OID 17529)
-- Dependencies: 3788 3787
-- Name: id_resolucion; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE resolucion ALTER COLUMN id_resolucion SET DEFAULT nextval('resolucion_id_resolucion_seq'::regclass);


--
-- TOC entry 4554 (class 2604 OID 17530)
-- Dependencies: 3790 3789
-- Name: id_unidad; Type: DEFAULT; Schema: secont; Owner: rchumacero
--

ALTER TABLE unidad ALTER COLUMN id_unidad SET DEFAULT nextval('unidad_id_unidad_seq'::regclass);


SET search_path = segu, pg_catalog;

--
-- TOC entry 5122 (class 2604 OID 3511234)
-- Dependencies: 4122 4123 4123
-- Name: id_libreta; Type: DEFAULT; Schema: segu; Owner: rac
--

ALTER TABLE libreta ALTER COLUMN id_libreta SET DEFAULT nextval('libreta_id_libreta_seq'::regclass);


--
-- TOC entry 5126 (class 2604 OID 3512009)
-- Dependencies: 4125 4124 4125
-- Name: id_libreta_her; Type: DEFAULT; Schema: segu; Owner: rac
--

ALTER TABLE libreta_her ALTER COLUMN id_libreta_her SET DEFAULT nextval('libreta_her_id_libreta_her_seq'::regclass);


--
-- TOC entry 4559 (class 2604 OID 17531)
-- Dependencies: 3796 3795
-- Name: id_actividad; Type: DEFAULT; Schema: segu; Owner: postgres
--

ALTER TABLE tactividad ALTER COLUMN id_actividad SET DEFAULT nextval('actividad_id_actividad_seq'::regclass);


--
-- TOC entry 4584 (class 2604 OID 17532)
-- Dependencies: 3823 3822
-- Name: id_bloqueo_notificacion; Type: DEFAULT; Schema: segu; Owner: postgres
--

ALTER TABLE tbloqueo_notificacion ALTER COLUMN id_bloqueo_notificacion SET DEFAULT nextval('tbloqueo_notificacion_id_bloqueo_notificacion_seq'::regclass);


--
-- TOC entry 4562 (class 2604 OID 17533)
-- Dependencies: 3799 3798
-- Name: id_estructura_dato; Type: DEFAULT; Schema: segu; Owner: postgres
--

ALTER TABLE testructura_dato ALTER COLUMN id_estructura_dato SET DEFAULT nextval('estructura_dato_id_estructura_dato_seq'::regclass);


--
-- TOC entry 4565 (class 2604 OID 17534)
-- Dependencies: 3801 3800
-- Name: id_estructura_gui; Type: DEFAULT; Schema: segu; Owner: postgres
--

ALTER TABLE testructura_gui ALTER COLUMN id_estructura_gui SET DEFAULT nextval('estructura_gui_id_estructura_gui_seq'::regclass);


--
-- TOC entry 4568 (class 2604 OID 17535)
-- Dependencies: 3804 3803
-- Name: id_gui_rol; Type: DEFAULT; Schema: segu; Owner: postgres
--

ALTER TABLE tgui_rol ALTER COLUMN id_gui_rol SET DEFAULT nextval('gui_rol_id_gui_rol_seq'::regclass);


--
-- TOC entry 4595 (class 2604 OID 17536)
-- Dependencies: 3829 3828
-- Name: id_horario_trabajo; Type: DEFAULT; Schema: segu; Owner: postgres
--

ALTER TABLE thorario_trabajo ALTER COLUMN id_horario_trabajo SET DEFAULT nextval('thorario_trabajo_id_horario_trabajo_seq'::regclass);


--
-- TOC entry 4602 (class 2604 OID 17537)
-- Dependencies: 3834 3833
-- Name: id_patron_evento; Type: DEFAULT; Schema: segu; Owner: postgres
--

ALTER TABLE tpatron_evento ALTER COLUMN id_patron_evento SET DEFAULT nextval('tpatron_evento_id_patron_evento_seq'::regclass);


--
-- TOC entry 4570 (class 2604 OID 17538)
-- Dependencies: 3807 3806
-- Name: id_permiso; Type: DEFAULT; Schema: segu; Owner: postgres
--

ALTER TABLE tpermiso ALTER COLUMN id_permiso SET DEFAULT nextval('permiso_id_permiso_seq'::regclass);


--
-- TOC entry 4555 (class 2604 OID 17539)
-- Dependencies: 3836 3791
-- Name: id_persona; Type: DEFAULT; Schema: segu; Owner: rchumacero
--

ALTER TABLE tpersona ALTER COLUMN id_persona SET DEFAULT nextval('tpersona_id_persona_seq'::regclass);


--
-- TOC entry 4573 (class 2604 OID 17540)
-- Dependencies: 3810 3809
-- Name: id_procedimiento_gui; Type: DEFAULT; Schema: segu; Owner: postgres
--

ALTER TABLE tprocedimiento_gui ALTER COLUMN id_procedimiento_gui SET DEFAULT nextval('procedimiento_gui_id_procedimiento_gui_seq'::regclass);


--
-- TOC entry 4576 (class 2604 OID 17541)
-- Dependencies: 3813 3812
-- Name: id_proyecto; Type: DEFAULT; Schema: segu; Owner: postgres
--

ALTER TABLE tproyecto ALTER COLUMN id_proyecto SET DEFAULT nextval('proyecto_id_proyecto_seq'::regclass);


--
-- TOC entry 4580 (class 2604 OID 17542)
-- Dependencies: 3816 3815
-- Name: id_recurso; Type: DEFAULT; Schema: segu; Owner: postgres
--

ALTER TABLE trecurso ALTER COLUMN id_recurso SET DEFAULT nextval('recurso_id_recurso_seq'::regclass);


--
-- TOC entry 4582 (class 2604 OID 17543)
-- Dependencies: 3820 3819
-- Name: id_rol_procedimiento; Type: DEFAULT; Schema: segu; Owner: postgres
--

ALTER TABLE trol_procedimiento_gui ALTER COLUMN id_rol_procedimiento SET DEFAULT nextval('rol_procedimiento_id_rol_procedimiento_seq'::regclass);


--
-- TOC entry 4618 (class 2604 OID 17544)
-- Dependencies: 3842 3841
-- Name: id_sesion; Type: DEFAULT; Schema: segu; Owner: postgres
--

ALTER TABLE tsesion ALTER COLUMN id_sesion SET DEFAULT nextval('tsesion_id_sesion_seq'::regclass);


--
-- TOC entry 4596 (class 2604 OID 17545)
-- Dependencies: 3831 3830
-- Name: id_tipo_documento; Type: DEFAULT; Schema: segu; Owner: rchumacero
--

ALTER TABLE ttipo_documento ALTER COLUMN id_tipo_documento SET DEFAULT nextval('tipo_documento_id_tipo_documento_seq'::regclass);


--
-- TOC entry 4627 (class 2604 OID 17546)
-- Dependencies: 3851 3846
-- Name: id_usuario_actividad; Type: DEFAULT; Schema: segu; Owner: rchumacero
--

ALTER TABLE tusuario_actividad ALTER COLUMN id_usuario_actividad SET DEFAULT nextval('usuario_actividad_id_usuario_actividad_seq'::regclass);


--
-- TOC entry 4631 (class 2604 OID 17547)
-- Dependencies: 3853 3848
-- Name: id_usuario_proyecto; Type: DEFAULT; Schema: segu; Owner: rchumacero
--

ALTER TABLE tusuario_proyecto ALTER COLUMN id_usuario_proyecto SET DEFAULT nextval('usuario_proyecto_id_usuario_proyecto_seq'::regclass);


SET search_path = tesoro, pg_catalog;

--
-- TOC entry 4696 (class 2604 OID 56471)
-- Dependencies: 3886 3885 3886
-- Name: id_corte; Type: DEFAULT; Schema: tesoro; Owner: rchumacero
--

ALTER TABLE tts_corte_moneda ALTER COLUMN id_corte SET DEFAULT nextval('tts_corte_moneda_id_corte_seq'::regclass);


SET search_path = actif, pg_catalog;

--
-- TOC entry 5632 (class 2606 OID 3176108)
-- Dependencies: 4037 4037
-- Name: taf_activo_fijo_codigo_key; Type: CONSTRAINT; Schema: actif; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY taf_activo_fijo
    ADD CONSTRAINT taf_activo_fijo_codigo_key UNIQUE (codigo);


--
-- TOC entry 5638 (class 2606 OID 3176106)
-- Dependencies: 4037 4037
-- Name: taf_activo_fijo_pkey; Type: CONSTRAINT; Schema: actif; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY taf_activo_fijo
    ADD CONSTRAINT taf_activo_fijo_pkey PRIMARY KEY (id_activo_fijo);


--
-- TOC entry 5630 (class 2606 OID 3176074)
-- Dependencies: 4035 4035
-- Name: taf_sub_tipo_activo_pkey; Type: CONSTRAINT; Schema: actif; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY taf_sub_tipo_activo
    ADD CONSTRAINT taf_sub_tipo_activo_pkey PRIMARY KEY (id_sub_tipo_activo);


--
-- TOC entry 5623 (class 2606 OID 3176008)
-- Dependencies: 4033 4033
-- Name: taf_tipo_activo_codigo_key; Type: CONSTRAINT; Schema: actif; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY taf_tipo_activo
    ADD CONSTRAINT taf_tipo_activo_codigo_key UNIQUE (codigo);


--
-- TOC entry 5626 (class 2606 OID 3176006)
-- Dependencies: 4033 4033
-- Name: taf_tipo_activo_pkey; Type: CONSTRAINT; Schema: actif; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY taf_tipo_activo
    ADD CONSTRAINT taf_tipo_activo_pkey PRIMARY KEY (id_tipo_activo);


SET search_path = cobra, pg_catalog;

--
-- TOC entry 5509 (class 2606 OID 1651085)
-- Dependencies: 3935 3935
-- Name: tarqueo_estado_pkey; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_arqueo_estado
    ADD CONSTRAINT tarqueo_estado_pkey PRIMARY KEY (id_arqueo_estado);


--
-- TOC entry 5433 (class 2606 OID 56442)
-- Dependencies: 3882 3882
-- Name: tcb_agencia_pkey; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_agencia
    ADD CONSTRAINT tcb_agencia_pkey PRIMARY KEY (id_agencia);


--
-- TOC entry 5455 (class 2606 OID 59315)
-- Dependencies: 3903 3903
-- Name: tcb_arqueo_det_pkey; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_arqueo_det
    ADD CONSTRAINT tcb_arqueo_det_pkey PRIMARY KEY (id_arqueo_det);


--
-- TOC entry 5453 (class 2606 OID 59302)
-- Dependencies: 3902 3902
-- Name: tcb_arqueo_pkey; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_arqueo
    ADD CONSTRAINT tcb_arqueo_pkey PRIMARY KEY (id_arqueo);


--
-- TOC entry 5445 (class 2606 OID 59149)
-- Dependencies: 3894 3894
-- Name: tcb_caja_estado_pkey; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_caja_estado
    ADD CONSTRAINT tcb_caja_estado_pkey PRIMARY KEY (id_caja_estado);


--
-- TOC entry 5441 (class 2606 OID 59119)
-- Dependencies: 3890 3890
-- Name: tcb_caja_pkey; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_caja
    ADD CONSTRAINT tcb_caja_pkey PRIMARY KEY (id_caja);


--
-- TOC entry 5447 (class 2606 OID 1652082)
-- Dependencies: 3896 3896
-- Name: tcb_cajero_estado_pkey; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_caja_cajero
    ADD CONSTRAINT tcb_cajero_estado_pkey PRIMARY KEY (id_caja_cajero);


--
-- TOC entry 5443 (class 2606 OID 59135)
-- Dependencies: 3892 3892
-- Name: tcb_cajero_pkey; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_cajero
    ADD CONSTRAINT tcb_cajero_pkey PRIMARY KEY (id_cajero);


--
-- TOC entry 5427 (class 2606 OID 1515635)
-- Dependencies: 3878 3878 3878
-- Name: tcb_cliente_idx; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_cliente
    ADD CONSTRAINT tcb_cliente_idx UNIQUE (id_sistema_dist, id_cliente_dist);


--
-- TOC entry 5429 (class 2606 OID 1515608)
-- Dependencies: 3878 3878
-- Name: tcb_cliente_pkey; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_cliente
    ADD CONSTRAINT tcb_cliente_pkey PRIMARY KEY (id_cliente);


--
-- TOC entry 5504 (class 2606 OID 1546328)
-- Dependencies: 3932 3932
-- Name: tcb_cobro_pkey; Type: CONSTRAINT; Schema: cobra; Owner: gvelasquez; Tablespace: 
--

ALTER TABLE ONLY tcb_cobro
    ADD CONSTRAINT tcb_cobro_pkey PRIMARY KEY (id_cobro);


--
-- TOC entry 5497 (class 2606 OID 1505648)
-- Dependencies: 3927 3927
-- Name: tcb_enti_fin2_pkey; Type: CONSTRAINT; Schema: cobra; Owner: gvelasquez; Tablespace: 
--

ALTER TABLE ONLY tcb_enti_fin
    ADD CONSTRAINT tcb_enti_fin2_pkey PRIMARY KEY (id_enti_fin);


--
-- TOC entry 5451 (class 2606 OID 59267)
-- Dependencies: 3900 3900
-- Name: tcb_factura_cob_anulado_pkey; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_factura_cob_anulado
    ADD CONSTRAINT tcb_factura_cob_anulado_pkey PRIMARY KEY (id_factura_cob_anulado);


--
-- TOC entry 5449 (class 2606 OID 59233)
-- Dependencies: 3898 3898
-- Name: tcb_factura_cob_det_pkey; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_factura_cob_det
    ADD CONSTRAINT tcb_factura_cob_det_pkey PRIMARY KEY (id_factura_cob_det);


--
-- TOC entry 5439 (class 2606 OID 58212)
-- Dependencies: 3888 3888
-- Name: tcb_factura_cob_pkey; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_factura_cob
    ADD CONSTRAINT tcb_factura_cob_pkey PRIMARY KEY (id_factura_cob);


--
-- TOC entry 5411 (class 2606 OID 49295)
-- Dependencies: 3869 3869
-- Name: tcb_prueba_pkey; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_prueba
    ADD CONSTRAINT tcb_prueba_pkey PRIMARY KEY (id_prueba);


--
-- TOC entry 5431 (class 2606 OID 56423)
-- Dependencies: 3880 3880
-- Name: tcb_sistema_dist_agencia_pkey; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_sistema_dist_agencia
    ADD CONSTRAINT tcb_sistema_dist_agencia_pkey PRIMARY KEY (id_sistema_dist_agencia);


--
-- TOC entry 5421 (class 2606 OID 1558060)
-- Dependencies: 3877 3877
-- Name: tcb_sistema_dist_codigo_key; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_sistema_dist
    ADD CONSTRAINT tcb_sistema_dist_codigo_key UNIQUE (codigo);


--
-- TOC entry 5423 (class 2606 OID 1503301)
-- Dependencies: 3877 3877
-- Name: tcb_sistema_dist_pkey; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_sistema_dist
    ADD CONSTRAINT tcb_sistema_dist_pkey PRIMARY KEY (id_sistema_dist);


--
-- TOC entry 5435 (class 2606 OID 56463)
-- Dependencies: 3884 3884
-- Name: tcb_sistema_dist_usuario_pkey; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_sistema_dist_usuario
    ADD CONSTRAINT tcb_sistema_dist_usuario_pkey PRIMARY KEY (id_sistema_dist_usuario);


--
-- TOC entry 5425 (class 2606 OID 56389)
-- Dependencies: 3877 3877
-- Name: tcb_sistema_distribucion_nombre_sistema_distribucion_key; Type: CONSTRAINT; Schema: cobra; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcb_sistema_dist
    ADD CONSTRAINT tcb_sistema_distribucion_nombre_sistema_distribucion_key UNIQUE (nombre);


SET search_path = conta, pg_catalog;

--
-- TOC entry 5141 (class 2606 OID 17549)
-- Dependencies: 3709 3709
-- Name: pk_tdocumento__id_documento; Type: CONSTRAINT; Schema: conta; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tdocumento
    ADD CONSTRAINT pk_tdocumento__id_documento PRIMARY KEY (id_documento);


--
-- TOC entry 5143 (class 2606 OID 17551)
-- Dependencies: 3710 3710
-- Name: pk_tdocumento_tipo; Type: CONSTRAINT; Schema: conta; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tdocumento_tipo
    ADD CONSTRAINT pk_tdocumento_tipo PRIMARY KEY (id_documento_tipo);


--
-- TOC entry 5137 (class 2606 OID 17553)
-- Dependencies: 3704 3704
-- Name: tauxiliar_pkey; Type: CONSTRAINT; Schema: conta; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tauxiliar
    ADD CONSTRAINT tauxiliar_pkey PRIMARY KEY (id_auxiliar);


--
-- TOC entry 5139 (class 2606 OID 17555)
-- Dependencies: 3706 3706
-- Name: tcuenta_pkey; Type: CONSTRAINT; Schema: conta; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcuenta
    ADD CONSTRAINT tcuenta_pkey PRIMARY KEY (id_cuenta);


SET search_path = factur, pg_catalog;

--
-- TOC entry 5419 (class 2606 OID 56324)
-- Dependencies: 3875 3875
-- Name: tfv_descuento_pkey; Type: CONSTRAINT; Schema: factur; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tfv_descuento
    ADD CONSTRAINT tfv_descuento_pkey PRIMARY KEY (id_descuento);


--
-- TOC entry 5413 (class 2606 OID 56297)
-- Dependencies: 3871 3871
-- Name: tfv_entidad_fin_pkey; Type: CONSTRAINT; Schema: factur; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tfv_entidad_fin
    ADD CONSTRAINT tfv_entidad_fin_pkey PRIMARY KEY (id_enti_fin);


--
-- TOC entry 5416 (class 2606 OID 56309)
-- Dependencies: 3873 3873
-- Name: tfv_tasa_pkey; Type: CONSTRAINT; Schema: factur; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tfv_tasa
    ADD CONSTRAINT tfv_tasa_pkey PRIMARY KEY (id_tasa);


SET search_path = gen, pg_catalog;

--
-- TOC entry 5145 (class 2606 OID 17557)
-- Dependencies: 3711 3711
-- Name: pk_tcolumna__id_columna; Type: CONSTRAINT; Schema: gen; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcolumna
    ADD CONSTRAINT pk_tcolumna__id_columna PRIMARY KEY (id_columna);


--
-- TOC entry 5147 (class 2606 OID 17559)
-- Dependencies: 3713 3713
-- Name: pk_ttabla__id_tabla; Type: CONSTRAINT; Schema: gen; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ttabla
    ADD CONSTRAINT pk_ttabla__id_tabla PRIMARY KEY (id_tabla);


SET search_path = gev, pg_catalog;

--
-- TOC entry 5617 (class 2606 OID 3175979)
-- Dependencies: 4031 4031
-- Name: tgv_activo_datos_tec_id_activo_fijo_key; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_activo_datos_tec
    ADD CONSTRAINT tgv_activo_datos_tec_id_activo_fijo_key UNIQUE (id_activo_fijo);


--
-- TOC entry 5619 (class 2606 OID 3175981)
-- Dependencies: 4031 4031
-- Name: tgv_activo_datos_tec_modem_id_key; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_activo_datos_tec
    ADD CONSTRAINT tgv_activo_datos_tec_modem_id_key UNIQUE (modem_id);


--
-- TOC entry 5621 (class 2606 OID 3175977)
-- Dependencies: 4031 4031
-- Name: tgv_activo_datos_tec_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_activo_datos_tec
    ADD CONSTRAINT tgv_activo_datos_tec_pkey PRIMARY KEY (id_activo_datos_tec);


--
-- TOC entry 5645 (class 2606 OID 3176220)
-- Dependencies: 4045 4045
-- Name: tgv_activo_fijo_Ultimo_Registro_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_activo_fijo_ultimo_registro
    ADD CONSTRAINT "tgv_activo_fijo_Ultimo_Registro_pkey" PRIMARY KEY (id_ultimo_registro);


--
-- TOC entry 5641 (class 2606 OID 3176162)
-- Dependencies: 4041 4041
-- Name: tgv_activo_fijo_grupo_evento_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_activo_fijo_grupo_evento
    ADD CONSTRAINT tgv_activo_fijo_grupo_evento_pkey PRIMARY KEY (id_activo_fijo_grupo_evento);


--
-- TOC entry 5643 (class 2606 OID 3176188)
-- Dependencies: 4043 4043
-- Name: tgv_activo_fijo_rastreo_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_activo_fijo_rastreo
    ADD CONSTRAINT tgv_activo_fijo_rastreo_pkey PRIMARY KEY (id_activo_fijo_rastreo);


--
-- TOC entry 5651 (class 2606 OID 3176297)
-- Dependencies: 4052 4052
-- Name: tgv_agrupacion_evento_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_agrupacion_evento
    ADD CONSTRAINT tgv_agrupacion_evento_pkey PRIMARY KEY (id_agrupacion_evento);


--
-- TOC entry 5647 (class 2606 OID 3176251)
-- Dependencies: 4047 4047
-- Name: tgv_agrupacion_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_agrupacion
    ADD CONSTRAINT tgv_agrupacion_pkey PRIMARY KEY (id_agrupacion);


--
-- TOC entry 5653 (class 2606 OID 3176336)
-- Dependencies: 4055 4055
-- Name: tgv_bitacora_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_bitacora
    ADD CONSTRAINT tgv_bitacora_pkey PRIMARY KEY (id_bitacora);


--
-- TOC entry 5659 (class 2606 OID 3176409)
-- Dependencies: 4061 4061
-- Name: tgv_datos_tec_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_datos_tec
    ADD CONSTRAINT tgv_datos_tec_pkey PRIMARY KEY (id_datos_tec);


--
-- TOC entry 5649 (class 2606 OID 3176276)
-- Dependencies: 4050 4050
-- Name: tgv_evento_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_evento
    ADD CONSTRAINT tgv_evento_pkey PRIMARY KEY (id_evento);


--
-- TOC entry 5661 (class 2606 OID 3176427)
-- Dependencies: 4063 4063
-- Name: tgv_iboton_codigo_key; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_iboton
    ADD CONSTRAINT tgv_iboton_codigo_key UNIQUE (codigo);


--
-- TOC entry 5663 (class 2606 OID 3176429)
-- Dependencies: 4063 4063
-- Name: tgv_iboton_id_funcionario_key; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_iboton
    ADD CONSTRAINT tgv_iboton_id_funcionario_key UNIQUE (id_funcionario);


--
-- TOC entry 5665 (class 2606 OID 3176425)
-- Dependencies: 4063 4063
-- Name: tgv_iboton_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_iboton
    ADD CONSTRAINT tgv_iboton_pkey PRIMARY KEY (id_iboton);


--
-- TOC entry 5671 (class 2606 OID 3176489)
-- Dependencies: 4069 4069
-- Name: tgv_mantenimiento_det_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_mantenimiento_det
    ADD CONSTRAINT tgv_mantenimiento_det_pkey PRIMARY KEY (id_mantenimiento_det);


--
-- TOC entry 5669 (class 2606 OID 3176459)
-- Dependencies: 4067 4067
-- Name: tgv_mantenimiento_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_mantenimiento
    ADD CONSTRAINT tgv_mantenimiento_pkey PRIMARY KEY (id_mantenimiento);


--
-- TOC entry 5655 (class 2606 OID 3176357)
-- Dependencies: 4057 4057
-- Name: tgv_marca_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_marca
    ADD CONSTRAINT tgv_marca_pkey PRIMARY KEY (id_marca);


--
-- TOC entry 5657 (class 2606 OID 3176379)
-- Dependencies: 4059 4059
-- Name: tgv_modelo_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_modelo
    ADD CONSTRAINT tgv_modelo_pkey PRIMARY KEY (id_modelo);


--
-- TOC entry 5677 (class 2606 OID 3176570)
-- Dependencies: 4075 4075
-- Name: tgv_servicio_det_evento_pkey; Type: CONSTRAINT; Schema: gev; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY tgv_servicio_det_evento
    ADD CONSTRAINT tgv_servicio_det_evento_pkey PRIMARY KEY (id_servicio_det_evento);


--
-- TOC entry 5675 (class 2606 OID 3176545)
-- Dependencies: 4073 4073
-- Name: tgv_servicio_det_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_servicio_det
    ADD CONSTRAINT tgv_servicio_det_pkey PRIMARY KEY (id_servicio_det);


--
-- TOC entry 5673 (class 2606 OID 3176519)
-- Dependencies: 4071 4071
-- Name: tgv_servicio_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_servicio
    ADD CONSTRAINT tgv_servicio_pkey PRIMARY KEY (id_servicio);


--
-- TOC entry 5667 (class 2606 OID 3176445)
-- Dependencies: 4065 4065
-- Name: tgv_tipo_evento_pkey; Type: CONSTRAINT; Schema: gev; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tgv_tipo_evento
    ADD CONSTRAINT tgv_tipo_evento_pkey PRIMARY KEY (id_tipo_evento);


SET search_path = hidro, pg_catalog;

--
-- TOC entry 5475 (class 2606 OID 1379058)
-- Dependencies: 3913 3913
-- Name: thd_administrador_hidro_codigo_key; Type: CONSTRAINT; Schema: hidro; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY thd_administrador_hidro
    ADD CONSTRAINT thd_administrador_hidro_codigo_key UNIQUE (codigo);


--
-- TOC entry 5477 (class 2606 OID 1379060)
-- Dependencies: 3913 3913
-- Name: thd_administrador_hidro_nombre_key; Type: CONSTRAINT; Schema: hidro; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY thd_administrador_hidro
    ADD CONSTRAINT thd_administrador_hidro_nombre_key UNIQUE (nombre);


--
-- TOC entry 5479 (class 2606 OID 1379056)
-- Dependencies: 3913 3913
-- Name: thd_administrador_hidro_pkey; Type: CONSTRAINT; Schema: hidro; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY thd_administrador_hidro
    ADD CONSTRAINT thd_administrador_hidro_pkey PRIMARY KEY (id_administrador);


--
-- TOC entry 5581 (class 2606 OID 2048993)
-- Dependencies: 3990 3990
-- Name: thd_archivo_pkey; Type: CONSTRAINT; Schema: hidro; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY thd_archivo
    ADD CONSTRAINT thd_archivo_pkey PRIMARY KEY (id_archivo);


--
-- TOC entry 5579 (class 2606 OID 2048559)
-- Dependencies: 3988 3988
-- Name: thd_archivo_sensor_pkey; Type: CONSTRAINT; Schema: hidro; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY thd_archivo_sensor
    ADD CONSTRAINT thd_archivo_sensor_pkey PRIMARY KEY (id_archivo_sensor);


--
-- TOC entry 5467 (class 2606 OID 1394036)
-- Dependencies: 3908 3908
-- Name: thd_cuenca_codigo_key; Type: CONSTRAINT; Schema: hidro; Owner: mflores; Tablespace: 
--

ALTER TABLE ONLY thd_cuenca
    ADD CONSTRAINT thd_cuenca_codigo_key UNIQUE (codigo);


--
-- TOC entry 5469 (class 2606 OID 1379264)
-- Dependencies: 3908 3908
-- Name: thd_cuenca_pkey; Type: CONSTRAINT; Schema: hidro; Owner: mflores; Tablespace: 
--

ALTER TABLE ONLY thd_cuenca
    ADD CONSTRAINT thd_cuenca_pkey PRIMARY KEY (id_cuenca);


--
-- TOC entry 5463 (class 2606 OID 1406859)
-- Dependencies: 3906 3906
-- Name: thd_estacion_pkey; Type: CONSTRAINT; Schema: hidro; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY thd_estacion
    ADD CONSTRAINT thd_estacion_pkey PRIMARY KEY (id_estacion);


--
-- TOC entry 5527 (class 2606 OID 1872096)
-- Dependencies: 3946 3946
-- Name: thd_estacion_proyecto_pkey; Type: CONSTRAINT; Schema: hidro; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY thd_estacion_proyecto
    ADD CONSTRAINT thd_estacion_proyecto_pkey PRIMARY KEY (id_estacion_proyecto);


--
-- TOC entry 5495 (class 2606 OID 1427564)
-- Dependencies: 3924 3924
-- Name: thd_medicion_pkey; Type: CONSTRAINT; Schema: hidro; Owner: mflores; Tablespace: 
--

ALTER TABLE ONLY thd_medicion
    ADD CONSTRAINT thd_medicion_pkey PRIMARY KEY (id_medicion);


--
-- TOC entry 5485 (class 2606 OID 1400301)
-- Dependencies: 3916 3916
-- Name: thd_operador_pkey; Type: CONSTRAINT; Schema: hidro; Owner: mflores; Tablespace: 
--

ALTER TABLE ONLY thd_operador
    ADD CONSTRAINT thd_operador_pkey PRIMARY KEY (id_operador);


--
-- TOC entry 5471 (class 2606 OID 1379042)
-- Dependencies: 3911 3911
-- Name: thd_rio_codigo_key; Type: CONSTRAINT; Schema: hidro; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY thd_rio
    ADD CONSTRAINT thd_rio_codigo_key UNIQUE (codigo);


--
-- TOC entry 5473 (class 2606 OID 1379040)
-- Dependencies: 3911 3911
-- Name: thd_rio_pkey; Type: CONSTRAINT; Schema: hidro; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY thd_rio
    ADD CONSTRAINT thd_rio_pkey PRIMARY KEY (id_rio);


--
-- TOC entry 5493 (class 2606 OID 1419958)
-- Dependencies: 3922 3922
-- Name: thd_sensores_pkey; Type: CONSTRAINT; Schema: hidro; Owner: mflores; Tablespace: 
--

ALTER TABLE ONLY thd_sensor
    ADD CONSTRAINT thd_sensores_pkey PRIMARY KEY (id_sensor);


--
-- TOC entry 5577 (class 2606 OID 2048341)
-- Dependencies: 3985 3985
-- Name: thd_tipo_archivo_pkey; Type: CONSTRAINT; Schema: hidro; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_archivo
    ADD CONSTRAINT thd_tipo_archivo_pkey PRIMARY KEY (id_tipo_archivo);


--
-- TOC entry 5679 (class 2606 OID 3198743)
-- Dependencies: 4077 4077
-- Name: thd_tipo_columna_pkey; Type: CONSTRAINT; Schema: hidro; Owner: mflores; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_columna
    ADD CONSTRAINT thd_tipo_columna_pkey PRIMARY KEY (id_tipo_columna);


--
-- TOC entry 5682 (class 2606 OID 3207736)
-- Dependencies: 4079 4079
-- Name: thd_tipo_columna_sensor_pkey; Type: CONSTRAINT; Schema: hidro; Owner: mflores; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_columna_sensor
    ADD CONSTRAINT thd_tipo_columna_sensor_pkey PRIMARY KEY (id_tipo_columna_sensor);


--
-- TOC entry 5699 (class 2606 OID 3322533)
-- Dependencies: 4108 4108
-- Name: thd_tipo_dato_nombre_key; Type: CONSTRAINT; Schema: hidro; Owner: mflores; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_dato
    ADD CONSTRAINT thd_tipo_dato_nombre_key UNIQUE (tipo_dato);


--
-- TOC entry 5701 (class 2606 OID 3322527)
-- Dependencies: 4108 4108
-- Name: thd_tipo_dato_pkey; Type: CONSTRAINT; Schema: hidro; Owner: mflores; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_dato
    ADD CONSTRAINT thd_tipo_dato_pkey PRIMARY KEY (id_tipo_dato);


--
-- TOC entry 5487 (class 2606 OID 2081785)
-- Dependencies: 3918 3918
-- Name: thd_tipo_medicion_abreviacion_key; Type: CONSTRAINT; Schema: hidro; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor
    ADD CONSTRAINT thd_tipo_medicion_abreviacion_key UNIQUE (abreviacion);


--
-- TOC entry 5489 (class 2606 OID 1400231)
-- Dependencies: 3918 3918
-- Name: thd_tipo_medicion_pkey; Type: CONSTRAINT; Schema: hidro; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor
    ADD CONSTRAINT thd_tipo_medicion_pkey PRIMARY KEY (id_tipo_sensor);


--
-- TOC entry 5583 (class 2606 OID 2050764)
-- Dependencies: 3992 3992
-- Name: thd_tipo_muestra_pkey; Type: CONSTRAINT; Schema: hidro; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_muestra
    ADD CONSTRAINT thd_tipo_muestra_pkey PRIMARY KEY (id_tipo_muestra);


--
-- TOC entry 5688 (class 2606 OID 3276674)
-- Dependencies: 4100 4100
-- Name: thd_tipo_sensor_22_pkey; Type: CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_22
    ADD CONSTRAINT thd_tipo_sensor_22_pkey PRIMARY KEY (id_tipo_sensor_22);


--
-- TOC entry 5684 (class 2606 OID 3270717)
-- Dependencies: 4096 4096
-- Name: thd_tipo_sensor_33_pkey; Type: CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_33
    ADD CONSTRAINT thd_tipo_sensor_33_pkey PRIMARY KEY (id_tipo_sensor_33);


--
-- TOC entry 5686 (class 2606 OID 3271729)
-- Dependencies: 4098 4098
-- Name: thd_tipo_sensor_44_pkey; Type: CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_44
    ADD CONSTRAINT thd_tipo_sensor_44_pkey PRIMARY KEY (id_tipo_sensor_44);


--
-- TOC entry 5707 (class 2606 OID 3367552)
-- Dependencies: 4113 4113
-- Name: thd_tipo_sensor_anemometro_pkey; Type: CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_anemometro
    ADD CONSTRAINT thd_tipo_sensor_anemometro_pkey PRIMARY KEY (id_tipo_sensor_anemometro);


--
-- TOC entry 5692 (class 2606 OID 3285677)
-- Dependencies: 4104 4104
-- Name: thd_tipo_sensor_caudal_pkey; Type: CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_caudal
    ADD CONSTRAINT thd_tipo_sensor_caudal_pkey PRIMARY KEY (id_tipo_sensor_caudal);


--
-- TOC entry 5491 (class 2606 OID 3233788)
-- Dependencies: 3918 3918
-- Name: thd_tipo_sensor_codigo_key; Type: CONSTRAINT; Schema: hidro; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor
    ADD CONSTRAINT thd_tipo_sensor_codigo_key UNIQUE (codigo);


--
-- TOC entry 5690 (class 2606 OID 3282966)
-- Dependencies: 4102 4102
-- Name: thd_tipo_sensor_limnimetrica_pkey; Type: CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_limnimetrica
    ADD CONSTRAINT thd_tipo_sensor_limnimetrica_pkey PRIMARY KEY (id_tipo_sensor_limnimetrica);


--
-- TOC entry 5694 (class 2606 OID 3318874)
-- Dependencies: 4106 4106
-- Name: thd_tipo_sensor_presion_pkey; Type: CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_mflores; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_presion
    ADD CONSTRAINT thd_tipo_sensor_presion_pkey PRIMARY KEY (id_tipo_sensor_presion);


--
-- TOC entry 5712 (class 2606 OID 3461602)
-- Dependencies: 4116 4116
-- Name: thd_tipo_sensor_pru_pkey; Type: CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_mflores; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_pru
    ADD CONSTRAINT thd_tipo_sensor_pru_pkey PRIMARY KEY (id_tipo_sensor_pru);


--
-- TOC entry 5716 (class 2606 OID 3470620)
-- Dependencies: 4120 4120
-- Name: thd_tipo_sensor_prue_pkey; Type: CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_mflores; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_prue
    ADD CONSTRAINT thd_tipo_sensor_prue_pkey PRIMARY KEY (id_tipo_sensor_prue);


--
-- TOC entry 5714 (class 2606 OID 3464015)
-- Dependencies: 4118 4118
-- Name: thd_tipo_sensor_termo_pkey; Type: CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_mflores; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_termo
    ADD CONSTRAINT thd_tipo_sensor_termo_pkey PRIMARY KEY (id_tipo_sensor_termo);


--
-- TOC entry 5703 (class 2606 OID 3369212)
-- Dependencies: 4110 4110
-- Name: thd_unidad_medida_pkey; Type: CONSTRAINT; Schema: hidro; Owner: mflores; Tablespace: 
--

ALTER TABLE ONLY thd_unidad_medida
    ADD CONSTRAINT thd_unidad_medida_pkey PRIMARY KEY (simbolo);


--
-- TOC entry 5705 (class 2606 OID 3322552)
-- Dependencies: 4110 4110
-- Name: thd_unidad_medida_unidad_medida_key; Type: CONSTRAINT; Schema: hidro; Owner: mflores; Tablespace: 
--

ALTER TABLE ONLY thd_unidad_medida
    ADD CONSTRAINT thd_unidad_medida_unidad_medida_key UNIQUE (unidad_medida);


SET search_path = log, pg_catalog;

--
-- TOC entry 5155 (class 2606 OID 17561)
-- Dependencies: 3717 3717
-- Name: tlog_2011_02_id_log_key; Type: CONSTRAINT; Schema: log; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_02
    ADD CONSTRAINT tlog_2011_02_id_log_key UNIQUE (id_log);


--
-- TOC entry 5158 (class 2606 OID 17563)
-- Dependencies: 3718 3718
-- Name: tlog_2011_04_id_log_key; Type: CONSTRAINT; Schema: log; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_04
    ADD CONSTRAINT tlog_2011_04_id_log_key UNIQUE (id_log);


--
-- TOC entry 5161 (class 2606 OID 17565)
-- Dependencies: 3719 3719
-- Name: tlog_2011_05_id_log_key; Type: CONSTRAINT; Schema: log; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_05
    ADD CONSTRAINT tlog_2011_05_id_log_key UNIQUE (id_log);


--
-- TOC entry 5408 (class 2606 OID 43525)
-- Dependencies: 3867 3867
-- Name: tlog_2011_06_id_log_key; Type: CONSTRAINT; Schema: log; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_06
    ADD CONSTRAINT tlog_2011_06_id_log_key UNIQUE (id_log);


--
-- TOC entry 5457 (class 2606 OID 1352263)
-- Dependencies: 3904 3904
-- Name: tlog_2011_07_id_log_key; Type: CONSTRAINT; Schema: log; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_07
    ADD CONSTRAINT tlog_2011_07_id_log_key UNIQUE (id_log);


--
-- TOC entry 5460 (class 2606 OID 1361197)
-- Dependencies: 3905 3905
-- Name: tlog_2011_08_id_log_key; Type: CONSTRAINT; Schema: log; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_08
    ADD CONSTRAINT tlog_2011_08_id_log_key UNIQUE (id_log);


--
-- TOC entry 5481 (class 2606 OID 1384725)
-- Dependencies: 3915 3915
-- Name: tlog_2011_09_id_log_key; Type: CONSTRAINT; Schema: log; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_09
    ADD CONSTRAINT tlog_2011_09_id_log_key UNIQUE (id_log);


--
-- TOC entry 5506 (class 2606 OID 1578824)
-- Dependencies: 3933 3933
-- Name: tlog_2011_10_id_log_key; Type: CONSTRAINT; Schema: log; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_10
    ADD CONSTRAINT tlog_2011_10_id_log_key UNIQUE (id_log);


--
-- TOC entry 5533 (class 2606 OID 1914235)
-- Dependencies: 3951 3951
-- Name: tlog_2011_11_id_log_key; Type: CONSTRAINT; Schema: log; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_11
    ADD CONSTRAINT tlog_2011_11_id_log_key UNIQUE (id_log);


--
-- TOC entry 5603 (class 2606 OID 2181250)
-- Dependencies: 4014 4014
-- Name: tlog_2011_12_id_log_key; Type: CONSTRAINT; Schema: log; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_12
    ADD CONSTRAINT tlog_2011_12_id_log_key UNIQUE (id_log);


--
-- TOC entry 5608 (class 2606 OID 2395701)
-- Dependencies: 4017 4017
-- Name: tlog_2012_01_id_log_key; Type: CONSTRAINT; Schema: log; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_2012_01
    ADD CONSTRAINT tlog_2012_01_id_log_key UNIQUE (id_log);


--
-- TOC entry 5611 (class 2606 OID 2549437)
-- Dependencies: 4019 4019
-- Name: tlog_2012_02_id_log_key; Type: CONSTRAINT; Schema: log; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_2012_02
    ADD CONSTRAINT tlog_2012_02_id_log_key UNIQUE (id_log);


--
-- TOC entry 5614 (class 2606 OID 2928816)
-- Dependencies: 4022 4022
-- Name: tlog_2012_03_id_log_key; Type: CONSTRAINT; Schema: log; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_2012_03
    ADD CONSTRAINT tlog_2012_03_id_log_key UNIQUE (id_log);


--
-- TOC entry 5696 (class 2606 OID 3320368)
-- Dependencies: 4107 4107
-- Name: tlog_2012_04_id_log_key; Type: CONSTRAINT; Schema: log; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_2012_04
    ADD CONSTRAINT tlog_2012_04_id_log_key UNIQUE (id_log);


--
-- TOC entry 5709 (class 2606 OID 3440764)
-- Dependencies: 4114 4114
-- Name: tlog_2012_05_id_log_key; Type: CONSTRAINT; Schema: log; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_2012_05
    ADD CONSTRAINT tlog_2012_05_id_log_key UNIQUE (id_log);


--
-- TOC entry 5718 (class 2606 OID 3502039)
-- Dependencies: 4121 4121
-- Name: tlog_2012_06_id_log_key; Type: CONSTRAINT; Schema: log; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_2012_06
    ADD CONSTRAINT tlog_2012_06_id_log_key UNIQUE (id_log);


SET search_path = param, pg_catalog;

--
-- TOC entry 5511 (class 2606 OID 1687707)
-- Dependencies: 3938 3938
-- Name: pk_pm_id_financiador; Type: CONSTRAINT; Schema: param; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tpm_financiador
    ADD CONSTRAINT pk_pm_id_financiador PRIMARY KEY (id_financiador);


--
-- TOC entry 5519 (class 2606 OID 1687762)
-- Dependencies: 3942 3942
-- Name: pk_pm_id_programa; Type: CONSTRAINT; Schema: param; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tpm_programa
    ADD CONSTRAINT pk_pm_id_programa PRIMARY KEY (id_programa);


--
-- TOC entry 5523 (class 2606 OID 1687782)
-- Dependencies: 3944 3944
-- Name: pk_pm_id_proyecto; Type: CONSTRAINT; Schema: param; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tpm_proyecto
    ADD CONSTRAINT pk_pm_id_proyecto PRIMARY KEY (id_proyecto);


--
-- TOC entry 5515 (class 2606 OID 1687742)
-- Dependencies: 3940 3940
-- Name: pk_pm_id_regional; Type: CONSTRAINT; Schema: param; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tpm_regional
    ADD CONSTRAINT pk_pm_id_regional PRIMARY KEY (id_regional);


--
-- TOC entry 5566 (class 2606 OID 1987205)
-- Dependencies: 3975 3975
-- Name: table1_pkey; Type: CONSTRAINT; Schema: param; Owner: rvasquez; Tablespace: 
--

ALTER TABLE ONLY table1
    ADD CONSTRAINT table1_pkey PRIMARY KEY (id_depto_usuario);


--
-- TOC entry 5558 (class 2606 OID 1951832)
-- Dependencies: 3969 3969
-- Name: talarma_pkey; Type: CONSTRAINT; Schema: param; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY talarma
    ADD CONSTRAINT talarma_pkey PRIMARY KEY (id_alarma);


--
-- TOC entry 5606 (class 2606 OID 2188424)
-- Dependencies: 4016 4016
-- Name: tcorrelativo_pkey; Type: CONSTRAINT; Schema: param; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY tcorrelativo
    ADD CONSTRAINT tcorrelativo_pkey PRIMARY KEY (id_correlativo);


--
-- TOC entry 5585 (class 2606 OID 2091662)
-- Dependencies: 3995 3995
-- Name: tdepto_pkey; Type: CONSTRAINT; Schema: param; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tdepto
    ADD CONSTRAINT tdepto_pkey PRIMARY KEY (id_depto);


--
-- TOC entry 5593 (class 2606 OID 2109345)
-- Dependencies: 4003 4003
-- Name: tdepto_usuairo_pkey; Type: CONSTRAINT; Schema: param; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY tdepto_usuario
    ADD CONSTRAINT tdepto_usuairo_pkey PRIMARY KEY (id_depto_usuario);


--
-- TOC entry 5601 (class 2606 OID 2133131)
-- Dependencies: 4011 4011
-- Name: tdocumento_pkey; Type: CONSTRAINT; Schema: param; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY tdocumento
    ADD CONSTRAINT tdocumento_pkey PRIMARY KEY (id_documento);


--
-- TOC entry 5164 (class 2606 OID 17567)
-- Dependencies: 3720 3720
-- Name: tgestion_pkey; Type: CONSTRAINT; Schema: param; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tgestion
    ADD CONSTRAINT tgestion_pkey PRIMARY KEY (id_gestion);


--
-- TOC entry 5499 (class 2606 OID 3279240)
-- Dependencies: 3929 3929
-- Name: tinstitucion_codigo_key; Type: CONSTRAINT; Schema: param; Owner: gvelasquez; Tablespace: 
--

ALTER TABLE ONLY tinstitucion
    ADD CONSTRAINT tinstitucion_codigo_key UNIQUE (codigo);


--
-- TOC entry 5502 (class 2606 OID 1512532)
-- Dependencies: 3929 3929
-- Name: tinstitucion_pkey; Type: CONSTRAINT; Schema: param; Owner: gvelasquez; Tablespace: 
--

ALTER TABLE ONLY tinstitucion
    ADD CONSTRAINT tinstitucion_pkey PRIMARY KEY (id_institucion);


--
-- TOC entry 5465 (class 2606 OID 1371156)
-- Dependencies: 3907 3907
-- Name: tlugas_pkey; Type: CONSTRAINT; Schema: param; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tlugar
    ADD CONSTRAINT tlugas_pkey PRIMARY KEY (id_lugar);


--
-- TOC entry 5166 (class 2606 OID 17569)
-- Dependencies: 3722 3722
-- Name: tmoneda_pkey; Type: CONSTRAINT; Schema: param; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tmoneda
    ADD CONSTRAINT tmoneda_pkey PRIMARY KEY (id_moneda);


--
-- TOC entry 5169 (class 2606 OID 17571)
-- Dependencies: 3724 3724
-- Name: tperiodo_pkey; Type: CONSTRAINT; Schema: param; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tperiodo
    ADD CONSTRAINT tperiodo_pkey PRIMARY KEY (id_periodo);


--
-- TOC entry 5513 (class 2606 OID 1687709)
-- Dependencies: 3938 3938
-- Name: tpm_financiador_codigo_financiador_key; Type: CONSTRAINT; Schema: param; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tpm_financiador
    ADD CONSTRAINT tpm_financiador_codigo_financiador_key UNIQUE (codigo_financiador);


--
-- TOC entry 5521 (class 2606 OID 1687764)
-- Dependencies: 3942 3942
-- Name: tpm_programa_codigo_programa_key; Type: CONSTRAINT; Schema: param; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tpm_programa
    ADD CONSTRAINT tpm_programa_codigo_programa_key UNIQUE (codigo_programa);


--
-- TOC entry 5525 (class 2606 OID 1687784)
-- Dependencies: 3944 3944
-- Name: tpm_proyecto_codigo_proyecto_key; Type: CONSTRAINT; Schema: param; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tpm_proyecto
    ADD CONSTRAINT tpm_proyecto_codigo_proyecto_key UNIQUE (codigo_proyecto);


--
-- TOC entry 5517 (class 2606 OID 1687744)
-- Dependencies: 3940 3940
-- Name: tpm_regional_codigo_regional_key; Type: CONSTRAINT; Schema: param; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tpm_regional
    ADD CONSTRAINT tpm_regional_codigo_regional_key UNIQUE (codigo_regional);


--
-- TOC entry 5560 (class 2606 OID 2245969)
-- Dependencies: 3971 3971 3971 3971
-- Name: tproveedor_idx; Type: CONSTRAINT; Schema: param; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY tproveedor
    ADD CONSTRAINT tproveedor_idx UNIQUE (id_institucion, tipo, estado_reg);


--
-- TOC entry 5562 (class 2606 OID 2245967)
-- Dependencies: 3971 3971 3971 3971
-- Name: tproveedor_idx1; Type: CONSTRAINT; Schema: param; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY tproveedor
    ADD CONSTRAINT tproveedor_idx1 UNIQUE (id_persona, tipo, estado_reg);


--
-- TOC entry 5564 (class 2606 OID 1952163)
-- Dependencies: 3971 3971
-- Name: tproveedor_pkey; Type: CONSTRAINT; Schema: param; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY tproveedor
    ADD CONSTRAINT tproveedor_pkey PRIMARY KEY (id_proveedor);


--
-- TOC entry 5595 (class 2606 OID 2131438)
-- Dependencies: 4007 4007
-- Name: tusuario_uo_pkey; Type: CONSTRAINT; Schema: param; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY tusuario_uo
    ADD CONSTRAINT tusuario_uo_pkey PRIMARY KEY (id_usuario_uo);


SET search_path = public, pg_catalog;

--
-- TOC entry 5531 (class 2606 OID 1898426)
-- Dependencies: 3949 3949 3949 3949 3949
-- Name: geometry_columns_pk; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY geometry_columns
    ADD CONSTRAINT geometry_columns_pk PRIMARY KEY (f_table_catalog, f_table_schema, f_table_name, f_geometry_column);


--
-- TOC entry 5529 (class 2606 OID 1898418)
-- Dependencies: 3948 3948
-- Name: spatial_ref_sys_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY spatial_ref_sys
    ADD CONSTRAINT spatial_ref_sys_pkey PRIMARY KEY (srid);


--
-- TOC entry 5171 (class 2606 OID 17573)
-- Dependencies: 3733 3733
-- Name: variable_global_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY variable_global
    ADD CONSTRAINT variable_global_pkey PRIMARY KEY (id_variable_global);


--
-- TOC entry 5173 (class 2606 OID 17575)
-- Dependencies: 3733 3733
-- Name: variable_global_variable_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY variable_global
    ADD CONSTRAINT variable_global_variable_key UNIQUE (variable);


SET search_path = rhum, pg_catalog;

--
-- TOC entry 5175 (class 2606 OID 17577)
-- Dependencies: 3735 3735
-- Name: tcolumna_pkey; Type: CONSTRAINT; Schema: rhum; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcolumna
    ADD CONSTRAINT tcolumna_pkey PRIMARY KEY (id_columna);


--
-- TOC entry 5587 (class 2606 OID 2106150)
-- Dependencies: 3997 3997
-- Name: testructura_uo_pkey; Type: CONSTRAINT; Schema: rhum; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY testructura_uo
    ADD CONSTRAINT testructura_uo_pkey PRIMARY KEY (id_estructura_uo);


--
-- TOC entry 5181 (class 2606 OID 17579)
-- Dependencies: 3738 3738
-- Name: tfuncionario_horario_pkey; Type: CONSTRAINT; Schema: rhum; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tfuncionario_horario
    ADD CONSTRAINT tfuncionario_horario_pkey PRIMARY KEY (id_funcionario_horario);


--
-- TOC entry 5177 (class 2606 OID 2260408)
-- Dependencies: 3737 3737
-- Name: tfuncionario_id_persona_key; Type: CONSTRAINT; Schema: rhum; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tfuncionario
    ADD CONSTRAINT tfuncionario_id_persona_key UNIQUE (id_persona);


--
-- TOC entry 5179 (class 2606 OID 17581)
-- Dependencies: 3737 3737
-- Name: tfuncionario_pkey; Type: CONSTRAINT; Schema: rhum; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tfuncionario
    ADD CONSTRAINT tfuncionario_pkey PRIMARY KEY (id_funcionario);


--
-- TOC entry 5184 (class 2606 OID 17583)
-- Dependencies: 3741 3741
-- Name: thorario_pkey; Type: CONSTRAINT; Schema: rhum; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY thorario
    ADD CONSTRAINT thorario_pkey PRIMARY KEY (id_horario);


--
-- TOC entry 5597 (class 2606 OID 2131550)
-- Dependencies: 4009 4009
-- Name: tnivel_organizacional_numero_nivel_key; Type: CONSTRAINT; Schema: rhum; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY tnivel_organizacional
    ADD CONSTRAINT tnivel_organizacional_numero_nivel_key UNIQUE (numero_nivel);


--
-- TOC entry 5599 (class 2606 OID 2131548)
-- Dependencies: 4009 4009
-- Name: tnivel_organizacional_pk_kp_id_nivel_organizacional; Type: CONSTRAINT; Schema: rhum; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY tnivel_organizacional
    ADD CONSTRAINT tnivel_organizacional_pk_kp_id_nivel_organizacional PRIMARY KEY (id_nivel_organizacional);


--
-- TOC entry 5186 (class 2606 OID 17585)
-- Dependencies: 3743 3743
-- Name: tobligacion_pkey; Type: CONSTRAINT; Schema: rhum; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tobligacion
    ADD CONSTRAINT tobligacion_pkey PRIMARY KEY (id_obligacion);


--
-- TOC entry 5188 (class 2606 OID 17587)
-- Dependencies: 3745 3745
-- Name: tparametro_rhum_pkey; Type: CONSTRAINT; Schema: rhum; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tparametro_rhum
    ADD CONSTRAINT tparametro_rhum_pkey PRIMARY KEY (id_parametro);


--
-- TOC entry 5190 (class 2606 OID 17589)
-- Dependencies: 3747 3747
-- Name: tplanilla_pkey; Type: CONSTRAINT; Schema: rhum; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tplanilla
    ADD CONSTRAINT tplanilla_pkey PRIMARY KEY (id_planilla);


--
-- TOC entry 5192 (class 2606 OID 17591)
-- Dependencies: 3749 3749
-- Name: ttipo_columna_pkey; Type: CONSTRAINT; Schema: rhum; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY ttipo_columna
    ADD CONSTRAINT ttipo_columna_pkey PRIMARY KEY (id_tipo_columna);


--
-- TOC entry 5194 (class 2606 OID 17593)
-- Dependencies: 3751 3751
-- Name: ttipo_horario_pkey; Type: CONSTRAINT; Schema: rhum; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY ttipo_horario
    ADD CONSTRAINT ttipo_horario_pkey PRIMARY KEY (id_tipo_horario);


--
-- TOC entry 5196 (class 2606 OID 17595)
-- Dependencies: 3753 3753
-- Name: ttipo_obligacion_pkey; Type: CONSTRAINT; Schema: rhum; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY ttipo_obligacion
    ADD CONSTRAINT ttipo_obligacion_pkey PRIMARY KEY (id_tipo_obligacion);


--
-- TOC entry 5198 (class 2606 OID 17597)
-- Dependencies: 3755 3755
-- Name: ttipo_planilla_pkey; Type: CONSTRAINT; Schema: rhum; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY ttipo_planilla
    ADD CONSTRAINT ttipo_planilla_pkey PRIMARY KEY (id_tipo_planilla);


--
-- TOC entry 5589 (class 2606 OID 2106201)
-- Dependencies: 3999 3999
-- Name: tuo_funcionario_pkey; Type: CONSTRAINT; Schema: rhum; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY tuo_funcionario
    ADD CONSTRAINT tuo_funcionario_pkey PRIMARY KEY (id_uo_funcionario);


--
-- TOC entry 5591 (class 2606 OID 2106642)
-- Dependencies: 4001 4001
-- Name: tuo_pkey; Type: CONSTRAINT; Schema: rhum; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY tuo
    ADD CONSTRAINT tuo_pkey PRIMARY KEY (id_uo);


SET search_path = saj, pg_catalog;

--
-- TOC entry 5556 (class 2606 OID 1951742)
-- Dependencies: 3967 3967
-- Name: tboleta_pkey; Type: CONSTRAINT; Schema: saj; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY tboleta
    ADD CONSTRAINT tboleta_pkey PRIMARY KEY (id_boleta);


--
-- TOC entry 5554 (class 2606 OID 1951262)
-- Dependencies: 3965 3965
-- Name: tdocumento_anexo_pkey; Type: CONSTRAINT; Schema: saj; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY tdocumento_anexo
    ADD CONSTRAINT tdocumento_anexo_pkey PRIMARY KEY (id_documento_anexo);


--
-- TOC entry 5540 (class 2606 OID 2222244)
-- Dependencies: 3957 3957
-- Name: testado_codigo_key; Type: CONSTRAINT; Schema: saj; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY testado
    ADD CONSTRAINT testado_codigo_key UNIQUE (codigo);


--
-- TOC entry 5542 (class 2606 OID 2222246)
-- Dependencies: 3957 3957
-- Name: testado_nombre_key; Type: CONSTRAINT; Schema: saj; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY testado
    ADD CONSTRAINT testado_nombre_key UNIQUE (nombre);


--
-- TOC entry 5544 (class 2606 OID 2222242)
-- Dependencies: 3957 3957
-- Name: testado_orden_key; Type: CONSTRAINT; Schema: saj; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY testado
    ADD CONSTRAINT testado_orden_key UNIQUE (orden);


--
-- TOC entry 5546 (class 2606 OID 1945723)
-- Dependencies: 3957 3957
-- Name: testado_pkey; Type: CONSTRAINT; Schema: saj; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY testado
    ADD CONSTRAINT testado_pkey PRIMARY KEY (id_estado);


--
-- TOC entry 5552 (class 2606 OID 1951119)
-- Dependencies: 3963 3963
-- Name: testado_proceso_pkey; Type: CONSTRAINT; Schema: saj; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY testado_proceso
    ADD CONSTRAINT testado_proceso_pkey PRIMARY KEY (id_estado_proceso);


--
-- TOC entry 5536 (class 2606 OID 1944521)
-- Dependencies: 3953 3953
-- Name: tipo_contrato_pkey; Type: CONSTRAINT; Schema: saj; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY ttipo_contrato
    ADD CONSTRAINT tipo_contrato_pkey PRIMARY KEY (id_tipo_contrato);


--
-- TOC entry 5538 (class 2606 OID 1945294)
-- Dependencies: 3955 3955
-- Name: tmodalidad_pkey; Type: CONSTRAINT; Schema: saj; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY tmodalidad
    ADD CONSTRAINT tmodalidad_pkey PRIMARY KEY (id_modalidad);


--
-- TOC entry 5550 (class 2606 OID 1950330)
-- Dependencies: 3961 3961
-- Name: tproceso_contrato_pkey; Type: CONSTRAINT; Schema: saj; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT tproceso_contrato_pkey PRIMARY KEY (id_proceso_contrato);


--
-- TOC entry 5548 (class 2606 OID 1946230)
-- Dependencies: 3959 3959
-- Name: tresponsable_proceso_pkey; Type: CONSTRAINT; Schema: saj; Owner: mzambrana; Tablespace: 
--

ALTER TABLE ONLY tresponsable_proceso
    ADD CONSTRAINT tresponsable_proceso_pkey PRIMARY KEY (id_responsable_proceso);


SET search_path = sast, pg_catalog;

--
-- TOC entry 5571 (class 2606 OID 2420555)
-- Dependencies: 3981 3981
-- Name: testado_orden_key; Type: CONSTRAINT; Schema: sast; Owner: rvasquez; Tablespace: 
--

ALTER TABLE ONLY testado
    ADD CONSTRAINT testado_orden_key UNIQUE (orden);


--
-- TOC entry 5573 (class 2606 OID 1993319)
-- Dependencies: 3981 3981
-- Name: testado_pkey; Type: CONSTRAINT; Schema: sast; Owner: rvasquez; Tablespace: 
--

ALTER TABLE ONLY testado
    ADD CONSTRAINT testado_pkey PRIMARY KEY (id_estado);


--
-- TOC entry 5575 (class 2606 OID 1993330)
-- Dependencies: 3983 3983
-- Name: tipo_requerimiento_pkey; Type: CONSTRAINT; Schema: sast; Owner: rvasquez; Tablespace: 
--

ALTER TABLE ONLY ttipo_requerimiento
    ADD CONSTRAINT tipo_requerimiento_pkey PRIMARY KEY (id_tipo_requerimiento);


--
-- TOC entry 5568 (class 2606 OID 1993291)
-- Dependencies: 3977 3977
-- Name: trequerimientos_pkey; Type: CONSTRAINT; Schema: sast; Owner: rvasquez; Tablespace: 
--

ALTER TABLE ONLY trequerimientos
    ADD CONSTRAINT trequerimientos_pkey PRIMARY KEY (id_requerimiento);


SET search_path = secont, pg_catalog;

--
-- TOC entry 5206 (class 2606 OID 17599)
-- Dependencies: 3758 3758
-- Name: pk_contratista; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY contratista
    ADD CONSTRAINT pk_contratista PRIMARY KEY (id_contratista);


--
-- TOC entry 5212 (class 2606 OID 17601)
-- Dependencies: 3760 3760
-- Name: pk_contrato; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY contrato
    ADD CONSTRAINT pk_contrato PRIMARY KEY (id_contrato);


--
-- TOC entry 5218 (class 2606 OID 17603)
-- Dependencies: 3762 3762
-- Name: pk_correspondencia; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY correspondencia
    ADD CONSTRAINT pk_correspondencia PRIMARY KEY (id_correspondencia);


--
-- TOC entry 5222 (class 2606 OID 17605)
-- Dependencies: 3764 3764
-- Name: pk_doc_anexo; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY doc_anexo
    ADD CONSTRAINT pk_doc_anexo PRIMARY KEY (id_documento);


--
-- TOC entry 5226 (class 2606 OID 17607)
-- Dependencies: 3766 3766
-- Name: pk_empleado; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY empleado
    ADD CONSTRAINT pk_empleado PRIMARY KEY (id_personal);


--
-- TOC entry 5231 (class 2606 OID 17609)
-- Dependencies: 3768 3768
-- Name: pk_estado; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY estado
    ADD CONSTRAINT pk_estado PRIMARY KEY (id_estado);


--
-- TOC entry 5234 (class 2606 OID 17611)
-- Dependencies: 3770 3770
-- Name: pk_estado_requerimiento; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY estado_requerimiento
    ADD CONSTRAINT pk_estado_requerimiento PRIMARY KEY (id_estado_requerimiento);


--
-- TOC entry 5240 (class 2606 OID 17613)
-- Dependencies: 3772 3772
-- Name: pk_garantia; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY garantia
    ADD CONSTRAINT pk_garantia PRIMARY KEY (id_garantia);


--
-- TOC entry 5243 (class 2606 OID 17615)
-- Dependencies: 3774 3774
-- Name: pk_informe; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY informe
    ADD CONSTRAINT pk_informe PRIMARY KEY (id_informe);


--
-- TOC entry 5201 (class 2606 OID 17617)
-- Dependencies: 3757 3757
-- Name: pk_leg_alarma; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY alarma
    ADD CONSTRAINT pk_leg_alarma PRIMARY KEY (id_alarma);


--
-- TOC entry 5247 (class 2606 OID 17619)
-- Dependencies: 3777 3777
-- Name: pk_oferta; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY oferta
    ADD CONSTRAINT pk_oferta PRIMARY KEY (id_oferta);


--
-- TOC entry 5251 (class 2606 OID 17621)
-- Dependencies: 3779 3779
-- Name: pk_persona_juridica; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY persona_juridica
    ADD CONSTRAINT pk_persona_juridica PRIMARY KEY (id_persona_juridica);


--
-- TOC entry 5253 (class 2606 OID 17623)
-- Dependencies: 3781 3781
-- Name: pk_proyecto; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY proyecto
    ADD CONSTRAINT pk_proyecto PRIMARY KEY (id_proyecto);


--
-- TOC entry 5256 (class 2606 OID 17625)
-- Dependencies: 3783 3783
-- Name: pk_representante; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY representante
    ADD CONSTRAINT pk_representante PRIMARY KEY (id_representante);


--
-- TOC entry 5260 (class 2606 OID 17627)
-- Dependencies: 3785 3785
-- Name: pk_requerimiento; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY requerimiento
    ADD CONSTRAINT pk_requerimiento PRIMARY KEY (id_requerimiento);


--
-- TOC entry 5266 (class 2606 OID 17629)
-- Dependencies: 3787 3787
-- Name: pk_resolucion; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY resolucion
    ADD CONSTRAINT pk_resolucion PRIMARY KEY (id_resolucion);


--
-- TOC entry 5269 (class 2606 OID 17631)
-- Dependencies: 3789 3789
-- Name: pk_unidad; Type: CONSTRAINT; Schema: secont; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY unidad
    ADD CONSTRAINT pk_unidad PRIMARY KEY (id_unidad);


SET search_path = segu, pg_catalog;

--
-- TOC entry 5321 (class 2606 OID 17633)
-- Dependencies: 3826 3826
-- Name: gui_codigo_gui_key; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tgui
    ADD CONSTRAINT gui_codigo_gui_key UNIQUE (codigo_gui);


--
-- TOC entry 5723 (class 2606 OID 3512014)
-- Dependencies: 4125 4125
-- Name: libreta_her_pkey; Type: CONSTRAINT; Schema: segu; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY libreta_her
    ADD CONSTRAINT libreta_her_pkey PRIMARY KEY (id_libreta_her);


--
-- TOC entry 5721 (class 2606 OID 3511239)
-- Dependencies: 4123 4123
-- Name: libreta_pkey; Type: CONSTRAINT; Schema: segu; Owner: rac; Tablespace: 
--

ALTER TABLE ONLY libreta
    ADD CONSTRAINT libreta_pkey PRIMARY KEY (id_libreta);


--
-- TOC entry 5273 (class 2606 OID 17635)
-- Dependencies: 3791 3791
-- Name: persona_pk_persona; Type: CONSTRAINT; Schema: segu; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tpersona
    ADD CONSTRAINT persona_pk_persona PRIMARY KEY (id_persona);


--
-- TOC entry 5276 (class 2606 OID 17637)
-- Dependencies: 3795 3795
-- Name: pk_actividad; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tactividad
    ADD CONSTRAINT pk_actividad PRIMARY KEY (id_actividad);


--
-- TOC entry 5314 (class 2606 OID 17639)
-- Dependencies: 3824 3824
-- Name: pk_clasificador; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tclasificador
    ADD CONSTRAINT pk_clasificador PRIMARY KEY (id_clasificador);


--
-- TOC entry 5280 (class 2606 OID 17641)
-- Dependencies: 3798 3798
-- Name: pk_estructura_dato; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY testructura_dato
    ADD CONSTRAINT pk_estructura_dato PRIMARY KEY (id_estructura_dato);


--
-- TOC entry 5285 (class 2606 OID 17643)
-- Dependencies: 3800 3800
-- Name: pk_estructura_gui; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY testructura_gui
    ADD CONSTRAINT pk_estructura_gui PRIMARY KEY (id_estructura_gui);


--
-- TOC entry 5317 (class 2606 OID 17645)
-- Dependencies: 3825 3825
-- Name: pk_funcion; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tfuncion
    ADD CONSTRAINT pk_funcion PRIMARY KEY (id_funcion);


--
-- TOC entry 5324 (class 2606 OID 17647)
-- Dependencies: 3826 3826
-- Name: pk_gui; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tgui
    ADD CONSTRAINT pk_gui PRIMARY KEY (id_gui);


--
-- TOC entry 5289 (class 2606 OID 17649)
-- Dependencies: 3803 3803
-- Name: pk_gui_rol; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tgui_rol
    ADD CONSTRAINT pk_gui_rol PRIMARY KEY (id_gui_rol);


--
-- TOC entry 5303 (class 2606 OID 17651)
-- Dependencies: 3815 3815
-- Name: pk_id_recurso; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY trecurso
    ADD CONSTRAINT pk_id_recurso PRIMARY KEY (id_recurso);


--
-- TOC entry 5328 (class 2606 OID 17653)
-- Dependencies: 3830 3830
-- Name: pk_id_tipo_documento; Type: CONSTRAINT; Schema: segu; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY ttipo_documento
    ADD CONSTRAINT pk_id_tipo_documento PRIMARY KEY (id_tipo_documento);


--
-- TOC entry 5333 (class 2606 OID 17655)
-- Dependencies: 3832 3832
-- Name: pk_log; Type: CONSTRAINT; Schema: segu; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tlog_
    ADD CONSTRAINT pk_log PRIMARY KEY (id_log);


--
-- TOC entry 5341 (class 2606 OID 17657)
-- Dependencies: 3835 3835
-- Name: pk_perfil; Type: CONSTRAINT; Schema: segu; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tperfil
    ADD CONSTRAINT pk_perfil PRIMARY KEY (id_perfil);


--
-- TOC entry 5294 (class 2606 OID 17659)
-- Dependencies: 3806 3806
-- Name: pk_permiso; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tpermiso
    ADD CONSTRAINT pk_permiso PRIMARY KEY (id_permiso);


--
-- TOC entry 5343 (class 2606 OID 17661)
-- Dependencies: 3837 3837
-- Name: pk_primo; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tprimo
    ADD CONSTRAINT pk_primo PRIMARY KEY (id_primo);


--
-- TOC entry 5346 (class 2606 OID 17663)
-- Dependencies: 3838 3838
-- Name: pk_procedimiento; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tprocedimiento
    ADD CONSTRAINT pk_procedimiento PRIMARY KEY (id_procedimiento);


--
-- TOC entry 5297 (class 2606 OID 17665)
-- Dependencies: 3809 3809
-- Name: pk_procedimiento_gui; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tprocedimiento_gui
    ADD CONSTRAINT pk_procedimiento_gui PRIMARY KEY (id_procedimiento_gui);


--
-- TOC entry 5300 (class 2606 OID 17667)
-- Dependencies: 3812 3812
-- Name: pk_proyecto; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tproyecto
    ADD CONSTRAINT pk_proyecto PRIMARY KEY (id_proyecto);


--
-- TOC entry 5352 (class 2606 OID 17669)
-- Dependencies: 3839 3839
-- Name: pk_regional; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tregional
    ADD CONSTRAINT pk_regional PRIMARY KEY (id_regional);


--
-- TOC entry 5355 (class 2606 OID 17671)
-- Dependencies: 3840 3840
-- Name: pk_rol; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY trol
    ADD CONSTRAINT pk_rol PRIMARY KEY (id_rol);


--
-- TOC entry 5308 (class 2606 OID 17673)
-- Dependencies: 3819 3819
-- Name: pk_rol_procedimiento; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY trol_procedimiento_gui
    ADD CONSTRAINT pk_rol_procedimiento PRIMARY KEY (id_rol_procedimiento);


--
-- TOC entry 5360 (class 2606 OID 17675)
-- Dependencies: 3843 3843
-- Name: pk_subsistema; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tsubsistema
    ADD CONSTRAINT pk_subsistema PRIMARY KEY (id_subsistema);


--
-- TOC entry 5367 (class 2606 OID 17677)
-- Dependencies: 3845 3845
-- Name: pk_usuario; Type: CONSTRAINT; Schema: segu; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tusuario
    ADD CONSTRAINT pk_usuario PRIMARY KEY (id_usuario);


--
-- TOC entry 5375 (class 2606 OID 17679)
-- Dependencies: 3846 3846
-- Name: pk_usuario_actividad; Type: CONSTRAINT; Schema: segu; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tusuario_actividad
    ADD CONSTRAINT pk_usuario_actividad PRIMARY KEY (id_usuario_actividad);


--
-- TOC entry 5378 (class 2606 OID 17681)
-- Dependencies: 3847 3847
-- Name: pk_usuario_perfil; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tusuario_perfil
    ADD CONSTRAINT pk_usuario_perfil PRIMARY KEY (id_usuario_perfil);


--
-- TOC entry 5385 (class 2606 OID 17683)
-- Dependencies: 3848 3848
-- Name: pk_usuario_proyecto; Type: CONSTRAINT; Schema: segu; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tusuario_proyecto
    ADD CONSTRAINT pk_usuario_proyecto PRIMARY KEY (id_usuario_proyecto);


--
-- TOC entry 5388 (class 2606 OID 17685)
-- Dependencies: 3849 3849
-- Name: pk_usuario_regional; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tusuario_regional
    ADD CONSTRAINT pk_usuario_regional PRIMARY KEY (id_usuario_regional);


--
-- TOC entry 5394 (class 2606 OID 17687)
-- Dependencies: 3850 3850
-- Name: pk_usuario_rol; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tusuario_rol
    ADD CONSTRAINT pk_usuario_rol PRIMARY KEY (id_usuario_rol);


--
-- TOC entry 5362 (class 2606 OID 17689)
-- Dependencies: 3843 3843
-- Name: subsistema_codigo_key; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tsubsistema
    ADD CONSTRAINT subsistema_codigo_key UNIQUE (codigo);


--
-- TOC entry 5365 (class 2606 OID 17691)
-- Dependencies: 3843 3843
-- Name: subsistema_prefijo_key; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tsubsistema
    ADD CONSTRAINT subsistema_prefijo_key UNIQUE (prefijo);


--
-- TOC entry 5311 (class 2606 OID 17693)
-- Dependencies: 3822 3822
-- Name: tbloqueo_notificacion_pkey; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tbloqueo_notificacion
    ADD CONSTRAINT tbloqueo_notificacion_pkey PRIMARY KEY (id_bloqueo_notificacion);


--
-- TOC entry 5319 (class 2606 OID 3229337)
-- Dependencies: 3825 3825
-- Name: tfuncion_nombre_key; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tfuncion
    ADD CONSTRAINT tfuncion_nombre_key UNIQUE (nombre);


--
-- TOC entry 5326 (class 2606 OID 17695)
-- Dependencies: 3828 3828
-- Name: thorario_trabajo_pkey; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY thorario_trabajo
    ADD CONSTRAINT thorario_trabajo_pkey PRIMARY KEY (id_horario_trabajo);


--
-- TOC entry 5152 (class 2606 OID 17697)
-- Dependencies: 3716 3716
-- Name: tlog_26112010_pk_log; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tlog
    ADD CONSTRAINT tlog_26112010_pk_log PRIMARY KEY (id_log);


--
-- TOC entry 5338 (class 2606 OID 17699)
-- Dependencies: 3833 3833
-- Name: tpatron_evento_pkey; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tpatron_evento
    ADD CONSTRAINT tpatron_evento_pkey PRIMARY KEY (id_patron_evento);


--
-- TOC entry 5350 (class 2606 OID 3211310)
-- Dependencies: 3838 3838
-- Name: tprocedimiento_codigo_key; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tprocedimiento
    ADD CONSTRAINT tprocedimiento_codigo_key UNIQUE (codigo);


--
-- TOC entry 5358 (class 2606 OID 17701)
-- Dependencies: 3841 3841
-- Name: tsesion_pkey; Type: CONSTRAINT; Schema: segu; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tsesion
    ADD CONSTRAINT tsesion_pkey PRIMARY KEY (id_sesion);


--
-- TOC entry 5370 (class 2606 OID 2125290)
-- Dependencies: 3845 3845
-- Name: tusuario_cuenta_key; Type: CONSTRAINT; Schema: segu; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tusuario
    ADD CONSTRAINT tusuario_cuenta_key UNIQUE (cuenta);


SET search_path = tesor, pg_catalog;

--
-- TOC entry 5398 (class 2606 OID 17703)
-- Dependencies: 3861 3861
-- Name: pk_tcaja__id_caja; Type: CONSTRAINT; Schema: tesor; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcaja
    ADD CONSTRAINT pk_tcaja__id_caja PRIMARY KEY (id_caja);


--
-- TOC entry 5400 (class 2606 OID 17705)
-- Dependencies: 3862 3862
-- Name: pk_tcaja_mov__id_caja_mov; Type: CONSTRAINT; Schema: tesor; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcaja_mov
    ADD CONSTRAINT pk_tcaja_mov__id_caja_mov PRIMARY KEY (id_caja_mov);


--
-- TOC entry 5402 (class 2606 OID 17707)
-- Dependencies: 3863 3863
-- Name: pk_tcajero__id_cajero; Type: CONSTRAINT; Schema: tesor; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tcajero
    ADD CONSTRAINT pk_tcajero__id_cajero PRIMARY KEY (id_cajero);


--
-- TOC entry 5404 (class 2606 OID 17709)
-- Dependencies: 3865 3865
-- Name: pk_trecibo__id_recibo; Type: CONSTRAINT; Schema: tesor; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY trecibo
    ADD CONSTRAINT pk_trecibo__id_recibo PRIMARY KEY (id_recibo);


--
-- TOC entry 5406 (class 2606 OID 17711)
-- Dependencies: 3866 3866
-- Name: pk_trendicion__id_rendicion; Type: CONSTRAINT; Schema: tesor; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY trendicion
    ADD CONSTRAINT pk_trendicion__id_rendicion PRIMARY KEY (id_rendicion);


SET search_path = tesoro, pg_catalog;

--
-- TOC entry 5437 (class 2606 OID 56473)
-- Dependencies: 3886 3886
-- Name: tts_corte_moneda_pkey; Type: CONSTRAINT; Schema: tesoro; Owner: rchumacero; Tablespace: 
--

ALTER TABLE ONLY tts_corte_moneda
    ADD CONSTRAINT tts_corte_moneda_pkey PRIMARY KEY (id_corte);


SET search_path = actif, pg_catalog;

--
-- TOC entry 5633 (class 1259 OID 3176109)
-- Dependencies: 4037
-- Name: taf_activo_fijo_fk_taf_acti_fijo__id_sub_tipo; Type: INDEX; Schema: actif; Owner: rchumacero; Tablespace: 
--

CREATE INDEX taf_activo_fijo_fk_taf_acti_fijo__id_sub_tipo ON taf_activo_fijo USING btree (id_sub_tipo_activo);


--
-- TOC entry 5634 (class 1259 OID 3176110)
-- Dependencies: 4037
-- Name: taf_activo_fijo_fk_taf_acti_fijo__id_unidad_constructiva; Type: INDEX; Schema: actif; Owner: rchumacero; Tablespace: 
--

CREATE INDEX taf_activo_fijo_fk_taf_acti_fijo__id_unidad_constructiva ON taf_activo_fijo USING btree (id_unidad_constructiva);


--
-- TOC entry 5635 (class 1259 OID 3176111)
-- Dependencies: 4037
-- Name: taf_activo_fijo_fk_taf_acti_fijo_empl__id_moneda; Type: INDEX; Schema: actif; Owner: rchumacero; Tablespace: 
--

CREATE INDEX taf_activo_fijo_fk_taf_acti_fijo_empl__id_moneda ON taf_activo_fijo USING btree (id_moneda);


--
-- TOC entry 5636 (class 1259 OID 3176112)
-- Dependencies: 4037
-- Name: taf_activo_fijo_fk_taf_acti_fijo_empl__id_moneda_original; Type: INDEX; Schema: actif; Owner: rchumacero; Tablespace: 
--

CREATE INDEX taf_activo_fijo_fk_taf_acti_fijo_empl__id_moneda_original ON taf_activo_fijo USING btree (id_moneda_original);


--
-- TOC entry 5639 (class 1259 OID 3176113)
-- Dependencies: 4037
-- Name: taf_activo_fijo_uk_taf_activo_fijo__codigo; Type: INDEX; Schema: actif; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX taf_activo_fijo_uk_taf_activo_fijo__codigo ON taf_activo_fijo USING btree (codigo);


--
-- TOC entry 5628 (class 1259 OID 3176075)
-- Dependencies: 4035
-- Name: taf_sub_tipo_activo_fk_taf_sub_tipo_acti__id_tipo_activo; Type: INDEX; Schema: actif; Owner: rchumacero; Tablespace: 
--

CREATE INDEX taf_sub_tipo_activo_fk_taf_sub_tipo_acti__id_tipo_activo ON taf_sub_tipo_activo USING btree (id_tipo_activo);


--
-- TOC entry 5624 (class 1259 OID 3176009)
-- Dependencies: 4033
-- Name: taf_tipo_activo_fk_taf_tipo_acti_fijo__id_metodo_depreciacion; Type: INDEX; Schema: actif; Owner: rchumacero; Tablespace: 
--

CREATE INDEX taf_tipo_activo_fk_taf_tipo_acti_fijo__id_metodo_depreciacion ON taf_tipo_activo USING btree (id_metodo_depreciacion);


--
-- TOC entry 5627 (class 1259 OID 3176010)
-- Dependencies: 4033
-- Name: taf_tipo_activo_uk_taf_tipo_activo__codigo; Type: INDEX; Schema: actif; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX taf_tipo_activo_uk_taf_tipo_activo__codigo ON taf_tipo_activo USING btree (codigo);


SET search_path = factur, pg_catalog;

--
-- TOC entry 5417 (class 1259 OID 56325)
-- Dependencies: 3875
-- Name: fk_tfv_descuento__id_cuenta; Type: INDEX; Schema: factur; Owner: rchumacero; Tablespace: 
--

CREATE INDEX fk_tfv_descuento__id_cuenta ON tfv_descuento USING btree (id_cuenta);


--
-- TOC entry 5414 (class 1259 OID 56310)
-- Dependencies: 3873
-- Name: fk_tfv_tasa__id_cuenta; Type: INDEX; Schema: factur; Owner: rchumacero; Tablespace: 
--

CREATE INDEX fk_tfv_tasa__id_cuenta ON tfv_tasa USING btree (id_cuenta);


SET search_path = gen, pg_catalog;

--
-- TOC entry 5148 (class 1259 OID 17713)
-- Dependencies: 3713 3713
-- Name: uk_ttabla_esquema_nombre; Type: INDEX; Schema: gen; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX uk_ttabla_esquema_nombre ON ttabla USING btree (esquema, nombre);


SET search_path = hidro, pg_catalog;

--
-- TOC entry 5483 (class 1259 OID 2049144)
-- Dependencies: 3916
-- Name: thd_operador_id_persona_key; Type: INDEX; Schema: hidro; Owner: mflores; Tablespace: 
--

CREATE UNIQUE INDEX thd_operador_id_persona_key ON thd_operador USING btree (id_persona);


--
-- TOC entry 5680 (class 1259 OID 3236038)
-- Dependencies: 4079 4079
-- Name: thd_tipo_columna_sensor_idx; Type: INDEX; Schema: hidro; Owner: mflores; Tablespace: 
--

CREATE UNIQUE INDEX thd_tipo_columna_sensor_idx ON thd_tipo_columna_sensor USING btree (id_tipo_sensor, codigo_columna);


SET search_path = log, pg_catalog;

--
-- TOC entry 5156 (class 1259 OID 17714)
-- Dependencies: 3717
-- Name: tlog_2011_02_idx; Type: INDEX; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_2011_02_idx ON tlog_2011_02 USING btree (fecha_reg);


--
-- TOC entry 5159 (class 1259 OID 17715)
-- Dependencies: 3718
-- Name: tlog_2011_04_idx; Type: INDEX; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_2011_04_idx ON tlog_2011_04 USING btree (fecha_reg);


--
-- TOC entry 5162 (class 1259 OID 17716)
-- Dependencies: 3719
-- Name: tlog_2011_05_idx; Type: INDEX; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_2011_05_idx ON tlog_2011_05 USING btree (fecha_reg);


--
-- TOC entry 5409 (class 1259 OID 43526)
-- Dependencies: 3867
-- Name: tlog_2011_06_idx; Type: INDEX; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_2011_06_idx ON tlog_2011_06 USING btree (fecha_reg);


--
-- TOC entry 5458 (class 1259 OID 1352264)
-- Dependencies: 3904
-- Name: tlog_2011_07_idx; Type: INDEX; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_2011_07_idx ON tlog_2011_07 USING btree (fecha_reg);


--
-- TOC entry 5461 (class 1259 OID 1361198)
-- Dependencies: 3905
-- Name: tlog_2011_08_idx; Type: INDEX; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_2011_08_idx ON tlog_2011_08 USING btree (fecha_reg);


--
-- TOC entry 5482 (class 1259 OID 1384726)
-- Dependencies: 3915
-- Name: tlog_2011_09_idx; Type: INDEX; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_2011_09_idx ON tlog_2011_09 USING btree (fecha_reg);


--
-- TOC entry 5507 (class 1259 OID 1578825)
-- Dependencies: 3933
-- Name: tlog_2011_10_idx; Type: INDEX; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_2011_10_idx ON tlog_2011_10 USING btree (fecha_reg);


--
-- TOC entry 5534 (class 1259 OID 1914236)
-- Dependencies: 3951
-- Name: tlog_2011_11_idx; Type: INDEX; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_2011_11_idx ON tlog_2011_11 USING btree (fecha_reg);


--
-- TOC entry 5604 (class 1259 OID 2181251)
-- Dependencies: 4014
-- Name: tlog_2011_12_idx; Type: INDEX; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_2011_12_idx ON tlog_2011_12 USING btree (fecha_reg);


--
-- TOC entry 5609 (class 1259 OID 2395702)
-- Dependencies: 4017
-- Name: tlog_2012_01_idx; Type: INDEX; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_2012_01_idx ON tlog_2012_01 USING btree (fecha_reg);


--
-- TOC entry 5612 (class 1259 OID 2549438)
-- Dependencies: 4019
-- Name: tlog_2012_02_idx; Type: INDEX; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_2012_02_idx ON tlog_2012_02 USING btree (fecha_reg);


--
-- TOC entry 5615 (class 1259 OID 2928817)
-- Dependencies: 4022
-- Name: tlog_2012_03_idx; Type: INDEX; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_2012_03_idx ON tlog_2012_03 USING btree (fecha_reg);


--
-- TOC entry 5697 (class 1259 OID 3320369)
-- Dependencies: 4107
-- Name: tlog_2012_04_idx; Type: INDEX; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_2012_04_idx ON tlog_2012_04 USING btree (fecha_reg);


--
-- TOC entry 5710 (class 1259 OID 3440765)
-- Dependencies: 4114
-- Name: tlog_2012_05_idx; Type: INDEX; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_2012_05_idx ON tlog_2012_05 USING btree (fecha_reg);


--
-- TOC entry 5719 (class 1259 OID 3502040)
-- Dependencies: 4121
-- Name: tlog_2012_06_idx; Type: INDEX; Schema: log; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_2012_06_idx ON tlog_2012_06 USING btree (fecha_reg);


SET search_path = param, pg_catalog;

--
-- TOC entry 5500 (class 1259 OID 2241767)
-- Dependencies: 3929 3929
-- Name: tinstitucion_idx; Type: INDEX; Schema: param; Owner: gvelasquez; Tablespace: 
--

CREATE UNIQUE INDEX tinstitucion_idx ON tinstitucion USING btree (doc_id, estado_reg);


--
-- TOC entry 5167 (class 1259 OID 1475588)
-- Dependencies: 3724 3724 3724
-- Name: tperiodo__gestion_per_estado__idx; Type: INDEX; Schema: param; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX tperiodo__gestion_per_estado__idx ON tperiodo USING btree (estado_reg, periodo, id_gestion);


SET search_path = rhum, pg_catalog;

--
-- TOC entry 5182 (class 1259 OID 17717)
-- Dependencies: 3741
-- Name: thorario_id_horario_key; Type: INDEX; Schema: rhum; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX thorario_id_horario_key ON thorario USING btree (id_horario);


SET search_path = sast, pg_catalog;

--
-- TOC entry 5569 (class 1259 OID 2240624)
-- Dependencies: 3981
-- Name: testado_codigo_key; Type: INDEX; Schema: sast; Owner: rvasquez; Tablespace: 
--

CREATE UNIQUE INDEX testado_codigo_key ON testado USING btree (codigo);


SET search_path = secont, pg_catalog;

--
-- TOC entry 5208 (class 1259 OID 17718)
-- Dependencies: 3760
-- Name: abogado_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX abogado_fk ON contrato USING btree (emp_id_empleado);


--
-- TOC entry 5203 (class 1259 OID 17719)
-- Dependencies: 3758
-- Name: contratista_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX contratista_pk ON contratista USING btree (id_contratista);


--
-- TOC entry 5237 (class 1259 OID 17720)
-- Dependencies: 3772
-- Name: contrato_garantia_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX contrato_garantia_fk ON garantia USING btree (id_contrato);


--
-- TOC entry 5209 (class 1259 OID 17721)
-- Dependencies: 3760
-- Name: contrato_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX contrato_pk ON contrato USING btree (id_contrato);


--
-- TOC entry 5264 (class 1259 OID 17722)
-- Dependencies: 3787
-- Name: contrato_resolucion_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX contrato_resolucion_fk ON resolucion USING btree (id_contrato);


--
-- TOC entry 5216 (class 1259 OID 17723)
-- Dependencies: 3762
-- Name: correspondencia_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX correspondencia_pk ON correspondencia USING btree (id_correspondencia);


--
-- TOC entry 5220 (class 1259 OID 17724)
-- Dependencies: 3764
-- Name: doc_anexo_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX doc_anexo_pk ON doc_anexo USING btree (id_documento);


--
-- TOC entry 5204 (class 1259 OID 17725)
-- Dependencies: 3758
-- Name: es_persona_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX es_persona_fk ON contratista USING btree (id_persona);


--
-- TOC entry 5229 (class 1259 OID 17726)
-- Dependencies: 3768
-- Name: estado_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX estado_pk ON estado USING btree (id_estado);


--
-- TOC entry 5232 (class 1259 OID 17727)
-- Dependencies: 3770
-- Name: estado_requerimiento_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX estado_requerimiento_pk ON estado_requerimiento USING btree (id_estado_requerimiento);


--
-- TOC entry 5210 (class 1259 OID 17728)
-- Dependencies: 3760
-- Name: firma_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX firma_fk ON contrato USING btree (id_representante);


--
-- TOC entry 5238 (class 1259 OID 17729)
-- Dependencies: 3772
-- Name: garantia_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX garantia_pk ON garantia USING btree (id_garantia);


--
-- TOC entry 5224 (class 1259 OID 17730)
-- Dependencies: 3766
-- Name: id_empleado_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX id_empleado_pk ON empleado USING btree (id_personal);


--
-- TOC entry 5241 (class 1259 OID 17731)
-- Dependencies: 3774
-- Name: informe_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX informe_pk ON informe USING btree (id_informe);


--
-- TOC entry 5199 (class 1259 OID 17732)
-- Dependencies: 3757
-- Name: leg_alarma_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX leg_alarma_pk ON alarma USING btree (id_alarma);


--
-- TOC entry 5245 (class 1259 OID 17733)
-- Dependencies: 3777
-- Name: oferta_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX oferta_pk ON oferta USING btree (id_oferta);


--
-- TOC entry 5249 (class 1259 OID 17734)
-- Dependencies: 3779
-- Name: persona_juridica_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX persona_juridica_pk ON persona_juridica USING btree (id_persona_juridica);


--
-- TOC entry 5202 (class 1259 OID 17735)
-- Dependencies: 3757
-- Name: proyecto_alarma_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX proyecto_alarma_fk ON alarma USING btree (id_proyecto);


--
-- TOC entry 5213 (class 1259 OID 17736)
-- Dependencies: 3760
-- Name: proyecto_contrato_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX proyecto_contrato_fk ON contrato USING btree (id_proyecto);


--
-- TOC entry 5254 (class 1259 OID 17737)
-- Dependencies: 3781
-- Name: proyecto_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX proyecto_pk ON proyecto USING btree (id_proyecto);


--
-- TOC entry 5227 (class 1259 OID 17738)
-- Dependencies: 3766
-- Name: relationship_12_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX relationship_12_fk ON empleado USING btree (id_persona);


--
-- TOC entry 5235 (class 1259 OID 17739)
-- Dependencies: 3770
-- Name: relationship_13_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX relationship_13_fk ON estado_requerimiento USING btree (id_requerimiento);


--
-- TOC entry 5236 (class 1259 OID 17740)
-- Dependencies: 3770
-- Name: relationship_14_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX relationship_14_fk ON estado_requerimiento USING btree (id_estado);


--
-- TOC entry 5261 (class 1259 OID 17741)
-- Dependencies: 3785
-- Name: relationship_16_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX relationship_16_fk ON requerimiento USING btree (id_personal);


--
-- TOC entry 5207 (class 1259 OID 17742)
-- Dependencies: 3758
-- Name: relationship_22_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX relationship_22_fk ON contratista USING btree (id_persona_juridica);


--
-- TOC entry 5223 (class 1259 OID 17743)
-- Dependencies: 3764
-- Name: relationship_26_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX relationship_26_fk ON doc_anexo USING btree (id_contrato);


--
-- TOC entry 5219 (class 1259 OID 17744)
-- Dependencies: 3762
-- Name: relationship_4_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX relationship_4_fk ON correspondencia USING btree (id_contrato);


--
-- TOC entry 5244 (class 1259 OID 17745)
-- Dependencies: 3774
-- Name: relationship_5_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX relationship_5_fk ON informe USING btree (id_contrato);


--
-- TOC entry 5248 (class 1259 OID 17746)
-- Dependencies: 3777
-- Name: relationship_6_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX relationship_6_fk ON oferta USING btree (id_contrato);


--
-- TOC entry 5214 (class 1259 OID 17747)
-- Dependencies: 3760
-- Name: relationship_9_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX relationship_9_fk ON contrato USING btree (id_requerimiento);


--
-- TOC entry 5257 (class 1259 OID 17748)
-- Dependencies: 3783
-- Name: repre_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX repre_fk ON representante USING btree (id_contratista);


--
-- TOC entry 5258 (class 1259 OID 17749)
-- Dependencies: 3783
-- Name: representante_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX representante_pk ON representante USING btree (id_representante);


--
-- TOC entry 5262 (class 1259 OID 17750)
-- Dependencies: 3785
-- Name: requerimiento_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX requerimiento_pk ON requerimiento USING btree (id_requerimiento);


--
-- TOC entry 5267 (class 1259 OID 17751)
-- Dependencies: 3787
-- Name: resolucion_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX resolucion_pk ON resolucion USING btree (id_resolucion);


--
-- TOC entry 5215 (class 1259 OID 17752)
-- Dependencies: 3760
-- Name: responsable_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX responsable_fk ON contrato USING btree (id_empleado);


--
-- TOC entry 5263 (class 1259 OID 17753)
-- Dependencies: 3785
-- Name: solicitante_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX solicitante_fk ON requerimiento USING btree (emp_id_personal);


--
-- TOC entry 5228 (class 1259 OID 17754)
-- Dependencies: 3766
-- Name: unidad_empleado_fk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE INDEX unidad_empleado_fk ON empleado USING btree (id_unidad);


--
-- TOC entry 5270 (class 1259 OID 17755)
-- Dependencies: 3789
-- Name: unidad_pk; Type: INDEX; Schema: secont; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX unidad_pk ON unidad USING btree (id_unidad);


SET search_path = segu, pg_catalog;

--
-- TOC entry 5312 (class 1259 OID 17756)
-- Dependencies: 3824
-- Name: clasificador_pk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX clasificador_pk ON tclasificador USING btree (id_clasificador);


--
-- TOC entry 5392 (class 1259 OID 17757)
-- Dependencies: 3850
-- Name: es_asignado_fk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX es_asignado_fk ON tusuario_rol USING btree (id_rol);


--
-- TOC entry 5330 (class 1259 OID 17758)
-- Dependencies: 3832
-- Name: esta_fk; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE INDEX esta_fk ON tlog_ USING btree (id_subsistema);


--
-- TOC entry 5278 (class 1259 OID 17759)
-- Dependencies: 3798
-- Name: fki_estructura_dato__id_subsistema; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX fki_estructura_dato__id_subsistema ON testructura_dato USING btree (id_subsistema);


--
-- TOC entry 5282 (class 1259 OID 17760)
-- Dependencies: 3800
-- Name: fki_estructura_gui__id_hijo; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX fki_estructura_gui__id_hijo ON testructura_gui USING btree (id_gui);


--
-- TOC entry 5283 (class 1259 OID 17761)
-- Dependencies: 3800
-- Name: fki_estructura_gui__id_padre; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX fki_estructura_gui__id_padre ON testructura_gui USING btree (fk_id_gui);


--
-- TOC entry 5287 (class 1259 OID 17762)
-- Dependencies: 3803
-- Name: fki_gui_rol__id_gui; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX fki_gui_rol__id_gui ON tgui_rol USING btree (id_gui);


--
-- TOC entry 5291 (class 1259 OID 17763)
-- Dependencies: 3806
-- Name: fki_permiso__id_estructura; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX fki_permiso__id_estructura ON tpermiso USING btree (id_estructura);


--
-- TOC entry 5292 (class 1259 OID 17764)
-- Dependencies: 3806
-- Name: fki_permiso__id_proc; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX fki_permiso__id_proc ON tpermiso USING btree (id_procedimiento);


--
-- TOC entry 5305 (class 1259 OID 17765)
-- Dependencies: 3819
-- Name: fki_rol_procedimiento__id_proc; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX fki_rol_procedimiento__id_proc ON trol_procedimiento_gui USING btree (id_procedimiento_gui);


--
-- TOC entry 5306 (class 1259 OID 17766)
-- Dependencies: 3819
-- Name: fki_rol_procedimiento__id_rol; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX fki_rol_procedimiento__id_rol ON trol_procedimiento_gui USING btree (id_rol);


--
-- TOC entry 5372 (class 1259 OID 17767)
-- Dependencies: 3846
-- Name: fki_usuario_actividad__id_actividad; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE INDEX fki_usuario_actividad__id_actividad ON tusuario_actividad USING btree (id_actividad);


--
-- TOC entry 5373 (class 1259 OID 17768)
-- Dependencies: 3846
-- Name: fki_usuario_actividad__id_usuario; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE INDEX fki_usuario_actividad__id_usuario ON tusuario_actividad USING btree (id_usuario);


--
-- TOC entry 5382 (class 1259 OID 17769)
-- Dependencies: 3848
-- Name: fki_usuario_proyecto__id_proyecto; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE INDEX fki_usuario_proyecto__id_proyecto ON tusuario_proyecto USING btree (id_proyecto);


--
-- TOC entry 5383 (class 1259 OID 17770)
-- Dependencies: 3848
-- Name: fki_usuario_proyecto__id_usuario; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE INDEX fki_usuario_proyecto__id_usuario ON tusuario_proyecto USING btree (id_usuario);


--
-- TOC entry 5315 (class 1259 OID 17771)
-- Dependencies: 3825
-- Name: funcion_pk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX funcion_pk ON tfuncion USING btree (id_funcion);


--
-- TOC entry 5322 (class 1259 OID 17772)
-- Dependencies: 3826
-- Name: gui_pk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX gui_pk ON tgui USING btree (id_gui);


--
-- TOC entry 5331 (class 1259 OID 17773)
-- Dependencies: 3832
-- Name: log_pk; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX log_pk ON tlog_ USING btree (id_log);


--
-- TOC entry 5339 (class 1259 OID 17774)
-- Dependencies: 3835
-- Name: perfil_pk; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX perfil_pk ON tperfil USING btree (id_perfil);


--
-- TOC entry 5271 (class 1259 OID 17775)
-- Dependencies: 3791
-- Name: persona_pk; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX persona_pk ON tpersona USING btree (id_persona);


--
-- TOC entry 5274 (class 1259 OID 17776)
-- Dependencies: 3791
-- Name: persona_relationship_11_fk; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE INDEX persona_relationship_11_fk ON tpersona USING btree (id_persona);


--
-- TOC entry 5277 (class 1259 OID 17777)
-- Dependencies: 3795
-- Name: pki_actividad__id_actividad; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX pki_actividad__id_actividad ON tactividad USING btree (id_actividad);


--
-- TOC entry 5281 (class 1259 OID 17778)
-- Dependencies: 3798
-- Name: pki_estructura_dato__id_estructura_dato; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX pki_estructura_dato__id_estructura_dato ON testructura_dato USING btree (id_estructura_dato);


--
-- TOC entry 5286 (class 1259 OID 17779)
-- Dependencies: 3800
-- Name: pki_estructura_gui__id_estructura_gui; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX pki_estructura_gui__id_estructura_gui ON testructura_gui USING btree (id_estructura_gui);


--
-- TOC entry 5290 (class 1259 OID 17780)
-- Dependencies: 3803
-- Name: pki_gui_rol__id_gui_rol; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX pki_gui_rol__id_gui_rol ON tgui_rol USING btree (id_gui_rol);


--
-- TOC entry 5295 (class 1259 OID 17781)
-- Dependencies: 3806
-- Name: pki_permiso__id_permiso; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX pki_permiso__id_permiso ON tpermiso USING btree (id_permiso);


--
-- TOC entry 5301 (class 1259 OID 17782)
-- Dependencies: 3812
-- Name: pki_proyecto__id_proyecto; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX pki_proyecto__id_proyecto ON tproyecto USING btree (id_proyecto);


--
-- TOC entry 5304 (class 1259 OID 17783)
-- Dependencies: 3815
-- Name: pki_recurso__id_recurso; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX pki_recurso__id_recurso ON trecurso USING btree (id_recurso);


--
-- TOC entry 5309 (class 1259 OID 17784)
-- Dependencies: 3819
-- Name: pki_rol_procedimiento__id_rol_proc; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX pki_rol_procedimiento__id_rol_proc ON trol_procedimiento_gui USING btree (id_rol_procedimiento);


--
-- TOC entry 5329 (class 1259 OID 17785)
-- Dependencies: 3830
-- Name: pki_tipo_documento__id_tipo_doc; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX pki_tipo_documento__id_tipo_doc ON ttipo_documento USING btree (id_tipo_documento);


--
-- TOC entry 5376 (class 1259 OID 17786)
-- Dependencies: 3846
-- Name: pki_usuario_actividad__id_usuario_actividad; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX pki_usuario_actividad__id_usuario_actividad ON tusuario_actividad USING btree (id_usuario_actividad);


--
-- TOC entry 5386 (class 1259 OID 17787)
-- Dependencies: 3848
-- Name: pki_usuario_proyecto__id_usuario_proyecto; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX pki_usuario_proyecto__id_usuario_proyecto ON tusuario_proyecto USING btree (id_usuario_proyecto);


--
-- TOC entry 5344 (class 1259 OID 17788)
-- Dependencies: 3837
-- Name: primo_pk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX primo_pk ON tprimo USING btree (id_primo);


--
-- TOC entry 5334 (class 1259 OID 17789)
-- Dependencies: 3832
-- Name: procedimiento_esta_en_log_fk; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE INDEX procedimiento_esta_en_log_fk ON tlog_ USING btree (id_procedimiento);


--
-- TOC entry 5347 (class 1259 OID 17790)
-- Dependencies: 3838
-- Name: procedimiento_pk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX procedimiento_pk ON tprocedimiento USING btree (id_procedimiento);


--
-- TOC entry 5353 (class 1259 OID 17791)
-- Dependencies: 3839
-- Name: regional_pk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX regional_pk ON tregional USING btree (id_regional);


--
-- TOC entry 5389 (class 1259 OID 17792)
-- Dependencies: 3849
-- Name: regional_tiene_usuarios_fk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX regional_tiene_usuarios_fk ON tusuario_regional USING btree (id_regional);


--
-- TOC entry 5356 (class 1259 OID 17793)
-- Dependencies: 3840
-- Name: rol_pk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX rol_pk ON trol USING btree (id_rol);


--
-- TOC entry 5379 (class 1259 OID 17794)
-- Dependencies: 3847
-- Name: se_asigna_a_usuario_fk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX se_asigna_a_usuario_fk ON tusuario_perfil USING btree (id_perfil);


--
-- TOC entry 5368 (class 1259 OID 17795)
-- Dependencies: 3845
-- Name: se_asigna_fk; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE INDEX se_asigna_fk ON tusuario USING btree (id_clasificador);


--
-- TOC entry 5363 (class 1259 OID 17796)
-- Dependencies: 3843
-- Name: subsistema_pk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX subsistema_pk ON tsubsistema USING btree (id_subsistema);


--
-- TOC entry 5380 (class 1259 OID 17797)
-- Dependencies: 3847
-- Name: tiene_perfil_fk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX tiene_perfil_fk ON tusuario_perfil USING btree (id_usuario);


--
-- TOC entry 5395 (class 1259 OID 17798)
-- Dependencies: 3850
-- Name: tiene_privilegios_fk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX tiene_privilegios_fk ON tusuario_rol USING btree (id_usuario);


--
-- TOC entry 5348 (class 1259 OID 17799)
-- Dependencies: 3838
-- Name: tiene_procedimientos_fk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX tiene_procedimientos_fk ON tprocedimiento USING btree (id_funcion);


--
-- TOC entry 5149 (class 1259 OID 17800)
-- Dependencies: 3716
-- Name: tlog_26112010_esta_fk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX tlog_26112010_esta_fk ON tlog USING btree (id_subsistema);


--
-- TOC entry 5150 (class 1259 OID 17801)
-- Dependencies: 3716
-- Name: tlog_26112010_log_pk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX tlog_26112010_log_pk ON tlog USING btree (id_log);


--
-- TOC entry 5153 (class 1259 OID 17802)
-- Dependencies: 3716
-- Name: tlog_26112010_usuario_esta_en_log_fk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX tlog_26112010_usuario_esta_en_log_fk ON tlog USING btree (id_usuario);


--
-- TOC entry 5335 (class 1259 OID 17803)
-- Dependencies: 3832
-- Name: tlog_idx; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE INDEX tlog_idx ON tlog_ USING btree (ip_maquina);


--
-- TOC entry 5298 (class 1259 OID 2594119)
-- Dependencies: 3809 3809
-- Name: tprocedimiento_gui_idx; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX tprocedimiento_gui_idx ON tprocedimiento_gui USING btree (id_gui, id_procedimiento);


--
-- TOC entry 5336 (class 1259 OID 17804)
-- Dependencies: 3832
-- Name: usuario_esta_en_log_fk; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE INDEX usuario_esta_en_log_fk ON tlog_ USING btree (id_usuario);


--
-- TOC entry 5381 (class 1259 OID 17805)
-- Dependencies: 3847
-- Name: usuario_perfil_pk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX usuario_perfil_pk ON tusuario_perfil USING btree (id_usuario_perfil);


--
-- TOC entry 5390 (class 1259 OID 17806)
-- Dependencies: 3849
-- Name: usuario_pertenece_a_regional_fk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE INDEX usuario_pertenece_a_regional_fk ON tusuario_regional USING btree (id_usuario);


--
-- TOC entry 5371 (class 1259 OID 17807)
-- Dependencies: 3845
-- Name: usuario_pk; Type: INDEX; Schema: segu; Owner: rchumacero; Tablespace: 
--

CREATE UNIQUE INDEX usuario_pk ON tusuario USING btree (id_usuario);


--
-- TOC entry 5391 (class 1259 OID 17808)
-- Dependencies: 3849
-- Name: usuario_regional_pk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX usuario_regional_pk ON tusuario_regional USING btree (id_usuario_regional);


--
-- TOC entry 5396 (class 1259 OID 17809)
-- Dependencies: 3850
-- Name: usuario_rol_pk; Type: INDEX; Schema: segu; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX usuario_rol_pk ON tusuario_rol USING btree (id_usuario_rol);


--
-- TOC entry 5957 (class 2620 OID 17810)
-- Dependencies: 214 3716
-- Name: trig_log; Type: TRIGGER; Schema: segu; Owner: postgres
--

CREATE TRIGGER trig_log BEFORE INSERT ON tlog FOR EACH ROW EXECUTE PROCEDURE ftrig_log();


--
-- TOC entry 5958 (class 2620 OID 17811)
-- Dependencies: 3845 1276
-- Name: trigger_usuario; Type: TRIGGER; Schema: segu; Owner: rchumacero
--

CREATE TRIGGER trigger_usuario AFTER INSERT OR DELETE OR UPDATE ON tusuario FOR EACH ROW EXECUTE PROCEDURE public.trigger_usuario();


SET search_path = actif, pg_catalog;

--
-- TOC entry 5917 (class 2606 OID 3176119)
-- Dependencies: 4037 5629 4035
-- Name: fk_taf_acti_fijo__id_sub_tipo; Type: FK CONSTRAINT; Schema: actif; Owner: rchumacero
--

ALTER TABLE ONLY taf_activo_fijo
    ADD CONSTRAINT fk_taf_acti_fijo__id_sub_tipo FOREIGN KEY (id_sub_tipo_activo) REFERENCES taf_sub_tipo_activo(id_sub_tipo_activo) ON UPDATE CASCADE;


--
-- TOC entry 5916 (class 2606 OID 3176124)
-- Dependencies: 4037 4037 5637
-- Name: fk_taf_activo_fijo__id_clon_origen; Type: FK CONSTRAINT; Schema: actif; Owner: rchumacero
--

ALTER TABLE ONLY taf_activo_fijo
    ADD CONSTRAINT fk_taf_activo_fijo__id_clon_origen FOREIGN KEY (id_clon_origen) REFERENCES taf_activo_fijo(id_activo_fijo);


--
-- TOC entry 5915 (class 2606 OID 3176078)
-- Dependencies: 4035 5625 4033
-- Name: fk_taf_sub_tipo_acti__id_tipo_activo; Type: FK CONSTRAINT; Schema: actif; Owner: rchumacero
--

ALTER TABLE ONLY taf_sub_tipo_activo
    ADD CONSTRAINT fk_taf_sub_tipo_acti__id_tipo_activo FOREIGN KEY (id_tipo_activo) REFERENCES taf_tipo_activo(id_tipo_activo) MATCH FULL ON UPDATE CASCADE;


SET search_path = cobra, pg_catalog;

--
-- TOC entry 5817 (class 2606 OID 1530783)
-- Dependencies: 3882 3927 5496
-- Name: fk_tcb_agencia__id_enti_fin; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_agencia
    ADD CONSTRAINT fk_tcb_agencia__id_enti_fin FOREIGN KEY (id_enti_fin) REFERENCES tcb_enti_fin(id_enti_fin);


--
-- TOC entry 5835 (class 2606 OID 59303)
-- Dependencies: 3890 3902 5440
-- Name: fk_tcb_arqueo__id_caja; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_arqueo
    ADD CONSTRAINT fk_tcb_arqueo__id_caja FOREIGN KEY (id_caja) REFERENCES tcb_caja(id_caja);


--
-- TOC entry 5836 (class 2606 OID 59316)
-- Dependencies: 5452 3903 3902
-- Name: fk_tcb_arqueo_det__id_arqueo; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_arqueo_det
    ADD CONSTRAINT fk_tcb_arqueo_det__id_arqueo FOREIGN KEY (id_arqueo) REFERENCES tcb_arqueo(id_arqueo);


--
-- TOC entry 5837 (class 2606 OID 59321)
-- Dependencies: 5436 3903 3886
-- Name: fk_tcb_arqueo_det__id_corte; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_arqueo_det
    ADD CONSTRAINT fk_tcb_arqueo_det__id_corte FOREIGN KEY (id_corte) REFERENCES tesoro.tts_corte_moneda(id_corte);


--
-- TOC entry 5822 (class 2606 OID 2260991)
-- Dependencies: 3890 5432 3882
-- Name: fk_tcb_caja__id_agencia; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_caja
    ADD CONSTRAINT fk_tcb_caja__id_agencia FOREIGN KEY (id_agencia) REFERENCES tcb_agencia(id_agencia);


--
-- TOC entry 5825 (class 2606 OID 59187)
-- Dependencies: 3896 3890 5440
-- Name: fk_tcb_caja_cajero__id_caja; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_caja_cajero
    ADD CONSTRAINT fk_tcb_caja_cajero__id_caja FOREIGN KEY (id_caja) REFERENCES tcb_caja(id_caja);


--
-- TOC entry 5826 (class 2606 OID 59192)
-- Dependencies: 3896 3892 5442
-- Name: fk_tcb_caja_cajero__id_cajero; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_caja_cajero
    ADD CONSTRAINT fk_tcb_caja_cajero__id_cajero FOREIGN KEY (id_cajero) REFERENCES tcb_cajero(id_cajero);


--
-- TOC entry 5824 (class 2606 OID 59177)
-- Dependencies: 3894 3890 5440
-- Name: fk_tcb_caja_estado__id_caja; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_caja_estado
    ADD CONSTRAINT fk_tcb_caja_estado__id_caja FOREIGN KEY (id_caja) REFERENCES tcb_caja(id_caja);


--
-- TOC entry 5823 (class 2606 OID 59182)
-- Dependencies: 3890 5440 3892
-- Name: fk_tcb_cajero__id_caja; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_cajero
    ADD CONSTRAINT fk_tcb_cajero__id_caja FOREIGN KEY (id_caja) REFERENCES tcb_caja(id_caja);


--
-- TOC entry 5814 (class 2606 OID 1503302)
-- Dependencies: 3878 3877 5422
-- Name: fk_tcb_cliente__id_sistema_dist; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_cliente
    ADD CONSTRAINT fk_tcb_cliente__id_sistema_dist FOREIGN KEY (id_sistema_dist) REFERENCES tcb_sistema_dist(id_sistema_dist);


--
-- TOC entry 5851 (class 2606 OID 2261505)
-- Dependencies: 3927 5501 3929
-- Name: fk_tcb_enti_fin__id_institucion; Type: FK CONSTRAINT; Schema: cobra; Owner: gvelasquez
--

ALTER TABLE ONLY tcb_enti_fin
    ADD CONSTRAINT fk_tcb_enti_fin__id_institucion FOREIGN KEY (id_institucion) REFERENCES param.tinstitucion(id_institucion);


--
-- TOC entry 5820 (class 2606 OID 59197)
-- Dependencies: 3890 5440 3888
-- Name: fk_tcb_factura_cob__id_caja; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_factura_cob
    ADD CONSTRAINT fk_tcb_factura_cob__id_caja FOREIGN KEY (id_caja) REFERENCES tcb_caja(id_caja);


--
-- TOC entry 5821 (class 2606 OID 59202)
-- Dependencies: 5442 3892 3888
-- Name: fk_tcb_factura_cob__id_cajero; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_factura_cob
    ADD CONSTRAINT fk_tcb_factura_cob__id_cajero FOREIGN KEY (id_cajero) REFERENCES tcb_cajero(id_cajero);


--
-- TOC entry 5819 (class 2606 OID 59218)
-- Dependencies: 3722 5165 3888
-- Name: fk_tcb_factura_cob__id_moneda; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_factura_cob
    ADD CONSTRAINT fk_tcb_factura_cob__id_moneda FOREIGN KEY (id_moneda) REFERENCES param.tmoneda(id_moneda);


--
-- TOC entry 5831 (class 2606 OID 59274)
-- Dependencies: 3890 3900 5440
-- Name: fk_tcb_factura_cob_anulado__id_caja; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_factura_cob_anulado
    ADD CONSTRAINT fk_tcb_factura_cob_anulado__id_caja FOREIGN KEY (id_caja) REFERENCES tcb_caja(id_caja);


--
-- TOC entry 5832 (class 2606 OID 59279)
-- Dependencies: 5442 3900 3892
-- Name: fk_tcb_factura_cob_anulado__id_cajero; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_factura_cob_anulado
    ADD CONSTRAINT fk_tcb_factura_cob_anulado__id_cajero FOREIGN KEY (id_cajero) REFERENCES tcb_cajero(id_cajero);


--
-- TOC entry 5834 (class 2606 OID 1949365)
-- Dependencies: 3900 3932 5503
-- Name: fk_tcb_factura_cob_anulado__id_cobro; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_factura_cob_anulado
    ADD CONSTRAINT fk_tcb_factura_cob_anulado__id_cobro FOREIGN KEY (id_cobro) REFERENCES tcb_cobro(id_cobro);


--
-- TOC entry 5830 (class 2606 OID 59268)
-- Dependencies: 3900 3888 5438
-- Name: fk_tcb_factura_cob_anulado__id_factura_cob; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_factura_cob_anulado
    ADD CONSTRAINT fk_tcb_factura_cob_anulado__id_factura_cob FOREIGN KEY (id_factura_cob) REFERENCES tcb_factura_cob(id_factura_cob);


--
-- TOC entry 5833 (class 2606 OID 59284)
-- Dependencies: 3900 3845 5366
-- Name: fk_tcb_factura_cob_anulado__id_usuario; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_factura_cob_anulado
    ADD CONSTRAINT fk_tcb_factura_cob_anulado__id_usuario FOREIGN KEY (id_usuario) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5829 (class 2606 OID 59249)
-- Dependencies: 5418 3898 3875
-- Name: fk_tcb_factura_cob_det__id_descuento; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_factura_cob_det
    ADD CONSTRAINT fk_tcb_factura_cob_det__id_descuento FOREIGN KEY (id_descuento) REFERENCES factur.tfv_descuento(id_descuento);


--
-- TOC entry 5827 (class 2606 OID 59234)
-- Dependencies: 5438 3888 3898
-- Name: fk_tcb_factura_cob_det__id_factura_cob; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_factura_cob_det
    ADD CONSTRAINT fk_tcb_factura_cob_det__id_factura_cob FOREIGN KEY (id_factura_cob) REFERENCES tcb_factura_cob(id_factura_cob);


--
-- TOC entry 5828 (class 2606 OID 59244)
-- Dependencies: 5415 3873 3898
-- Name: fk_tcb_factura_cob_det__id_tasa; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_factura_cob_det
    ADD CONSTRAINT fk_tcb_factura_cob_det__id_tasa FOREIGN KEY (id_tasa) REFERENCES factur.tfv_tasa(id_tasa);


--
-- TOC entry 5815 (class 2606 OID 56448)
-- Dependencies: 5432 3882 3880
-- Name: fk_tcb_sistema_dist_agencia__id_agencia; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_sistema_dist_agencia
    ADD CONSTRAINT fk_tcb_sistema_dist_agencia__id_agencia FOREIGN KEY (id_agencia) REFERENCES tcb_agencia(id_agencia);


--
-- TOC entry 5816 (class 2606 OID 1503307)
-- Dependencies: 3880 3877 5422
-- Name: fk_tcb_sistema_dist_agencia__id_sistema_dist; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_sistema_dist_agencia
    ADD CONSTRAINT fk_tcb_sistema_dist_agencia__id_sistema_dist FOREIGN KEY (id_sistema_dist) REFERENCES tcb_sistema_dist(id_sistema_dist);


--
-- TOC entry 5853 (class 2606 OID 1652101)
-- Dependencies: 3902 3935 5452
-- Name: tcb_arqueo_estado_fk; Type: FK CONSTRAINT; Schema: cobra; Owner: rchumacero
--

ALTER TABLE ONLY tcb_arqueo_estado
    ADD CONSTRAINT tcb_arqueo_estado_fk FOREIGN KEY (id_arqueo) REFERENCES tcb_arqueo(id_arqueo);


SET search_path = conta, pg_catalog;

--
-- TOC entry 5726 (class 2606 OID 17812)
-- Dependencies: 3709 3710 5142
-- Name: fk_tdocumento__id_documento_tipo; Type: FK CONSTRAINT; Schema: conta; Owner: rchumacero
--

ALTER TABLE ONLY tdocumento
    ADD CONSTRAINT fk_tdocumento__id_documento_tipo FOREIGN KEY (id_documento_tipo) REFERENCES tdocumento_tipo(id_documento_tipo);


SET search_path = gen, pg_catalog;

--
-- TOC entry 5727 (class 2606 OID 17817)
-- Dependencies: 3711 3713 5146
-- Name: fk_tcolumna__id_tabla; Type: FK CONSTRAINT; Schema: gen; Owner: rchumacero
--

ALTER TABLE ONLY tcolumna
    ADD CONSTRAINT fk_tcolumna__id_tabla FOREIGN KEY (id_tabla) REFERENCES ttabla(id_tabla);


--
-- TOC entry 5728 (class 2606 OID 17822)
-- Dependencies: 3713 3843 5359
-- Name: fk_ttabla__id_subsistema; Type: FK CONSTRAINT; Schema: gen; Owner: postgres
--

ALTER TABLE ONLY ttabla
    ADD CONSTRAINT fk_ttabla__id_subsistema FOREIGN KEY (id_subsistema) REFERENCES segu.tsubsistema(id_subsistema);


SET search_path = gev, pg_catalog;

--
-- TOC entry 5919 (class 2606 OID 3176197)
-- Dependencies: 4043 4037 5637
-- Name: fk_tgv_activo_fijo_rastreo__id_activo_fijo; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_activo_fijo_rastreo
    ADD CONSTRAINT fk_tgv_activo_fijo_rastreo__id_activo_fijo FOREIGN KEY (id_activo_fijo) REFERENCES actif.taf_activo_fijo(id_activo_fijo);


--
-- TOC entry 5929 (class 2606 OID 3176460)
-- Dependencies: 3737 5178 4067
-- Name: fk_tgv_mantenimiento__id_funcionario; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_mantenimiento
    ADD CONSTRAINT fk_tgv_mantenimiento__id_funcionario FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 5928 (class 2606 OID 3176465)
-- Dependencies: 5563 3971 4067
-- Name: fk_tgv_mantenimiento__id_proveedor; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_mantenimiento
    ADD CONSTRAINT fk_tgv_mantenimiento__id_proveedor FOREIGN KEY (id_proveedor) REFERENCES param.tproveedor(id_proveedor);


--
-- TOC entry 5932 (class 2606 OID 3176491)
-- Dependencies: 5637 4037 4069
-- Name: fk_tgv_mantenimiento_det__id_activo_fijo; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_mantenimiento_det
    ADD CONSTRAINT fk_tgv_mantenimiento_det__id_activo_fijo FOREIGN KEY (id_activo_fijo) REFERENCES actif.taf_activo_fijo(id_activo_fijo);


--
-- TOC entry 5931 (class 2606 OID 3176496)
-- Dependencies: 4069 4050 5648
-- Name: fk_tgv_mantenimiento_det__id_evento; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_mantenimiento_det
    ADD CONSTRAINT fk_tgv_mantenimiento_det__id_evento FOREIGN KEY (id_evento) REFERENCES tgv_evento(id_evento);


--
-- TOC entry 5930 (class 2606 OID 3176501)
-- Dependencies: 4069 5668 4067
-- Name: fk_tgv_mantenimiento_det__id_mantenimiento; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_mantenimiento_det
    ADD CONSTRAINT fk_tgv_mantenimiento_det__id_mantenimiento FOREIGN KEY (id_mantenimiento) REFERENCES tgv_mantenimiento(id_mantenimiento);


--
-- TOC entry 5935 (class 2606 OID 3176520)
-- Dependencies: 4071 5178 3737
-- Name: fk_tgv_servicio__id_funcionario; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_servicio
    ADD CONSTRAINT fk_tgv_servicio__id_funcionario FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 5934 (class 2606 OID 3176525)
-- Dependencies: 5464 4071 3907
-- Name: fk_tgv_servicio__id_lugar_destino; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_servicio
    ADD CONSTRAINT fk_tgv_servicio__id_lugar_destino FOREIGN KEY (id_lugar_destino) REFERENCES param.tlugar(id_lugar);


--
-- TOC entry 5933 (class 2606 OID 3176530)
-- Dependencies: 5464 3907 4071
-- Name: fk_tgv_servicio__id_lugar_origen; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_servicio
    ADD CONSTRAINT fk_tgv_servicio__id_lugar_origen FOREIGN KEY (id_lugar_origen) REFERENCES param.tlugar(id_lugar);


--
-- TOC entry 5921 (class 2606 OID 3176221)
-- Dependencies: 4037 4045 5637
-- Name: tgv_acf_ultreg_fk; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_activo_fijo_ultimo_registro
    ADD CONSTRAINT tgv_acf_ultreg_fk FOREIGN KEY (id_activo_fijo) REFERENCES actif.taf_activo_fijo(id_activo_fijo);


--
-- TOC entry 5918 (class 2606 OID 3176202)
-- Dependencies: 4043 5178 3737
-- Name: tgv_activo_fijo_rastreo__id_funcionario_fk; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_activo_fijo_rastreo
    ADD CONSTRAINT tgv_activo_fijo_rastreo__id_funcionario_fk FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 5920 (class 2606 OID 3176226)
-- Dependencies: 3737 5178 4045
-- Name: tgv_activo_fijo_ultimo_registro__id_funcionarioo_fk; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_activo_fijo_ultimo_registro
    ADD CONSTRAINT tgv_activo_fijo_ultimo_registro__id_funcionarioo_fk FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 5923 (class 2606 OID 3176298)
-- Dependencies: 4050 5648 4052
-- Name: tgv_agrupacion_evento_fk; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_agrupacion_evento
    ADD CONSTRAINT tgv_agrupacion_evento_fk FOREIGN KEY (id_evento) REFERENCES tgv_evento(id_evento);


--
-- TOC entry 5922 (class 2606 OID 3176303)
-- Dependencies: 4047 4052 5646
-- Name: tgv_agrupacion_evento_fk1; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_agrupacion_evento
    ADD CONSTRAINT tgv_agrupacion_evento_fk1 FOREIGN KEY (id_agrupacion) REFERENCES tgv_agrupacion(id_agrupacion);


--
-- TOC entry 5925 (class 2606 OID 3176410)
-- Dependencies: 4061 4059 5656
-- Name: tgv_datos_tec_fk; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_datos_tec
    ADD CONSTRAINT tgv_datos_tec_fk FOREIGN KEY (id_modelo) REFERENCES tgv_modelo(id_modelo);


--
-- TOC entry 5926 (class 2606 OID 3176430)
-- Dependencies: 5178 3737 4063
-- Name: tgv_iboton_fk; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_iboton
    ADD CONSTRAINT tgv_iboton_fk FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 5927 (class 2606 OID 3176470)
-- Dependencies: 5666 4065 4067
-- Name: tgv_mantenimiento_fk; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_mantenimiento
    ADD CONSTRAINT tgv_mantenimiento_fk FOREIGN KEY (id_tipo_evento) REFERENCES tgv_tipo_evento(id_tipo_evento);


--
-- TOC entry 5924 (class 2606 OID 3176380)
-- Dependencies: 4059 4057 5654
-- Name: tgv_modelo_fk; Type: FK CONSTRAINT; Schema: gev; Owner: rchumacero
--

ALTER TABLE ONLY tgv_modelo
    ADD CONSTRAINT tgv_modelo_fk FOREIGN KEY (id_marca) REFERENCES tgv_marca(id_marca);


SET search_path = hidro, pg_catalog;

--
-- TOC entry 5839 (class 2606 OID 1414145)
-- Dependencies: 3906 3913 5478
-- Name: fk_estacion__id_administrador; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_estacion
    ADD CONSTRAINT fk_estacion__id_administrador FOREIGN KEY (id_administrador) REFERENCES thd_administrador_hidro(id_administrador);


--
-- TOC entry 5838 (class 2606 OID 1414140)
-- Dependencies: 3906 3908 5468
-- Name: fk_estacion__id_cuenca; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_estacion
    ADD CONSTRAINT fk_estacion__id_cuenca FOREIGN KEY (id_cuenca) REFERENCES thd_cuenca(id_cuenca);


--
-- TOC entry 5840 (class 2606 OID 1414150)
-- Dependencies: 3906 3907 5464
-- Name: fk_estacion__id_lugar; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_estacion
    ADD CONSTRAINT fk_estacion__id_lugar FOREIGN KEY (id_lugar) REFERENCES param.tlugar(id_lugar);


--
-- TOC entry 5841 (class 2606 OID 1414155)
-- Dependencies: 3906 3911 5472
-- Name: fk_estacion__id_rio; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_estacion
    ADD CONSTRAINT fk_estacion__id_rio FOREIGN KEY (id_rio) REFERENCES thd_rio(id_rio);


--
-- TOC entry 5859 (class 2606 OID 1880257)
-- Dependencies: 3946 3906 5462
-- Name: fk_estacion_proyecto__id_estacion; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_estacion_proyecto
    ADD CONSTRAINT fk_estacion_proyecto__id_estacion FOREIGN KEY (id_estacion) REFERENCES thd_estacion(id_estacion);


--
-- TOC entry 5858 (class 2606 OID 1880252)
-- Dependencies: 3946 3944 5522
-- Name: fk_estacion_proyecto__id_proyecto; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_estacion_proyecto
    ADD CONSTRAINT fk_estacion_proyecto__id_proyecto FOREIGN KEY (id_proyecto) REFERENCES param.tpm_proyecto(id_proyecto);


--
-- TOC entry 5849 (class 2606 OID 2064533)
-- Dependencies: 5580 3990 3924
-- Name: fk_medicion__id_archivo; Type: FK CONSTRAINT; Schema: hidro; Owner: mflores
--

ALTER TABLE ONLY thd_medicion
    ADD CONSTRAINT fk_medicion__id_archivo FOREIGN KEY (id_archivo) REFERENCES thd_archivo(id_archivo);


--
-- TOC entry 5850 (class 2606 OID 2064538)
-- Dependencies: 5484 3916 3924
-- Name: fk_medicion__id_operador; Type: FK CONSTRAINT; Schema: hidro; Owner: mflores
--

ALTER TABLE ONLY thd_medicion
    ADD CONSTRAINT fk_medicion__id_operador FOREIGN KEY (id_operador) REFERENCES thd_operador(id_operador);


--
-- TOC entry 5848 (class 2606 OID 1439712)
-- Dependencies: 3924 3922 5492
-- Name: fk_medicion__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: mflores
--

ALTER TABLE ONLY thd_medicion
    ADD CONSTRAINT fk_medicion__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 5843 (class 2606 OID 1399259)
-- Dependencies: 5272 3916 3791
-- Name: fk_operador__id_persona; Type: FK CONSTRAINT; Schema: hidro; Owner: mflores
--

ALTER TABLE ONLY thd_operador
    ADD CONSTRAINT fk_operador__id_persona FOREIGN KEY (id_persona) REFERENCES segu.tpersona(id_persona);


--
-- TOC entry 5844 (class 2606 OID 1880247)
-- Dependencies: 3916 3944 5522
-- Name: fk_operador__id_proyecto; Type: FK CONSTRAINT; Schema: hidro; Owner: mflores
--

ALTER TABLE ONLY thd_operador
    ADD CONSTRAINT fk_operador__id_proyecto FOREIGN KEY (id_proyecto) REFERENCES param.tpm_proyecto(id_proyecto);


--
-- TOC entry 5846 (class 2606 OID 1427210)
-- Dependencies: 3922 3906 5462
-- Name: fk_sensor__id_estacion; Type: FK CONSTRAINT; Schema: hidro; Owner: mflores
--

ALTER TABLE ONLY thd_sensor
    ADD CONSTRAINT fk_sensor__id_estacion FOREIGN KEY (id_estacion) REFERENCES thd_estacion(id_estacion);


--
-- TOC entry 5845 (class 2606 OID 3326893)
-- Dependencies: 5488 3922 3918
-- Name: fk_sensor__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: mflores
--

ALTER TABLE ONLY thd_sensor
    ADD CONSTRAINT fk_sensor__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 5941 (class 2606 OID 3276680)
-- Dependencies: 3922 5492 4100
-- Name: fk_thd_sensor_22__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE ONLY thd_tipo_sensor_22
    ADD CONSTRAINT fk_thd_sensor_22__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 5937 (class 2606 OID 3270723)
-- Dependencies: 3922 5492 4096
-- Name: fk_thd_sensor_33__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE ONLY thd_tipo_sensor_33
    ADD CONSTRAINT fk_thd_sensor_33__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 5939 (class 2606 OID 3271735)
-- Dependencies: 4098 5492 3922
-- Name: fk_thd_sensor_44__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE ONLY thd_tipo_sensor_44
    ADD CONSTRAINT fk_thd_sensor_44__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 5949 (class 2606 OID 3367558)
-- Dependencies: 4113 3922 5492
-- Name: fk_thd_sensor_anemometro__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE ONLY thd_tipo_sensor_anemometro
    ADD CONSTRAINT fk_thd_sensor_anemometro__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 5945 (class 2606 OID 3285683)
-- Dependencies: 3922 5492 4104
-- Name: fk_thd_sensor_caudal__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE ONLY thd_tipo_sensor_caudal
    ADD CONSTRAINT fk_thd_sensor_caudal__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 5943 (class 2606 OID 3282972)
-- Dependencies: 5492 4102 3922
-- Name: fk_thd_sensor_limnimetrica__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE ONLY thd_tipo_sensor_limnimetrica
    ADD CONSTRAINT fk_thd_sensor_limnimetrica__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 5947 (class 2606 OID 3318880)
-- Dependencies: 4106 5492 3922
-- Name: fk_thd_sensor_presion__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_mflores
--

ALTER TABLE ONLY thd_tipo_sensor_presion
    ADD CONSTRAINT fk_thd_sensor_presion__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 5951 (class 2606 OID 3461608)
-- Dependencies: 3922 5492 4116
-- Name: fk_thd_sensor_pru__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_mflores
--

ALTER TABLE ONLY thd_tipo_sensor_pru
    ADD CONSTRAINT fk_thd_sensor_pru__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 5955 (class 2606 OID 3470626)
-- Dependencies: 5492 4120 3922
-- Name: fk_thd_sensor_prue__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_mflores
--

ALTER TABLE ONLY thd_tipo_sensor_prue
    ADD CONSTRAINT fk_thd_sensor_prue__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 5953 (class 2606 OID 3464021)
-- Dependencies: 5492 4118 3922
-- Name: fk_thd_sensor_termo__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_mflores
--

ALTER TABLE ONLY thd_tipo_sensor_termo
    ADD CONSTRAINT fk_thd_sensor_termo__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 5942 (class 2606 OID 3276675)
-- Dependencies: 3918 4100 5488
-- Name: fk_thd_tipo_sensor_22__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE ONLY thd_tipo_sensor_22
    ADD CONSTRAINT fk_thd_tipo_sensor_22__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 5938 (class 2606 OID 3270718)
-- Dependencies: 3918 4096 5488
-- Name: fk_thd_tipo_sensor_33__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE ONLY thd_tipo_sensor_33
    ADD CONSTRAINT fk_thd_tipo_sensor_33__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 5940 (class 2606 OID 3271730)
-- Dependencies: 3918 4098 5488
-- Name: fk_thd_tipo_sensor_44__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE ONLY thd_tipo_sensor_44
    ADD CONSTRAINT fk_thd_tipo_sensor_44__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 5950 (class 2606 OID 3367553)
-- Dependencies: 4113 5488 3918
-- Name: fk_thd_tipo_sensor_anemometro__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE ONLY thd_tipo_sensor_anemometro
    ADD CONSTRAINT fk_thd_tipo_sensor_anemometro__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 5946 (class 2606 OID 3285678)
-- Dependencies: 3918 4104 5488
-- Name: fk_thd_tipo_sensor_caudal__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE ONLY thd_tipo_sensor_caudal
    ADD CONSTRAINT fk_thd_tipo_sensor_caudal__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 5944 (class 2606 OID 3282967)
-- Dependencies: 5488 3918 4102
-- Name: fk_thd_tipo_sensor_limnimetrica__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_rac
--

ALTER TABLE ONLY thd_tipo_sensor_limnimetrica
    ADD CONSTRAINT fk_thd_tipo_sensor_limnimetrica__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 5948 (class 2606 OID 3318875)
-- Dependencies: 3918 4106 5488
-- Name: fk_thd_tipo_sensor_presion__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_mflores
--

ALTER TABLE ONLY thd_tipo_sensor_presion
    ADD CONSTRAINT fk_thd_tipo_sensor_presion__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 5952 (class 2606 OID 3461603)
-- Dependencies: 3918 5488 4116
-- Name: fk_thd_tipo_sensor_pru__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_mflores
--

ALTER TABLE ONLY thd_tipo_sensor_pru
    ADD CONSTRAINT fk_thd_tipo_sensor_pru__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 5956 (class 2606 OID 3470621)
-- Dependencies: 5488 3918 4120
-- Name: fk_thd_tipo_sensor_prue__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_mflores
--

ALTER TABLE ONLY thd_tipo_sensor_prue
    ADD CONSTRAINT fk_thd_tipo_sensor_prue__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 5954 (class 2606 OID 3464016)
-- Dependencies: 4118 3918 5488
-- Name: fk_thd_tipo_sensor_termo__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: dbendesis_cobra_mflores
--

ALTER TABLE ONLY thd_tipo_sensor_termo
    ADD CONSTRAINT fk_thd_tipo_sensor_termo__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 5936 (class 2606 OID 3207970)
-- Dependencies: 5488 4079 3918
-- Name: fk_tipo_columna_sensor__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: mflores
--

ALTER TABLE ONLY thd_tipo_columna_sensor
    ADD CONSTRAINT fk_tipo_columna_sensor__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 5847 (class 2606 OID 2050792)
-- Dependencies: 5582 3992 3922
-- Name: fkthd_sensor1240; Type: FK CONSTRAINT; Schema: hidro; Owner: mflores
--

ALTER TABLE ONLY thd_sensor
    ADD CONSTRAINT fkthd_sensor1240 FOREIGN KEY (id_tipo_muestra) REFERENCES thd_tipo_muestra(id_tipo_muestra);


--
-- TOC entry 5900 (class 2606 OID 2049223)
-- Dependencies: 3990 3985 5576
-- Name: thd_archivo__id_tipo_archivo; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_archivo
    ADD CONSTRAINT thd_archivo__id_tipo_archivo FOREIGN KEY (id_tipo_archivo) REFERENCES thd_tipo_archivo(id_tipo_archivo);


--
-- TOC entry 5902 (class 2606 OID 2049236)
-- Dependencies: 5366 3845 3990
-- Name: thd_archivo__id_usuario_mod; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_archivo
    ADD CONSTRAINT thd_archivo__id_usuario_mod FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5901 (class 2606 OID 2049228)
-- Dependencies: 5366 3990 3845
-- Name: thd_archivo__id_usuario_reg; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_archivo
    ADD CONSTRAINT thd_archivo__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5899 (class 2606 OID 2049145)
-- Dependencies: 5483 3916 3990
-- Name: thd_archivo_fk; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_archivo
    ADD CONSTRAINT thd_archivo_fk FOREIGN KEY (id_operador) REFERENCES thd_operador(id_persona);


--
-- TOC entry 5895 (class 2606 OID 2049259)
-- Dependencies: 3988 3922 5492
-- Name: thd_archivo_sensor__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_archivo_sensor
    ADD CONSTRAINT thd_archivo_sensor__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 5896 (class 2606 OID 2049267)
-- Dependencies: 3985 5576 3988
-- Name: thd_archivo_sensor__id_tipo_archivo; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_archivo_sensor
    ADD CONSTRAINT thd_archivo_sensor__id_tipo_archivo FOREIGN KEY (id_tipo_archivo) REFERENCES thd_tipo_archivo(id_tipo_archivo);


--
-- TOC entry 5898 (class 2606 OID 2049277)
-- Dependencies: 5366 3988 3845
-- Name: thd_archivo_sensor__id_usuario_mod; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_archivo_sensor
    ADD CONSTRAINT thd_archivo_sensor__id_usuario_mod FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5897 (class 2606 OID 2049272)
-- Dependencies: 5366 3988 3845
-- Name: thd_archivo_sensor__id_usuario_reg; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_archivo_sensor
    ADD CONSTRAINT thd_archivo_sensor__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5892 (class 2606 OID 2049338)
-- Dependencies: 3906 5462 3985
-- Name: thd_tipo_archivo__id_estacion; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_tipo_archivo
    ADD CONSTRAINT thd_tipo_archivo__id_estacion FOREIGN KEY (id_estacion) REFERENCES thd_estacion(id_estacion);


--
-- TOC entry 5893 (class 2606 OID 2049410)
-- Dependencies: 5366 3845 3985
-- Name: thd_tipo_archivo__id_usuairo_reg; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_tipo_archivo
    ADD CONSTRAINT thd_tipo_archivo__id_usuairo_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5894 (class 2606 OID 2049442)
-- Dependencies: 5366 3985 3845
-- Name: thd_tipo_archivo__id_usuario_mod; Type: FK CONSTRAINT; Schema: hidro; Owner: rac
--

ALTER TABLE ONLY thd_tipo_archivo
    ADD CONSTRAINT thd_tipo_archivo__id_usuario_mod FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


SET search_path = param, pg_catalog;

--
-- TOC entry 5904 (class 2606 OID 2115291)
-- Dependencies: 4005 3843 5359
-- Name: fk_tconfig_alarma__id_subsistema; Type: FK CONSTRAINT; Schema: param; Owner: fprudencio
--

ALTER TABLE ONLY tconfig_alarma
    ADD CONSTRAINT fk_tconfig_alarma__id_subsistema FOREIGN KEY (id_subsistema) REFERENCES segu.tsubsistema(id_subsistema);


--
-- TOC entry 5908 (class 2606 OID 2188425)
-- Dependencies: 3995 5584 4016
-- Name: fk_tcorrelativo__id_depto; Type: FK CONSTRAINT; Schema: param; Owner: rac
--

ALTER TABLE ONLY tcorrelativo
    ADD CONSTRAINT fk_tcorrelativo__id_depto FOREIGN KEY (id_depto) REFERENCES tdepto(id_depto);


--
-- TOC entry 5909 (class 2606 OID 2188430)
-- Dependencies: 4016 5600 4011
-- Name: fk_tcorrelativo__id_documento; Type: FK CONSTRAINT; Schema: param; Owner: rac
--

ALTER TABLE ONLY tcorrelativo
    ADD CONSTRAINT fk_tcorrelativo__id_documento FOREIGN KEY (id_documento) REFERENCES tdocumento(id_documento);


--
-- TOC entry 5910 (class 2606 OID 2188435)
-- Dependencies: 4016 3720 5163
-- Name: fk_tcorrelativo__id_gestion; Type: FK CONSTRAINT; Schema: param; Owner: rac
--

ALTER TABLE ONLY tcorrelativo
    ADD CONSTRAINT fk_tcorrelativo__id_gestion FOREIGN KEY (id_gestion) REFERENCES tgestion(id_gestion);


--
-- TOC entry 5911 (class 2606 OID 2188440)
-- Dependencies: 3724 4016 5168
-- Name: fk_tcorrelativo__id_periodo; Type: FK CONSTRAINT; Schema: param; Owner: rac
--

ALTER TABLE ONLY tcorrelativo
    ADD CONSTRAINT fk_tcorrelativo__id_periodo FOREIGN KEY (id_periodo) REFERENCES tperiodo(id_periodo);


--
-- TOC entry 5912 (class 2606 OID 2188445)
-- Dependencies: 5590 4016 4001
-- Name: fk_tcorrelativo__id_uo; Type: FK CONSTRAINT; Schema: param; Owner: rac
--

ALTER TABLE ONLY tcorrelativo
    ADD CONSTRAINT fk_tcorrelativo__id_uo FOREIGN KEY (id_uo) REFERENCES rhum.tuo(id_uo);


--
-- TOC entry 5913 (class 2606 OID 2188450)
-- Dependencies: 3845 4016 5366
-- Name: fk_tcorrelativo__id_usuario_mod; Type: FK CONSTRAINT; Schema: param; Owner: rac
--

ALTER TABLE ONLY tcorrelativo
    ADD CONSTRAINT fk_tcorrelativo__id_usuario_mod FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5914 (class 2606 OID 2188455)
-- Dependencies: 5366 4016 3845
-- Name: fk_tcorrelativo__id_usuario_reg; Type: FK CONSTRAINT; Schema: param; Owner: rac
--

ALTER TABLE ONLY tcorrelativo
    ADD CONSTRAINT fk_tcorrelativo__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5903 (class 2606 OID 2108401)
-- Dependencies: 3843 3995 5359
-- Name: fk_tdepto__id_subsistema; Type: FK CONSTRAINT; Schema: param; Owner: postgres
--

ALTER TABLE ONLY tdepto
    ADD CONSTRAINT fk_tdepto__id_subsistema FOREIGN KEY (id_subsistema) REFERENCES segu.tsubsistema(id_subsistema);


--
-- TOC entry 5907 (class 2606 OID 2133384)
-- Dependencies: 4011 5359 3843
-- Name: fk_tdocumento__id_subsistema; Type: FK CONSTRAINT; Schema: param; Owner: mzambrana
--

ALTER TABLE ONLY tdocumento
    ADD CONSTRAINT fk_tdocumento__id_subsistema FOREIGN KEY (id_subsistema) REFERENCES segu.tsubsistema(id_subsistema);


--
-- TOC entry 5854 (class 2606 OID 1687710)
-- Dependencies: 3938 3845 5366
-- Name: fk_tpm_financiador__id_usuario; Type: FK CONSTRAINT; Schema: param; Owner: rchumacero
--

ALTER TABLE ONLY tpm_financiador
    ADD CONSTRAINT fk_tpm_financiador__id_usuario FOREIGN KEY (id_usuario) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5856 (class 2606 OID 1687765)
-- Dependencies: 3845 3942 5366
-- Name: fk_tpm_programa__id_usuario; Type: FK CONSTRAINT; Schema: param; Owner: rchumacero
--

ALTER TABLE ONLY tpm_programa
    ADD CONSTRAINT fk_tpm_programa__id_usuario FOREIGN KEY (id_usuario) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5857 (class 2606 OID 1687785)
-- Dependencies: 3845 3944 5366
-- Name: fk_tpm_proyecto__id_usuario; Type: FK CONSTRAINT; Schema: param; Owner: rchumacero
--

ALTER TABLE ONLY tpm_proyecto
    ADD CONSTRAINT fk_tpm_proyecto__id_usuario FOREIGN KEY (id_usuario) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5883 (class 2606 OID 1952175)
-- Dependencies: 3971 3929 5501
-- Name: fk_tproveedor__id_institucion; Type: FK CONSTRAINT; Schema: param; Owner: mzambrana
--

ALTER TABLE ONLY tproveedor
    ADD CONSTRAINT fk_tproveedor__id_institucion FOREIGN KEY (id_institucion) REFERENCES tinstitucion(id_institucion);


--
-- TOC entry 5882 (class 2606 OID 1952170)
-- Dependencies: 5272 3791 3971
-- Name: fk_tproveedor__id_persona; Type: FK CONSTRAINT; Schema: param; Owner: mzambrana
--

ALTER TABLE ONLY tproveedor
    ADD CONSTRAINT fk_tproveedor__id_persona FOREIGN KEY (id_persona) REFERENCES segu.tpersona(id_persona);


--
-- TOC entry 5905 (class 2606 OID 2131439)
-- Dependencies: 4007 4001 5590
-- Name: fk_tusuario_uo__id_uo; Type: FK CONSTRAINT; Schema: param; Owner: rac
--

ALTER TABLE ONLY tusuario_uo
    ADD CONSTRAINT fk_tusuario_uo__id_uo FOREIGN KEY (id_uo) REFERENCES rhum.tuo(id_uo);


--
-- TOC entry 5906 (class 2606 OID 2131444)
-- Dependencies: 4007 3845 5366
-- Name: fk_tusuario_uo__id_ususario; Type: FK CONSTRAINT; Schema: param; Owner: rac
--

ALTER TABLE ONLY tusuario_uo
    ADD CONSTRAINT fk_tusuario_uo__id_ususario FOREIGN KEY (id_usuario) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5852 (class 2606 OID 2241768)
-- Dependencies: 3929 5272 3791
-- Name: tinstitucion_fk; Type: FK CONSTRAINT; Schema: param; Owner: gvelasquez
--

ALTER TABLE ONLY tinstitucion
    ADD CONSTRAINT tinstitucion_fk FOREIGN KEY (id_persona) REFERENCES segu.tpersona(id_persona);


--
-- TOC entry 5842 (class 2606 OID 1371157)
-- Dependencies: 3907 3907 5464
-- Name: tlugar_fk; Type: FK CONSTRAINT; Schema: param; Owner: postgres
--

ALTER TABLE ONLY tlugar
    ADD CONSTRAINT tlugar_fk FOREIGN KEY (id_lugar_fk) REFERENCES tlugar(id_lugar);


--
-- TOC entry 5731 (class 2606 OID 2216284)
-- Dependencies: 3724 5163 3720
-- Name: tperiodo_fk; Type: FK CONSTRAINT; Schema: param; Owner: postgres
--

ALTER TABLE ONLY tperiodo
    ADD CONSTRAINT tperiodo_fk FOREIGN KEY (id_gestion) REFERENCES tgestion(id_gestion);


--
-- TOC entry 5855 (class 2606 OID 1687745)
-- Dependencies: 5366 3940 3845
-- Name: tpm_regional_fk; Type: FK CONSTRAINT; Schema: param; Owner: rchumacero
--

ALTER TABLE ONLY tpm_regional
    ADD CONSTRAINT tpm_regional_fk FOREIGN KEY (id_usuario) REFERENCES segu.tusuario(id_usuario);


SET search_path = public, pg_catalog;

--
-- TOC entry 5724 (class 2606 OID 17832)
-- Dependencies: 3708 3845 5366
-- Name: fk_tbase__id_usuario_mod; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY tbase
    ADD CONSTRAINT fk_tbase__id_usuario_mod FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5725 (class 2606 OID 17837)
-- Dependencies: 3845 3708 5366
-- Name: fk_tbase__id_usuario_reg; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY tbase
    ADD CONSTRAINT fk_tbase__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


SET search_path = rhum, pg_catalog;

--
-- TOC entry 5732 (class 2606 OID 17842)
-- Dependencies: 3737 3791 5272
-- Name: fk_tfuncionario__id_persona; Type: FK CONSTRAINT; Schema: rhum; Owner: postgres
--

ALTER TABLE ONLY tfuncionario
    ADD CONSTRAINT fk_tfuncionario__id_persona FOREIGN KEY (id_persona) REFERENCES segu.tpersona(id_persona);


--
-- TOC entry 5733 (class 2606 OID 17847)
-- Dependencies: 3737 3845 5366
-- Name: fk_tfuncionario__id_usuario_mod; Type: FK CONSTRAINT; Schema: rhum; Owner: postgres
--

ALTER TABLE ONLY tfuncionario
    ADD CONSTRAINT fk_tfuncionario__id_usuario_mod FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5734 (class 2606 OID 17852)
-- Dependencies: 3737 3845 5366
-- Name: fk_tfuncionario__id_usuario_reg; Type: FK CONSTRAINT; Schema: rhum; Owner: postgres
--

ALTER TABLE ONLY tfuncionario
    ADD CONSTRAINT fk_tfuncionario__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5735 (class 2606 OID 17857)
-- Dependencies: 5178 3738 3737
-- Name: fk_tfuncionario_horario__id_funcionario; Type: FK CONSTRAINT; Schema: rhum; Owner: postgres
--

ALTER TABLE ONLY tfuncionario_horario
    ADD CONSTRAINT fk_tfuncionario_horario__id_funcionario FOREIGN KEY (id_funcionario) REFERENCES tfuncionario(id_funcionario);


--
-- TOC entry 5736 (class 2606 OID 17862)
-- Dependencies: 3738 3741 5183
-- Name: fk_tfuncionario_horario__id_horario; Type: FK CONSTRAINT; Schema: rhum; Owner: postgres
--

ALTER TABLE ONLY tfuncionario_horario
    ADD CONSTRAINT fk_tfuncionario_horario__id_horario FOREIGN KEY (id_horario) REFERENCES thorario(id_horario);


--
-- TOC entry 5737 (class 2606 OID 17867)
-- Dependencies: 5366 3845 3738
-- Name: fk_tfuncionario_horario__id_usuario_reg; Type: FK CONSTRAINT; Schema: rhum; Owner: postgres
--

ALTER TABLE ONLY tfuncionario_horario
    ADD CONSTRAINT fk_tfuncionario_horario__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5738 (class 2606 OID 17872)
-- Dependencies: 3745 3720 5163
-- Name: fk_tparametro__id_gestion; Type: FK CONSTRAINT; Schema: rhum; Owner: postgres
--

ALTER TABLE ONLY tparametro_rhum
    ADD CONSTRAINT fk_tparametro__id_gestion FOREIGN KEY (id_gestion) REFERENCES param.tgestion(id_gestion);


--
-- TOC entry 5739 (class 2606 OID 17877)
-- Dependencies: 3745 3845 5366
-- Name: fk_tparametro__id_usuario_mod; Type: FK CONSTRAINT; Schema: rhum; Owner: postgres
--

ALTER TABLE ONLY tparametro_rhum
    ADD CONSTRAINT fk_tparametro__id_usuario_mod FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5740 (class 2606 OID 17882)
-- Dependencies: 3745 3845 5366
-- Name: fk_tparametro__id_usuario_reg; Type: FK CONSTRAINT; Schema: rhum; Owner: postgres
--

ALTER TABLE ONLY tparametro_rhum
    ADD CONSTRAINT fk_tparametro__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5741 (class 2606 OID 17887)
-- Dependencies: 3745 3722 5165
-- Name: fk_tparametro_rhum__id_moneda_sal_min_nal; Type: FK CONSTRAINT; Schema: rhum; Owner: postgres
--

ALTER TABLE ONLY tparametro_rhum
    ADD CONSTRAINT fk_tparametro_rhum__id_moneda_sal_min_nal FOREIGN KEY (id_moneda_sal_min_nal) REFERENCES param.tmoneda(id_moneda);


--
-- TOC entry 5742 (class 2606 OID 17892)
-- Dependencies: 3749 3704 5136
-- Name: fk_ttipo_columna__id_auxiliar_pasivo; Type: FK CONSTRAINT; Schema: rhum; Owner: rchumacero
--

ALTER TABLE ONLY ttipo_columna
    ADD CONSTRAINT fk_ttipo_columna__id_auxiliar_pasivo FOREIGN KEY (id_auxiliar_pasivo) REFERENCES conta.tauxiliar(id_auxiliar);


--
-- TOC entry 5743 (class 2606 OID 17897)
-- Dependencies: 3749 5138 3706
-- Name: fk_ttipo_columna__id_cuenta_pasivo; Type: FK CONSTRAINT; Schema: rhum; Owner: rchumacero
--

ALTER TABLE ONLY ttipo_columna
    ADD CONSTRAINT fk_ttipo_columna__id_cuenta_pasivo FOREIGN KEY (id_cuenta_pasivo) REFERENCES conta.tcuenta(id_cuenta);


--
-- TOC entry 5744 (class 2606 OID 17902)
-- Dependencies: 3749 3722 5165
-- Name: fk_ttipo_columna__id_moneda; Type: FK CONSTRAINT; Schema: rhum; Owner: rchumacero
--

ALTER TABLE ONLY ttipo_columna
    ADD CONSTRAINT fk_ttipo_columna__id_moneda FOREIGN KEY (id_moneda) REFERENCES param.tmoneda(id_moneda);


--
-- TOC entry 5745 (class 2606 OID 17907)
-- Dependencies: 3749 3745 5187
-- Name: fk_ttipo_columna__id_parametro_rhum; Type: FK CONSTRAINT; Schema: rhum; Owner: rchumacero
--

ALTER TABLE ONLY ttipo_columna
    ADD CONSTRAINT fk_ttipo_columna__id_parametro_rhum FOREIGN KEY (id_parametro_rhum) REFERENCES tparametro_rhum(id_parametro);


--
-- TOC entry 5746 (class 2606 OID 17912)
-- Dependencies: 3749 3753 5195
-- Name: fk_ttipo_columna__id_tipo_obligacion; Type: FK CONSTRAINT; Schema: rhum; Owner: rchumacero
--

ALTER TABLE ONLY ttipo_columna
    ADD CONSTRAINT fk_ttipo_columna__id_tipo_obligacion FOREIGN KEY (id_tipo_obligacion) REFERENCES ttipo_obligacion(id_tipo_obligacion);


--
-- TOC entry 5747 (class 2606 OID 17917)
-- Dependencies: 5366 3845 3749
-- Name: fk_ttipo_columna__id_usuario_reg; Type: FK CONSTRAINT; Schema: rhum; Owner: rchumacero
--

ALTER TABLE ONLY ttipo_columna
    ADD CONSTRAINT fk_ttipo_columna__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5748 (class 2606 OID 17922)
-- Dependencies: 5165 3722 3755
-- Name: fk_ttipo_planilla__id_moneda; Type: FK CONSTRAINT; Schema: rhum; Owner: rchumacero
--

ALTER TABLE ONLY ttipo_planilla
    ADD CONSTRAINT fk_ttipo_planilla__id_moneda FOREIGN KEY (id_moneda) REFERENCES param.tmoneda(id_moneda);


--
-- TOC entry 5749 (class 2606 OID 17927)
-- Dependencies: 3755 3845 5366
-- Name: fk_ttipo_planilla__id_usuario_mod; Type: FK CONSTRAINT; Schema: rhum; Owner: rchumacero
--

ALTER TABLE ONLY ttipo_planilla
    ADD CONSTRAINT fk_ttipo_planilla__id_usuario_mod FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5750 (class 2606 OID 17932)
-- Dependencies: 3755 3845 5366
-- Name: fk_ttipo_planilla__id_usuario_reg; Type: FK CONSTRAINT; Schema: rhum; Owner: rchumacero
--

ALTER TABLE ONLY ttipo_planilla
    ADD CONSTRAINT fk_ttipo_planilla__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


SET search_path = saj, pg_catalog;

--
-- TOC entry 5874 (class 2606 OID 2067947)
-- Dependencies: 5549 3963 3961
-- Name: fk_testado_proceso_id_proceso_contrato; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY testado_proceso
    ADD CONSTRAINT fk_testado_proceso_id_proceso_contrato FOREIGN KEY (id_proceso_contrato) REFERENCES tproceso_contrato(id_proceso_contrato);


--
-- TOC entry 5862 (class 2606 OID 1951743)
-- Dependencies: 3961 3737 5178
-- Name: fk_tproceso_contrato__id_funcionario; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_funcionario FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 5867 (class 2606 OID 1951979)
-- Dependencies: 3961 3720 5163
-- Name: fk_tproceso_contrato__id_gestion; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_gestion FOREIGN KEY (id_gestion) REFERENCES param.tgestion(id_gestion);


--
-- TOC entry 5869 (class 2606 OID 1952185)
-- Dependencies: 3961 3955 5537
-- Name: fk_tproceso_contrato__id_modalidad; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_modalidad FOREIGN KEY (id_modalidad) REFERENCES tmodalidad(id_modalidad);


--
-- TOC entry 5866 (class 2606 OID 1951962)
-- Dependencies: 3961 5165 3722
-- Name: fk_tproceso_contrato__id_moneda; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_moneda FOREIGN KEY (id_moneda) REFERENCES param.tmoneda(id_moneda);


--
-- TOC entry 5868 (class 2606 OID 1952180)
-- Dependencies: 3971 5563 3961
-- Name: fk_tproceso_contrato__id_proveedor; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_proveedor FOREIGN KEY (id_proveedor) REFERENCES param.tproveedor(id_proveedor);


--
-- TOC entry 5871 (class 2606 OID 1952531)
-- Dependencies: 3944 3961 5522
-- Name: fk_tproceso_contrato__id_proyecto; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_proyecto FOREIGN KEY (id_proyecto) REFERENCES param.tpm_proyecto(id_proyecto);


--
-- TOC entry 5865 (class 2606 OID 1951950)
-- Dependencies: 5547 3959 3961
-- Name: fk_tproceso_contrato__id_rep_legal; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_rep_legal FOREIGN KEY (id_representante_legal) REFERENCES tresponsable_proceso(id_responsable_proceso);


--
-- TOC entry 5863 (class 2606 OID 1951866)
-- Dependencies: 3959 5547 3961
-- Name: fk_tproceso_contrato__id_rpc; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_rpc FOREIGN KEY (id_rpc) REFERENCES tresponsable_proceso(id_responsable_proceso);


--
-- TOC entry 5864 (class 2606 OID 1951929)
-- Dependencies: 5547 3961 3959
-- Name: fk_tproceso_contrato__id_supervisor; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_supervisor FOREIGN KEY (id_supervisor) REFERENCES tresponsable_proceso(id_responsable_proceso);


--
-- TOC entry 5870 (class 2606 OID 1952303)
-- Dependencies: 5535 3961 3953
-- Name: fk_tproceso_contrato__id_tipo_contrato; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_tipo_contrato FOREIGN KEY (id_tipo_contrato) REFERENCES ttipo_contrato(id_tipo_contrato);


--
-- TOC entry 5872 (class 2606 OID 2106648)
-- Dependencies: 5590 3961 4001
-- Name: fk_tproceso_contrato_id_uo; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato_id_uo FOREIGN KEY (id_uo) REFERENCES rhum.tuo(id_uo);


--
-- TOC entry 5861 (class 2606 OID 1946277)
-- Dependencies: 3737 3959 5178
-- Name: fk_tresponsable_proceso__id_funcionario; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tresponsable_proceso
    ADD CONSTRAINT fk_tresponsable_proceso__id_funcionario FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 5860 (class 2606 OID 2406262)
-- Dependencies: 3959 5547 3959
-- Name: fk_tresponsable_proceso__id_responsable_anterior; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tresponsable_proceso
    ADD CONSTRAINT fk_tresponsable_proceso__id_responsable_anterior FOREIGN KEY (id_responsable_proceso_anterior) REFERENCES tresponsable_proceso(id_responsable_proceso);


--
-- TOC entry 5878 (class 2606 OID 2425798)
-- Dependencies: 3967 5501 3929
-- Name: tboleta__id_institucion_fk; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tboleta
    ADD CONSTRAINT tboleta__id_institucion_fk FOREIGN KEY (id_institucion_banco) REFERENCES param.tinstitucion(id_institucion);


--
-- TOC entry 5879 (class 2606 OID 2425793)
-- Dependencies: 3967 5165 3722
-- Name: tboleta__id_moneda_fk; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tboleta
    ADD CONSTRAINT tboleta__id_moneda_fk FOREIGN KEY (id_moneda) REFERENCES param.tmoneda(id_moneda);


--
-- TOC entry 5880 (class 2606 OID 2425788)
-- Dependencies: 3961 3967 5549
-- Name: tboleta__id_proceso_contrato_fk; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tboleta
    ADD CONSTRAINT tboleta__id_proceso_contrato_fk FOREIGN KEY (id_proceso_contrato) REFERENCES tproceso_contrato(id_proceso_contrato);


--
-- TOC entry 5877 (class 2606 OID 2425815)
-- Dependencies: 5366 3967 3845
-- Name: tboleta__id_usuario_fk; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tboleta
    ADD CONSTRAINT tboleta__id_usuario_fk FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 5881 (class 2606 OID 2425783)
-- Dependencies: 3967 3967 5555
-- Name: tboleta_fk; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY tboleta
    ADD CONSTRAINT tboleta_fk FOREIGN KEY (id_boleta_fk) REFERENCES tboleta(id_boleta);


--
-- TOC entry 5876 (class 2606 OID 2222317)
-- Dependencies: 3963 3957 5539
-- Name: testado_proceso_estado_anterior_fk; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY testado_proceso
    ADD CONSTRAINT testado_proceso_estado_anterior_fk FOREIGN KEY (estado_anterior) REFERENCES testado(codigo);


--
-- TOC entry 5875 (class 2606 OID 2222303)
-- Dependencies: 3963 3957 5539
-- Name: testado_proceso_estado_vigente_fk; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY testado_proceso
    ADD CONSTRAINT testado_proceso_estado_vigente_fk FOREIGN KEY (estado_vigente) REFERENCES testado(codigo);


--
-- TOC entry 5873 (class 2606 OID 2292695)
-- Dependencies: 3959 5547 3963
-- Name: testado_proceso_fk; Type: FK CONSTRAINT; Schema: saj; Owner: mzambrana
--

ALTER TABLE ONLY testado_proceso
    ADD CONSTRAINT testado_proceso_fk FOREIGN KEY (id_responsable_proceso) REFERENCES tresponsable_proceso(id_responsable_proceso);


SET search_path = sast, pg_catalog;

--
-- TOC entry 5891 (class 2606 OID 2118308)
-- Dependencies: 4003 5592 3979
-- Name: fk_testado_requerimiento__id_depto_usuario; Type: FK CONSTRAINT; Schema: sast; Owner: rvasquez
--

ALTER TABLE ONLY testado_requerimiento
    ADD CONSTRAINT fk_testado_requerimiento__id_depto_usuario FOREIGN KEY (id_depto_usuario) REFERENCES param.tdepto_usuario(id_depto_usuario);


--
-- TOC entry 5888 (class 2606 OID 2420293)
-- Dependencies: 3977 5567 3979
-- Name: fk_testado_requerimiento__id_requerimiento; Type: FK CONSTRAINT; Schema: sast; Owner: rvasquez
--

ALTER TABLE ONLY testado_requerimiento
    ADD CONSTRAINT fk_testado_requerimiento__id_requerimiento FOREIGN KEY (id_requerimiento) REFERENCES trequerimientos(id_requerimiento);


--
-- TOC entry 5887 (class 2606 OID 2106643)
-- Dependencies: 3977 5584 3995
-- Name: fk_trequerimientos__id_depto; Type: FK CONSTRAINT; Schema: sast; Owner: rvasquez
--

ALTER TABLE ONLY trequerimientos
    ADD CONSTRAINT fk_trequerimientos__id_depto FOREIGN KEY (id_depto) REFERENCES param.tdepto(id_depto);


--
-- TOC entry 5885 (class 2606 OID 1993341)
-- Dependencies: 3737 5178 3977
-- Name: fk_trequerimientos__id_funcionario; Type: FK CONSTRAINT; Schema: sast; Owner: rvasquez
--

ALTER TABLE ONLY trequerimientos
    ADD CONSTRAINT fk_trequerimientos__id_funcionario FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 5884 (class 2606 OID 2290788)
-- Dependencies: 3977 3720 5163
-- Name: fk_trequerimientos__id_gestion; Type: FK CONSTRAINT; Schema: sast; Owner: rvasquez
--

ALTER TABLE ONLY trequerimientos
    ADD CONSTRAINT fk_trequerimientos__id_gestion FOREIGN KEY (id_gestion) REFERENCES param.tgestion(id_gestion);


--
-- TOC entry 5886 (class 2606 OID 1993346)
-- Dependencies: 5574 3977 3983
-- Name: fk_trequerimientos__id_tipo_requerimiento; Type: FK CONSTRAINT; Schema: sast; Owner: rvasquez
--

ALTER TABLE ONLY trequerimientos
    ADD CONSTRAINT fk_trequerimientos__id_tipo_requerimiento FOREIGN KEY (id_tipo_requerimiento) REFERENCES ttipo_requerimiento(id_tipo_requerimiento);


--
-- TOC entry 5889 (class 2606 OID 2240642)
-- Dependencies: 3979 3981 5569
-- Name: testado_requerimiento_estado_anterior_fk; Type: FK CONSTRAINT; Schema: sast; Owner: rvasquez
--

ALTER TABLE ONLY testado_requerimiento
    ADD CONSTRAINT testado_requerimiento_estado_anterior_fk FOREIGN KEY (estado_anterior) REFERENCES testado(codigo);


--
-- TOC entry 5890 (class 2606 OID 2240625)
-- Dependencies: 3979 3981 5569
-- Name: testado_requerimiento_estado_vigente_fk; Type: FK CONSTRAINT; Schema: sast; Owner: rvasquez
--

ALTER TABLE ONLY testado_requerimiento
    ADD CONSTRAINT testado_requerimiento_estado_vigente_fk FOREIGN KEY (estado_vigente) REFERENCES testado(codigo);


SET search_path = secont, pg_catalog;

--
-- TOC entry 5752 (class 2606 OID 17937)
-- Dependencies: 3758 3791 5272
-- Name: fk_contrati_es_person_persona; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY contratista
    ADD CONSTRAINT fk_contrati_es_person_persona FOREIGN KEY (id_persona) REFERENCES segu.tpersona(id_persona) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5753 (class 2606 OID 17942)
-- Dependencies: 3758 3779 5250
-- Name: fk_contrati_relations_persona_; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY contratista
    ADD CONSTRAINT fk_contrati_relations_persona_ FOREIGN KEY (id_persona_juridica) REFERENCES persona_juridica(id_persona_juridica) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5754 (class 2606 OID 17947)
-- Dependencies: 3760 3766 5225
-- Name: fk_contrato_abogado_empleado; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY contrato
    ADD CONSTRAINT fk_contrato_abogado_empleado FOREIGN KEY (emp_id_empleado) REFERENCES empleado(id_personal) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5755 (class 2606 OID 17952)
-- Dependencies: 3760 3783 5255
-- Name: fk_contrato_firma_represen; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY contrato
    ADD CONSTRAINT fk_contrato_firma_represen FOREIGN KEY (id_representante) REFERENCES representante(id_representante) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5756 (class 2606 OID 17957)
-- Dependencies: 3760 3781 5252
-- Name: fk_contrato_proyecto__proyecto; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY contrato
    ADD CONSTRAINT fk_contrato_proyecto__proyecto FOREIGN KEY (id_proyecto) REFERENCES proyecto(id_proyecto) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5757 (class 2606 OID 17962)
-- Dependencies: 3760 3785 5259
-- Name: fk_contrato_relations_requerim; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY contrato
    ADD CONSTRAINT fk_contrato_relations_requerim FOREIGN KEY (id_requerimiento) REFERENCES requerimiento(id_requerimiento) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5758 (class 2606 OID 17967)
-- Dependencies: 3760 3766 5225
-- Name: fk_contrato_responsab_empleado; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY contrato
    ADD CONSTRAINT fk_contrato_responsab_empleado FOREIGN KEY (id_empleado) REFERENCES empleado(id_personal) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5759 (class 2606 OID 17972)
-- Dependencies: 3762 3760 5211
-- Name: fk_correspo_relations_contrato; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY correspondencia
    ADD CONSTRAINT fk_correspo_relations_contrato FOREIGN KEY (id_contrato) REFERENCES contrato(id_contrato) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5760 (class 2606 OID 17977)
-- Dependencies: 5211 3764 3760
-- Name: fk_doc_anex_relations_contrato; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY doc_anexo
    ADD CONSTRAINT fk_doc_anex_relations_contrato FOREIGN KEY (id_contrato) REFERENCES contrato(id_contrato) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5761 (class 2606 OID 17982)
-- Dependencies: 3766 3791 5272
-- Name: fk_empleado_relations_persona; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY empleado
    ADD CONSTRAINT fk_empleado_relations_persona FOREIGN KEY (id_persona) REFERENCES segu.tpersona(id_persona) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5762 (class 2606 OID 17987)
-- Dependencies: 3766 3789 5268
-- Name: fk_empleado_unidad_em_unidad; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY empleado
    ADD CONSTRAINT fk_empleado_unidad_em_unidad FOREIGN KEY (id_unidad) REFERENCES unidad(id_unidad) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5763 (class 2606 OID 17992)
-- Dependencies: 3770 3768 5230
-- Name: fk_estado_r_relations_estado; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY estado_requerimiento
    ADD CONSTRAINT fk_estado_r_relations_estado FOREIGN KEY (id_estado) REFERENCES estado(id_estado) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5764 (class 2606 OID 17997)
-- Dependencies: 3770 5259 3785
-- Name: fk_estado_r_relations_requerim; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY estado_requerimiento
    ADD CONSTRAINT fk_estado_r_relations_requerim FOREIGN KEY (id_requerimiento) REFERENCES requerimiento(id_requerimiento) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5765 (class 2606 OID 18002)
-- Dependencies: 3772 3760 5211
-- Name: fk_garantia_contrato__contrato; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY garantia
    ADD CONSTRAINT fk_garantia_contrato__contrato FOREIGN KEY (id_contrato) REFERENCES contrato(id_contrato) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5766 (class 2606 OID 18007)
-- Dependencies: 3760 5211 3774
-- Name: fk_informe_relations_contrato; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY informe
    ADD CONSTRAINT fk_informe_relations_contrato FOREIGN KEY (id_contrato) REFERENCES contrato(id_contrato) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5751 (class 2606 OID 18012)
-- Dependencies: 5252 3757 3781
-- Name: fk_leg_alar_proyecto__proyecto; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY alarma
    ADD CONSTRAINT fk_leg_alar_proyecto__proyecto FOREIGN KEY (id_proyecto) REFERENCES proyecto(id_proyecto) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5767 (class 2606 OID 18017)
-- Dependencies: 3777 5211 3760
-- Name: fk_oferta_relations_contrato; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY oferta
    ADD CONSTRAINT fk_oferta_relations_contrato FOREIGN KEY (id_contrato) REFERENCES contrato(id_contrato) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5768 (class 2606 OID 18022)
-- Dependencies: 3758 5205 3783
-- Name: fk_represen_repre_contrati; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY representante
    ADD CONSTRAINT fk_represen_repre_contrati FOREIGN KEY (id_contratista) REFERENCES contratista(id_contratista) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5769 (class 2606 OID 18027)
-- Dependencies: 3783 3791 5272
-- Name: fk_representante__id_persona; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY representante
    ADD CONSTRAINT fk_representante__id_persona FOREIGN KEY (id_persona) REFERENCES segu.tpersona(id_persona) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5770 (class 2606 OID 18032)
-- Dependencies: 3785 3766 5225
-- Name: fk_requerim_relations_empleado; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY requerimiento
    ADD CONSTRAINT fk_requerim_relations_empleado FOREIGN KEY (id_personal) REFERENCES empleado(id_personal) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5771 (class 2606 OID 18037)
-- Dependencies: 3785 3766 5225
-- Name: fk_requerim_solicitan_empleado; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY requerimiento
    ADD CONSTRAINT fk_requerim_solicitan_empleado FOREIGN KEY (emp_id_personal) REFERENCES empleado(id_personal) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5772 (class 2606 OID 18042)
-- Dependencies: 3785 3789 5268
-- Name: fk_requerimiento__id_unidad; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY requerimiento
    ADD CONSTRAINT fk_requerimiento__id_unidad FOREIGN KEY (id_unidad) REFERENCES unidad(id_unidad) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5773 (class 2606 OID 18047)
-- Dependencies: 3760 5211 3787
-- Name: fk_resoluci_contrato__contrato; Type: FK CONSTRAINT; Schema: secont; Owner: rchumacero
--

ALTER TABLE ONLY resolucion
    ADD CONSTRAINT fk_resoluci_contrato__contrato FOREIGN KEY (id_contrato) REFERENCES contrato(id_contrato) ON UPDATE RESTRICT ON DELETE RESTRICT;


SET search_path = segu, pg_catalog;

--
-- TOC entry 5774 (class 2606 OID 18052)
-- Dependencies: 3843 5359 3798
-- Name: fk_estructura_dato__id_subsistema; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY testructura_dato
    ADD CONSTRAINT fk_estructura_dato__id_subsistema FOREIGN KEY (id_subsistema) REFERENCES tsubsistema(id_subsistema);


--
-- TOC entry 5775 (class 2606 OID 18057)
-- Dependencies: 3800 3826 5323
-- Name: fk_estructura_gui__id_hijo; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY testructura_gui
    ADD CONSTRAINT fk_estructura_gui__id_hijo FOREIGN KEY (id_gui) REFERENCES tgui(id_gui);


--
-- TOC entry 5776 (class 2606 OID 18062)
-- Dependencies: 3826 5323 3800
-- Name: fk_estructura_gui__id_padre; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY testructura_gui
    ADD CONSTRAINT fk_estructura_gui__id_padre FOREIGN KEY (fk_id_gui) REFERENCES tgui(id_gui);


--
-- TOC entry 5786 (class 2606 OID 18067)
-- Dependencies: 3825 5359 3843
-- Name: fk_funcion__id_subsistema; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tfuncion
    ADD CONSTRAINT fk_funcion__id_subsistema FOREIGN KEY (id_subsistema) REFERENCES tsubsistema(id_subsistema);


--
-- TOC entry 5787 (class 2606 OID 18072)
-- Dependencies: 3826 5359 3843
-- Name: fk_gui__id_subsistema; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tgui
    ADD CONSTRAINT fk_gui__id_subsistema FOREIGN KEY (id_subsistema) REFERENCES tsubsistema(id_subsistema);


--
-- TOC entry 5777 (class 2606 OID 18077)
-- Dependencies: 3803 3826 5323
-- Name: fk_gui_rol__id_gui; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tgui_rol
    ADD CONSTRAINT fk_gui_rol__id_gui FOREIGN KEY (id_gui) REFERENCES tgui(id_gui);


--
-- TOC entry 5778 (class 2606 OID 18082)
-- Dependencies: 5354 3803 3840
-- Name: fk_gui_rol__id_rol; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tgui_rol
    ADD CONSTRAINT fk_gui_rol__id_rol FOREIGN KEY (id_rol) REFERENCES trol(id_rol);


--
-- TOC entry 5785 (class 2606 OID 18087)
-- Dependencies: 3833 5337 3822
-- Name: fk_id_patron_evento; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tbloqueo_notificacion
    ADD CONSTRAINT fk_id_patron_evento FOREIGN KEY (id_patron_evento) REFERENCES tpatron_evento(id_patron_evento) ON UPDATE CASCADE;


--
-- TOC entry 5788 (class 2606 OID 18092)
-- Dependencies: 5359 3832 3843
-- Name: fk_log_esta_subsiste; Type: FK CONSTRAINT; Schema: segu; Owner: rchumacero
--

ALTER TABLE ONLY tlog_
    ADD CONSTRAINT fk_log_esta_subsiste FOREIGN KEY (id_subsistema) REFERENCES tsubsistema(id_subsistema) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5729 (class 2606 OID 18097)
-- Dependencies: 3716 3843 5359
-- Name: fk_log_esta_subsiste; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tlog
    ADD CONSTRAINT fk_log_esta_subsiste FOREIGN KEY (id_subsistema) REFERENCES tsubsistema(id_subsistema) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5789 (class 2606 OID 18102)
-- Dependencies: 3838 3832 5345
-- Name: fk_log_procedimi_procedim; Type: FK CONSTRAINT; Schema: segu; Owner: rchumacero
--

ALTER TABLE ONLY tlog_
    ADD CONSTRAINT fk_log_procedimi_procedim FOREIGN KEY (id_procedimiento) REFERENCES tprocedimiento(id_procedimiento) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5790 (class 2606 OID 18107)
-- Dependencies: 5366 3832 3845
-- Name: fk_log_usuario_e_usuario; Type: FK CONSTRAINT; Schema: segu; Owner: rchumacero
--

ALTER TABLE ONLY tlog_
    ADD CONSTRAINT fk_log_usuario_e_usuario FOREIGN KEY (id_usuario) REFERENCES tusuario(id_usuario) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5730 (class 2606 OID 18112)
-- Dependencies: 5366 3845 3716
-- Name: fk_log_usuario_e_usuario; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tlog
    ADD CONSTRAINT fk_log_usuario_e_usuario FOREIGN KEY (id_usuario) REFERENCES tusuario(id_usuario) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5791 (class 2606 OID 18117)
-- Dependencies: 3815 5302 3835
-- Name: fk_perfil__id_recurso; Type: FK CONSTRAINT; Schema: segu; Owner: rchumacero
--

ALTER TABLE ONLY tperfil
    ADD CONSTRAINT fk_perfil__id_recurso FOREIGN KEY (id_recurso) REFERENCES trecurso(id_recurso);


--
-- TOC entry 5779 (class 2606 OID 18122)
-- Dependencies: 3806 3798 5279
-- Name: fk_permiso__id_estructura; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tpermiso
    ADD CONSTRAINT fk_permiso__id_estructura FOREIGN KEY (id_estructura) REFERENCES testructura_dato(id_estructura_dato);


--
-- TOC entry 5780 (class 2606 OID 18127)
-- Dependencies: 3806 3838 5345
-- Name: fk_permiso__id_proc; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tpermiso
    ADD CONSTRAINT fk_permiso__id_proc FOREIGN KEY (id_procedimiento) REFERENCES tprocedimiento(id_procedimiento);


--
-- TOC entry 5792 (class 2606 OID 18137)
-- Dependencies: 5316 3838 3825
-- Name: fk_procedim_tiene_pro_funcion; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tprocedimiento
    ADD CONSTRAINT fk_procedim_tiene_pro_funcion FOREIGN KEY (id_funcion) REFERENCES tfuncion(id_funcion) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5781 (class 2606 OID 18142)
-- Dependencies: 3826 5323 3809
-- Name: fk_procedimiento_gui__id_gui; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tprocedimiento_gui
    ADD CONSTRAINT fk_procedimiento_gui__id_gui FOREIGN KEY (id_gui) REFERENCES tgui(id_gui);


--
-- TOC entry 5782 (class 2606 OID 18147)
-- Dependencies: 3809 3838 5345
-- Name: fk_procedimiento_gui__id_proc; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tprocedimiento_gui
    ADD CONSTRAINT fk_procedimiento_gui__id_proc FOREIGN KEY (id_procedimiento) REFERENCES tprocedimiento(id_procedimiento);


--
-- TOC entry 5793 (class 2606 OID 18152)
-- Dependencies: 3843 3840 5359
-- Name: fk_rol__id_subsistema; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY trol
    ADD CONSTRAINT fk_rol__id_subsistema FOREIGN KEY (id_subsistema) REFERENCES tsubsistema(id_subsistema);


--
-- TOC entry 5783 (class 2606 OID 18157)
-- Dependencies: 3819 3809 5296
-- Name: fk_rol_procedimiento__id_procedimiento_gui; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY trol_procedimiento_gui
    ADD CONSTRAINT fk_rol_procedimiento__id_procedimiento_gui FOREIGN KEY (id_procedimiento_gui) REFERENCES tprocedimiento_gui(id_procedimiento_gui);


--
-- TOC entry 5784 (class 2606 OID 18162)
-- Dependencies: 3819 3840 5354
-- Name: fk_rol_procedimiento__id_rol; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY trol_procedimiento_gui
    ADD CONSTRAINT fk_rol_procedimiento__id_rol FOREIGN KEY (id_rol) REFERENCES trol(id_rol);


--
-- TOC entry 5804 (class 2606 OID 18167)
-- Dependencies: 3850 5354 3840
-- Name: fk_usuario__es_asigna_rol; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tusuario_rol
    ADD CONSTRAINT fk_usuario__es_asigna_rol FOREIGN KEY (id_rol) REFERENCES trol(id_rol) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5794 (class 2606 OID 18172)
-- Dependencies: 3791 5272 3845
-- Name: fk_usuario__id_persona; Type: FK CONSTRAINT; Schema: segu; Owner: rchumacero
--

ALTER TABLE ONLY tusuario
    ADD CONSTRAINT fk_usuario__id_persona FOREIGN KEY (id_persona) REFERENCES tpersona(id_persona);


--
-- TOC entry 5802 (class 2606 OID 18177)
-- Dependencies: 3849 3839 5351
-- Name: fk_usuario__regional__regional; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tusuario_regional
    ADD CONSTRAINT fk_usuario__regional__regional FOREIGN KEY (id_regional) REFERENCES tregional(id_regional) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5798 (class 2606 OID 18182)
-- Dependencies: 5340 3847 3835
-- Name: fk_usuario__se_asigna_perfil; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tusuario_perfil
    ADD CONSTRAINT fk_usuario__se_asigna_perfil FOREIGN KEY (id_perfil) REFERENCES tperfil(id_perfil) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5799 (class 2606 OID 18187)
-- Dependencies: 5366 3845 3847
-- Name: fk_usuario__tiene_per_usuario; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tusuario_perfil
    ADD CONSTRAINT fk_usuario__tiene_per_usuario FOREIGN KEY (id_usuario) REFERENCES tusuario(id_usuario) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5805 (class 2606 OID 18192)
-- Dependencies: 3850 5366 3845
-- Name: fk_usuario__tiene_pri_usuario; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tusuario_rol
    ADD CONSTRAINT fk_usuario__tiene_pri_usuario FOREIGN KEY (id_usuario) REFERENCES tusuario(id_usuario) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5803 (class 2606 OID 18197)
-- Dependencies: 3849 5366 3845
-- Name: fk_usuario__usuario_p_usuario; Type: FK CONSTRAINT; Schema: segu; Owner: postgres
--

ALTER TABLE ONLY tusuario_regional
    ADD CONSTRAINT fk_usuario__usuario_p_usuario FOREIGN KEY (id_usuario) REFERENCES tusuario(id_usuario) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5796 (class 2606 OID 18202)
-- Dependencies: 3846 3795 5275
-- Name: fk_usuario_actividad__id_actividad; Type: FK CONSTRAINT; Schema: segu; Owner: rchumacero
--

ALTER TABLE ONLY tusuario_actividad
    ADD CONSTRAINT fk_usuario_actividad__id_actividad FOREIGN KEY (id_actividad) REFERENCES tactividad(id_actividad);


--
-- TOC entry 5797 (class 2606 OID 18207)
-- Dependencies: 3846 3845 5366
-- Name: fk_usuario_actividad__id_usuario; Type: FK CONSTRAINT; Schema: segu; Owner: rchumacero
--

ALTER TABLE ONLY tusuario_actividad
    ADD CONSTRAINT fk_usuario_actividad__id_usuario FOREIGN KEY (id_usuario) REFERENCES tusuario(id_usuario);


--
-- TOC entry 5800 (class 2606 OID 18212)
-- Dependencies: 5299 3812 3848
-- Name: fk_usuario_proyecto__id_proyecto; Type: FK CONSTRAINT; Schema: segu; Owner: rchumacero
--

ALTER TABLE ONLY tusuario_proyecto
    ADD CONSTRAINT fk_usuario_proyecto__id_proyecto FOREIGN KEY (id_proyecto) REFERENCES tproyecto(id_proyecto);


--
-- TOC entry 5801 (class 2606 OID 18217)
-- Dependencies: 3848 3845 5366
-- Name: fk_usuario_proyecto__id_usuario; Type: FK CONSTRAINT; Schema: segu; Owner: rchumacero
--

ALTER TABLE ONLY tusuario_proyecto
    ADD CONSTRAINT fk_usuario_proyecto__id_usuario FOREIGN KEY (id_usuario) REFERENCES tusuario(id_usuario);


--
-- TOC entry 5795 (class 2606 OID 18222)
-- Dependencies: 3824 5313 3845
-- Name: fk_usuario_se_asigna_clasific; Type: FK CONSTRAINT; Schema: segu; Owner: rchumacero
--

ALTER TABLE ONLY tusuario
    ADD CONSTRAINT fk_usuario_se_asigna_clasific FOREIGN KEY (id_clasificador) REFERENCES tclasificador(id_clasificador) ON UPDATE RESTRICT ON DELETE RESTRICT;


SET search_path = tesor, pg_catalog;

--
-- TOC entry 5806 (class 2606 OID 18227)
-- Dependencies: 5397 3861 3862
-- Name: fk_tcaja_mov; Type: FK CONSTRAINT; Schema: tesor; Owner: rchumacero
--

ALTER TABLE ONLY tcaja_mov
    ADD CONSTRAINT fk_tcaja_mov FOREIGN KEY (id_caja) REFERENCES tcaja(id_caja);


--
-- TOC entry 5807 (class 2606 OID 18232)
-- Dependencies: 3863 3861 5397
-- Name: fk_tcajero__id_caja; Type: FK CONSTRAINT; Schema: tesor; Owner: rchumacero
--

ALTER TABLE ONLY tcajero
    ADD CONSTRAINT fk_tcajero__id_caja FOREIGN KEY (id_caja) REFERENCES tcaja(id_caja);


--
-- TOC entry 5808 (class 2606 OID 18237)
-- Dependencies: 3863 3737 5178
-- Name: fk_tcajero__id_funcionario; Type: FK CONSTRAINT; Schema: tesor; Owner: rchumacero
--

ALTER TABLE ONLY tcajero
    ADD CONSTRAINT fk_tcajero__id_funcionario FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 5809 (class 2606 OID 18242)
-- Dependencies: 3863 5401 3865
-- Name: fk_trecibo__id_cajero; Type: FK CONSTRAINT; Schema: tesor; Owner: rchumacero
--

ALTER TABLE ONLY trecibo
    ADD CONSTRAINT fk_trecibo__id_cajero FOREIGN KEY (id_cajero) REFERENCES tcajero(id_cajero);


--
-- TOC entry 5810 (class 2606 OID 18247)
-- Dependencies: 3865 3737 5178
-- Name: fk_trecibo__id_funcionario; Type: FK CONSTRAINT; Schema: tesor; Owner: rchumacero
--

ALTER TABLE ONLY trecibo
    ADD CONSTRAINT fk_trecibo__id_funcionario FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 5811 (class 2606 OID 18252)
-- Dependencies: 3865 3722 5165
-- Name: fk_trecibo__id_moneda; Type: FK CONSTRAINT; Schema: tesor; Owner: rchumacero
--

ALTER TABLE ONLY trecibo
    ADD CONSTRAINT fk_trecibo__id_moneda FOREIGN KEY (id_moneda) REFERENCES param.tmoneda(id_moneda);


--
-- TOC entry 5812 (class 2606 OID 18257)
-- Dependencies: 3866 3709 5140
-- Name: fk_trendicion__id_documento; Type: FK CONSTRAINT; Schema: tesor; Owner: rchumacero
--

ALTER TABLE ONLY trendicion
    ADD CONSTRAINT fk_trendicion__id_documento FOREIGN KEY (id_documento) REFERENCES conta.tdocumento(id_documento);


--
-- TOC entry 5813 (class 2606 OID 18262)
-- Dependencies: 5403 3865 3866
-- Name: fk_trendicion__id_recibo; Type: FK CONSTRAINT; Schema: tesor; Owner: rchumacero
--

ALTER TABLE ONLY trendicion
    ADD CONSTRAINT fk_trendicion__id_recibo FOREIGN KEY (id_recibo) REFERENCES trecibo(id_recibo);


SET search_path = tesoro, pg_catalog;

--
-- TOC entry 5818 (class 2606 OID 56474)
-- Dependencies: 3886 3722 5165
-- Name: fk_tts_corte__id_moneda; Type: FK CONSTRAINT; Schema: tesoro; Owner: rchumacero
--

ALTER TABLE ONLY tts_corte_moneda
    ADD CONSTRAINT fk_tts_corte__id_moneda FOREIGN KEY (id_moneda) REFERENCES param.tmoneda(id_moneda) ON UPDATE CASCADE;


--
-- TOC entry 5963 (class 0 OID 0)
-- Dependencies: 5
-- Name: public; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM postgres;
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO PUBLIC;


SET search_path = hidro, pg_catalog;

--
-- TOC entry 5964 (class 0 OID 0)
-- Dependencies: 257
-- Name: f_thd_cuenca_sel(integer, integer, character varying, character varying); Type: ACL; Schema: hidro; Owner: mflores
--

REVOKE ALL ON FUNCTION f_thd_cuenca_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION f_thd_cuenca_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) FROM mflores;
GRANT ALL ON FUNCTION f_thd_cuenca_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) TO mflores;
GRANT ALL ON FUNCTION f_thd_cuenca_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) TO PUBLIC;
GRANT ALL ON FUNCTION f_thd_cuenca_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 5965 (class 0 OID 0)
-- Dependencies: 1213
-- Name: f_thd_tipo_muestra_sel(integer, integer, character varying, character varying); Type: ACL; Schema: hidro; Owner: postgres
--

REVOKE ALL ON FUNCTION f_thd_tipo_muestra_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION f_thd_tipo_muestra_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) FROM postgres;
GRANT ALL ON FUNCTION f_thd_tipo_muestra_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) TO postgres;
GRANT ALL ON FUNCTION f_thd_tipo_muestra_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) TO PUBLIC;
GRANT ALL ON FUNCTION f_thd_tipo_muestra_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) TO rol_usuario_dbendesis_cobra;


SET search_path = public, pg_catalog;

--
-- TOC entry 5972 (class 0 OID 0)
-- Dependencies: 217
-- Name: dblink_connect_u(text); Type: ACL; Schema: public; Owner: rchumacero
--

REVOKE ALL ON FUNCTION dblink_connect_u(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION dblink_connect_u(text) FROM rchumacero;
GRANT ALL ON FUNCTION dblink_connect_u(text) TO rchumacero;


--
-- TOC entry 5973 (class 0 OID 0)
-- Dependencies: 218
-- Name: dblink_connect_u(text, text); Type: ACL; Schema: public; Owner: rchumacero
--

REVOKE ALL ON FUNCTION dblink_connect_u(text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION dblink_connect_u(text, text) FROM rchumacero;
GRANT ALL ON FUNCTION dblink_connect_u(text, text) TO rchumacero;


--
-- TOC entry 5974 (class 0 OID 0)
-- Dependencies: 212
-- Name: f_intermediario_sel(integer, character varying, integer, character varying, macaddr, character varying, character varying, integer, character varying[], character varying[], character varying[], character varying[], character varying, character varying); Type: ACL; Schema: public; Owner: rchumacero
--

REVOKE ALL ON FUNCTION f_intermediario_sel(par_id_usuario integer, par_sid_web character varying, par_pid_web integer, par_ip character varying, par_mac macaddr, par_procedimiento character varying, par_transaccion character varying, par_id_categoria integer, ip_admin character varying[], variables character varying[], valores character varying[], tipos character varying[], tipo_retorno character varying, datos_retorno character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION f_intermediario_sel(par_id_usuario integer, par_sid_web character varying, par_pid_web integer, par_ip character varying, par_mac macaddr, par_procedimiento character varying, par_transaccion character varying, par_id_categoria integer, ip_admin character varying[], variables character varying[], valores character varying[], tipos character varying[], tipo_retorno character varying, datos_retorno character varying) FROM rchumacero;
GRANT ALL ON FUNCTION f_intermediario_sel(par_id_usuario integer, par_sid_web character varying, par_pid_web integer, par_ip character varying, par_mac macaddr, par_procedimiento character varying, par_transaccion character varying, par_id_categoria integer, ip_admin character varying[], variables character varying[], valores character varying[], tipos character varying[], tipo_retorno character varying, datos_retorno character varying) TO rchumacero;
GRANT ALL ON FUNCTION f_intermediario_sel(par_id_usuario integer, par_sid_web character varying, par_pid_web integer, par_ip character varying, par_mac macaddr, par_procedimiento character varying, par_transaccion character varying, par_id_categoria integer, ip_admin character varying[], variables character varying[], valores character varying[], tipos character varying[], tipo_retorno character varying, datos_retorno character varying) TO PUBLIC;
GRANT ALL ON FUNCTION f_intermediario_sel(par_id_usuario integer, par_sid_web character varying, par_pid_web integer, par_ip character varying, par_mac macaddr, par_procedimiento character varying, par_transaccion character varying, par_id_categoria integer, ip_admin character varying[], variables character varying[], valores character varying[], tipos character varying[], tipo_retorno character varying, datos_retorno character varying) TO dbendesis_cobra_pruebasaj;
GRANT ALL ON FUNCTION f_intermediario_sel(par_id_usuario integer, par_sid_web character varying, par_pid_web integer, par_ip character varying, par_mac macaddr, par_procedimiento character varying, par_transaccion character varying, par_id_categoria integer, ip_admin character varying[], variables character varying[], valores character varying[], tipos character varying[], tipo_retorno character varying, datos_retorno character varying) TO rol_usuario_dbendesis_cobra;


SET search_path = segu, pg_catalog;

--
-- TOC entry 5976 (class 0 OID 0)
-- Dependencies: 1169
-- Name: ft_sesion_sel(integer, integer, character varying, character varying); Type: ACL; Schema: segu; Owner: postgres
--

REVOKE ALL ON FUNCTION ft_sesion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION ft_sesion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) FROM postgres;
GRANT ALL ON FUNCTION ft_sesion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) TO postgres;
GRANT ALL ON FUNCTION ft_sesion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) TO PUBLIC;
GRANT ALL ON FUNCTION ft_sesion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) TO dbendesis_cobra_pruebasaj;


SET search_path = hidro, pg_catalog;

--
-- TOC entry 6088 (class 0 OID 0)
-- Dependencies: 4100
-- Name: thd_tipo_sensor_22; Type: ACL; Schema: hidro; Owner: dbendesis_cobra_rac
--

REVOKE ALL ON TABLE thd_tipo_sensor_22 FROM PUBLIC;
REVOKE ALL ON TABLE thd_tipo_sensor_22 FROM dbendesis_cobra_rac;
GRANT ALL ON TABLE thd_tipo_sensor_22 TO dbendesis_cobra_rac;
GRANT ALL ON TABLE thd_tipo_sensor_22 TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6090 (class 0 OID 0)
-- Dependencies: 4096
-- Name: thd_tipo_sensor_33; Type: ACL; Schema: hidro; Owner: dbendesis_cobra_rac
--

REVOKE ALL ON TABLE thd_tipo_sensor_33 FROM PUBLIC;
REVOKE ALL ON TABLE thd_tipo_sensor_33 FROM dbendesis_cobra_rac;
GRANT ALL ON TABLE thd_tipo_sensor_33 TO dbendesis_cobra_rac;
GRANT ALL ON TABLE thd_tipo_sensor_33 TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6092 (class 0 OID 0)
-- Dependencies: 4098
-- Name: thd_tipo_sensor_44; Type: ACL; Schema: hidro; Owner: dbendesis_cobra_rac
--

REVOKE ALL ON TABLE thd_tipo_sensor_44 FROM PUBLIC;
REVOKE ALL ON TABLE thd_tipo_sensor_44 FROM dbendesis_cobra_rac;
GRANT ALL ON TABLE thd_tipo_sensor_44 TO dbendesis_cobra_rac;
GRANT ALL ON TABLE thd_tipo_sensor_44 TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6094 (class 0 OID 0)
-- Dependencies: 4113
-- Name: thd_tipo_sensor_anemometro; Type: ACL; Schema: hidro; Owner: dbendesis_cobra_rac
--

REVOKE ALL ON TABLE thd_tipo_sensor_anemometro FROM PUBLIC;
REVOKE ALL ON TABLE thd_tipo_sensor_anemometro FROM dbendesis_cobra_rac;
GRANT ALL ON TABLE thd_tipo_sensor_anemometro TO dbendesis_cobra_rac;
GRANT ALL ON TABLE thd_tipo_sensor_anemometro TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6096 (class 0 OID 0)
-- Dependencies: 4104
-- Name: thd_tipo_sensor_caudal; Type: ACL; Schema: hidro; Owner: dbendesis_cobra_rac
--

REVOKE ALL ON TABLE thd_tipo_sensor_caudal FROM PUBLIC;
REVOKE ALL ON TABLE thd_tipo_sensor_caudal FROM dbendesis_cobra_rac;
GRANT ALL ON TABLE thd_tipo_sensor_caudal TO dbendesis_cobra_rac;
GRANT ALL ON TABLE thd_tipo_sensor_caudal TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6098 (class 0 OID 0)
-- Dependencies: 4102
-- Name: thd_tipo_sensor_limnimetrica; Type: ACL; Schema: hidro; Owner: dbendesis_cobra_rac
--

REVOKE ALL ON TABLE thd_tipo_sensor_limnimetrica FROM PUBLIC;
REVOKE ALL ON TABLE thd_tipo_sensor_limnimetrica FROM dbendesis_cobra_rac;
GRANT ALL ON TABLE thd_tipo_sensor_limnimetrica TO dbendesis_cobra_rac;
GRANT ALL ON TABLE thd_tipo_sensor_limnimetrica TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6100 (class 0 OID 0)
-- Dependencies: 4106
-- Name: thd_tipo_sensor_presion; Type: ACL; Schema: hidro; Owner: dbendesis_cobra_mflores
--

REVOKE ALL ON TABLE thd_tipo_sensor_presion FROM PUBLIC;
REVOKE ALL ON TABLE thd_tipo_sensor_presion FROM dbendesis_cobra_mflores;
GRANT ALL ON TABLE thd_tipo_sensor_presion TO dbendesis_cobra_mflores;
GRANT ALL ON TABLE thd_tipo_sensor_presion TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6102 (class 0 OID 0)
-- Dependencies: 4116
-- Name: thd_tipo_sensor_pru; Type: ACL; Schema: hidro; Owner: dbendesis_cobra_mflores
--

REVOKE ALL ON TABLE thd_tipo_sensor_pru FROM PUBLIC;
REVOKE ALL ON TABLE thd_tipo_sensor_pru FROM dbendesis_cobra_mflores;
GRANT ALL ON TABLE thd_tipo_sensor_pru TO dbendesis_cobra_mflores;
GRANT ALL ON TABLE thd_tipo_sensor_pru TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6104 (class 0 OID 0)
-- Dependencies: 4120
-- Name: thd_tipo_sensor_prue; Type: ACL; Schema: hidro; Owner: dbendesis_cobra_mflores
--

REVOKE ALL ON TABLE thd_tipo_sensor_prue FROM PUBLIC;
REVOKE ALL ON TABLE thd_tipo_sensor_prue FROM dbendesis_cobra_mflores;
GRANT ALL ON TABLE thd_tipo_sensor_prue TO dbendesis_cobra_mflores;
GRANT ALL ON TABLE thd_tipo_sensor_prue TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6106 (class 0 OID 0)
-- Dependencies: 4118
-- Name: thd_tipo_sensor_termo; Type: ACL; Schema: hidro; Owner: dbendesis_cobra_mflores
--

REVOKE ALL ON TABLE thd_tipo_sensor_termo FROM PUBLIC;
REVOKE ALL ON TABLE thd_tipo_sensor_termo FROM dbendesis_cobra_mflores;
GRANT ALL ON TABLE thd_tipo_sensor_termo TO dbendesis_cobra_mflores;
GRANT ALL ON TABLE thd_tipo_sensor_termo TO rol_usuario_dbendesis_cobra;


SET search_path = log, pg_catalog;

--
-- TOC entry 6108 (class 0 OID 0)
-- Dependencies: 3867
-- Name: tlog_2011_06; Type: ACL; Schema: log; Owner: rchumacero
--

REVOKE ALL ON TABLE tlog_2011_06 FROM PUBLIC;
REVOKE ALL ON TABLE tlog_2011_06 FROM rchumacero;
GRANT ALL ON TABLE tlog_2011_06 TO rchumacero;
GRANT SELECT ON TABLE tlog_2011_06 TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6109 (class 0 OID 0)
-- Dependencies: 3904
-- Name: tlog_2011_07; Type: ACL; Schema: log; Owner: rchumacero
--

REVOKE ALL ON TABLE tlog_2011_07 FROM PUBLIC;
REVOKE ALL ON TABLE tlog_2011_07 FROM rchumacero;
GRANT ALL ON TABLE tlog_2011_07 TO rchumacero;
GRANT SELECT ON TABLE tlog_2011_07 TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6110 (class 0 OID 0)
-- Dependencies: 3905
-- Name: tlog_2011_08; Type: ACL; Schema: log; Owner: rchumacero
--

REVOKE ALL ON TABLE tlog_2011_08 FROM PUBLIC;
REVOKE ALL ON TABLE tlog_2011_08 FROM rchumacero;
GRANT ALL ON TABLE tlog_2011_08 TO rchumacero;
GRANT SELECT ON TABLE tlog_2011_08 TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6111 (class 0 OID 0)
-- Dependencies: 3915
-- Name: tlog_2011_09; Type: ACL; Schema: log; Owner: rchumacero
--

REVOKE ALL ON TABLE tlog_2011_09 FROM PUBLIC;
REVOKE ALL ON TABLE tlog_2011_09 FROM rchumacero;
GRANT ALL ON TABLE tlog_2011_09 TO rchumacero;
GRANT SELECT ON TABLE tlog_2011_09 TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6112 (class 0 OID 0)
-- Dependencies: 3933
-- Name: tlog_2011_10; Type: ACL; Schema: log; Owner: rchumacero
--

REVOKE ALL ON TABLE tlog_2011_10 FROM PUBLIC;
REVOKE ALL ON TABLE tlog_2011_10 FROM rchumacero;
GRANT ALL ON TABLE tlog_2011_10 TO rchumacero;
GRANT SELECT ON TABLE tlog_2011_10 TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6113 (class 0 OID 0)
-- Dependencies: 3951
-- Name: tlog_2011_11; Type: ACL; Schema: log; Owner: rchumacero
--

REVOKE ALL ON TABLE tlog_2011_11 FROM PUBLIC;
REVOKE ALL ON TABLE tlog_2011_11 FROM rchumacero;
GRANT ALL ON TABLE tlog_2011_11 TO rchumacero;
GRANT SELECT ON TABLE tlog_2011_11 TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6114 (class 0 OID 0)
-- Dependencies: 4014
-- Name: tlog_2011_12; Type: ACL; Schema: log; Owner: rchumacero
--

REVOKE ALL ON TABLE tlog_2011_12 FROM PUBLIC;
REVOKE ALL ON TABLE tlog_2011_12 FROM rchumacero;
GRANT ALL ON TABLE tlog_2011_12 TO rchumacero;
GRANT SELECT ON TABLE tlog_2011_12 TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6115 (class 0 OID 0)
-- Dependencies: 4017
-- Name: tlog_2012_01; Type: ACL; Schema: log; Owner: rchumacero
--

REVOKE ALL ON TABLE tlog_2012_01 FROM PUBLIC;
REVOKE ALL ON TABLE tlog_2012_01 FROM rchumacero;
GRANT ALL ON TABLE tlog_2012_01 TO rchumacero;
GRANT SELECT ON TABLE tlog_2012_01 TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6116 (class 0 OID 0)
-- Dependencies: 4019
-- Name: tlog_2012_02; Type: ACL; Schema: log; Owner: rchumacero
--

REVOKE ALL ON TABLE tlog_2012_02 FROM PUBLIC;
REVOKE ALL ON TABLE tlog_2012_02 FROM rchumacero;
GRANT ALL ON TABLE tlog_2012_02 TO rchumacero;
GRANT SELECT ON TABLE tlog_2012_02 TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6117 (class 0 OID 0)
-- Dependencies: 4022
-- Name: tlog_2012_03; Type: ACL; Schema: log; Owner: rchumacero
--

REVOKE ALL ON TABLE tlog_2012_03 FROM PUBLIC;
REVOKE ALL ON TABLE tlog_2012_03 FROM rchumacero;
GRANT ALL ON TABLE tlog_2012_03 TO rchumacero;
GRANT SELECT ON TABLE tlog_2012_03 TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6118 (class 0 OID 0)
-- Dependencies: 4107
-- Name: tlog_2012_04; Type: ACL; Schema: log; Owner: rchumacero
--

REVOKE ALL ON TABLE tlog_2012_04 FROM PUBLIC;
REVOKE ALL ON TABLE tlog_2012_04 FROM rchumacero;
GRANT ALL ON TABLE tlog_2012_04 TO rchumacero;
GRANT SELECT ON TABLE tlog_2012_04 TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6119 (class 0 OID 0)
-- Dependencies: 4114
-- Name: tlog_2012_05; Type: ACL; Schema: log; Owner: rchumacero
--

REVOKE ALL ON TABLE tlog_2012_05 FROM PUBLIC;
REVOKE ALL ON TABLE tlog_2012_05 FROM rchumacero;
GRANT ALL ON TABLE tlog_2012_05 TO rchumacero;
GRANT SELECT ON TABLE tlog_2012_05 TO rol_usuario_dbendesis_cobra;


--
-- TOC entry 6120 (class 0 OID 0)
-- Dependencies: 4121
-- Name: tlog_2012_06; Type: ACL; Schema: log; Owner: rchumacero
--

REVOKE ALL ON TABLE tlog_2012_06 FROM PUBLIC;
REVOKE ALL ON TABLE tlog_2012_06 FROM rchumacero;
GRANT ALL ON TABLE tlog_2012_06 TO rchumacero;
GRANT SELECT ON TABLE tlog_2012_06 TO rol_usuario_dbendesis_cobra;


-- Completed on 2012-06-19 10:56:57 BOT

--
-- PostgreSQL database dump complete
--

