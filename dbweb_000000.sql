--
-- PostgreSQL database dump
--

-- Dumped from database version 9.1.3
-- Dumped by pg_dump version 9.1.3
-- Started on 2012-08-08 20:59:59 BOT

SET statement_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;

--
-- TOC entry 6 (class 2615 OID 207018)
-- Name: actif; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA actif;


--
-- TOC entry 7 (class 2615 OID 207019)
-- Name: adqui; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA adqui;


--
-- TOC entry 8 (class 2615 OID 207020)
-- Name: cobra; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA cobra;


--
-- TOC entry 9 (class 2615 OID 207021)
-- Name: conta; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA conta;


--
-- TOC entry 10 (class 2615 OID 207022)
-- Name: factur; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA factur;


--
-- TOC entry 42 (class 2615 OID 313623)
-- Name: gem; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA gem;


--
-- TOC entry 11 (class 2615 OID 207023)
-- Name: gen; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA gen;


--
-- TOC entry 12 (class 2615 OID 207024)
-- Name: gev; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA gev;


--
-- TOC entry 13 (class 2615 OID 207025)
-- Name: hidro; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA hidro;


--
-- TOC entry 14 (class 2615 OID 207026)
-- Name: log; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA log;


--
-- TOC entry 15 (class 2615 OID 207027)
-- Name: param; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA param;


--
-- TOC entry 16 (class 2615 OID 207028)
-- Name: rhum; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA rhum;


--
-- TOC entry 17 (class 2615 OID 207029)
-- Name: saj; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA saj;


--
-- TOC entry 18 (class 2615 OID 207030)
-- Name: sast; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA sast;


--
-- TOC entry 19 (class 2615 OID 207031)
-- Name: secont; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA secont;


--
-- TOC entry 20 (class 2615 OID 207032)
-- Name: segu; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA segu;


--
-- TOC entry 21 (class 2615 OID 207033)
-- Name: tesor; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA tesor;


--
-- TOC entry 22 (class 2615 OID 207034)
-- Name: tesoro; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA tesoro;


--
-- TOC entry 627 (class 3079 OID 12424)
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- TOC entry 7040 (class 0 OID 0)
-- Dependencies: 627
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


--
-- TOC entry 3247 (class 2612 OID 207038)
-- Name: plpythonu; Type: PROCEDURAL LANGUAGE; Schema: -; Owner: -
--

CREATE OR REPLACE PROCEDURAL LANGUAGE plpythonu;


SET search_path = public, pg_catalog;

--
-- TOC entry 2161 (class 0 OID 0)
-- Name: box2d; Type: SHELL TYPE; Schema: public; Owner: -
--

CREATE TYPE box2d;


--
-- TOC entry 639 (class 1255 OID 207040)
-- Dependencies: 23 2161
-- Name: box2d_in(cstring); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION box2d_in(cstring) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_in';


--
-- TOC entry 640 (class 1255 OID 207041)
-- Dependencies: 23 2161
-- Name: box2d_out(box2d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION box2d_out(box2d) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_out';


--
-- TOC entry 2160 (class 1247 OID 207039)
-- Dependencies: 639 640 23
-- Name: box2d; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE box2d (
    INTERNALLENGTH = 16,
    INPUT = box2d_in,
    OUTPUT = box2d_out,
    ALIGNMENT = int4,
    STORAGE = plain
);


--
-- TOC entry 2165 (class 0 OID 0)
-- Name: box3d; Type: SHELL TYPE; Schema: public; Owner: -
--

CREATE TYPE box3d;


--
-- TOC entry 641 (class 1255 OID 207044)
-- Dependencies: 23 2165
-- Name: box3d_in(cstring); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION box3d_in(cstring) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_in';


--
-- TOC entry 642 (class 1255 OID 207045)
-- Dependencies: 23 2165
-- Name: box3d_out(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION box3d_out(box3d) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_out';


--
-- TOC entry 2164 (class 1247 OID 207043)
-- Dependencies: 23 642 641
-- Name: box3d; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE box3d (
    INTERNALLENGTH = 48,
    INPUT = box3d_in,
    OUTPUT = box3d_out,
    ALIGNMENT = double,
    STORAGE = plain
);


--
-- TOC entry 2169 (class 0 OID 0)
-- Name: box3d_extent; Type: SHELL TYPE; Schema: public; Owner: -
--

CREATE TYPE box3d_extent;


--
-- TOC entry 643 (class 1255 OID 207048)
-- Dependencies: 23 2169
-- Name: box3d_extent_in(cstring); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION box3d_extent_in(cstring) RETURNS box3d_extent
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_in';


--
-- TOC entry 644 (class 1255 OID 207049)
-- Dependencies: 23 2169
-- Name: box3d_extent_out(box3d_extent); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION box3d_extent_out(box3d_extent) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_extent_out';


--
-- TOC entry 2168 (class 1247 OID 207047)
-- Dependencies: 23 644 643
-- Name: box3d_extent; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE box3d_extent (
    INTERNALLENGTH = 48,
    INPUT = box3d_extent_in,
    OUTPUT = box3d_extent_out,
    ALIGNMENT = double,
    STORAGE = plain
);


--
-- TOC entry 2173 (class 0 OID 0)
-- Name: chip; Type: SHELL TYPE; Schema: public; Owner: -
--

CREATE TYPE chip;


--
-- TOC entry 645 (class 1255 OID 207052)
-- Dependencies: 23 2173
-- Name: chip_in(cstring); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION chip_in(cstring) RETURNS chip
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_in';


--
-- TOC entry 646 (class 1255 OID 207053)
-- Dependencies: 23 2173
-- Name: chip_out(chip); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION chip_out(chip) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_out';


--
-- TOC entry 2172 (class 1247 OID 207051)
-- Dependencies: 645 646 23
-- Name: chip; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE chip (
    INTERNALLENGTH = variable,
    INPUT = chip_in,
    OUTPUT = chip_out,
    ALIGNMENT = double,
    STORAGE = extended
);


--
-- TOC entry 2176 (class 1247 OID 207057)
-- Dependencies: 23 201
-- Name: dblink_pkey_results; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE dblink_pkey_results AS (
	"position" integer,
	colname text
);


--
-- TOC entry 2179 (class 1247 OID 207059)
-- Dependencies: 23
-- Name: enum_tipo_dato; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE enum_tipo_dato AS ENUM (
    'varchar',
    'integer',
    'float',
    'numeric',
    'boolean',
    'text'
);


--
-- TOC entry 2182 (class 1247 OID 207072)
-- Dependencies: 23
-- Name: estado_reg; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE estado_reg AS ENUM (
    'activo',
    'inactivo'
);


--
-- TOC entry 2186 (class 0 OID 0)
-- Name: geography; Type: SHELL TYPE; Schema: public; Owner: -
--

CREATE TYPE geography;


--
-- TOC entry 647 (class 1255 OID 207078)
-- Dependencies: 23
-- Name: geography_analyze(internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_analyze(internal) RETURNS boolean
    LANGUAGE c STRICT
    AS '$libdir/postgis-1.5', 'geography_analyze';


--
-- TOC entry 648 (class 1255 OID 207079)
-- Dependencies: 23 2186
-- Name: geography_in(cstring, oid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_in(cstring, oid, integer) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_in';


--
-- TOC entry 649 (class 1255 OID 207080)
-- Dependencies: 23 2186
-- Name: geography_out(geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_out(geography) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_out';


--
-- TOC entry 650 (class 1255 OID 207081)
-- Dependencies: 23
-- Name: geography_typmod_in(cstring[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_typmod_in(cstring[]) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_typmod_in';


--
-- TOC entry 651 (class 1255 OID 207082)
-- Dependencies: 23
-- Name: geography_typmod_out(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_typmod_out(integer) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_typmod_out';


--
-- TOC entry 2185 (class 1247 OID 207077)
-- Dependencies: 651 23 648 649 647 650
-- Name: geography; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE geography (
    INTERNALLENGTH = variable,
    INPUT = geography_in,
    OUTPUT = geography_out,
    TYPMOD_IN = geography_typmod_in,
    TYPMOD_OUT = geography_typmod_out,
    ANALYZE = geography_analyze,
    ALIGNMENT = double,
    STORAGE = main
);


--
-- TOC entry 2190 (class 0 OID 0)
-- Name: geometry; Type: SHELL TYPE; Schema: public; Owner: -
--

CREATE TYPE geometry;


--
-- TOC entry 652 (class 1255 OID 207085)
-- Dependencies: 23
-- Name: geometry_analyze(internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_analyze(internal) RETURNS boolean
    LANGUAGE c STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_analyze';


--
-- TOC entry 653 (class 1255 OID 207086)
-- Dependencies: 23 2190
-- Name: geometry_in(cstring); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_in(cstring) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_in';


--
-- TOC entry 654 (class 1255 OID 207087)
-- Dependencies: 23 2190
-- Name: geometry_out(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_out(geometry) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_out';


--
-- TOC entry 655 (class 1255 OID 207088)
-- Dependencies: 23 2190
-- Name: geometry_recv(internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_recv(internal) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_recv';


--
-- TOC entry 656 (class 1255 OID 207089)
-- Dependencies: 23 2190
-- Name: geometry_send(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_send(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_send';


--
-- TOC entry 2189 (class 1247 OID 207084)
-- Dependencies: 653 23 656 652 655 654
-- Name: geometry; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE geometry (
    INTERNALLENGTH = variable,
    INPUT = geometry_in,
    OUTPUT = geometry_out,
    RECEIVE = geometry_recv,
    SEND = geometry_send,
    ANALYZE = geometry_analyze,
    DELIMITER = ':',
    ALIGNMENT = int4,
    STORAGE = main
);


--
-- TOC entry 2193 (class 1247 OID 207093)
-- Dependencies: 23 202
-- Name: geometry_dump; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE geometry_dump AS (
	path integer[],
	geom geometry
);


--
-- TOC entry 2197 (class 0 OID 0)
-- Name: gidx; Type: SHELL TYPE; Schema: public; Owner: -
--

CREATE TYPE gidx;


--
-- TOC entry 657 (class 1255 OID 207095)
-- Dependencies: 23 2197
-- Name: gidx_in(cstring); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION gidx_in(cstring) RETURNS gidx
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'gidx_in';


--
-- TOC entry 658 (class 1255 OID 207096)
-- Dependencies: 23 2197
-- Name: gidx_out(gidx); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION gidx_out(gidx) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'gidx_out';


--
-- TOC entry 2196 (class 1247 OID 207094)
-- Dependencies: 23 658 657
-- Name: gidx; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE gidx (
    INTERNALLENGTH = variable,
    INPUT = gidx_in,
    OUTPUT = gidx_out,
    ALIGNMENT = double,
    STORAGE = plain
);


--
-- TOC entry 2201 (class 0 OID 0)
-- Name: intbig_gkey; Type: SHELL TYPE; Schema: public; Owner: -
--

CREATE TYPE intbig_gkey;


--
-- TOC entry 659 (class 1255 OID 207099)
-- Dependencies: 23 2201
-- Name: _intbig_in(cstring); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _intbig_in(cstring) RETURNS intbig_gkey
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_intbig_in';


--
-- TOC entry 660 (class 1255 OID 207100)
-- Dependencies: 23 2201
-- Name: _intbig_out(intbig_gkey); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _intbig_out(intbig_gkey) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_intbig_out';


--
-- TOC entry 2200 (class 1247 OID 207098)
-- Dependencies: 660 23 659
-- Name: intbig_gkey; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE intbig_gkey (
    INTERNALLENGTH = variable,
    INPUT = _intbig_in,
    OUTPUT = _intbig_out,
    ALIGNMENT = int4,
    STORAGE = plain
);


--
-- TOC entry 2205 (class 0 OID 0)
-- Name: pgis_abs; Type: SHELL TYPE; Schema: public; Owner: -
--

CREATE TYPE pgis_abs;


--
-- TOC entry 661 (class 1255 OID 207103)
-- Dependencies: 23 2205
-- Name: pgis_abs_in(cstring); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pgis_abs_in(cstring) RETURNS pgis_abs
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'pgis_abs_in';


--
-- TOC entry 662 (class 1255 OID 207104)
-- Dependencies: 23 2205
-- Name: pgis_abs_out(pgis_abs); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pgis_abs_out(pgis_abs) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'pgis_abs_out';


--
-- TOC entry 2204 (class 1247 OID 207102)
-- Dependencies: 661 662 23
-- Name: pgis_abs; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE pgis_abs (
    INTERNALLENGTH = 8,
    INPUT = pgis_abs_in,
    OUTPUT = pgis_abs_out,
    ALIGNMENT = double,
    STORAGE = plain
);


--
-- TOC entry 2209 (class 0 OID 0)
-- Name: query_int; Type: SHELL TYPE; Schema: public; Owner: -
--

CREATE TYPE query_int;


--
-- TOC entry 663 (class 1255 OID 207107)
-- Dependencies: 23 2209
-- Name: bqarr_in(cstring); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION bqarr_in(cstring) RETURNS query_int
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'bqarr_in';


--
-- TOC entry 664 (class 1255 OID 207108)
-- Dependencies: 23 2209
-- Name: bqarr_out(query_int); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION bqarr_out(query_int) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'bqarr_out';


--
-- TOC entry 2208 (class 1247 OID 207106)
-- Dependencies: 664 663 23
-- Name: query_int; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE query_int (
    INTERNALLENGTH = variable,
    INPUT = bqarr_in,
    OUTPUT = bqarr_out,
    ALIGNMENT = int4,
    STORAGE = plain
);


--
-- TOC entry 2213 (class 0 OID 0)
-- Name: spheroid; Type: SHELL TYPE; Schema: public; Owner: -
--

CREATE TYPE spheroid;


--
-- TOC entry 665 (class 1255 OID 207111)
-- Dependencies: 23 2213
-- Name: spheroid_in(cstring); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION spheroid_in(cstring) RETURNS spheroid
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ellipsoid_in';


--
-- TOC entry 666 (class 1255 OID 207112)
-- Dependencies: 23 2213
-- Name: spheroid_out(spheroid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION spheroid_out(spheroid) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ellipsoid_out';


--
-- TOC entry 2212 (class 1247 OID 207110)
-- Dependencies: 666 665 23
-- Name: spheroid; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE spheroid (
    INTERNALLENGTH = 65,
    INPUT = spheroid_in,
    OUTPUT = spheroid_out,
    ALIGNMENT = double,
    STORAGE = plain
);


SET search_path = segu, pg_catalog;

--
-- TOC entry 2216 (class 1247 OID 207114)
-- Dependencies: 20
-- Name: activo_inactivo; Type: DOMAIN; Schema: segu; Owner: -
--

CREATE DOMAIN activo_inactivo AS character varying(10) NOT NULL DEFAULT 'activo'::character varying;


--
-- TOC entry 2217 (class 1247 OID 207115)
-- Dependencies: 20
-- Name: error_advertencia_informativo; Type: DOMAIN; Schema: segu; Owner: -
--

CREATE DOMAIN error_advertencia_informativo AS character varying(15);


--
-- TOC entry 2218 (class 1247 OID 207117)
-- Dependencies: 20
-- Name: estado; Type: TYPE; Schema: segu; Owner: -
--

CREATE TYPE estado AS ENUM (
    'activo',
    'inactivo'
);


--
-- TOC entry 2221 (class 1247 OID 207121)
-- Dependencies: 20
-- Name: si_no; Type: DOMAIN; Schema: segu; Owner: -
--

CREATE DOMAIN si_no AS character varying(10) DEFAULT 'si'::character varying;


SET search_path = cobra, pg_catalog;

--
-- TOC entry 667 (class 1255 OID 207122)
-- Dependencies: 3246 8
-- Name: f_cb_obtener_consumo_historico(integer); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_cb_obtener_consumo_historico(cb_id_factura_cob integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
/*
Autor: RCM
Fecha: 07-03-2012
Propósito: Desplegar todo el consumo histórico de una factura en función a la cantidad parametrizada
*/
DECLARE

	v_cantidad integer = 0;

BEGIN
return;
END;
$$;


--
-- TOC entry 668 (class 1255 OID 207123)
-- Dependencies: 8 3246
-- Name: f_tcb_agencia_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_agencia_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_agencia_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_agencia'
 AUTOR: 		 (fprudencio)
 FECHA:	        20-09-2011 19:15:41
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_agencia	integer;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_agencia_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_AGEN_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 19:15:41
	***********************************/

	if(p_transaccion='CB_AGEN_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_agencia(
			observaciones,
			estado_reg,
			nombre,
			id_enti_fin,
			codigo,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.observaciones,
			'activo',
			v_parametros.nombre,
			v_parametros.id_enti_fin,
			v_parametros.codigo,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_agencia into v_id_agencia;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Agencia almacenado(a) con exito (id_agencia'||v_id_agencia||')'); 
            v_resp = f_agrega_clave(v_resp,'id_agencia',v_id_agencia::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_AGEN_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 19:15:41
	***********************************/

	elsif(p_transaccion='CB_AGEN_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_agencia set
			observaciones = v_parametros.observaciones,
			nombre = v_parametros.nombre,
			id_enti_fin = v_parametros.id_enti_fin,
			codigo = v_parametros.codigo,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_agencia=v_parametros.id_agencia;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Agencia modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_agencia',v_parametros.id_agencia::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_AGEN_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 19:15:41
	***********************************/

	elsif(p_transaccion='CB_AGEN_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_agencia
            where id_agencia=v_parametros.id_agencia;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Agencia eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_agencia',v_parametros.id_agencia::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 671 (class 1255 OID 207124)
-- Dependencies: 3246 8
-- Name: f_tcb_agencia_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_agencia_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_agencia_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_agencia'
 AUTOR: 		 (fprudencio)
 FECHA:	        20-09-2011 19:15:41
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_agencia_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_AGEN_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 19:15:41
	***********************************/

	if(p_transaccion='CB_AGEN_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						agen.id_agencia,
						agen.observaciones,
						agen.estado_reg,
						agen.nombre,
						agen.id_enti_fin,
						agen.codigo,
						agen.id_usuario_reg,
						agen.fecha_reg,
						agen.id_usuario_mod,
						agen.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_agencia agen
						inner join segu.tusuario usu1 on usu1.id_usuario = agen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = agen.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_AGEN_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 19:15:41
	***********************************/

	elsif(p_transaccion='CB_AGEN_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_agencia)
					    from cobra.tcb_agencia agen
					    inner join segu.tusuario usu1 on usu1.id_usuario = agen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = agen.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 672 (class 1255 OID 207125)
-- Dependencies: 8 3246
-- Name: f_tcb_arqueo_det_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_arqueo_det_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_arqueo_det_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_arqueo_det'
 AUTOR: 		 (fprudencio)
 FECHA:	        29-09-2011 17:20:27
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_arqueo_det	integer;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_arqueo_det_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_ARQDET_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 17:20:27
	***********************************/

	if(p_transaccion='CB_ARQDET_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_arqueo_det(
			estado_reg,
			cantidad,
			id_corte,
			importe,
			id_arqueo,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.cantidad,
			v_parametros.id_corte,
			v_parametros.importe,
			v_parametros.id_arqueo,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_arqueo_det into v_id_arqueo_det;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Arqueo almacenado(a) con exito (id_arqueo_det'||v_id_arqueo_det||')'); 
            v_resp = f_agrega_clave(v_resp,'id_arqueo_det',v_id_arqueo_det::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_ARQDET_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 17:20:27
	***********************************/

	elsif(p_transaccion='CB_ARQDET_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_arqueo_det set
			cantidad = v_parametros.cantidad,
			id_corte = v_parametros.id_corte,
			importe = v_parametros.importe,
			id_arqueo = v_parametros.id_arqueo,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_arqueo_det=v_parametros.id_arqueo_det;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Arqueo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_arqueo_det',v_parametros.id_arqueo_det::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_ARQDET_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 17:20:27
	***********************************/

	elsif(p_transaccion='CB_ARQDET_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_arqueo_det
            where id_arqueo_det=v_parametros.id_arqueo_det;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Arqueo eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_arqueo_det',v_parametros.id_arqueo_det::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 673 (class 1255 OID 207126)
-- Dependencies: 8 3246
-- Name: f_tcb_arqueo_det_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_arqueo_det_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_arqueo_det_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_arqueo_det'
 AUTOR: 		 (fprudencio)
 FECHA:	        29-09-2011 17:20:27
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_arqueo_det_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_ARQDET_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 17:20:27
	***********************************/

	if(p_transaccion='CB_ARQDET_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						arqdet.id_arqueo_det,
						arqdet.estado_reg,
						arqdet.cantidad,
						arqdet.id_corte,
                        cormon.descri_corte,
						arqdet.importe,
						arqdet.id_arqueo,
						arqdet.id_usuario_reg,
						arqdet.fecha_reg,
						arqdet.id_usuario_mod,
						arqdet.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_arqueo_det arqdet
						inner join segu.tusuario usu1 on usu1.id_usuario = arqdet.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = arqdet.id_usuario_mod 
                        inner join tesoro.tts_corte_moneda cormon on cormon.id_corte=arqdet.id_corte
                        inner join cobra.tcb_arqueo arq on arq.id_arqueo=arqdet.id_arqueo
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_ARQDET_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 17:20:27
	***********************************/

	elsif(p_transaccion='CB_ARQDET_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_arqueo_det)
					    from cobra.tcb_arqueo_det arqdet
					    inner join segu.tusuario usu1 on usu1.id_usuario = arqdet.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = arqdet.id_usuario_mod
                        inner join tesoro.tts_corte_moneda cormon on cormon.id_corte=arqdet.id_corte
                        inner join cobra.tcb_arqueo arq on arq.id_arqueo=arqdet.id_arqueo
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 674 (class 1255 OID 207127)
-- Dependencies: 3246 8
-- Name: f_tcb_arqueo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_arqueo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_arqueo_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_arqueo'
 AUTOR: 		 (fprudencio)
 FECHA:	        27-09-2011 11:02:53
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_arqueo	integer;
  
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_arqueo_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_ARQ_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		27-09-2011 11:02:53
	***********************************/

	if(p_transaccion='CB_ARQ_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_arqueo(
			estado_reg,
			observaciones,
			estado,
			id_caja,
			fecha,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.observaciones,
			v_parametros.estado,
			v_parametros.id_caja,
			v_parametros.fecha,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_arqueo into v_id_arqueo;
             
             --Insertamos a la tabla arqueo_estado
             insert into cobra.tcb_arqueo_estado(
			id_arqueo,
			estado_arqueo,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_id_arqueo,
			v_parametros.estado,
			'activo',
			p_id_usuario,
			now(),
			null,
			null
			);  
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Arqueo almacenado(a) con exito (id_arqueo'||v_id_arqueo||')'); 
            v_resp = f_agrega_clave(v_resp,'id_arqueo',v_id_arqueo::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_ARQ_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		27-09-2011 11:02:53
	***********************************/

	elsif(p_transaccion='CB_ARQ_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_arqueo set
			observaciones = v_parametros.observaciones,
			estado = v_parametros.estado,
			id_caja = v_parametros.id_caja,
			fecha = v_parametros.fecha,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_arqueo=v_parametros.id_arqueo;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Arqueo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_arqueo',v_parametros.id_arqueo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_ARQ_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		27-09-2011 11:02:53
	***********************************/

	elsif(p_transaccion='CB_ARQ_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_arqueo
            where id_arqueo=v_parametros.id_arqueo;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Arqueo eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_arqueo',v_parametros.id_arqueo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
    /*********************************    
 	#TRANSACCION:  'CB_REV_ARQUEO'
 	#DESCRIPCION:	Cambio de estado del arqueo
 	#AUTOR:		fprudencio	
 	#FECHA:		27-09-2011 11:02:53
	***********************************/

	elsif(p_transaccion='CB_REV_ARQUEO')then

		begin
			
            
            update cobra.tcb_arqueo set
			estado = v_parametros.operacion,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_arqueo=v_parametros.id_arqueo;
             
            --Actualizacion de la tabla arqueo_estado
           
             update cobra.tcb_arqueo_estado set    
			        estado_reg='inactivo',
			        id_usuario_mod=p_id_usuario,
			        fecha_mod=now()
             where estado_reg='activo' AND id_arqueo=v_parametros.id_arqueo; 
            
             --Inserto nuievo registro en caja_cajero
              insert into cobra.tcb_arqueo_estado(
			id_arqueo,
			estado_arqueo,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_arqueo,
			v_parametros.operacion,
			'activo',
			p_id_usuario,
			now(),
			null,
			null
			);  
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Arqueo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_arqueo',v_parametros.id_arqueo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;     
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 675 (class 1255 OID 207128)
-- Dependencies: 3246 8
-- Name: f_tcb_arqueo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_arqueo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_arqueo_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_arqueo'
 AUTOR: 		 (fprudencio)
 FECHA:	        27-09-2011 11:02:53
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_arqueo_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_ARQ_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		27-09-2011 11:02:53
	***********************************/

	if(p_transaccion='CB_ARQ_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						arq.id_arqueo,
						arq.estado_reg,
						arq.observaciones,
						arq.estado,
						arq.id_caja,
                        caja.codigo,
						arq.fecha,
						arq.id_usuario_reg,
						arq.fecha_reg,
						arq.id_usuario_mod,
						arq.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_arqueo arq
						inner join segu.tusuario usu1 on usu1.id_usuario = arq.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = arq.id_usuario_mod 
                        inner join cobra.tcb_caja caja on caja.id_caja=arq.id_caja
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_ARQ_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		27-09-2011 11:02:53
	***********************************/

	elsif(p_transaccion='CB_ARQ_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_arqueo)
					    from cobra.tcb_arqueo arq
					    inner join segu.tusuario usu1 on usu1.id_usuario = arq.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = arq.id_usuario_mod 
                        inner join cobra.tcb_caja caja on caja.id_caja=arq.id_caja
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 676 (class 1255 OID 207129)
-- Dependencies: 3246 8
-- Name: f_tcb_caja_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_caja_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_caja_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_caja'
 AUTOR: 		 (fprudencio)
 FECHA:	        26-09-2011 18:19:13
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_caja	integer; 
    v_id_caja_estado	integer;
    v_estado_anterior	varchar;
    v_estado			varchar;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_caja_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_CAJA_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		26-09-2011 18:19:13
	***********************************/

	if(p_transaccion='CB_CAJA_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_caja(
			observaciones,
			estado_reg,
			id_agencia,
			estado_caja,
			codigo,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.observaciones,
			'activo',
			v_parametros.id_agencia,
			v_parametros.estado_caja,
			v_parametros.codigo,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_caja into v_id_caja;
            
            --Sentencia de inserción en la tabla tcb_caja_estado 
             insert into cobra.tcb_caja_estado(
			id_caja,
			estado_act,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod,
            estado_reg
          	) values(
			v_id_caja,
			'borrador',
			p_id_usuario,
			now(),
			null,
			null,
            'activo'
			);
              
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Cajas almacenado(a) con exito (id_caja'||v_id_caja||')'); 
            v_resp = f_agrega_clave(v_resp,'id_caja',v_id_caja::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_CAJA_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		26-09-2011 18:19:13
	***********************************/

	elsif(p_transaccion='CB_CAJA_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_caja set
			observaciones = v_parametros.observaciones,
			id_agencia = v_parametros.id_agencia,
			estado_caja = v_parametros.estado_caja,
			codigo = v_parametros.codigo,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_caja=v_parametros.id_caja;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Cajas modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_caja',v_parametros.id_caja::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_CAJA_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		26-09-2011 18:19:13
	***********************************/

	elsif(p_transaccion='CB_CAJA_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_caja
            where id_caja=v_parametros.id_caja;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Cajas eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_caja',v_parametros.id_caja::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
    
    /*********************************    
 	#TRANSACCION:  'CB_ABRIR_CAJA'
 	#DESCRIPCION:	Apertura y Cierre de Cajas
 	#AUTOR:		fprudencio	
 	#FECHA:		26-09-2011 18:19:13
	***********************************/

	elsif(p_transaccion='CB_ABRIR_CAJA')then

		begin
			--Sentencia de la modificacion 
           
              
              update cobra.tcb_caja SET
              estado_caja=v_parametros.operacion
              where id_caja=v_parametros.id_caja; 
              
                    			
            
            --Obtengo el id_caja_estado y el estado_actual
            SELECT MAX(id_caja_estado),estado_act INTO v_id_caja_estado,v_estado_anterior
            FROM cobra.tcb_caja_estado
            WHERE id_caja=v_parametros.id_caja AND estado_reg='activo'
            GROUP BY estado_act;
            
            --Actualizo el estado_reg de caja_estado
            UPDATE cobra.tcb_caja_estado SET
            estado_reg='inactivo',
            id_usuario_mod=p_id_usuario,
            fecha_mod=now()
            WHERE id_caja_estado=v_id_caja_estado;
            
            --Ingreso un nuevo campo  para tcb_caja_estado
               insert into cobra.tcb_caja_estado(
			   id_caja,
			   estado_act,
               estado_ant,
			   id_usuario_reg,
			   fecha_reg,
			   id_usuario_mod,
			   fecha_mod,
               estado_reg
          	   ) values(
			   v_parametros.id_caja,
			   v_parametros.operacion,
               v_estado_anterior,
			   p_id_usuario,
			   now(),
			   null,
			   null,
               'activo'
			    );
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Cajas modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_caja',v_parametros.id_caja::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;     
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 677 (class 1255 OID 207131)
-- Dependencies: 3246 8
-- Name: f_tcb_caja_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_caja_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_caja_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_caja'
 AUTOR: 		 (fprudencio)
 FECHA:	        26-09-2011 18:19:13
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_caja_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_CAJA_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		26-09-2011 18:19:13
	***********************************/

	if(p_transaccion='CB_CAJA_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						caja.id_caja,
						caja.observaciones,
						caja.estado_reg,
						caja.id_agencia,
                        instit.nombre as institucion,
						caja.estado_caja,
						caja.codigo,
						caja.id_usuario_reg,
						caja.fecha_reg,
						caja.id_usuario_mod,
						caja.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        agencia.codigo as cod_agencia,
                        agencia.nombre as nombre_agencia
						from cobra.tcb_caja caja
						inner join segu.tusuario usu1 on usu1.id_usuario = caja.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = caja.id_usuario_mod 
                        inner join cobra.tcb_agencia agencia on agencia.id_agencia = caja.id_agencia
                        inner join cobra.tcb_enti_fin entfin on entfin.id_enti_fin=agencia.id_enti_fin
                        inner join param.tinstitucion instit on instit.id_institucion=entfin.id_institucion
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_CAJA_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		26-09-2011 18:19:13
	***********************************/

	elsif(p_transaccion='CB_CAJA_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_caja)
					    from cobra.tcb_caja caja
					    inner join segu.tusuario usu1 on usu1.id_usuario = caja.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = caja.id_usuario_mod
                        inner join cobra.tcb_agencia agencia on agencia.id_agencia = caja.id_agencia
                        inner join cobra.tcb_enti_fin entfin on entfin.id_enti_fin=agencia.id_enti_fin
                        inner join param.tinstitucion instit on instit.id_institucion=entfin.id_institucion
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 678 (class 1255 OID 207132)
-- Dependencies: 8 3246
-- Name: f_tcb_cajero_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_cajero_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_cajero_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_cajero'
 AUTOR: 		 (fprudencio)
 FECHA:	        28-09-2011 14:13:20
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_cajero	integer;       
    v_estado_cajero		varchar;
	v_caja_cajero		varchar;		    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_cajero_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_CAJERO_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		28-09-2011 14:13:20
	***********************************/

	if(p_transaccion='CB_CAJERO_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_cajero(
			id_usuario,
			estado_reg,
			estado_cajero,
			id_caja,
			tipo_cajero,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_usuario,
			'activo',
			v_parametros.estado_cajero,
			v_parametros.id_caja,
			v_parametros.tipo_cajero,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_cajero into v_id_cajero;
             --Insertamos a la tabla caja_cajero
             insert into cobra.tcb_caja_cajero(
			id_cajero,
			estado_cajero,
			estado_reg,
			id_caja,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_id_cajero,
			'activo',
			'activo',
			v_parametros.id_caja,
			p_id_usuario,
			now(),
			null,
			null
			);
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','CAJERO almacenado(a) con exito (id_cajero'||v_id_cajero||')'); 
            v_resp = f_agrega_clave(v_resp,'id_cajero',v_id_cajero::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_CAJERO_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		28-09-2011 14:13:20
	***********************************/

	elsif(p_transaccion='CB_CAJERO_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_cajero set
			id_usuario = v_parametros.id_usuario,
			estado_cajero = v_parametros.estado_cajero,
			id_caja = v_parametros.id_caja,
			tipo_cajero = v_parametros.tipo_cajero,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_cajero=v_parametros.id_cajero;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','CAJERO modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_cajero',v_parametros.id_cajero::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_CAJERO_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		28-09-2011 14:13:20
	***********************************/

	elsif(p_transaccion='CB_CAJERO_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_cajero
            where id_cajero=v_parametros.id_cajero;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','CAJERO eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_cajero',v_parametros.id_cajero::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
    /*********************************    
 	#TRANSACCION:  'CB_HABILITAR_CAJERO'
 	#DESCRIPCION:	Habilita o Deshabilita Cajeros
 	#AUTOR:		fprudencio	
 	#FECHA:		28-09-2011 14:13:20
	***********************************/

	elsif(p_transaccion='CB_HABILITAR_CAJERO')then

		begin
            -- Obtengo el estado del cajero
            SELECT estado_cajero INTO v_estado_cajero
            FROM cobra.tcb_cajero 
            WHERE id_cajero=v_parametros.id_cajero;
            
            --Verifico si el estado es activo o inactivo
            if (v_estado_cajero='activo')then
                v_caja_cajero='inactivo';    
            else
                v_caja_cajero='activo';
            end if;  
            
            --actualizo la tabla cajero
			 update cobra.tcb_cajero set
			           estado_cajero = v_caja_cajero,
			           id_usuario_mod = p_id_usuario,
			           fecha_mod = now()
			     where id_cajero=v_parametros.id_cajero;
            
             --actualizo la tabla caja_cajero
             update cobra.tcb_caja_cajero set            
			      --  estado_cajero=v_caja_cajero,
			        estado_reg='inactivo',
			        id_usuario_mod=p_id_usuario,
			        fecha_mod=now()
             where id_cajero=v_parametros.id_cajero AND estado_reg='activo' AND id_caja=v_parametros.id_caja; 
            
             --Inserto nuievo registro en caja_cajero
              insert into cobra.tcb_caja_cajero(
			id_cajero,
			estado_cajero,
			estado_reg,
			id_caja,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_cajero,
			v_caja_cajero,
			'activo',
			v_parametros.id_caja,
			p_id_usuario,
			now(),
			null,
			null
			);
                     
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','CAJERO habilitado(a) o deshabilitado'); 
            v_resp = f_agrega_clave(v_resp,'id_cajero',v_parametros.id_cajero::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;     
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 679 (class 1255 OID 207134)
-- Dependencies: 3246 8
-- Name: f_tcb_cajero_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_cajero_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_cajero_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_cajero'
 AUTOR: 		 (fprudencio)
 FECHA:	        28-09-2011 14:13:20
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_cajero_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_CAJERO_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		28-09-2011 14:13:20
	***********************************/

	if(p_transaccion='CB_CAJERO_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						cajero.id_cajero,
						cajero.id_usuario,
                        person.nombre_completo2,
						cajero.estado_reg,
						cajero.estado_cajero,
						cajero.id_caja,
						cajero.tipo_cajero,
						cajero.id_usuario_reg,
						cajero.fecha_reg,
						cajero.id_usuario_mod,
						cajero.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_cajero cajero
						inner join segu.tusuario usu1 on usu1.id_usuario = cajero.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = cajero.id_usuario_mod
                        inner join cobra.tcb_caja caja on caja.id_caja=cajero.id_caja
                        inner join segu.tusuario usuari on usuari.id_usuario=cajero.id_usuario
                        inner join segu.vpersona person on person.id_persona=usuari.id_persona
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_CAJERO_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		28-09-2011 14:13:20
	***********************************/

	elsif(p_transaccion='CB_CAJERO_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_cajero)
					    from cobra.tcb_cajero cajero
					    inner join segu.tusuario usu1 on usu1.id_usuario = cajero.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = cajero.id_usuario_mod
                        inner join cobra.tcb_caja caja on caja.id_caja=cajero.id_caja
                        inner join segu.tusuario usuari on usuari.id_usuario=cajero.id_usuario
                        inner join segu.vpersona person on person.id_persona=usuari.id_persona
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
    
    /*********************************    
 	#TRANSACCION:  'CB_CAJSIS_SEL'
 	#DESCRIPCION:	Listado de los Cajeros por Sistema de Distribución
 	#AUTOR:		rchumacero	
 	#FECHA:		12/12/2011
	***********************************/

	elsif(p_transaccion='CB_CAJSIS_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
                         cajero.id_cajero, cajero.id_caja, sisdis.codigo as cod_sist_dist,
                         sisdis.nombre as sist_dist, caja.codigo as cod_caja,
                         caja.estado_caja,  usuari.cuenta,
                         person.nombre_completo2 as cajero
                         from cobra.tcb_cajero cajero
                         inner join cobra.tcb_caja caja
                         on caja.id_caja = cajero.id_caja
                         inner join cobra.tcb_agencia agen
                         on agen.id_agencia = caja.id_agencia
                         inner join cobra.tcb_sistema_dist_agencia sisage
                         on sisage.id_agencia = agen.id_agencia
                         inner join cobra.tcb_sistema_dist sisdis
                         on sisdis.id_sistema_dist = sisage.id_sistema_dist
                         inner join segu.tusuario usuari
                         on usuari.id_usuario = cajero.id_usuario
                         inner join segu.vpersona person
                         on person.id_persona = usuari.id_persona
				         where ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;
        
    /*********************************    
 	#TRANSACCION:  'CB_CAJSIS_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rchumacero	
 	#FECHA:		12/12/2011
	***********************************/

	elsif(p_transaccion='CB_CAJSIS_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(cajero.id_cajero)
					     from cobra.tcb_cajero cajero
                         inner join cobra.tcb_caja caja
                         on caja.id_caja = cajero.id_caja
                         inner join cobra.tcb_agencia agen
                         on agen.id_agencia = caja.id_agencia
                         inner join cobra.tcb_sistema_dist_agencia sisage
                         on sisage.id_agencia = agen.id_agencia
                         inner join cobra.tcb_sistema_dist sisdis
                         on sisdis.id_sistema_dist = sisage.id_sistema_dist
                         inner join segu.tusuario usuari
                         on usuari.id_usuario = cajero.id_usuario
                         inner join segu.vpersona person
                         on person.id_persona = usuari.id_persona
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 680 (class 1255 OID 207135)
-- Dependencies: 8 3246
-- Name: f_tcb_cliente_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_cliente_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_cliente_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_cliente'
 AUTOR: 		 (fprudencio)
 FECHA:	        22-09-2011 11:53:34
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_cliente	integer;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_cliente_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_CLIE_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		22-09-2011 11:53:34
	***********************************/

	if(p_transaccion='CB_CLIE_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_cliente(
			estado_reg,
			nro_cuenta,
			tipo_cliente,
			nro_nit,
			id_sistema_dist,
			id_cliente_dist,
			nombre,
			nro_cuenta_ant,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.nro_cuenta,
			v_parametros.tipo_cliente,
			v_parametros.nro_nit,
			v_parametros.id_sistema_dist,
			v_parametros.id_cliente_dist,
			v_parametros.nombre,
			v_parametros.nro_cuenta_ant,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_cliente into v_id_cliente;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Clientes almacenado(a) con exito (id_cliente'||v_id_cliente||')'); 
            v_resp = f_agrega_clave(v_resp,'id_cliente',v_id_cliente::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_CLIE_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		22-09-2011 11:53:34
	***********************************/

	elsif(p_transaccion='CB_CLIE_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_cliente set
			nro_cuenta = v_parametros.nro_cuenta,
			tipo_cliente = v_parametros.tipo_cliente,
			nro_nit = v_parametros.nro_nit,
			id_sistema_dist = v_parametros.id_sistema_dist,
			id_cliente_dist = v_parametros.id_cliente_dist,
			nombre = v_parametros.nombre,
			nro_cuenta_ant = v_parametros.nro_cuenta_ant,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_cliente=v_parametros.id_cliente;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Clientes modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_cliente',v_parametros.id_cliente::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_CLIE_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		22-09-2011 11:53:34
	***********************************/

	elsif(p_transaccion='CB_CLIE_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_cliente
            where id_cliente=v_parametros.id_cliente;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Clientes eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_cliente',v_parametros.id_cliente::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 684 (class 1255 OID 207136)
-- Dependencies: 8 3246
-- Name: f_tcb_cliente_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_cliente_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_cliente_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_cliente'
 AUTOR: 		 (fprudencio)
 FECHA:	        22-09-2011 11:53:34
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_cliente_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_CLIE_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		22-09-2011 11:53:34
	***********************************/

	if(p_transaccion='CB_CLIE_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						clie.id_cliente,
						clie.estado_reg,
						clie.nro_cuenta,
						clie.tipo_cliente,
						clie.nro_nit,
						clie.id_sistema_dist,
						clie.id_cliente_dist,
						clie.nombre,
						clie.nro_cuenta_ant,
						clie.id_usuario_reg,
						clie.fecha_reg,
						clie.id_usuario_mod,
						clie.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_cliente clie
						inner join segu.tusuario usu1 on usu1.id_usuario = clie.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = clie.id_usuario_mod
                        inner join cobra.tcb_sistema_dist sisdis on sisdis.id_sistema_dist=clie.id_sistema_dist 
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_CLIE_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		22-09-2011 11:53:34
	***********************************/

	elsif(p_transaccion='CB_CLIE_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_cliente)
					    from cobra.tcb_cliente clie
					    inner join segu.tusuario usu1 on usu1.id_usuario = clie.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = clie.id_usuario_mod
                        inner join cobra.tcb_sistema_dist sisdis on sisdis.id_sistema_dist=clie.id_sistema_dist
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 685 (class 1255 OID 207137)
-- Dependencies: 8 3246
-- Name: f_tcb_cobro_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_cobro_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_cobro_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_cobro'
 AUTOR: 		 (gvelasquez)
 FECHA:	        27-09-2011 14:59:03
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_cobro				integer;
    
    v_id_factura_cob		varchar[];
	v_i 					integer;
	v_tamano 				integer;
    v_gestion				numeric; 
    v_periodo				numeric; 
    v_fecha_pago  			date;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_cobro_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_COBRO_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		27-09-2011 14:59:03
	***********************************/

	if(p_transaccion='CB_COBRO_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_cobro(
			id_cajero,
			id_cliente,
			cant_facturas,
			importe_cobro,
			importe_recibido,
			importe_cambio,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_cajero,
			v_parametros.id_cliente,
			v_parametros.cant_facturas,
			v_parametros.importe_cobro,
			v_parametros.importe_recibido,
			v_parametros.importe_cambio,
			'activo',
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_cobro into v_id_cobro;
            
           --insertamos los roles del usuario
           v_id_factura_cob= string_to_array(v_parametros.id_factura_cob,',');
           v_tamano = coalesce(array_length(v_id_factura_cob, 1),0);             

            
            FOR v_i IN 1..v_tamano LOOP
         
        		--validamos que las facturas seleccionadas no esten pagadas
                IF EXISTS (Select id_factura_cob 
                			From cobra.tcb_factura_cob 
                            Where id_factura_cob = v_id_factura_cob[v_i]::integer and estado_fac='pagado') Then
                	
                    Select gestion, periodo, fecha_pago
                    into v_gestion, v_periodo, v_fecha_pago 
                    from cobra.tcb_factura_cob 
                    where id_factura_cob = v_id_factura_cob[v_i]::integer 
                    and estado_fac='pagado';
                    
                    raise exception 'La factura de la gestion: % y periodo: %; ya fue pagada en fecha: %.',v_gestion,v_periodo,v_fecha_pago;
                END IF;
                
        
        	  --modificamos el estado de las facturas seleccionadas
              	update cobra.tcb_factura_cob set
                id_cobro = v_id_cobro,
				estado_fac = 'pagado',
                fecha_pago = now(),
                fecha_mod = now(),
                id_usuario_mod = p_id_usuario
				where id_factura_cob = v_id_factura_cob[v_i]::integer;
             
            END LOOP;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Cobro almacenado(a) con exito (id_cobro'||v_id_cobro||')'); 
            v_resp = f_agrega_clave(v_resp,'id_cobro',v_id_cobro::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_COBRO_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		27-09-2011 14:59:03
	***********************************/

	elsif(p_transaccion='CB_COBRO_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_cobro set
			id_cajero = v_parametros.id_cajero,
			id_cliente = v_parametros.id_cliente,
			cant_facturas = v_parametros.cant_facturas,
			importe_cobro = v_parametros.importe_cobro,
			importe_recibido = v_parametros.importe_recibido,
			importe_cambio = v_parametros.importe_cambio,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_cobro=v_parametros.id_cobro;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Cobro modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_cobro',v_parametros.id_cobro::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
            
            
             --modificamos lor roles relacionados al usuario
             --partimos los datos de id_roles en un vector    
           
             v_id_factura_cob= string_to_array(v_parametros.id_factura_cob,',');
             v_tamano = coalesce(array_length(v_id_factura_cob, 1),0);         
             
             
             -- inactivamos todas las facturas que no estan seleccionadas
             
            /* update cobra.tcb_factura_cob 
             set estado_fac='inactivo'
             where 
             id_usuario = v_parametros.id_usuario
             and 
             (id_rol::varchar != ANY(v_id_roles) or v_tamano=0);
             
            --pagamos las que faltan
  
            
            FOR v_i IN 1..v_tamano LOOP
                         
            --preguntamos si el id_rol ya se encuentra asignado si no insertamos
            IF  (NOT EXISTS (select 1 from segu.tusuario_rol 
                        where id_usuario = v_parametros.id_usuario
                        and id_rol = v_id_roles[v_i]::integer 
                        and estado_reg='activo')) THEN
              	  --insertamos  registro si no esta presente como activo
                  insert into segu.tusuario_rol 
                     (id_usuario, 
                     id_rol, 
                     estado_reg) 
                  values(
                  v_parametros.id_usuario,
                  v_id_roles[v_i]::integer,
                  'activo'); 
              END IF;
            END LOOP;*/
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_COBRO_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		27-09-2011 14:59:03
	***********************************/

	elsif(p_transaccion='CB_COBRO_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_cobro
            where id_cobro=v_parametros.id_cobro;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Cobro eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_cobro',v_parametros.id_cobro::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 686 (class 1255 OID 207139)
-- Dependencies: 3246 8
-- Name: f_tcb_cobro_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_cobro_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_cobro_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_cobro'
 AUTOR: 		 (gvelasquez)
 FECHA:	        27-09-2011 14:59:03
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_cobro_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_COBRO_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		gvelasquez	
 	#FECHA:		27-09-2011 14:59:03
	***********************************/

	if(p_transaccion='CB_COBRO_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						cobro.id_cobro,
						cobro.id_cajero,
						cobro.id_cliente,
						cobro.cant_facturas,
						cobro.importe_cobro,
						cobro.importe_recibido,
						cobro.importe_cambio,
						cobro.estado_reg,
						cobro.id_usuario_reg,
						cobro.fecha_reg,
						cobro.id_usuario_mod,
						cobro.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_cobro cobro
						inner join segu.tusuario usu1 on usu1.id_usuario = cobro.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = cobro.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_COBRO_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		27-09-2011 14:59:03
	***********************************/

	elsif(p_transaccion='CB_COBRO_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_cobro)
					    from cobra.tcb_cobro cobro
					    inner join segu.tusuario usu1 on usu1.id_usuario = cobro.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = cobro.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 687 (class 1255 OID 207140)
-- Dependencies: 8 3246
-- Name: f_tcb_enti_fin_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_enti_fin_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_enti_fin_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_enti_fin'
 AUTOR: 		 (gvelasquez)
 FECHA:	        20-09-2011 16:58:53
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_enti_fin	integer;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_enti_fin_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_ENTFIN_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		20-09-2011 16:58:53
	***********************************/

	if(p_transaccion='CB_ENTFIN_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_enti_fin(
			estado_reg,
			id_institucion,
			nro_cuenta,
			--tipo_entidad,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.id_institucion,
			v_parametros.nro_cuenta,
			--v_parametros.tipo_entidad,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_enti_fin into v_id_enti_fin;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Entidad Financiera almacenado(a) con exito (id_enti_fin'||v_id_enti_fin||')'); 
            v_resp = f_agrega_clave(v_resp,'id_enti_fin',v_id_enti_fin::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_ENTFIN_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		20-09-2011 16:58:53
	***********************************/

	elsif(p_transaccion='CB_ENTFIN_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_enti_fin set
			id_institucion = v_parametros.id_institucion,
			nro_cuenta = v_parametros.nro_cuenta,
			--tipo_entidad = v_parametros.tipo_entidad,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_enti_fin=v_parametros.id_enti_fin;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Entidad Financiera modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_enti_fin',v_parametros.id_enti_fin::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_ENTFIN_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		20-09-2011 16:58:53
	***********************************/

	elsif(p_transaccion='CB_ENTFIN_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_enti_fin
            where id_enti_fin=v_parametros.id_enti_fin;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Entidad Financiera eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_enti_fin',v_parametros.id_enti_fin::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 688 (class 1255 OID 207141)
-- Dependencies: 8 3246
-- Name: f_tcb_enti_fin_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_enti_fin_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_enti_fin_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_enti_fin'
 AUTOR: 		 (gvelasquez)
 FECHA:	        20-09-2011 16:58:53
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			cobra.f_tcb_enti_fin_sel(p_administrador integer, p_id_usuario integer, p_tabla varchar, p_transaccion varchar)
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_enti_fin_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_ENTFIN_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		gvelasquez	
 	#FECHA:		20-09-2011 16:58:53
	***********************************/

	if(p_transaccion='CB_ENTFIN_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						entfin.id_enti_fin,
						entfin.estado_reg,
						entfin.id_institucion,
                        instit.nombre as institucion,
						entfin.nro_cuenta,
						entfin.tipo_entidad,
						entfin.id_usuario_reg,
						entfin.fecha_reg,
						entfin.id_usuario_mod,
						entfin.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_enti_fin entfin
                        inner join param.tinstitucion instit on instit.id_institucion=entfin.id_institucion
						inner join segu.tusuario usu1 on usu1.id_usuario = entfin.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = entfin.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_ENTFIN_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		20-09-2011 16:58:53
	***********************************/

	elsif(p_transaccion='CB_ENTFIN_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_enti_fin)
					    from cobra.tcb_enti_fin entfin
                        inner join param.tinstitucion instit on instit.id_institucion=entfin.id_institucion
					    inner join segu.tusuario usu1 on usu1.id_usuario = entfin.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = entfin.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 690 (class 1255 OID 207142)
-- Dependencies: 8 3246
-- Name: f_tcb_factura_cob_det_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_factura_cob_det_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_factura_cob_det_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_factura_cob_det'
 AUTOR: 		 (gvelasquez)
 FECHA:	        23-09-2011 16:47:28
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_factura_cob_det	integer;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_factura_cob_det_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_FACODE_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 16:47:28
	***********************************/

	if(p_transaccion='CB_FACODE_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_factura_cob_det(
			id_tasa,
			id_descuento,
			importe,
			estado_reg,
			id_factura_cob,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_tasa,
			v_parametros.id_descuento,
			v_parametros.importe,
			'activo',
			v_parametros.id_factura_cob,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_factura_cob_det into v_id_factura_cob_det;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Cobro almacenado(a) con exito (id_factura_cob_det'||v_id_factura_cob_det||')'); 
            v_resp = f_agrega_clave(v_resp,'id_factura_cob_det',v_id_factura_cob_det::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_FACODE_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 16:47:28
	***********************************/

	elsif(p_transaccion='CB_FACODE_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_factura_cob_det set
			id_tasa = v_parametros.id_tasa,
			id_descuento = v_parametros.id_descuento,
			importe = v_parametros.importe,
			id_factura_cob = v_parametros.id_factura_cob,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_factura_cob_det=v_parametros.id_factura_cob_det;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Cobro modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_factura_cob_det',v_parametros.id_factura_cob_det::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_FACODE_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 16:47:28
	***********************************/

	elsif(p_transaccion='CB_FACODE_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_factura_cob_det
            where id_factura_cob_det=v_parametros.id_factura_cob_det;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Cobro eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_factura_cob_det',v_parametros.id_factura_cob_det::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 691 (class 1255 OID 207143)
-- Dependencies: 3246 8
-- Name: f_tcb_factura_cob_det_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_factura_cob_det_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_factura_cob_det_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_factura_cob_det'
 AUTOR: 		 (gvelasquez)
 FECHA:	        23-09-2011 16:47:28
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_factura_cob_det_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_FACODE_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 16:47:28
	***********************************/

	if(p_transaccion='CB_FACODE_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						facode.id_factura_cob_det,
						facode.id_tasa,
						facode.id_descuento,
						facode.importe,
						facode.estado_reg,
						facode.id_factura_cob,
						facode.id_usuario_reg,
						facode.fecha_reg,
						facode.id_usuario_mod,
						facode.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_factura_cob_det facode
						inner join segu.tusuario usu1 on usu1.id_usuario = facode.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = facode.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_FACODE_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 16:47:28
	***********************************/

	elsif(p_transaccion='CB_FACODE_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_factura_cob_det)
					    from cobra.tcb_factura_cob_det facode
					    inner join segu.tusuario usu1 on usu1.id_usuario = facode.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = facode.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 692 (class 1255 OID 207144)
-- Dependencies: 3246 8
-- Name: f_tcb_factura_cob_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_factura_cob_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_factura_cob_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_factura_cob'
 AUTOR: 		 (gvelasquez)
 FECHA:	        23-09-2011 17:21:15
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_factura_cob	integer;  
    v_id_cobro			integer; 
    v_id_cajero			integer;
    v_id_caja           integer;  
    v_registros			record; 
    v_estado_ant		varchar;
    
    v_i 				integer;
    v_tamano 			integer;
    v_id_factura_cob_cadena	varchar[];
    v_estado_fac		varchar;
    v_id_factura_cob_antiguas	varchar[];
    v_rec				record;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_factura_cob_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_FACCOB_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/

	if(p_transaccion='CB_FACCOB_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_factura_cob(
			importe_cred_fis,
			estado_reg,
			tipo_lectura,
			reconex_val,
			credito_pagado,
			consumo_cambio,
			nombre_fac,
			potencia_val,
			nro_factura,
			consumo_libre,
			nro_orden,
			sw_deb_fis,
			consumo_total,
			cod_alfanum,
			cod_control,
			id_caja,
			fecha_act,
			conexion_val,
			fecha_ant,
			nit_fact,
			fecha_prox_med,
			estado_fac,
			lectura_kw,
			cod_ubica,
			nro_autorizacion,
			multi_kwh,
			gestion,
			id_cajero,
			id_cliente,
			periodo,
			consumo_val,
			fecha_pago,
			direccion,
			importe_dev,
			nro_medidor,
			lectura_act,
			importe_total,
			num_formulario,
			fecha_vence,
			fecha_factura,
			id_moneda,
			consumo_periodo,
			lectura_ant,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.importe_cred_fis,
			'activo',
			v_parametros.tipo_lectura,
			v_parametros.reconex_val,
			v_parametros.credito_pagado,
			v_parametros.consumo_cambio,
			v_parametros.nombre_fac,
			v_parametros.potencia_val,
			v_parametros.nro_factura,
			v_parametros.consumo_libre,
			v_parametros.nro_orden,
			v_parametros.sw_deb_fis,
			v_parametros.consumo_total,
			v_parametros.cod_alfanum,
			v_parametros.cod_control,
			v_parametros.id_caja,
			v_parametros.fecha_act,
			v_parametros.conexion_val,
			v_parametros.fecha_ant,
			v_parametros.nit_fact,
			v_parametros.fecha_prox_med,
			v_parametros.estado_fac,
			v_parametros.lectura_kw,
			v_parametros.cod_ubica,
			v_parametros.nro_autorizacion,
			v_parametros.multi_kwh,
			v_parametros.gestion,
			v_parametros.id_cajero,
			v_parametros.id_cliente,
			v_parametros.periodo,
			v_parametros.consumo_val,
			v_parametros.fecha_pago,
			v_parametros.direccion,
			v_parametros.importe_dev,
			v_parametros.nro_medidor,
			v_parametros.lectura_act,
			v_parametros.importe_total,
			v_parametros.num_formulario,
			v_parametros.fecha_vence,
			v_parametros.fecha_factura,
			v_parametros.id_moneda,
			v_parametros.consumo_periodo,
			v_parametros.lectura_ant,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_factura_cob into v_id_factura_cob;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Cobranza almacenado(a) con exito (id_factura_cob'||v_id_factura_cob||')'); 
            v_resp = f_agrega_clave(v_resp,'id_factura_cob',v_id_factura_cob::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_FACCOB_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/

	elsif(p_transaccion='CB_FACCOB_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_factura_cob set
			importe_cred_fis = v_parametros.importe_cred_fis,
			tipo_lectura = v_parametros.tipo_lectura,
			reconex_val = v_parametros.reconex_val,
			credito_pagado = v_parametros.credito_pagado,
			consumo_cambio = v_parametros.consumo_cambio,
			nombre_fac = v_parametros.nombre_fac,
			potencia_val = v_parametros.potencia_val,
			nro_factura = v_parametros.nro_factura,
			consumo_libre = v_parametros.consumo_libre,
			nro_orden = v_parametros.nro_orden,
			sw_deb_fis = v_parametros.sw_deb_fis,
			consumo_total = v_parametros.consumo_total,
			cod_alfanum = v_parametros.cod_alfanum,
			cod_control = v_parametros.cod_control,
			id_caja = v_parametros.id_caja,
			fecha_act = v_parametros.fecha_act,
			conexion_val = v_parametros.conexion_val,
			fecha_ant = v_parametros.fecha_ant,
			nit_fact = v_parametros.nit_fact,
			fecha_prox_med = v_parametros.fecha_prox_med,
			estado_fac = v_parametros.estado_fac,
			lectura_kw = v_parametros.lectura_kw,
			cod_ubica = v_parametros.cod_ubica,
			nro_autorizacion = v_parametros.nro_autorizacion,
			multi_kwh = v_parametros.multi_kwh,
			gestion = v_parametros.gestion,
			id_cajero = v_parametros.id_cajero,
			id_cliente = v_parametros.id_cliente,
			periodo = v_parametros.periodo,
			consumo_val = v_parametros.consumo_val,
			fecha_pago = v_parametros.fecha_pago,
			direccion = v_parametros.direccion,
			importe_dev = v_parametros.importe_dev,
			nro_medidor = v_parametros.nro_medidor,
			lectura_act = v_parametros.lectura_act,
			importe_total = v_parametros.importe_total,
			num_formulario = v_parametros.num_formulario,
			fecha_vence = v_parametros.fecha_vence,
			fecha_factura = v_parametros.fecha_factura,
			id_moneda = v_parametros.id_moneda,
			consumo_periodo = v_parametros.consumo_periodo,
			lectura_ant = v_parametros.lectura_ant,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_factura_cob=v_parametros.id_factura_cob;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Cobranza modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_factura_cob',v_parametros.id_factura_cob::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_FACCOB_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/

	elsif(p_transaccion='CB_FACCOB_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_factura_cob
            where id_factura_cob=v_parametros.id_factura_cob;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Cobranza eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_factura_cob',v_parametros.id_factura_cob::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
    /*********************************    
 	#TRANSACCION:  'CB_PAGA_FAC'
 	#DESCRIPCION:	Pago de facturas pendientes
 	#AUTOR:		fprudencio	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/

	elsif(p_transaccion='CB_PAGA_FAC')then

		begin
            --obtenemos la cantidad de facturas a pagar
            v_id_factura_cob_cadena= string_to_array(v_parametros.id_factura_cob,',');

            --Obtiene la cantidad de facturas a pagar
            v_tamano = coalesce(array_length(v_id_factura_cob_cadena, 1),0);
            
            --Se obtiene las n facturas más antiguas del cliente como un array
            select '{'|| list(id_factura_cob::text)||'}'
            into v_id_factura_cob_antiguas
            from
            (select id_factura_cob
            from cobra.tcb_factura_cob
            where id_cliente=v_parametros.id_cliente
            and estado_fac in ('no_pagado','refacturado')
            order by fecha_factura ASC
            limit v_tamano) fact;
            
            --Ordena los arrays en función de los valores para luego compararlos
            v_id_factura_cob_cadena=sort(v_id_factura_cob_cadena::integer[],'asc');
            v_id_factura_cob_antiguas=sort(v_id_factura_cob_antiguas::integer[],'asc');
            
            --Compara los dos arrays para verificar si está pagando las n facturas más antiguas
            if v_id_factura_cob_cadena != v_id_factura_cob_antiguas then
                raise exception 'No es posible proceder con el Cobro porque existen facturas antiguas sin pagar o porque alguna de las facturas no existe. Verifique que las facturas a pagar correspondan desde la más antigua a la nueva o que todas las facturas existan.';
            end if;

            --Obtenemos el id_cajero en base al usuario
            select id_cajero into v_id_cajero
            from cobra.tcb_cajero 
            where id_usuario=p_id_usuario and estado_cajero='activo'; 
            select id_caja into v_id_caja
            from cobra.tcb_caja_cajero
            where id_cajero=v_id_cajero and estado_reg='activo' and estado_cajero='activo';
            
            
            --inserción del cobro
            insert into cobra.tcb_cobro(
			id_cliente,
            id_cajero,
			cant_facturas,
			importe_cobro,
			importe_recibido,
			importe_cambio,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_cliente,
            v_id_cajero,
			v_parametros.facturas_pagadas,
			v_parametros.acumulado,
			v_parametros.importe_recibido,
			v_parametros.importe_cambio,
			'activo',
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_cobro into v_id_cobro;
            
            --Ciclo para obtener las facturas que se pagaran
       		FOR v_rec IN SELECT estado_fac, id_factura_cob
            			FROM cobra.tcb_factura_cob
                        WHERE id_factura_cob = any(v_id_factura_cob_cadena::integer[])
                        ORDER BY fecha_factura LOOP
            	--Actualizamos los valores de facturas cobradas
                 UPDATE cobra.tcb_factura_cob SET
                 estado_fac		= 'pagado',
            	 id_cajero		= v_id_cajero,
            	 id_caja		= v_id_caja,
            	 id_cobro		= v_id_cobro,
            	 fecha_pago		= now(),
            	 id_usuario_mod	= p_id_usuario,
            	 fecha_mod		= now(),
                 estado_fac_ant	= v_estado_fac
                 WHERE id_factura_cob = v_rec.id_factura_cob;
                 
                  --TODO: aumentar llamada dblink para actualizar el estado del cobro
                 
            END LOOP;
            
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Facturas Pagadas'); 
            v_resp = f_agrega_clave(v_resp,'id_factura_cob',v_parametros.id_factura_cob::varchar);
            v_resp = f_agrega_clave(v_resp,'cambio',v_parametros.importe_cambio::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
    /*********************************    
 	#TRANSACCION:  'CB_ANULA_FAC'
 	#DESCRIPCION:	Anula los pagos de las facturas
 	#AUTOR:		fprudencio	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/

	elsif(p_transaccion='CB_ANULA_FAC')then

		begin                                              
            --Obtengo el estado anterior
              SELECT estado_fac_ant INTO v_estado_ant
              FROM cobra.tcb_factura_cob 
              WHERE id_factura_cob=v_parametros.id_factura_cob;
              
			--Sentencia para actualizar o anular la factura
			 UPDATE cobra.tcb_factura_cob SET
                 estado_fac=v_estado_ant,
            	 id_cajero=NULL,
            	 id_caja=NULL,
            	 id_cobro=NULL,
            	 fecha_pago=NULL,
            	 id_usuario_mod=p_id_usuario,
            	 fecha_mod=now(),
                 estado_fac_ant='no_pagado'
             WHERE id_factura_cob=v_parametros.id_factura_cob;
             
            --Insertamos los valores para historial en factura_cob_anulado
                 insert into cobra.tcb_factura_cob_anulado(
                 id_factura_cob,
			     nro_formulario,
				 estado_reg,
				 id_usuario_reg,
				 fecha_reg,
				 id_usuario_mod,
				 fecha_mod,
                 estado_fac,
                 estado_fac_ant,
                 id_cobro
          		 ) values(
                 v_parametros.id_factura_cob,
				 --v_parametros.importe_total,
                 0,
				'activo',
				 p_id_usuario,
				 now(),
				 null,
				 null,
                 v_estado_ant,
                 'pagado',
                 v_parametros.id_cobro
				 );
                 --Control de las facturas pagadas por cobro
                    
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Factura Anulada'); 
            v_resp = f_agrega_clave(v_resp,'id_factura_cob',v_parametros.id_factura_cob::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 693 (class 1255 OID 207146)
-- Dependencies: 8 3246
-- Name: f_tcb_factura_cob_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_factura_cob_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_factura_cob_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_factura_cob'
 AUTOR: 		 (gvelasquez)
 FECHA:	        23-09-2011 17:21:15
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_factura_cob_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_FACCOB_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/
    
    --raise exception '%',p_transaccion;

	if(p_transaccion='CB_FACCOB_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						faccob.id_factura_cob,
						faccob.importe_cred_fis,
						faccob.estado_reg,
						faccob.tipo_lectura,
						faccob.reconex_val,
						faccob.credito_pagado,
						faccob.consumo_cambio,
						faccob.nombre_fac,
						faccob.potencia_val,
						faccob.nro_factura,
						faccob.consumo_libre,
						faccob.nro_orden,
						faccob.sw_deb_fis,
						faccob.consumo_total,
						faccob.cod_alfanum,
						faccob.cod_control,
						faccob.id_caja,
						faccob.fecha_act,
						faccob.conexion_val,
						faccob.fecha_ant,
						faccob.nit_fact,
						faccob.fecha_prox_med,
						faccob.estado_fac,
						faccob.lectura_kw,
						faccob.cod_ubica,
						faccob.nro_autorizacion,
						faccob.multi_kwh,
						faccob.gestion,
						faccob.id_cajero,
						faccob.id_cliente,
						faccob.periodo,
						faccob.consumo_val,
						faccob.fecha_pago,
						faccob.direccion,
						faccob.importe_dev,
						faccob.nro_medidor,
						faccob.lectura_act,
						faccob.importe_total,
                        (select sum(f.importe_total) from cobra.tcb_factura_cob f where f.id_factura_cob <= faccob.id_factura_cob AND f.id_cliente=faccob.id_cliente AND f.estado_fac in (''no_pagado'',''refacturado'')) as acumulado,
                        (select count(f.id_factura_cob) from cobra.tcb_factura_cob f where f.periodo        <= faccob.periodo AND f.gestion = faccob.gestion AND f.id_cliente=faccob.id_cliente )as facturas_pagadas,
						faccob.num_formulario,
						faccob.fecha_vence,
						faccob.fecha_factura,
						faccob.id_moneda,
						faccob.consumo_periodo,
						faccob.lectura_ant,
						faccob.id_usuario_reg,
						faccob.fecha_reg,
						faccob.id_usuario_mod,
						faccob.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        
                        ((((((((faccob.gestion  || '' - '' ::text) || faccob.periodo ::text ) || '' - ''::text)||faccob.nombre_fac::text)||'' - ''::text)||faccob.importe_total::text)||'' - ''::text) ||faccob.nro_factura::text) as desc_factura
                        
						from cobra.tcb_factura_cob faccob
						inner join segu.tusuario usu1 on usu1.id_usuario = faccob.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = faccob.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_FACCOB_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/

	elsif(p_transaccion='CB_FACCOB_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_factura_cob)
					    from cobra.tcb_factura_cob faccob
					    inner join segu.tusuario usu1 on usu1.id_usuario = faccob.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = faccob.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
        
    /*********************************    
 	#TRANSACCION:  'CB_FACPEN_SEL'
 	#DESCRIPCION:	Listado de la facturación pendiente en un periodo de tiempo por Sistema de Distribución
 	#AUTOR:		rchumacero
 	#FECHA:		23-09-2011 17:21:15
	***********************************/
    elsif(p_transaccion='CB_FACPEN_SEL')then
     				
    	begin
        
    		--Sentencia de la consulta
			v_consulta:='select
                          cli.nombre, cli.nro_cuenta, facob.cod_alfanum, facob.cod_control,
                          facob.fecha_factura, facob.fecha_vence,facob.importe_total
                          from cobra.tcb_factura_cob facob
                          inner join cobra.tcb_cliente cli on cli.id_cliente = facob.id_cliente
				        where';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta|| ' cli.id_sistema_dist = ' || v_parametros.id_sistema_dist;
--            v_consulta:=v_consulta|| ' and and facob.estado_fac = ''' || v_parametros.estado_fac || '''';
            v_consulta:=v_consulta|| ' and facob.fecha_factura between ''' || v_parametros.fecha_ini || '''and ''' ||v_parametros.fecha_fin || '''';
			v_consulta:=v_consulta|| ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;
	
	/*********************************    
 	#TRANSACCION:  'CB_FACPEN_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rchumacero	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/
	elsif(p_transaccion='CB_FACPEN_CONT')then
     				
    	begin
        
    		--Sentencia de la consulta
			v_consulta:='select count(cli.nombre)
                          from cobra.tcb_factura_cob facob
                          inner join cobra.tcb_cliente cli on cli.id_cliente = facob.id_cliente
				        where';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta|| ' cli.id_sistema_dist = ' || v_parametros.id_sistema_dist;
--            v_consulta:=v_consulta|| ' and and facob.estado_fac = ''' || v_parametros.estado_fac || '''';
            v_consulta:=v_consulta|| ' and facob.fecha_factura between ''' || v_parametros.fecha_ini || '''and ''' ||v_parametros.fecha_fin || '''';

			--Devuelve la respuesta
			return v_consulta;
						
		end;
	
	/*********************************    
 	#TRANSACCION:  'CB_FACANU_SEL'
 	#DESCRIPCION:	Listado de la facturación anulada por cajero en un periodo de tiempo
 	#AUTOR:		rchumacero
 	#FECHA:		23-09-2011 17:21:15
	***********************************/
	elsif(p_transaccion='CB_FACANU_SEL')then
     				
    	begin
        
    		--Sentencia de la consulta
			v_consulta:='select fc.id_cajero, cl.nro_cuenta, cl.nombre, fa.nro_formulario,
            			fa.motivo, p.nombre_completo2 as cajero, fc.importe_total
                        from cobra.tcb_factura_cob fc
                        inner join cobra.tcb_factura_cob_anulado fa on fc.id_factura_cob=fa.id_factura_cob
                        inner join cobra.tcb_caja c on fc.id_caja=c.id_caja
                        inner join cobra.tcb_cajero cj on fc.id_cajero=cj.id_cajero
                        inner join cobra.tcb_cliente cl on cl.id_cliente=fc.id_cliente
                        inner join segu.tusuario u on u.id_usuario=fa.id_usuario
                        inner join segu.vpersona p on u.id_persona=p.id_persona
                        where fa.id_cajero = ' || v_parametros.id_cajero || '
                        and fa.fecha_reg between ''' || v_parametros.fecha_ini || ''' and ''' || v_parametros.fecha_fin  || '''';
			
			--Definicion de la respuesta
            raise notice '%',v_consulta;
			return v_consulta;
						
		end;
        
    
    /*********************************    
 	#TRANSACCION:  'CB_FACANU_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rchumacero	
 	#FECHA:		23-09-2011 17:21:15
	***********************************/    
	elsif(p_transaccion='CB_FACANU_CONT')then
     				
    	begin
        
    		--Sentencia de la consulta
			v_consulta:='select count(fa.id_factura_cob_anulado)
                        from cobra.tcb_factura_cob fc
                        inner join cobra.tcb_factura_cob_anulado fa on fc.id_factura_cob=fa.id_factura_cob
                        inner join cobra.tcb_caja c on fc.id_caja=c.id_caja
                        inner join cobra.tcb_cajero cj on fc.id_cajero=cj.id_cajero
                        inner join cobra.tcb_cliente cl on cl.id_cliente=fc.id_cliente
                        inner join segu.tusuario u on u.id_usuario=fa.id_usuario
                        inner join segu.vpersona p on u.id_persona=p.id_persona
                        where fa.id_cajero = ' || v_parametros.id_cajero || '
                        and fa.fecha_reg between ''' || v_parametros.fecha_ini || ''' and ''' || v_parametros.fecha_fin  || '''';
			
			--Definicion de la respuesta
			return v_consulta;
						
		end;
        
        
    /*********************************    
 	#TRANSACCION:  'CB_INGPORCAJ_SEL'
 	#DESCRIPCION:	Listado de los ingresos por cajero en un periodo de tiempo
 	#AUTOR:		Grover Velasquez Colque
 	#FECHA:		23-09-2011 17:21:15
	***********************************/
	elsif(p_transaccion='CB_INGPORCAJ_SEL')then
     				
    	begin
        
    		--Sentencia de la consulta
			v_consulta:='select fc.id_cajero, 
            			p.nombre_completo2 as cajero, 
                        count (fc.id_factura_cob) as cantidad_facturas,
                        sum(fc.importe_total)
                        
                        from cobra.tcb_factura_cob fc
                        inner join cobra.tcb_caja c on fc.id_caja=c.id_caja
                        inner join cobra.tcb_cajero cj on fc.id_cajero=cj.id_cajero
                        inner join segu.tusuario u on u.id_usuario=cj.id_usuario
                        inner join segu.vpersona p on u.id_persona=p.id_persona
                        
                        where c.id_agencia = ' || v_parametros.id_agencia || '
                        and fc.fecha_pago between ''' || v_parametros.fecha_ini || ''' and ''' || v_parametros.fecha_fin  || '''
                        group by fc.id_cajero, 
                        p.nombre_completo2 ';
			raise notice '%',v_consulta;
			--Definicion de la respuesta
			return v_consulta;
						
		end;
        
    
    /*********************************    
 	#TRANSACCION:  'CB_INGPORCAJ_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		GroverVelasquez Colque	
 	#FECHA:		27-12-2011 17:21:15
	***********************************/    
	elsif(p_transaccion='CB_INGPORCAJ_CONT')then
     				
    	begin
        
    		--Sentencia de la consulta
			v_consulta:='select count(fc.id_factura_cob)
            
                        from cobra.tcb_factura_cob fc
                        inner join cobra.tcb_caja c on fc.id_caja=c.id_caja
                        inner join cobra.tcb_cajero cj on fc.id_cajero=cj.id_cajero
                        inner join segu.tusuario u on u.id_usuario=cj.id_usuario
                        inner join segu.vpersona p on u.id_persona=p.id_persona
                        
                        where c.id_agencia = ' || v_parametros.id_agencia || '
                        and fc.fecha_pago between ''' || v_parametros.fecha_ini || ''' and ''' || v_parametros.fecha_fin  || '''
                       ';
			
			--Definicion de la respuesta
			return v_consulta;
						
		end;	

	 /*********************************    
 	#TRANSACCION:  'CB_RESFAC_SEL'
 	#DESCRIPCION:	Listado del resumen de facturacion
 	#AUTOR:		José Mita Huanca
 	#FECHA:		30-01-2012 17:21:15
	***********************************/
	elsif(p_transaccion='CB_RESFAC_SEL')then
     				
    	begin
        
    		--Sentencia de la consulta
			v_consulta:='select  count(fc.id_cliente) as cant_clientes, sum(fc.consumo_total) as energia,
 sum (fc.conexion_val + fc.reconex_val) as importe_reconex, sum(fc.credito_pagado + fc.importe_dev ) as devol,sum(fc.consumo_val) as importe_suministro,
 sum(fcd.importe) as descuento_1, sum(fcd1.importe) as descuento_2, sum(fcd2.importe) as tasa_1, sum(fcd3.importe) as tasa_2, sum(fcd4.importe) as descuento_3, sum(fc.importe_total) as importe_total
 from cobra.tcb_factura_cob fc 
 inner join cobra.tcb_cliente c on fc.id_cliente=c.id_cliente 
 inner join cobra.tcb_sistema_dist sd on sd.id_sistema_dist=c.id_sistema_dist
 left join cobra.tcb_factura_cob_det fcd on fc.id_factura_cob=fcd.id_factura_cob and fcd.id_descuento=1
 left join cobra.tcb_factura_cob_det fcd1 on fc.id_factura_cob=fcd1.id_factura_cob and fcd1.id_descuento=2
 left join cobra.tcb_factura_cob_det fcd2 on fc.id_factura_cob=fcd2.id_factura_cob and fcd2.id_tasa=1
 left join cobra.tcb_factura_cob_det fcd3 on fc.id_factura_cob=fcd3.id_factura_cob and fcd3.id_tasa=2
 left join cobra.tcb_factura_cob_det fcd4 on fc.id_factura_cob=fcd4.id_factura_cob and fcd4.id_descuento=3
 where c.id_sistema_dist= ' || v_parametros.id_sistema_dist || ' and by fc.periodo= ' || v_parametros.periodo || ' and fc.gestion= ' || v_parametros.gestion || '
 group by fc.periodo, fc.gestion, sd.nombre ';
			raise notice '%',v_consulta;
			--Definicion de la respuesta
			return v_consulta;
						
		end;
        
    
    /*********************************    
 	#TRANSACCION:  'CB_RESFAC_CONT'
 	#DESCRIPCION:	cantidad del resumen de facturacion
 	#AUTOR:		José Mita Huanca
 	#FECHA:		30-01-2012 17:21:15
	***********************************/    
	elsif(p_transaccion='CB_RESFAC_CONT')then
     				
    	begin
        
    		--Sentencia de la consulta
			v_consulta:='select 1';
			
			--Definicion de la respuesta
			return v_consulta;
						
		end;			
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 694 (class 1255 OID 207148)
-- Dependencies: 8 3246
-- Name: f_tcb_factura_rep_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_factura_rep_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_factura_rep_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas para la impresión de la factura
 AUTOR: 		 (rcm)
 FECHA:	        14-03-2012
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_reg				record;
    v_limite			integer;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_factura_rep_sel';
    v_parametros = f_get_record(p_tabla);
    v_limite = 3;

	/*********************************    
 	#TRANSACCION:  'CB_FADAGE_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			rcm	
 	#FECHA:			14-03-2012
	***********************************/

	if(p_transaccion='CB_FADAGE_SEL')then --FActura DAtos GEnerales
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select 
                        --datos cliente
                        fac.nro_factura, fac.nro_autorizacion,fac.fecha_factura as fecha_emision,
                        cli.nombre as cliente, cli.nro_nit as nit_cliente, fac.nro_medidor, cli.nro_cuenta,
                        fac.direccion, fac.desc_categoria as categoria, fac.cod_ubica,
                        fac.periodo as periodo_consumo, fac.fecha_act - fac.fecha_ant as dias,
                        fac.lectura_ant, fac.lectura_act, fac.consumo_total, fac.tipo_lectura, fac.multi_kwh,
                        fac.lectura_kw as potencia, fac.fecha_prox_med, fac.fecha_vence,
                        --importes consumo
                        fac.consumo_val as importe_energia,
                        fac.potencia_val as importe_portencia,
                        fac.conexion_val + fac.reconex_val as importe_conex_reconex,
                        fac.importe_dev-fac.credito_pagado as cred_deb_dev
                        from cobra.tcb_factura_cob fac
                        inner join cobra.tcb_cliente cli on cli.id_cliente = fac.id_cliente
                        where fac.id_factura_cob = ' || v_parametros.id_factura_cob;
			
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_FADADE_SEL'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:			rcm
 	#FECHA:			14-03-2012
	***********************************/

	elsif(p_transaccion='CB_FADADE_SEL')then --FActura DAtos DEtalle

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select
                        case coalesce(facdet.id_descuento,0)
                            when 0 then tas.desc_tasa
                            else des.desc_descuento
                        end as concepto,
                        facdet.importe
                        from cobra.tcb_factura_cob fac
                        inner join cobra.tcb_factura_cob_det facdet
                        on facdet.id_factura_cob = fac.id_factura_cob
                        left join factur.tfv_descuento des on des.id_descuento = facdet.id_descuento
                        left join factur.tfv_tasa tas on tas.id_tasa = facdet.id_tasa
                        where fac.id_factura_cob = ' || v_parametros.id_factura_cob;

			--Devuelve la respuesta
			return v_consulta;

		end;
        
	/*********************************    
 	#TRANSACCION:  'CB_FAHICO_SEL'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:			rcm
 	#FECHA:			14-03-2012
	***********************************/

	elsif(p_transaccion='CB_FAHICO_SEL')then --FActura HIstorico COnsumo

		begin
        	--Se obtiene el id_cliente y la fecha de la factura actual
            select id_cliente, fecha_factura
            into v_reg
            from cobra.tcb_factura_cob fac
            where fac.id_factura_cob = v_parametros.id_factura_cob;
            
            if v_reg.id_cliente is null or v_reg.fecha_factura is null then
            	raise exception 'No se puede encontrar el detalle del Consumo Histórico del cliente.';
            end if;
            
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select
                        periodo, consumo_total
                        from (
                        select
                        f_llenar_ceros(fac.periodo,2) || ''/'' || fac.gestion as periodo,fac.consumo_total,
                        fac.fecha_factura
                        from cobra.tcb_factura_cob fac
                        where fac.id_cliente = '||v_rec.id_cliente||'
                        and fac.fecha_factura <= '||v_rec.fecha_factura||'
                        order by fac.fecha_factura desc
                        limit '||v_limite||') res
                        order by fecha_factura';

			--Devuelve la respuesta
			return v_consulta;

		end;        
        		
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 695 (class 1255 OID 207151)
-- Dependencies: 3246 8
-- Name: f_tcb_importar_factur_resum_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_importar_factur_resum_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_importar_factur_resum_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_sistema_dist_usuario'
 AUTOR: 		 (jmita)
 FECHA:	        19-10-2011 10:41:58
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_importar_factur_resum_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_IMPRES_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		jmita	
 	#FECHA:		19-10-2011 10:41:58
	***********************************/

	if(p_transaccion='CB_IMPRES_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select fc.periodo,
            					fc.gestion,
                                count(fc.id_cliente) as cant_clientes,
                                sum(fc.importe_total) as importe_total
                         from cobra.tcb_factura_cob fc 
                         inner join cobra.tcb_cliente c on fc.id_cliente=c.id_cliente 
                         where c.id_sistema_dist=4 
                         group by fc.periodo, fc.gestion
                         order by fc.periodo, fc.gestion asc  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
            
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            raise notice '%',v_consulta;
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_IMPRES_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		jmita	
 	#FECHA:		19-10-2011 10:41:58
	***********************************/

	elsif(p_transaccion='CB_IMPRES_CONT')then


		begin
        
         EXECUTE('CREATE TEMP TABLE tt_facturacion_periodo("id_cliente" integer,                                                                      
                                                                 "nro_cuenta" VARCHAR,
                                                                 "nro_cuenta_ant" VARCHAR,
                                                                 "nombre" VARCHAR,
                                                                 "nro_nit" NUMERIC,
                                                                 "tipo_cliente" VARCHAR
                                                                      )  ON COMMIT DROP;');
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_sistema_dist_usuario)
					    from cobra.tcb_sistema_dist_usuario ushab
						inner join segu.tusuario usu1 on usu1.id_usuario = ushab.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ushab.id_usuario_mod
                        inner join segu.tusuario usu3 on usu3.id_usuario=ushab.id_usuario
                        inner join cobra.tcb_sistema_dist sisdis on sisdis.id_sistema_dist=ushab.id_sistema_dist 
                        INNER JOIN segu.vpersona PERSON on PERSON.id_persona = usu3.id_persona
				        where  ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 696 (class 1255 OID 207152)
-- Dependencies: 8 3246
-- Name: f_tcb_prueba_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_prueba_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_prueba_ime
 DESCRIPCION:   Función que gestiona las operaciones básicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_prueba'
 AUTOR: 		 (admin)
 FECHA:	        17-08-2011 17:53:45
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_prueba	integer;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_prueba_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_PRUEBA_INS'
 	#DESCRIPCION:	Inserción de registros
 	#AUTOR:		admin	
 	#FECHA:		17-08-2011 17:53:45
	***********************************/

	if(p_transaccion='CB_PRUEBA_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_prueba(
			empleado,
			estado,
			estado_reg,
			fecha,
			nombre,
			sueldo,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			v_parametros.empleado,
			v_parametros.estado,
			v_parametros.estado_reg,
			v_parametros.fecha,
			v_parametros.nombre,
			v_parametros.sueldo,
			now(),
			p_id_usuario,
			null,
			null
			)RETURNING id_prueba into v_id_prueba;
               
			--Definición de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Prueba almacenado(a) con exito (id_prueba'||v_id_prueba||')'); 
            v_resp = f_agrega_clave(v_resp,'id_prueba',v_id_prueba::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_PRUEBA_MOD'
 	#DESCRIPCION:	Modificación de registros
 	#AUTOR:		admin	
 	#FECHA:		17-08-2011 17:53:45
	***********************************/

	elsif(p_transaccion='CB_PRUEBA_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_prueba set
			empleado = v_parametros.empleado,
			estado = v_parametros.estado,
			estado_reg = v_parametros.estado_reg,
			fecha = v_parametros.fecha,
			nombre = v_parametros.nombre,
			sueldo = v_parametros.sueldo,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_prueba=v_parametros.id_prueba;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Prueba modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_prueba',v_parametros.id_prueba::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_PRUEBA_ELI'
 	#DESCRIPCION:	Eliminación de registros
 	#AUTOR:		admin	
 	#FECHA:		17-08-2011 17:53:45
	***********************************/

	elsif(p_transaccion='CB_PRUEBA_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_prueba
            where id_prueba=v_parametros.id_prueba;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Prueba eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_prueba',v_parametros.id_prueba::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 699 (class 1255 OID 207153)
-- Dependencies: 3246 8
-- Name: f_tcb_prueba_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_prueba_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_prueba_sel
 DESCRIPCION:   Función que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_prueba'
 AUTOR: 		 (admin)
 FECHA:	        17-08-2011 17:53:45
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_prueba_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_PRUEBA_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		admin	
 	#FECHA:		17-08-2011 17:53:45
	***********************************/

	if(p_transaccion='CB_PRUEBA_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						prueba.id_prueba,
						prueba.empleado,
						prueba.estado,
						prueba.estado_reg,
						prueba.fecha,
						prueba.nombre,
						prueba.sueldo,
						prueba.fecha_reg,
						prueba.id_usuario_reg,
						prueba.fecha_mod,
						prueba.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_prueba prueba
						inner join segu.tusuario usu1 on usu1.id_usuario = prueba.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = prueba.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_PRUEBA_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		admin	
 	#FECHA:		17-08-2011 17:53:45
	***********************************/

	elsif(p_transaccion='CB_PRUEBA_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_prueba)
					    from cobra.tcb_prueba prueba
					    inner join segu.tusuario usu1 on usu1.id_usuario = prueba.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = prueba.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 700 (class 1255 OID 207154)
-- Dependencies: 3246 8
-- Name: f_tcb_sistema_dist_agencia_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_sistema_dist_agencia_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_sistema_dist_agencia_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_sistema_dist_agencia'
 AUTOR: 		 (fprudencio)
 FECHA:	        20-09-2011 16:24:24
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_sistema_dist_agencia	integer;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_sistema_dist_agencia_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_ENTI_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 16:24:24
	***********************************/

	if(p_transaccion='CB_ENTI_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_sistema_dist_agencia(
			estado_reg,
			id_sistema_dist,
			id_agencia,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.id_sistema_dist,
			v_parametros.id_agencia,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_sistema_dist_agencia into v_id_sistema_dist_agencia;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Entidades o Agencias Habilitadas almacenado(a) con exito (id_sistema_dist_agencia'||v_id_sistema_dist_agencia||')'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist_agencia',v_id_sistema_dist_agencia::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_ENTI_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 16:24:24
	***********************************/

	elsif(p_transaccion='CB_ENTI_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_sistema_dist_agencia set
			id_sistema_dist = v_parametros.id_sistema_dist,
			id_agencia = v_parametros.id_agencia,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_sistema_dist_agencia=v_parametros.id_sistema_dist_agencia;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Entidades o Agencias Habilitadas modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist_agencia',v_parametros.id_sistema_dist_agencia::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_ENTI_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 16:24:24
	***********************************/

	elsif(p_transaccion='CB_ENTI_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_sistema_dist_agencia
            where id_sistema_dist_agencia=v_parametros.id_sistema_dist_agencia;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Entidades o Agencias Habilitadas eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist_agencia',v_parametros.id_sistema_dist_agencia::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 701 (class 1255 OID 207155)
-- Dependencies: 8 3246
-- Name: f_tcb_sistema_dist_agencia_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_sistema_dist_agencia_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_sistema_dist_agencia_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_sistema_dist_agencia'
 AUTOR: 		 (fprudencio)
 FECHA:	        20-09-2011 16:24:24
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_sistema_dist_agencia_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_ENTI_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 16:24:24
	***********************************/

	if(p_transaccion='CB_ENTI_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						enti.id_sistema_dist_agencia,
						enti.estado_reg,
						enti.id_sistema_dist, 
                        sisdis.nombre as nombre_sistema,
						enti.id_agencia,               
                        agen.nombre as nombre_agencia,
						enti.id_usuario_reg,
						enti.fecha_reg,
						enti.id_usuario_mod,
						enti.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_sistema_dist_agencia enti
						inner join segu.tusuario usu1 on usu1.id_usuario = enti.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = enti.id_usuario_mod
                        inner join cobra.tcb_sistema_dist sisdis on sisdis.id_sistema_dist=enti.id_sistema_dist
                        inner join cobra.tcb_agencia agen on agen.id_agencia=enti.id_agencia
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_ENTI_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 16:24:24
	***********************************/

	elsif(p_transaccion='CB_ENTI_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_sistema_dist_agencia)
					    from cobra.tcb_sistema_dist_agencia enti
						inner join segu.tusuario usu1 on usu1.id_usuario = enti.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = enti.id_usuario_mod
                        inner join cobra.tcb_sistema_dist sisdis on sisdis.id_sistema_dist=enti.id_sistema_dist
                        inner join cobra.tcb_agencia agen on agen.id_agencia=enti.id_agencia
				        where  ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 702 (class 1255 OID 207156)
-- Dependencies: 8 3246
-- Name: f_tcb_sistema_dist_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_sistema_dist_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_sistema_dist_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_sistema_dist'
 AUTOR: 		 (fprudencio)
 FECHA:	        20-09-2011 10:22:05
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_sistema_dist	integer;
    v_registros			record; 
    v_ss		text;
    v_periodo			numeric;
    v_gestion			numeric;
    v_pru				integer;
    v_consulta varchar;
    v_codigo_sis		varchar;
    v_id_cliente_cob	integer;
    v_id_fac_cob		bigint;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_sistema_dist_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_SISDIS_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 10:22:05
	***********************************/

	if(p_transaccion='CB_SISDIS_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_sistema_dist(
			codigo,
			conexion,
			nombre,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.codigo,
			v_parametros.conexion,
			v_parametros.nombre,
			'activo',
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_sistema_dist into v_id_sistema_dist;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Sistemas de DistribuciÃ³n almacenado(a) con exito (id_sistema_dist'||v_id_sistema_dist||')'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist',v_id_sistema_dist::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_SISDIS_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 10:22:05
	***********************************/

	elsif(p_transaccion='CB_SISDIS_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_sistema_dist set
			codigo = v_parametros.codigo,
			conexion = v_parametros.conexion,
			nombre = v_parametros.nombre,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_sistema_dist=v_parametros.id_sistema_dist;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Sistemas de DistribuciÃ³n modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist',v_parametros.id_sistema_dist::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_SISDIS_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 10:22:05
	***********************************/

	elsif(p_transaccion='CB_SISDIS_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_sistema_dist
            where id_sistema_dist=v_parametros.id_sistema_dist;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Sistemas de DistribuciÃ³n eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist',v_parametros.id_sistema_dist::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
     /*********************************    
 	#TRANSACCION:  'CB_IMPOR_CLIENTE'
 	#DESCRIPCION:	Para importar clientes de las diferentes bases de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 10:22:05
	***********************************/

	elsif(p_transaccion='CB_IMPOR_CLIENTE')then

		begin  
       
            -- Creamos la tabla temporal para 
             EXECUTE('CREATE TEMP TABLE tt_cliente_distribucion("id_cliente" integer,                                                                      
                                                                 "nro_cuenta" VARCHAR,
                                                                 "nro_cuenta_ant" VARCHAR,
                                                                 "nombre" VARCHAR,
                                                                 "nro_nit" NUMERIC,
                                                                 "tipo_cliente" VARCHAR
                                                                      )  ON COMMIT DROP;');  
                                                                      
                                                                      
            --Conexion a la base de datos con la cadena enviada  
           /* v_ss='insert into tt_cliente_distribucion
                                 SELECT P.id_cliente, P.nro_cuenta,P.nro_cuenta_ant,P.desc_cliente,P.nro_nit,P.tipo_cliente
                                 FROM dblink('''||v_parametros.conexion||''',
                                             ''SELECT cli.id_cliente,                                                    
                                                      cli.nro_cuenta,
                                                      cli.nro_cuenta_ant,
                                                      cli.desc_cliente,
                                                      cli.nro_nit,
                                                      (case when (cli.razon_social!='''' '''') THEN ''''Persona''''
                                                            else ''''Empresa''''
                                                            end) as tipo_cliente
                                               FROM factur.vfv_cliente cli'') AS P(
                                                                                  "id_cliente" integer,                                                                                  
                                                                                  "nro_cuenta" VARCHAR , 
                                                                                  "nro_cuenta_ant" VARCHAR,
                                                                                  "desc_cliente" TEXT,
                                                                                  "nro_nit" NUMERIC,
                                                                                  "tipo_cliente" VARCHAR);';  
                                                                                  raise exception '%',v_ss;   */
            execute('insert into tt_cliente_distribucion
                                 SELECT P.id_cliente, P.nro_cuenta,P.nro_cuenta_ant,P.desc_cliente,P.nro_nit,P.tipo_cliente
                                 FROM dblink('''||v_parametros.conexion||''',
                                             ''SELECT cli.id_cliente,                                                    
                                                      cli.nro_cuenta,
                                                      cli.nro_cuenta_ant,
                                                      cli.desc_cliente,
                                                      cli.nro_nit,
                                                      (case when (cli.razon_social!='''' '''') THEN ''''Empresa''''
                                                            else ''''Persona''''
                                                            end) as tipo_cliente
                                               FROM factur.vfv_cliente cli'') AS P(
                                                                                  "id_cliente" integer,                                                                                  
                                                                                  "nro_cuenta" VARCHAR , 
                                                                                  "nro_cuenta_ant" VARCHAR,
                                                                                  "desc_cliente" TEXT,
                                                                                  "nro_nit" NUMERIC,
                                                                                  "tipo_cliente" VARCHAR);');  
                                                                                  
                                                                              --raise exception'llegaaaa';
            --Recorremos la tabla para identificar los clientes que ya se importaron
            FOR v_registros IN(SELECT * FROM tt_cliente_distribucion)Loop
               IF NOT EXISTS(SELECT 1 FROM cobra.tcb_cliente WHERE id_sistema_dist=v_parametros.id_sistema_dist AND id_cliente_dist=v_registros.id_cliente)THEN
                  insert into cobra.tcb_cliente(
			                  estado_reg,
			                  nro_cuenta,
			                  tipo_cliente,
			                  nro_nit,
			                  id_sistema_dist,
			                  id_cliente_dist,
			                  nombre,
			                  nro_cuenta_ant,
			                  id_usuario_reg,
			                  fecha_reg,
			                  id_usuario_mod,
			                  fecha_mod
          	                  ) values(
			                  'activo',
			                  v_registros.nro_cuenta,
			                  v_registros.tipo_cliente,
			                  v_registros.nro_nit,
			                  v_parametros.id_sistema_dist,
			                  v_registros.id_cliente,
			                  v_registros.nombre,
			                  v_registros.nro_cuenta_ant,
			                  p_id_usuario,
			                  now(),
			                  null,
			                  null
			                  ); 
               END IF; 
            END LOOP;                                                                                                                                          			
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Clientes del Sistema importados'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist',v_parametros.id_sistema_dist::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;    
        
        /*********************************    
 	#TRANSACCION:  'CB_IMPOR_FACTUR'
 	#DESCRIPCION:	Para importar la facutacion de la regional seleccionada
 	#AUTOR:		jmita
 	#FECHA:		12-10-2011 10:22:05
	***********************************/

	elsif(p_transaccion='CB_IMPOR_FACTUR')then

		begin  
       
            -- Creamos la tabla temporal para 
             EXECUTE('CREATE TEMP TABLE tt_lectura("id_cliente" integer,        "periodo_lec" numeric,   "gestion_lec" numeric,      "tipo_lectura" numeric,      "fecha_factura" date,      "nro_factura" integer,
                                                   "cod_control" varchar,       "nro_autoriza" numeric,  "nro_orden" varchar,        "cod_alfanum" varchar,       "importe_total" numeric,   "fecha_vence" date,
                                                   "fecha_anterior" date,       "fecha_actual" date,     "lectura_anterior" numeric, "lectura_actual" numeric,    "consumo_cambio" numeric,  "consumo_peri" numeric,
                                                   "consumo_total" numeric,     "lectura_kw" numeric,    "consumo_val" numeric,      "conexion_val" numeric,      "reconex_val" numeric,     "importe_dev" numeric,
                                                   "credito_pagado" numeric,    "potencia_val" numeric,  "importe_cred_fis" numeric, "multi_kwh" numeric,         "fecha_proxmed" date,      "consumo_libre" integer,
                                                   "sw_debito_fiscal" varchar,  "cod_ubica" varchar,     "direccion" varchar,        "nombre_factura" varchar,    "nro_nit" numeric,         "nroserie_med" varchar,
                                                   "desc_categoria" varchar,    "id_ap" integer,         "importe_ap" numeric,       "id_aseo" integer,           "importe_aseo" numeric,    "id_vejez" integer,
													"importe_vejez" numeric,    "id_dignidad" integer,   "importe_dignidad" numeric)  ON COMMIT DROP;');  
                                                                      
                                                                  
            --Conexion a la base de datos con la cadena enviada  
 			/*
			SELECT P.periodo into v_periodo
           FROM dblink('hostaddr=10.10.0.11 port=5432 dbname=dbendesis user=db_link password=db_link','SELECT periodo from factur.tfv_parametro') AS P( "periodo" NUMERIC); 
           SELECT P.gestion into v_gestion
           FROM dblink('hostaddr=10.10.0.11 port=5432 dbname=dbendesis user=db_link password=db_link','SELECT gestion from factur.tfv_parametro') AS P( "gestion" NUMERIC);*/
     	  	  v_periodo=6;  
              v_gestion=2011;                                                                             
			   raise notice '%   %','periodo:'||v_periodo||'-gest:'||v_gestion, v_parametros.conexion; 
               
               
               v_consulta = 'insert into tt_lectura
                                 SELECT P.id_cliente,       P.periodo_lec,  P.gestion_lec,      P.tipo_lectura,   P.fecha_factura,  P.nro_factura,
                                        P.cod_control,      P.nro_autoriza, P.nro_orden,        P.cod_alfanum,    P.importe_total,  P.fecha_vence,
                                        P.fecha_anterior,   P.fecha_actual, P.lectura_anterior, P.lectura_actual, P.consumo_cambio, P.consumo_peri,
                                        P.consumo_total,    P.lectura_kw,   P.consumo_val,      P.conexion_val,   P.reconex_val,    P.importe_dev,
                                        P.credito_pagado,   P.potencia_val, P.importe_cred_fis, P.multi_kwh,      P.fecha_proxmed,  P.consumo_libre,
                                        P.sw_debito_fiscal, P.cod_ubica,    P.direccion,        P.nombre_factura, P.nro_nit,        P.nroserie_med, 
                                        P.desc_categoria,   P.id_ap,        P.importe_ap,       P.id_aseo,        P.importe_aseo,   P.id_vejez,
										P.importe_vejez,    P.id_dignidad,  P.importe_dignidad                 
                                 FROM dblink('''||v_parametros.conexion||''',
                                 ''select 
                                        ld.id_cliente ,      ld.periodo_lec,  ld.gestion_lec,      ld.tipo_lectura,   ld.fecha_factura,   ld.nro_factura,
                                        ld.cod_control,      ld.nro_autoriza, ld.nro_orden,        ld.cod_alfanum,    ld.importe_total,   ld.fecha_vence,
                                        ld.fecha_anterior,   ld.fecha_actual, ld.lectura_anterior, ld.lectura_actual, ld.consumo_cambio,  ld.consumo_peri,
                                        ld.consumo_total,    ld.lectura_kw,   ld.consumo_val,      ld.conexion_val,   ld.reconex_val,     ld.importe_dev,
                                        ld.credito_pagado,   ld.potencia_val, ld.importe_cred_fis, ld.multi_kwh,      ld.fecha_proxmed,   ld.consumo_libre,
                                        ld.sw_debito_fiscal, ld.cod_ubica,    ld.direccion,        ld.nombre_factura, ld.nro_nit,         ld.nroserie_med,
                                        ld.desc_categoria,   ld.id_ap,        ld.importe_ap,       ld.id_aseo,        ld.importe_aseo,    ld.id_vejez,
										ld.importe_vejez,    ld.id_dignidad,  ld.importe_dignidad
                                                      from factur.vfv_lectura_dblink ld 
                                                      where ld.periodo_lec='||v_periodo||' and ld.gestion_lec='||v_gestion||'
                                                       '') 
                                                      AS P( "id_cliente" bigint,"periodo_lec" numeric, "gestion_lec" numeric, "tipo_lectura" numeric, "fecha_factura" date, "nro_factura" integer,
                                                   "cod_control" varchar, "nro_autoriza" numeric, "nro_orden" varchar, "cod_alfanum" varchar, "importe_total" numeric, "fecha_vence" date,
                                                   "fecha_anterior" date, "fecha_actual" date, "lectura_anterior" numeric, "lectura_actual" numeric, "consumo_cambio" numeric, "consumo_peri" numeric,
                                                   "consumo_total" numeric, "lectura_kw" numeric, "consumo_val" numeric, "conexion_val" numeric, "reconex_val" numeric, "importe_dev" numeric,
                                                   "credito_pagado" numeric, "potencia_val" numeric, "importe_cred_fis" numeric, "multi_kwh" numeric, "fecha_proxmed" date, "consumo_libre" integer,
                                                   "sw_debito_fiscal" varchar, "cod_ubica" varchar, "direccion" varchar, "nombre_factura" varchar, "nro_nit" numeric, "nroserie_med" varchar, 
                                                   "desc_categoria" varchar,    "id_ap" integer,    "importe_ap" numeric,     "id_aseo" integer,  "importe_aseo" numeric,   "id_vejez" integer,
													"importe_vejez" numeric,    "id_dignidad" integer,  "importe_dignidad" numeric);';
--raise exception 'SALE: %',v_consulta;
execute(v_consulta);
                                                                                             
            /*execute('insert into tt_lectura
                                 SELECT P.id_cliente,       P.periodo_lec,  P.gestion_lec,      P.tipo_lectura,   P.fecha_factura,  P.nro_factura,
                                        P.cod_control,      P.nro_autoriza, P.nro_orden,        P.cod_alfanum,    P.importe_total,  P.fecha_vence,
                                        P.fecha_anterior,   P.fecha_actual, P.lectura_anterior, P.lectura_actual, P.consumo_cambio, P.consumo_peri,
                                        P.consumo_total,    P.lectura_kw,   P.consumo_val,      P.conexion_val,   P.reconex_val,    P.importe_dev,
                                        P.credito_pagado,   P.potencia_val, P.importe_cred_fis, P.multi_kwh,      P.fecha_proxmed,  P.consumo_libre,
                                        P.sw_debito_fiscal, P.cod_ubica,    P.direccion,        P.nombre_factura, P.nro_nit,        P.nroserie_med,    P.desc_categoria                    
                                 FROM dblink('''||v_parametros.conexion||''',
                                 ''select 
                                        c.id_cliente,       l.periodo_lec,  l.gestion_lec,      l.tipo_lectura,   f.fecha_factura,  f.nro_factura,
                                        f.cod_control,      d.nro_autoriza, coalesce(f.nro_orden,'''') as nro_orden,  coalesce(f.cod_alfanum,'''') as cod_alfanum,    co.importe_total,   l.fecha_vence,
                                        l.fecha_anterior,   l.fecha_actual, l.lectura_anterior, l.lectura_actual, l.consumo_cambio, l.consumo_peri,
                                        l.consumo_total,    l.lectura_kw,   l.consumo_val,      l.conexion_val,   l.reconex_val,    l.importe_dev,
                                        l.credito_pagado,   l.potencia_val, l.importe_total as importe_cred_fis,  l.multi_kwh,      l.fecha_proxmed,    coalesce(li.consumo_maximo,0) as consumo_libre,
                                        c.sw_debito_fiscal, l.cod_ubica,    c.direccion,        c.nombre_factura, c.nro_nit,        c.nroserie_med,     ca.desc_categoria
                                                      from factur.vfv_lectura_dblink ld 
                                                      where ld.periodo_fac='||v_periodo||' and co.gestion_fac='||v_gestion||''') 
                                                      AS P( "id_cliente" integer,"periodo_lec" numeric, "gestion_lec" numeric, "tipo_lectura" numeric, "fecha_factura" date, "nro_factura" integer,
                                                   "cod_control" varchar, "nro_autoriza" numeric, "nro_orden" varchar, "cod_alfanum" varchar, "importe_total" numeric, "fecha_vence" date,
                                                   "fecha_anterior" date, "fecha_actual" date, "lectura_anterior" numeric, "lectura_actual" numeric, "consumo_cambio" numeric, "consumo_peri" numeric,
                                                   "consumo_total" numeric, "lectura_kw" numeric, "consumo_val" numeric, "conexion_val" numeric, "reconex_val" numeric, "importe_dev" numeric,
                                                   "credito_pagado" numeric, "potencia_val" numeric, "importe_cred_fis" numeric, "multi_kwh" numeric, "fecha_proxmed" date, "consumo_libre" integer,
                                                   "sw_debito_fiscal" varchar, "cod_ubica" varchar, "direccion" varchar, "nombre_factura" varchar, "nro_nit" numeric, "nroserie_med" varchar, "desc_categoria" varchar);');  
                    select id_cliente into v_pru from  tt_lectura where id_cliente = 9520;
                    raise notice '%','id:'||v_pru; */
                    
                   ---- select id_cliente into v_pru from  tt_lectura where id_cliente = 9520;
                    --raise notice '%','como que null';
                    --raise notice '%','id:'||v_pru;  
                    
                    --select codigo into v_codigo_sis from cobra.tcb_sistema_dist where id_sistema_dist=v_parametros.id_sistema_dist;  
                    --select c.id_cliente into v_id_cliente_cob from cobra.tcb_cliente c where  c.id_cliente_dist=9520 and c.id_sistema_dist=v_parametros.id_sistema_dist;                                                     
                    --raise notice '%','id_cliente_cob:'||v_id_cliente_cob;   
                                                                              --raise exception'llegaaaa';
            --Recorremos la tabla para identificar los clientes que ya se importaron
            FOR v_registros IN(SELECT * FROM tt_lectura)Loop
            
            	select c.id_cliente into v_id_cliente_cob from cobra.tcb_cliente c where  c.id_cliente_dist=v_registros.id_cliente and c.id_sistema_dist=v_parametros.id_sistema_dist;
               IF NOT EXISTS(SELECT 1 FROM cobra.tcb_factura_cob WHERE id_cliente=v_id_cliente_cob and periodo=v_registros.periodo_lec and gestion=v_registros.gestion_lec)THEN
                  insert into cobra.tcb_factura_cob(
			                  			id_usuario_reg,   id_cliente,       periodo,          gestion,          estado_fac,     tipo_lectura,    fecha_factura,    nro_factura,
                                        cod_control,      nro_autorizacion, nro_orden,        cod_alfanum,    importe_total,   fecha_vence,
                                        fecha_ant,        fecha_act,        lectura_ant,      lectura_act,    consumo_cambio,  consumo_periodo,
                                        consumo_total,    lectura_kw,       consumo_val,      conexion_val,   reconex_val,     importe_dev,
                                        credito_pagado,   potencia_val,     importe_cred_fis, multi_kwh,      fecha_prox_med,  consumo_libre,
                                        sw_deb_fis,       cod_ubica,        direccion,        nombre_fac,     nit_fact,        nro_medidor,      desc_categoria
          	                  ) values(
			                   			p_id_usuario,				  v_id_cliente_cob,             v_registros.periodo_lec,  v_registros.gestion_lec,      'no_pagado',				  v_registros.tipo_lectura,   v_registros.fecha_factura,  v_registros.nro_factura,
                                        v_registros.cod_control,      v_registros.nro_autoriza, v_registros.nro_orden,        v_registros.cod_alfanum,    v_registros.importe_total,  v_registros.fecha_vence,
                                        v_registros.fecha_anterior,   v_registros.fecha_actual, v_registros.lectura_anterior, v_registros.lectura_actual, v_registros.consumo_cambio, v_registros.consumo_peri,
                                        v_registros.consumo_total,    v_registros.lectura_kw,   v_registros.consumo_val,      v_registros.conexion_val,   v_registros.reconex_val,    v_registros.importe_dev,
                                        v_registros.credito_pagado,   v_registros.potencia_val, v_registros.importe_cred_fis, v_registros.multi_kwh,      v_registros.fecha_proxmed,  v_registros.consumo_libre,
                                        v_registros.sw_debito_fiscal, v_registros.cod_ubica,    v_registros.direccion,        v_registros.nombre_factura, v_registros.nro_nit,        v_registros.nroserie_med,    v_registros.desc_categoria
                                                                                
			                  ); 
                  select max(id_factura_cob) into v_id_fac_cob from cobra.tcb_factura_cob; 
                    if (v_registros.importe_ap>0)THEN
                    insert into cobra.tcb_factura_cob_det (id_factura_cob,	id_tasa,			importe)
                    								VALUES(v_id_fac_cob,	v_registros.id_ap,	v_registros.importe_ap);
                    END if;
                    if (v_registros.importe_aseo>0)THEN
                    insert into cobra.tcb_factura_cob_det (id_factura_cob,	id_tasa,			importe)
                    								VALUES(v_id_fac_cob,	v_registros.id_aseo,	v_registros.importe_aseo);
                    END if;
                    if (v_registros.importe_vejez>0)THEN
                    insert into cobra.tcb_factura_cob_det (id_factura_cob,	id_descuento,			importe)
                    								VALUES(v_id_fac_cob,	v_registros.id_vejez,	v_registros.importe_vejez);
                    END if;
                    if (v_registros.importe_dignidad>0)THEN
                    insert into cobra.tcb_factura_cob_det (id_factura_cob,	id_descuento,			importe)
                    								VALUES(v_id_fac_cob,	v_registros.id_dignidad,	v_registros.importe_dignidad);
                    END if;     
                       
               END IF; 
            END LOOP;                                                                                                                                         			
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Facturación Importada'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist',v_parametros.id_sistema_dist::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end; 
        
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

/*EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
	*/			        
END;
$$;


--
-- TOC entry 703 (class 1255 OID 207158)
-- Dependencies: 3246 8
-- Name: f_tcb_sistema_dist_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_sistema_dist_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_sistema_dist_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_sistema_dist'
 AUTOR: 		 (fprudencio)
 FECHA:	        20-09-2011 10:22:05
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_sistema_dist_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_SISDIS_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 10:22:05
	***********************************/

	if(p_transaccion='CB_SISDIS_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						sisdis.id_sistema_dist,
						sisdis.codigo,
						sisdis.conexion,
						sisdis.nombre,
						sisdis.estado_reg,
						sisdis.id_usuario_reg,
						sisdis.fecha_reg,
						sisdis.id_usuario_mod,
						sisdis.fecha_mod, --::varchar,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_sistema_dist sisdis
						inner join segu.tusuario usu1 on usu1.id_usuario = sisdis.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = sisdis.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			raise notice '%',v_consulta;
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_SISDIS_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		20-09-2011 10:22:05
	***********************************/

	elsif(p_transaccion='CB_SISDIS_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_sistema_dist)
					    from cobra.tcb_sistema_dist sisdis
					    inner join segu.tusuario usu1 on usu1.id_usuario = sisdis.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = sisdis.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 704 (class 1255 OID 207159)
-- Dependencies: 3246 8
-- Name: f_tcb_sistema_dist_usuario_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_sistema_dist_usuario_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_sistema_dist_usuario_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'cobra.tcb_sistema_dist_usuario'
 AUTOR: 		 (fprudencio)
 FECHA:	        21-09-2011 10:41:58
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_sistema_dist_usuario	integer;
			    
BEGIN

    v_nombre_funcion = 'cobra.f_tcb_sistema_dist_usuario_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_USHAB_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		21-09-2011 10:41:58
	***********************************/

	if(p_transaccion='CB_USHAB_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into cobra.tcb_sistema_dist_usuario(
			estado_reg,
			id_usuario,
			id_sistema_dist,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.id_usuario,
			v_parametros.id_sistema_dist,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_sistema_dist_usuario into v_id_sistema_dist_usuario;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Usuarios Habilitados almacenado(a) con exito (id_sistema_dist_usuario'||v_id_sistema_dist_usuario||')'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist_usuario',v_id_sistema_dist_usuario::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'CB_USHAB_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		21-09-2011 10:41:58
	***********************************/

	elsif(p_transaccion='CB_USHAB_MOD')then

		begin
			--Sentencia de la modificacion
			update cobra.tcb_sistema_dist_usuario set
			id_usuario = v_parametros.id_usuario,
			id_sistema_dist = v_parametros.id_sistema_dist,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_sistema_dist_usuario=v_parametros.id_sistema_dist_usuario;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Usuarios Habilitados modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist_usuario',v_parametros.id_sistema_dist_usuario::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'CB_USHAB_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		21-09-2011 10:41:58
	***********************************/

	elsif(p_transaccion='CB_USHAB_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from cobra.tcb_sistema_dist_usuario
            where id_sistema_dist_usuario=v_parametros.id_sistema_dist_usuario;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Usuarios Habilitados eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_sistema_dist_usuario',v_parametros.id_sistema_dist_usuario::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 705 (class 1255 OID 207160)
-- Dependencies: 3246 8
-- Name: f_tcb_sistema_dist_usuario_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: cobra; Owner: -
--

CREATE FUNCTION f_tcb_sistema_dist_usuario_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Cobranza Online
 FUNCION: 		cobra.f_tcb_sistema_dist_usuario_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'cobra.tcb_sistema_dist_usuario'
 AUTOR: 		 (fprudencio)
 FECHA:	        21-09-2011 10:41:58
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'cobra.f_tcb_sistema_dist_usuario_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'CB_USHAB_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		21-09-2011 10:41:58
	***********************************/

	if(p_transaccion='CB_USHAB_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						ushab.id_sistema_dist_usuario,
						ushab.estado_reg,
						ushab.id_usuario,
                        usu3.cuenta ||'' - ''|| PERSON.nombre_completo2 as desc_usuario,
						ushab.id_sistema_dist,
                        sisdis.nombre as nombre_sisdis,
						ushab.id_usuario_reg,
						ushab.fecha_reg,
						ushab.id_usuario_mod,
						ushab.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from cobra.tcb_sistema_dist_usuario ushab
						inner join segu.tusuario usu1 on usu1.id_usuario = ushab.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ushab.id_usuario_mod
                        inner join segu.tusuario usu3 on usu3.id_usuario=ushab.id_usuario
                        inner join cobra.tcb_sistema_dist sisdis on sisdis.id_sistema_dist=ushab.id_sistema_dist 
                        INNER JOIN segu.vpersona PERSON on PERSON.id_persona = usu3.id_persona
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
            
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            raise notice '%',v_consulta;
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'CB_USHAB_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		21-09-2011 10:41:58
	***********************************/

	elsif(p_transaccion='CB_USHAB_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_sistema_dist_usuario)
					    from cobra.tcb_sistema_dist_usuario ushab
						inner join segu.tusuario usu1 on usu1.id_usuario = ushab.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ushab.id_usuario_mod
                        inner join segu.tusuario usu3 on usu3.id_usuario=ushab.id_usuario
                        inner join cobra.tcb_sistema_dist sisdis on sisdis.id_sistema_dist=ushab.id_sistema_dist 
                        INNER JOIN segu.vpersona PERSON on PERSON.id_persona = usu3.id_persona
				        where  ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
        
	/*********************************    
 	#TRANSACCION:  'CB_FACPER_SEL'
 	#DESCRIPCION:	Listado de registros
 	#AUTOR:		jmita	
 	#FECHA:		10-11-2011 10:41:58
	***********************************/

	elsif(p_transaccion='CB_FACPER_SEL')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:=' select fc.periodo, 
            					 fc.gestion, 
                                 count(fc.id_cliente) as cant_clientes, 
                                 sum(fc.importe_total) as importe_total
	 							from cobra.tcb_factura_cob fc 
								 inner join cobra.tcb_cliente c on fc.id_cliente=c.id_cliente 
						 where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:= v_consulta||' group by fc.periodo, fc.gestion ';
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            
			--raise notice '%',v_consulta;
			--Devuelve la respuesta
			return v_consulta;

		end;
		
        /*********************************    
 	#TRANSACCION:  'CB_FACPER_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		jmita	
 	#FECHA:		10-09-2011 10:41:58
	***********************************/

	elsif(p_transaccion='CB_FACPER_CONT')then

		begin
        	EXECUTE(' CREATE TEMP TABLE  tt_periodo (periodo numeric(2,0), gestion numeric(4,0),cant_clientes NUMERIC(18,2),importe_total numeric(18,2))ON COMMIT DROP;');
            EXECUTE('insert into tt_periodo select fc.periodo, fc.gestion, count(fc.id_cliente) as cant_clientes, sum(fc.importe_total) as importe_total
	 							from cobra.tcb_factura_cob fc 
								inner join cobra.tcb_cliente c on fc.id_cliente=c.id_cliente 
						 		where '||v_parametros.filtro||' group by fc.periodo, fc.gestion '||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero);
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count (*) from tt_periodo ';
			
			--Definicion de la respuesta		    
			--v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;						
	else
				     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


SET search_path = conta, pg_catalog;

--
-- TOC entry 706 (class 1255 OID 207162)
-- Dependencies: 3246 9
-- Name: ft_auxiliar_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: conta; Owner: -
--

CREATE FUNCTION ft_auxiliar_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		conta.ft_auxiliar_ime
 DESCRIPCIÓN:   modificaciones de auxiliars contables
 AUTOR: 		
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		02-02-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='conta.ft_auxiliar_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   CT_AUXILI_INS
 #DESCRIPCION:	Inserta auxiliars Contables
 #AUTOR:			
 #FECHA:		02-02-2011	
***********************************/
     if(par_transaccion='CT_AUXILI_INS')then

        
          BEGIN
              
               --insercion de nuevo parametro
               INSERT INTO conta.tauxiliar(codigo, nombre, estado_reg,fecha_reg)
               values(v_parametros.codigo,v_parametros.nombre,'activo',now()::date);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','auxiliar contable'||v_parametros.codigo||' insertada con exito ');
               v_resp = f_agrega_clave(v_resp,'id_periodo',v_id_funcion::varchar);
         END;
 /*******************************    
 #TRANSACCION:  CT_AUXILI_MOD
 #DESCRIPCION:	Modifica el auxiliar contable seleccionado
 #AUTOR:			
 #FECHA:		02-02-2011
***********************************/
     elsif(par_transaccion='CT_AUXILI_MOD')then

          
          BEGIN
               --modificacion de periodo
                update conta.tauxiliar
                set codigo=v_parametros.codigo,
                nombre=v_parametros.nombre
                where id_auxiliar=v_parametros.id_auxiliar;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','auxiliar contable modificado con exito '||v_parametros.codigo);
               v_resp = f_agrega_clave(v_resp,'id_auxiliar',v_parametros.id_auxiliar::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  CT_AUXILI_ELI
 #DESCRIPCION:	Inactiva el auxiliar contable selecionado
 #AUTOR:			
 #FECHA:		02-02-2011
***********************************/

    elsif(par_transaccion='CT_AUXILI_ELI')then
        BEGIN
        
         --inactivacion de la periodo
               delete from conta.tauxiliar
               where id_auxiliar=v_parametros.id_auxiliar;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','auxiliar contable eliminada con exito '||v_parametros.id_auxiliar);
               v_resp = f_agrega_clave(v_resp,'id_auxiliar',v_parametros.id_auxiliar::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 707 (class 1255 OID 207163)
-- Dependencies: 9 3246
-- Name: ft_auxiliar_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: conta; Owner: -
--

CREATE FUNCTION ft_auxiliar_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 parametro_conta: 		conta.ft_auxiliar_sel
 DESCRIPCIÓN:  listado de auxiliar contable
 AUTOR: 		
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		02-02-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='conta.ft_auxiliar_sel';


     if(par_transaccion='CT_AUXILI_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            AUXILI.id_auxiliar,
                            AUXILI.codigo,
                            AUXILI.nombre,
                            AUXILI.estado_reg,
                            AUXILI.fecha_reg
                            FROM CONTA.tauxiliar AUXILI
                            WHERE ';

               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='CT_AUXILI_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                            count(AUXILI.id_auxiliar)
                            FROM conta.tauxiliar AUXILI
                            WHERE  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 721 (class 1255 OID 207164)
-- Dependencies: 3246 9
-- Name: ft_cuenta_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: conta; Owner: -
--

CREATE FUNCTION ft_cuenta_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		conta.ft_cuenta_ime
 DESCRIPCIÓN:   modificaciones de cuentas contables
 AUTOR: 		KPLIAN
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		01-02-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='conta.ft_cuenta_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   CT_CUENTA_INS
 #DESCRIPCION:	Inserta Cuentas Contables
 #AUTOR:		KPLIAN	
 #FECHA:		01-02-2011	
***********************************/
     if(par_transaccion='CT_CUENTA_INS')then

        
          BEGIN
              
               --insercion de nuevo parametro
               INSERT INTO conta.tcuenta(codigo, nombre, estado_reg,fecha_reg)
               values(v_parametros.codigo,v_parametros.nombre,'activo',now()::date);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','Cuenta contable'||v_parametros.codigo||' insertada con exito ');
               v_resp = f_agrega_clave(v_resp,'id_periodo',v_id_funcion::varchar);
         END;
 /*******************************    
 #TRANSACCION:      CT_CUENTA_MOD
 #DESCRIPCION:	Modifica la cuenta contable seleccionada
 #AUTOR:		KPLIAN	
 #FECHA:		01-02-2011
***********************************/
     elsif(par_transaccion='CT_CUENTA_MOD')then

          
          BEGIN
               --modificacion de periodo
                update conta.tcuenta
                set codigo=v_parametros.codigo,
                nombre=v_parametros.nombre
                where id_cuenta=v_parametros.id_cuenta;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','Cuenta contable modificado con exito '||v_parametros.codigo);
               v_resp = f_agrega_clave(v_resp,'id_cuenta',v_parametros.id_cuenta::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  CT_CUENTA_ELI
 #DESCRIPCION:	Inactiva la cuenta contable selecionada
 #AUTOR:		KPLIAN	
 #FECHA:		01-02-2011
***********************************/

    elsif(par_transaccion='CT_CUENTA_ELI')then
        BEGIN
        
         --inactivacion de la periodo
               delete from conta.tcuenta
               where id_cuenta=v_parametros.id_cuenta;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Cuenta contable eliminada con exito '||v_parametros.id_cuenta);
               v_resp = f_agrega_clave(v_resp,'id_cuenta',v_parametros.id_cuenta::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 722 (class 1255 OID 207165)
-- Dependencies: 9 3246
-- Name: ft_cuenta_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: conta; Owner: -
--

CREATE FUNCTION ft_cuenta_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 parametro_conta: 		conta.ft_cuenta_sel
 DESCRIPCIÓN:  listado de cuenta contable
 AUTOR: 		
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		01-02-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='conta.ft_cuenta_sel';


     if(par_transaccion='CT_CUENTA_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            CUENTA.id_cuenta,
                            CUENTA.codigo,
                            CUENTA.nombre,
                            CUENTA.estado_reg,
                            CUENTA.fecha_reg
                            FROM CONTA.tcuenta CUENTA
                            WHERE ';

               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='CT_CUENTA_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                            count(CUENTA.id_cuenta)
                            FROM conta.tcuenta CUENTA
                            WHERE  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


SET search_path = gem, pg_catalog;

--
-- TOC entry 1849 (class 1255 OID 314587)
-- Dependencies: 42 3246
-- Name: f_localizacion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gem; Owner: -
--

CREATE FUNCTION f_localizacion_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		SISTEMA DE GESTION DE MANTENIMIENTO
 FUNCION: 		gem.f_localizacion_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gem.tlocalizacion'
 AUTOR: 		 (rac)
 FECHA:	        14-06-2012 03:48:41
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_localizacion	integer;
    
    v_codigo_largo  varchar;
			    
BEGIN

    v_nombre_funcion = 'gem.f_localizacion_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'GEM_loc_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		14-06-2012 03:48:41
	***********************************/

	if(p_transaccion='GEM_loc_INS')then
					
        begin
        /*
            --obtiene codigo recursivamente
            IF v_parametros.id_lugar_fk is null THEN
               v_codigo_largo = v_parametros.codigo;
            ELSE
            
             WITH RECURSIVE t(id,id_fk,cod,n) AS (
               SELECT l.id_localizacion,l.id_localizacion_fk, l.codigo,1 
               FROM gem.tlocalizacion l 
               WHERE l.id_localizacion = v_parametros.id_localizacion_fk
              UNION ALL
               SELECT l.id_localizacion,l.id_localizacion_fk, l.codigo , n+1
               FROM gem.tlocalizacion l, t
               WHERE l.id_localizacion = t.id_fk
            )
            SELECT textcat_all(a.cod||'.')
             into  
             v_codigo_largo
            FROM (SELECT  cod
                  FROM t 
                 order by n desc)  a;
                 
                 
               v_codigo_largo = v_codigo_largo||v_parametros.codigo;
            END IF;
            */
           
        	--Sentencia de la insercion
        	insert into gem.tlocalizacion(
			codigo,
			estado_reg,
			nombre,
			id_localizacion_fk,
			ubicacion,
			coordenadas,
			desc_ubicacion,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod,
            latitud,
            longitud
          	) values(
			v_parametros.codigo,
			'activo',
			v_parametros.nombre,
			v_parametros.id_localizacion_fk,
			v_parametros.ubicacion,
			v_parametros.coordenadas,
			v_parametros.desc_ubicacion,
			p_id_usuario,
			now(),
			null,
			null,
            v_parametros.latitud,
            v_parametros.longitud
			)RETURNING id_localizacion into v_id_localizacion;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Localizacion almacenado(a) con exito (id_localizacion'||v_id_localizacion||')'); 
            v_resp = f_agrega_clave(v_resp,'id_localizacion',v_id_localizacion::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'GEM_loc_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		14-06-2012 03:48:41
	***********************************/

	elsif(p_transaccion='GEM_loc_MOD')then

		begin
			--Sentencia de la modificacion
			update gem.tlocalizacion set
			codigo = v_parametros.codigo,
			nombre = v_parametros.nombre,
			id_localizacion = v_parametros.id_localizacion_fk,
			ubicacion = v_parametros.ubicacion,
			coordenadas = v_parametros.coordenadas,
			desc_ubicacion = v_parametros.desc_ubicacion,
            latitud=v_parametros.latitud,
            longitud=v_parametros.longitud,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_localizacion=v_parametros.id_localizacion;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Localizacion modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_localizacion',v_parametros.id_localizacion::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'GEM_loc_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		14-06-2012 03:48:41
	***********************************/

	elsif(p_transaccion='GEM_loc_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gem.tlocalizacion
            where id_localizacion=v_parametros.id_localizacion;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Localizacion eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_localizacion',v_parametros.id_localizacion::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 1850 (class 1255 OID 314588)
-- Dependencies: 3246 42
-- Name: f_localizacion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gem; Owner: -
--

CREATE FUNCTION f_localizacion_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		SISTEMA DE GESTION DE MANTENIMIENTO
 FUNCION: 		gem.f_localizacion_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gem.tlocalizacion'
 AUTOR: 		 (rac)
 FECHA:	        14-06-2012 03:48:41
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    
    v_where varchar;
    v_join varchar;
			    
BEGIN

	v_nombre_funcion = 'gem.f_localizacion_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'GEM_loc_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		14-06-2012 03:48:41
	***********************************/

	if(p_transaccion='GEM_loc_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						loc.id_localizacion,
						loc.codigo,
						loc.estado_reg,
						loc.nombre,
						loc.id_localizacion_fk,
						loc.ubicacion,
						loc.coordenadas,
						loc.desc_ubicacion,
						loc.id_usuario_reg,
						loc.fecha_reg,
						loc.id_usuario_mod,
						loc.fecha_mod,
                        loc.latitud,
                        loc.longitud,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gem.tlocalizacion loc
						inner join segu.tusuario usu1 on usu1.id_usuario = loc.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = loc.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;
        
      /*********************************    
 	#TRANSACCION:  'GEM_LOC_ARB_SEL'
 	#DESCRIPCION:	Consulta de datos en arbol para localizaciones
 	#AUTOR:		rac	
 	#FECHA:		29-08-2011 09:19:28
	***********************************/

	elseif(p_transaccion='GEM_LOC_ARB_SEL')then
     				
    	begin
        
              if(v_parametros.id_padre = '%') then
                v_where := ' loc.id_localizacion_fk is NULL';
                 v_join:= 'LEFT';      
                      
              else
                v_where := ' loc.id_localizacion_fk = '||v_parametros.id_padre;
                v_join := 'INNER';
              end if;
        
        
    		--Sentencia de la consulta
			v_consulta:='select
						loc.id_localizacion,
						loc.codigo,
						loc.estado_reg,
						loc.nombre,
						loc.id_localizacion_fk,
						loc.ubicacion,
						loc.coordenadas,
						loc.desc_ubicacion,
						loc.id_usuario_reg,
						loc.fecha_reg,
						loc.id_usuario_mod,
						loc.fecha_mod,
                        loc.latitud,
                        loc.longitud,
						usu1.cuenta as usr_reg,
						
                        case
                          when (loc.id_localizacion_fk is null )then
                               ''raiz''::varchar
                          ELSE
                              ''hijo''::varchar
                          END as tipo_nodo
                        from gem.tlocalizacion loc
						inner join segu.tusuario usu1 
                        on usu1.id_usuario = loc.id_usuario_reg
					    where  '||v_where|| '  
                        ORDER BY loc.id_localizacion';
			
			
			--Devuelve la respuesta
			return v_consulta;
						
		end;    

	/*********************************    
 	#TRANSACCION:  'GEM_loc_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		14-06-2012 03:48:41
	***********************************/

	elsif(p_transaccion='GEM_loc_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_localizacion)
					    from gem.tlocalizacion loc
					    inner join segu.tusuario usu1 on usu1.id_usuario = loc.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = loc.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


SET search_path = gen, pg_catalog;

--
-- TOC entry 723 (class 1255 OID 207166)
-- Dependencies: 11 3246
-- Name: f_obtener_datos_tabla_sel(integer, character varying, character varying); Type: FUNCTION; Schema: gen; Owner: -
--

CREATE FUNCTION f_obtener_datos_tabla_sel(p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
/*
Autor: RCM
Fecha: 19/11/201
Descripción: Función que devuelve los datos de las columnas y de la tabla para el generador
*/

DECLARE

	v_consulta    		varchar;
	v_rec  				record;
	v_nombre_funcion   	text;
    v_resp				varchar;
    v_sql				varchar;

BEGIN

    v_nombre_funcion:='gen.f_obtener_datos_tabla_sel';

    if p_transaccion = 'GEN_COLUMN_SEL' then

    	begin
        	--1. Creación de la tabla temporal para almacenar todos los datos de la columna
            v_sql = 'create temp table tt_tabla_metadatos(id integer,
             												columna varchar,
                                                            descripcion varchar,
                                                            tipo_dato varchar,
                                                            longitud text,
                                                            nulo varchar,
                                                            checks varchar,
                                                            valor_defecto varchar,
                                                            grid_ancho integer,
                                                            grid_mostrar varchar,
                                                            form_ancho_porcen integer,
                                                            orden smallint,
                                                            grupo smallint

            ) on commit drop;';
            
            execute(v_sql);
            
            v_sql = 'create temp table tt_constraints(id integer,
            											nombre varchar
            ) on commit drop';
            execute(v_sql);
                        
            --2. Obtención de las columnas y sus metadatos
            v_sql = 'insert into tt_tabla_metadatos(
            		columna, descripcion, tipo_dato, checks, nulo, longitud,
                    valor_defecto, grid_ancho, grid_mostrar, form_ancho_porcen,
                    orden, grupo
            		)
                    SELECT DISTINCT
                    a.attname as column_name,
                    pg_catalog.obj_description(c.oid) as descripcion,
                    t.typname as tipo_dato,
                    CASE
                    WHEN cc.contype=''p'' THEN ''PK''
                    WHEN cc.contype=''u'' THEN ''UQ''
                    WHEN cc.contype=''f'' THEN ''FK''
                    ELSE '''' END AS cheks,
                    CASE WHEN a.attnotnull=false THEN ''si'' ELSE ''no'' END AS  nulo,
                    CASE WHEN a.attlen=''-1'' THEN (a.atttypmod - 4) ELSE a.attlen END as  longitud,
                    d.adsrc as valor_defecto,
                    100, ''si'', 80, null::smallint, 1::smallint
                    FROM pg_catalog.pg_attribute a
                    LEFT JOIN pg_catalog.pg_type t ON t.oid = a.atttypid
                    LEFT JOIN pg_catalog.pg_class c ON c.oid = a.attrelid
                    LEFT JOIN pg_catalog.pg_constraint cc ON cc.conrelid = c.oid AND cc.conkey[1] = a.attnum
                    LEFT JOIN pg_catalog.pg_attrdef d ON d.adrelid = c.oid AND a.attnum = d.adnum
                    WHERE c.relname = ''' || p_tabla || '''
                    AND a.attnum > 0
                    AND t.oid = a.atttypid
                    AND NOT a.attisdropped';

            --raise exception '%',v_sql;
            execute(v_sql);
            
            --5. Consulta de la tabla resultado
            for v_rec in execute('select distinct columna, descripcion, tipo_dato,
            					longitud, nulo, checks, valor_defecto,
                                grid_ancho, grid_mostrar, form_ancho_porcen,
                                orden, grupo
                                from tt_tabla_metadatos') loop
            	return next v_rec;
            end loop;
            
            --6. Respuesta
            return;
 
		end;

     else
     
         raise exception 'Transaccion inexistente';
         
     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 689 (class 1255 OID 207167)
-- Dependencies: 3246 11
-- Name: ft_columna_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gen; Owner: -
--

CREATE FUNCTION ft_columna_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

    v_nro_requerimiento    	integer;
    v_parametros           	record;
    v_id_requerimiento     	integer;
    v_resp		            varchar;
    v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_columna			integer;


/*

 id_proyecto
 denominacion 
 descripcion
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='gen.ft_columna_ime';
     v_parametros:=f_get_record(p_tabla);

     if(p_transaccion='GEN_COLUMN_INS')then

          BEGIN
               
               insert into gen.tcolumna(
		 		nombre,
                 descripcion,
                 id_tabla,
                 id_usuario_reg,
                 id_usuario_mod,
                 fecha_reg,
                 fecha_mod,
                 estado_reg,
                 etiqueta,
                 guardar
               ) values(
                v_parametros.nombre,
                v_parametros.descripcion,
                v_parametros.id_tabla,
                v_parametros.id_usuario_reg,
                NULL,
                now(),
                NULL,
                'activo',
                v_parametros.etiqueta,
                v_parametros.guardar
               )RETURNING id_columna into v_id_columna;
               
		v_resp = f_agrega_clave(v_resp,'mensaje','Columna almacenada con exito (id_columna'||v_id_columna||')'); 
               v_resp = f_agrega_clave(v_resp,'id_columna',v_id_columna::varchar);

               return v_resp;

         END;

     elsif(p_transaccion='GEN_COLUMN_MOD')then

          BEGIN

               update gen.tcolumna set
               nombre=v_parametros.nombre,
               descripcion=v_parametros.descripcion,
               id_tabla=v_parametros.id_tabla,
               id_usuario_mod=v_parametros.id_usuario_mod,
               fecha_mod=now(),
               etiqueta=v_parametros.etiqueta,
               guardar=v_parametros.guardar,
               longitud=v_parametros.longitud,
               grid_ancho=v_parametros.grid_ancho,
               grid_mostrar=v_parametros.grid_mostrar,
               form_ancho_porcen=v_parametros.form_ancho_porcen,
               orden=v_parametros.orden,
               grupo=v_parametros.grupo
               where id_columna=v_parametros.id_columna;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Columna modificada'); 
               v_resp = f_agrega_clave(v_resp,'id_columna',v_parametros.id_columna::varchar);
               
               return v_resp;
          END;

    elsif(p_transaccion='GEN_COLUMN_ELI')then

          BEGIN

               delete from gen.tcolumna
               where id_columna=v_parametros.id_columna;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Columna eliminada'); 
               v_resp = f_agrega_clave(v_resp,'id_columna',v_parametros.id_columna::varchar);
              
               return v_resp;
         END;
         
     else
     
         raise exception 'Transacción inexistente: %',p_transaccion;

     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
        
END;
$$;


--
-- TOC entry 737 (class 1255 OID 207168)
-- Dependencies: 3246 11
-- Name: ft_columna_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gen; Owner: -
--

CREATE FUNCTION ft_columna_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*
Autor: RCM
Fecha: 30/11/2010
Descripción: Función que devuelve conjuntos de datos
*/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
    v_resp				varchar;

BEGIN

    v_parametros:=f_get_record(p_tabla);
    v_nombre_funcion:='gen.ft_columna_sel';

    if p_transaccion = 'GEN_COLUMN_SEL' then

    	begin
        	v_consulta:='select
            			id_columna, nombre, descripcion,
            			id_tabla, id_usuario_reg, id_usuario_mod, fecha_reg,
            			fecha_mod, estado_reg, etiqueta,guardar,
                        tipo_dato, longitud, nulo, checks, valor_defecto,
                        grid_ancho, grid_mostrar, form_ancho_porcen, orden,
                        grupo
            			from gen.tcolumna
                        where ';
            v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            raise notice '%',v_consulta;
            return v_consulta;
		end;

    elsif p_transaccion = 'GEN_COLUMN_CONT' then

        begin
        	v_consulta:='select count(id_columna)
            			from gen.tcolumna
                        where ';
            v_consulta:=v_consulta||v_parametros.filtro;
            return v_consulta;
        end;

     elsif p_transaccion = 'GEN_DATCOL_SEL' then

    	begin
        	v_consulta:='
SELECT (col.table_schema)::character varying AS esquema,
    (col.table_name)::character varying AS tabla, (col.column_name)::character
    varying AS columna, (col.ordinal_position)::integer AS posicion,
    (col.column_default)::character varying AS defecto,
    (col.is_nullable)::character varying AS blanco, (col.data_type)::character
    varying AS tipo, CASE WHEN ((col.data_type)::text =
    ''character varying''::text) THEN (col.character_maximum_length)::integer
    WHEN ((col.data_type)::text = ''numeric''::text) THEN
    (col.numeric_precision)::integer ELSE 0 END AS length, CASE WHEN
    ((col.data_type)::text = ''numeric''::text) THEN (col.numeric_scale)::integer
    ELSE 0 END AS "precision", (cons.conname)::character varying AS
    nombre_constraint, (cons.consrc)::character varying AS definicion_constraint,
    col1.guardar,col1.etiqueta
FROM information_schema.columns col
INNER JOIN gen.tcolumna col1
    on(col1.nombre=col.column_name)
LEFT JOIN information_schema.constraint_column_usage colcon ON
    col.table_schema::text = colcon.table_schema::text AND
    col.table_name::text = colcon.table_name::text AND
    col.column_name::text = colcon.column_name::text
LEFT JOIN pg_constraint cons ON
    cons.conname = colcon.constraint_name::name AND
    cons.contype = ''c''::"char"
LEFT JOIN pg_class c ON
cons.conrelid =c.oid AND c.relname = col.table_name::name
WHERE '; --col.table_schema::text = 'rhum'::text AND
    --col.table_name::text = 'tcolumna'::text AND id_tabla=21;
      
            v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            return v_consulta;
		end;

     elsif p_transaccion = 'GEN_DATCOL_CONT' then

        begin
        	v_consulta:='select count(col1.relname)
            		from gen.vcolumna col1
			left join gen.tcolumna col2
			on col2.nombre = col1.relname
                        where ';
            v_consulta:=v_consulta||v_parametros.filtro;
            return v_consulta;
        end;

     else
     
         raise exception 'Transaccion inexistente';
         
     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 738 (class 1255 OID 207169)
-- Dependencies: 3246 11
-- Name: ft_esquema_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gen; Owner: -
--

CREATE FUNCTION ft_esquema_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_esquema_sel
 DESCRIPCION:   lista las interfaces en el generador
 AUTOR: 	jrr	
 FECHA:	        25/01/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/


DECLARE


v_consulta   		varchar;
v_parametros  		record;
v_nombre_funcion  	text;
v_mensaje_error    	text;
v_resp              varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_esquema_sel';
     
/*******************************    
 #TRANSACCION:  GEN_ESQUEM_SEL
 #DESCRIPCION:	Listado de esquemas en los metadatos para el combo del generador
 #AUTOR:		Jaime Rivera Rojas	
 #FECHA:		25/01/11	
***********************************/

     if(par_transaccion='GEN_ESQUEM_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT n.oid::integer,
                                n.nspname::varchar AS name,
                                u.usename::varchar
                            FROM pg_namespace n
                            LEFT OUTER JOIN pg_user u ON n.nspowner = u.usesysid
                            LEFT OUTER JOIN pg_description ds ON n.oid = ds.objoid
                            where n.nspname not like ''pg_%'' and
                                n.nspname not like ''information_schema'' and ';
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by n.nspname limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

/*******************************
 #TRANSACCION:  GEN_ESQUEM_CONT
 #DESCRIPCION:	Listado de esquemas en los metadatos para el combo del generador
 #AUTOR:		Jaime Rivera Rojas	
 #FECHA:		25/01/11	
***********************************/
     elsif(par_transaccion='GEN_ESQUEM_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(n.oid)
                            FROM pg_namespace n
                            LEFT OUTER JOIN pg_user u ON n.nspowner = u.usesysid
                            LEFT OUTER JOIN pg_description ds ON n.oid = ds.objoid
                            where n.nspname not like ''pg_%'' and
                                n.nspname not like ''information_schema'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;      
END;
$$;


--
-- TOC entry 1847 (class 1255 OID 207170)
-- Dependencies: 3246 11
-- Name: ft_tabla_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gen; Owner: -
--

CREATE FUNCTION ft_tabla_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

    v_nro_requerimiento    	integer;
    v_parametros           	record;
    v_id_requerimiento     	integer;
    v_resp		            varchar;
    v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_tabla			integer;
    v_registros         record;
    v_tabla_antigua     varchar;
    v_esquema           varchar;


/*

 id_proyecto
 denominacion 
 descripcion
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='gen.ft_tabla_ime';
     v_parametros:=f_get_record(p_tabla);

     if(p_transaccion='GEN_TABLA_INS')then

          BEGIN
                select lower(s.codigo)
                into v_esquema
                from segu.tsubsistema s
                where id_subsistema=v_parametros.id_subsistema;
                
               insert into gen.ttabla(
		          esquema,
		          nombre,
                 titulo,
                 id_subsistema,
                 id_usuario_reg,
                 id_usuario_mod,
                 fecha_reg,
                 fecha_mod,
                 estado_reg,
                 alias,
                 --reemplazar,
                 --menu,
                 direccion,
                 cant_grupos
               ) values(
                v_esquema,
                v_parametros.nombre,
                v_parametros.titulo,
                v_parametros.id_subsistema,
                p_id_usuario,
                NULL,
                now(),
                NULL,
                'activo',
                v_parametros.alias,
                --v_parametros.reemplazar,
                --v_parametros.menu,
                v_parametros.direccion,
                v_parametros.cant_grupos
               )RETURNING id_tabla into v_id_tabla;
                --raise exception 'llega%',v_parametros.nombre;
              
          		--Registro de las colummas de la tabla
                insert into gen.tcolumna(
                id_usuario_reg,
                 estado_reg, 
                 nombre, 
                 descripcion,  
                 tipo_dato, 
                 longitud, 
                 nulo,
                id_tabla, 
                etiqueta, 
                guardar, checks, valor_defecto, grid_ancho, grid_mostrar,
                form_ancho_porcen, orden, grupo
                )
                select
                p_id_usuario, 'activo', columna, descripcion, tipo_dato, longitud, nulo,
                v_id_tabla, columna, 'si', checks, valor_defecto,grid_ancho, grid_mostrar,
                form_ancho_porcen, orden, grupo
                from gen.f_obtener_datos_tabla_sel(p_id_usuario,v_parametros.nombre,'GEN_COLUMN_SEL') as (
                columna varchar,descripcion varchar,tipo_dato varchar,longitud text,
                nulo varchar,checks varchar, valor_defecto varchar, grid_ancho INTEGER,
                grid_mostrar varchar, form_ancho_porcen integer, orden smallint, grupo smallint);
                --
               
				v_resp = f_agrega_clave(v_resp,'mensaje','Tabla almacenada con exito (id_tabla'||v_id_tabla||')'); 
          		v_resp = f_agrega_clave(v_resp,'id_tabla',v_id_tabla::varchar);

               return v_resp;

         END;

     elsif(p_transaccion='GEN_TABLA_MOD')then

          BEGIN

              select nombre
              into v_tabla_antigua
              from gen.ttabla
              where id_tabla=v_parametros.id_tabla;
              select lower(s.codigo)
                into v_esquema
                from segu.tsubsistema s
                where id_subsistema=v_parametros.id_subsistema;
              if(v_tabla_antigua!=v_parametros.nombre)then
                delete from gen.tcolumna
                where id_tabla=v_parametros.id_tabla;
                
                --Registro de las colummas de la tabla
                insert into gen.tcolumna(
                id_usuario_reg, estado_reg, nombre, descripcion,  tipo_dato, longitud, nulo,
                id_tabla, etiqueta, guardar
                )
                select
                p_id_usuario, 'activo', columna, descripcion, tipo_dato, longitud, nulo,
                v_parametros.id_tabla, columna, 'si'
                from gen.f_obtener_datos_tabla_sel(p_id_usuario,v_parametros.nombre,'GEN_COLUMN_SEL') as (
                id integer,columna varchar,descripcion varchar,tipo_dato varchar,longitud integer,nulo varchar,checks varchar);
                --
              
              end if;
              

               update gen.ttabla set
               esquema=v_esquema,
               nombre=v_parametros.nombre,
               titulo=v_parametros.titulo,
               id_subsistema=v_parametros.id_subsistema,
               id_usuario_mod=p_id_usuario,
               fecha_mod=now(),
               alias = v_parametros.alias,
              -- reemplazar = v_parametros.reemplazar,
              -- menu = v_parametros.menu,
               direccion=v_parametros.direccion,
               cant_grupos=v_parametros.cant_grupos
               where id_tabla=v_parametros.id_tabla;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Tabla modificada'); 
               v_resp = f_agrega_clave(v_resp,'id_tabla',v_parametros.id_tabla::varchar);
               
               return v_resp;
          END;

    elsif(p_transaccion='GEN_TABLA_ELI')then

          BEGIN
                delete from gen.tcolumna
               where id_tabla=v_parametros.id_tabla;
               
               delete from gen.ttabla
               where id_tabla=v_parametros.id_tabla;

               v_resp = f_agrega_clave(v_resp,'mensaje','Tabla eliminada'); 
               v_resp = f_agrega_clave(v_resp,'id_tabla',v_parametros.id_tabla::varchar);
              
               return v_resp;
         END;
         
     else
     
         raise exception 'Transacción inexistente: %',p_transaccion;

     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
        
END;
$$;


--
-- TOC entry 759 (class 1255 OID 207171)
-- Dependencies: 11 3246
-- Name: ft_tabla_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gen; Owner: -
--

CREATE FUNCTION ft_tabla_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*
Autor: RCM
Fecha: 30/11/2010
Descripción: Función que devuelve conjuntos de datos
*/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
    v_resp				varchar;

BEGIN

    v_parametros:=f_get_record(p_tabla);
    v_nombre_funcion:='gen.ft_tabla_sel';

    if p_transaccion = 'GEN_TABLA_SEL' then

    	begin
        	v_consulta:='select
            			tabla.id_tabla, tabla.esquema, tabla.nombre, tabla.titulo,
            			tabla.id_subsistema, tabla.id_usuario_reg, tabla.id_usuario_mod,
            			tabla.fecha_reg,tabla.fecha_mod, tabla.estado_reg,
            			subsis.nombre as desc_subsistema, subsis.prefijo, tabla.alias,
            			tabla.reemplazar, tabla.menu,tabla.direccion,subsis.nombre_carpeta,
                        (select nombre from gen.tcolumna where id_tabla = tabla.id_tabla and checks = ''PK'' LIMIT 1) as llave_primaria,
                        cant_grupos
            			from gen.ttabla tabla
            			inner join segu.tsubsistema subsis
            			on subsis.id_subsistema = tabla.id_subsistema
                        where  ';
            v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            return v_consulta;
		end;

    elsif p_transaccion = 'GEN_TABLA_CONT' then

        begin
        	v_consulta:='select count(id_tabla)
            			from gen.ttabla tabla
            			inner join segu.tsubsistema subsis
            			on subsis.id_subsistema = tabla.id_subsistema
                        where ';
            v_consulta:=v_consulta||v_parametros.filtro;
            return v_consulta;
        end;

     elsif p_transaccion = 'GEN_TABLACOM_SEL' then

        begin
        	v_consulta:='SELECT n.oid::integer as oid_esquema,
                                n.nspname::varchar AS nombre_esquema,
                                c.oid::integer as oid_tabla ,
                                c.relname::varchar as nombre

                        FROM pg_namespace n
                        INNER JOIN pg_class c ON c.relnamespace = n.oid
                        where n.nspname not like ''pg_%'' and
                            n.nspname not like ''information_schema'' and c.relkind=''r'' and ';
            v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:=v_consulta||' order by c.relname limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            return v_consulta;
        end;
     elsif p_transaccion = 'GEN_TABLACOM_CONT' then

        begin
        	v_consulta:='select count(c.oid)
            			FROM pg_namespace n
                        INNER JOIN pg_class c ON c.relnamespace = n.oid
                        where n.nspname not like ''pg_%'' and
                            n.nspname not like ''information_schema'' and c.relkind=''r'' and ';
            v_consulta:=v_consulta||v_parametros.filtro;
            return v_consulta;
        end;

     else
     
         raise exception 'Transaccion inexistente';
         
     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


SET search_path = gev, pg_catalog;

--
-- TOC entry 760 (class 1255 OID 207172)
-- Dependencies: 12 3246
-- Name: f_rpt_prueba(numeric, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_rpt_prueba(actid numeric, fechaini timestamp without time zone, fechafin timestamp without time zone) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
  pv_rec RECORD;
BEGIN

	for pv_rec in select afr.latitud,afr.longitud,afr.fecha_satelite from gev.tgv_activo_fijo_rastreo afr where afr.id_activo_fijo = actId and afr.fecha_satelite BETWEEN fechaini and fechafin loop
      return next pv_rec;
  	end loop;
  
 	
END;
$$;


--
-- TOC entry 769 (class 1255 OID 207173)
-- Dependencies: 12 3246
-- Name: f_tgv_activo_datos_tec_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_activo_datos_tec_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_activo_datos_tec_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_activo_datos_tec'
 AUTOR: 		 (rcm)
 FECHA:	        02-02-2012 22:47:06
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_activo_datos_tec	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_activo_datos_tec_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_VEHIC_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 22:47:06
	***********************************/

	if(p_transaccion='tgv_VEHIC_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_activo_datos_tec(
			rend_litro_km,
			fecha_ult_km,
			estado_reg,
			id_activo_fijo,
			chasis,
			num_motor,
			ult_kilometraje,
			placa,
			cilindrada_cc,
			modem_id,
			soat,
			id_modelo,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.rend_litro_km,
			v_parametros.fecha_ult_km,
			'activo',
			v_parametros.id_activo_fijo,
			v_parametros.chasis,
			v_parametros.num_motor,
			v_parametros.ult_kilometraje,
			v_parametros.placa,
			v_parametros.cilindrada_cc,
			v_parametros.modem_id,
			v_parametros.soat,
			v_parametros.id_modelo,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_activo_datos_tec into v_id_activo_datos_tec;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Vehículos almacenado(a) con exito (id_activo_datos_tec'||v_id_activo_datos_tec||')'); 
            v_resp = f_agrega_clave(v_resp,'id_activo_datos_tec',v_id_activo_datos_tec::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_VEHIC_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 22:47:06
	***********************************/

	elsif(p_transaccion='tgv_VEHIC_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_activo_datos_tec set
			rend_litro_km = v_parametros.rend_litro_km,
			fecha_ult_km = v_parametros.fecha_ult_km,
			id_activo_fijo = v_parametros.id_activo_fijo,
			chasis = v_parametros.chasis,
			num_motor = v_parametros.num_motor,
			ult_kilometraje = v_parametros.ult_kilometraje,
			placa = v_parametros.placa,
			cilindrada_cc = v_parametros.cilindrada_cc,
			modem_id = v_parametros.modem_id,
			soat = v_parametros.soat,
			id_modelo = v_parametros.id_modelo,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_activo_datos_tec=v_parametros.id_activo_datos_tec;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Vehículos modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_activo_datos_tec',v_parametros.id_activo_datos_tec::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_VEHIC_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 22:47:06
	***********************************/

	elsif(p_transaccion='tgv_VEHIC_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_activo_datos_tec
            where id_activo_datos_tec=v_parametros.id_activo_datos_tec;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Vehículos eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_activo_datos_tec',v_parametros.id_activo_datos_tec::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 770 (class 1255 OID 207174)
-- Dependencies: 3246 12
-- Name: f_tgv_activo_datos_tec_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_activo_datos_tec_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_activo_datos_tec_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_activo_datos_tec'
 AUTOR: 		 (rcm)
 FECHA:	        02-02-2012 22:47:06
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_activo_datos_tec_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_VEHIC_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 22:47:06
	***********************************/

	if(p_transaccion='tgv_VEHIC_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						vehic.id_activo_datos_tec,
						vehic.rend_litro_km,
						vehic.fecha_ult_km,
						vehic.estado_reg,
						vehic.id_activo_fijo,
						vehic.chasis,
						vehic.num_motor,
						vehic.ult_kilometraje,
						vehic.placa,
						vehic.cilindrada_cc,
						vehic.modem_id,
						vehic.soat,
						vehic.id_modelo,
						vehic.id_usuario_reg,
						vehic.fecha_reg,
						vehic.id_usuario_mod,
						vehic.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        (actif.codigo || '' - '' || actif.descripcion)::varchar as desc_activo_fijo	,
                        model.modelo,
                        marca.marca,
                        marca.id_marca
						from gev.tgv_activo_datos_tec vehic
                        inner join actif.taf_activo_fijo actif on actif.id_activo_fijo = vehic.id_activo_fijo
                        inner join gev.tgv_modelo model on model.id_modelo = vehic.id_modelo
                        inner join gev.tgv_marca marca on marca.id_marca = model.id_marca
						inner join segu.tusuario usu1 on usu1.id_usuario = vehic.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = vehic.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_VEHIC_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 22:47:06
	***********************************/

	elsif(p_transaccion='tgv_VEHIC_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_activo_datos_tec)
					    from gev.tgv_activo_datos_tec vehic
                        inner join gev.tgv_modelo model on model.id_modelo = vehic.id_modelo
                        inner join gev.tgv_marca marca on marca.id_marca = model.id_marca
                        inner join actif.taf_activo_fijo actif on actif.id_activo_fijo = vehic.id_activo_fijo
					    inner join segu.tusuario usu1 on usu1.id_usuario = vehic.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = vehic.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 771 (class 1255 OID 207175)
-- Dependencies: 12 3246
-- Name: f_tgv_activo_fijo_rastreo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_activo_fijo_rastreo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_activo_fijo_rastreo_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_activo_fijo_rastreo'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 15:47:13
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_activo_fijo_rastreo	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_activo_fijo_rastreo_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_AFR_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 15:47:13
	***********************************/

	if(p_transaccion='tgv_AFR_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_activo_fijo_rastreo(
			id_empleado,
			estado_reg,
			fecha_servidor,
			aux2,
			fecha_satelite,
			curso,
			fecha_hora,
			aux1,
			odometro,
			mensaje,
			hora_gps,
			velocidad,
			advisories,
			longitud,
			id_activo_fijo,
			dia,
			aux3,
			punto_cercano,
			altitud,
			ciudad,
			numero_actualizado,
			estado,
			aux4,
			latitud,
			events,
			mes,
			anio,
			calle,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_empleado,
			'activo',
			v_parametros.fecha_servidor,
			v_parametros.aux2,
			v_parametros.fecha_satelite,
			v_parametros.curso,
			v_parametros.fecha_hora,
			v_parametros.aux1,
			v_parametros.odometro,
			v_parametros.mensaje,
			v_parametros.hora_gps,
			v_parametros.velocidad,
			v_parametros.advisories,
			v_parametros.longitud,
			v_parametros.id_activo_fijo,
			v_parametros.dia,
			v_parametros.aux3,
			v_parametros.punto_cercano,
			v_parametros.altitud,
			v_parametros.ciudad,
			v_parametros.numero_actualizado,
			v_parametros.estado,
			v_parametros.aux4,
			v_parametros.latitud,
			v_parametros.events,
			v_parametros.mes,
			v_parametros.anio,
			v_parametros.calle,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_activo_fijo_rastreo into v_id_activo_fijo_rastreo;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Rastreo almacenado(a) con exito (id_activo_fijo_rastreo'||v_id_activo_fijo_rastreo||')'); 
            v_resp = f_agrega_clave(v_resp,'id_activo_fijo_rastreo',v_id_activo_fijo_rastreo::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_AFR_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 15:47:13
	***********************************/

	elsif(p_transaccion='tgv_AFR_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_activo_fijo_rastreo set
			id_empleado = v_parametros.id_empleado,
			fecha_servidor = v_parametros.fecha_servidor,
			aux2 = v_parametros.aux2,
			fecha_satelite = v_parametros.fecha_satelite,
			curso = v_parametros.curso,
			fecha_hora = v_parametros.fecha_hora,
			aux1 = v_parametros.aux1,
			odometro = v_parametros.odometro,
			mensaje = v_parametros.mensaje,
			hora_gps = v_parametros.hora_gps,
			velocidad = v_parametros.velocidad,
			advisories = v_parametros.advisories,
			longitud = v_parametros.longitud,
			id_activo_fijo = v_parametros.id_activo_fijo,
			dia = v_parametros.dia,
			aux3 = v_parametros.aux3,
			punto_cercano = v_parametros.punto_cercano,
			altitud = v_parametros.altitud,
			ciudad = v_parametros.ciudad,
			numero_actualizado = v_parametros.numero_actualizado,
			estado = v_parametros.estado,
			aux4 = v_parametros.aux4,
			latitud = v_parametros.latitud,
			events = v_parametros.events,
			mes = v_parametros.mes,
			anio = v_parametros.anio,
			calle = v_parametros.calle,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_activo_fijo_rastreo=v_parametros.id_activo_fijo_rastreo;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Rastreo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_activo_fijo_rastreo',v_parametros.id_activo_fijo_rastreo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_AFR_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 15:47:13
	***********************************/

	elsif(p_transaccion='tgv_AFR_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_activo_fijo_rastreo
            where id_activo_fijo_rastreo=v_parametros.id_activo_fijo_rastreo;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Rastreo eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_activo_fijo_rastreo',v_parametros.id_activo_fijo_rastreo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 772 (class 1255 OID 207178)
-- Dependencies: 12 3246
-- Name: f_tgv_activo_fijo_rastreo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_activo_fijo_rastreo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_activo_fijo_rastreo_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_activo_fijo_rastreo'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 15:47:13
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_activo_fijo_rastreo_sel';
    v_parametros = f_get_record(p_tabla);
    
    /*********************************    
 	#TRANSACCION:  'TGV_AFRDET_SEL'
 	#DESCRIPCION:	Consulta el total de los datos de la posicion del vehiculos
                    para mostrar en mapa  (no tiene COUNT ni paginacion)
 	#AUTOR:		RAC	
 	#FECHA:		03-02-2012 15:47:13
    ***********************************/

	if(p_transaccion='TGV_AFRDET_SEL')then
     				
    	begin
    		--Sentencia de la consulta
            IF (v_parametros.fecha_fin is NULL or v_parametros.fecha_fin is NULL) then
	            raise exception 'los datos de fecha no pueden ser nulos';
            end if;
            
			v_consulta:='   select 
						afr.id_activo_fijo_rastreo,
                        afr.id_funcionario,
						afr.fecha_satelite,
						afr.curso,
                        afr.velocidad,
						afr.longitud,
						afr.id_activo_fijo,
                        afr.punto_cercano,
						afr.altitud,
						afr.latitud,
                        f.desc_funcionario1
                        from gev.tgv_activo_fijo_rastreo afr
                        left join rhum.vfuncionario f 
                        on afr.id_funcionario = f.id_funcionario
						where  id_activo_fijo='||v_parametros.id_activo_fijo ||'
                          and fecha_satelite::date <=  '''||v_parametros.fecha_fin||''' 
                          and fecha_satelite::date >= '''||v_parametros.fecha_ini||''' 
                      
                        order by afr.fecha_satelite DESC';
                        
                         

			--Devuelve la respuesta
            
            raise notice '%',v_consulta;
			return v_consulta;
						
		end;
    

	/*********************************    
 	#TRANSACCION:  'tgv_AFR_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 15:47:13
    ***********************************/

	elseif(p_transaccion='tgv_AFR_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						afr.id_activo_fijo_rastreo,
						afr.id_empleado,
						afr.estado_reg,
						afr.fecha_servidor,
						afr.aux2,
						afr.fecha_satelite,
						afr.curso,
						afr.fecha_hora,
						afr.aux1,
						afr.odometro,
						afr.mensaje,
						afr.hora_gps,
						afr.velocidad,
						afr.advisories,
						afr.longitud,
						afr.id_activo_fijo,
						afr.dia,
						afr.aux3,
						afr.punto_cercano,
						afr.altitud,
						afr.ciudad,
						afr.numero_actualizado,
						afr.estado,
						afr.aux4,
						afr.latitud,
						afr.events,
						afr.mes,
						afr.anio,
						afr.calle,
						afr.id_usuario_reg,
						afr.fecha_reg,
						afr.id_usuario_mod,
						afr.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gev.tgv_activo_fijo_rastreo afr
						inner join segu.tusuario usu1 on usu1.id_usuario = afr.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = afr.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_AFR_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 15:47:13
	***********************************/

	elsif(p_transaccion='tgv_AFR_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_activo_fijo_rastreo)
					    from gev.tgv_activo_fijo_rastreo afr
					    inner join segu.tusuario usu1 on usu1.id_usuario = afr.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = afr.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 784 (class 1255 OID 207181)
-- Dependencies: 3246 12
-- Name: f_tgv_activo_fijo_ultimo_registro_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_activo_fijo_ultimo_registro_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_activo_fijo_ultimo_registro_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_activo_fijo_ultimo_registro'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 02:57:40
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_ultimo_registro	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_activo_fijo_ultimo_registro_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_urg_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 02:57:40
	***********************************/

	if(p_transaccion='tgv_urg_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_activo_fijo_ultimo_registro(
			id_empleado,
			estado_reg,
			aux2,
			curso,
			chofer,
			latitud,
			aux1,
			fecha_satelite,
			id_activo_fijo,
			aux3,
			aux4,
			velocidad,
			longitud,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_empleado,
			'activo',
			v_parametros.aux2,
			v_parametros.curso,
			v_parametros.chofer,
			v_parametros.latitud,
			v_parametros.aux1,
			v_parametros.fecha_satelite,
			v_parametros.id_activo_fijo,
			v_parametros.aux3,
			v_parametros.aux4,
			v_parametros.velocidad,
			v_parametros.longitud,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_ultimo_registro into v_id_ultimo_registro;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','ultimo_registro almacenado(a) con exito (id_ultimo_registro'||v_id_ultimo_registro||')'); 
            v_resp = f_agrega_clave(v_resp,'id_ultimo_registro',v_id_ultimo_registro::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_urg_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 02:57:40
	***********************************/

	elsif(p_transaccion='tgv_urg_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_activo_fijo_ultimo_registro set
			id_empleado = v_parametros.id_empleado,
			aux2 = v_parametros.aux2,
			curso = v_parametros.curso,
			chofer = v_parametros.chofer,
			latitud = v_parametros.latitud,
			aux1 = v_parametros.aux1,
			fecha_satelite = v_parametros.fecha_satelite,
			id_activo_fijo = v_parametros.id_activo_fijo,
			aux3 = v_parametros.aux3,
			aux4 = v_parametros.aux4,
			velocidad = v_parametros.velocidad,
			longitud = v_parametros.longitud,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_ultimo_registro=v_parametros.id_ultimo_registro;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','ultimo_registro modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_ultimo_registro',v_parametros.id_ultimo_registro::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_urg_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 02:57:40
	***********************************/

	elsif(p_transaccion='tgv_urg_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_activo_fijo_ultimo_registro
            where id_ultimo_registro=v_parametros.id_ultimo_registro;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','ultimo_registro eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_ultimo_registro',v_parametros.id_ultimo_registro::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 785 (class 1255 OID 207182)
-- Dependencies: 12 3246
-- Name: f_tgv_activo_fijo_ultimo_registro_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_activo_fijo_ultimo_registro_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_activo_fijo_ultimo_registro_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_activo_fijo_ultimo_registro'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 02:57:40
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_activo_fijo_ultimo_registro_sel';
    v_parametros = f_get_record(p_tabla);
    
     /*********************************    
 	#TRANSACCION:  'TGV_AFRDETULT_SEL'
 	#DESCRIPCION:	Consulta el ultimo registro de la posicion del vehiculo
                    para mostrar en mapa  (no tiene COUNT ni paginacion)
 	#AUTOR:		RAC	
 	#FECHA:		03-02-2012 15:47:13
    ***********************************/

	if(p_transaccion='TGV_AFRDETULT_SEL')then
     				
    	begin
    		--Sentencia de la consulta
         
            
			v_consulta:='SELECT
		                afr.id_ultimo_registro,
                        afr.id_funcionario,
						afr.fecha_satelite,
						afr.curso,
                        afr.velocidad,
						afr.longitud,
						afr.id_activo_fijo,
                        afr.latitud,
                        f.desc_funcionario1,
                        afr.punto_cercano
                        from gev.tgv_activo_fijo_ultimo_registro afr
                        left join rhum.vfuncionario f 
                        on afr.id_funcionario = f.id_funcionario
						WHERE  id_activo_fijo in ('||COALESCE(v_parametros.id_activo_fijo,'0')||')
                        order by afr.fecha_satelite DESC';
           --Devuelve la respuesta
          
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_urg_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 02:57:40
	***********************************/

	elseif(p_transaccion='tgv_urg_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						urg.id_ultimo_registro,
						urg.id_empleado,
						urg.estado_reg,
						urg.aux2,
						urg.curso,
						urg.chofer,
						urg.latitud,
						urg.aux1,
						urg.fecha_satelite,
						urg.id_activo_fijo,
						urg.aux3,
						urg.aux4,
						urg.velocidad,
						urg.longitud,
						urg.id_usuario_reg,
						urg.fecha_reg,
						urg.id_usuario_mod,
						urg.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gev.tgv_activo_fijo_ultimo_registro urg
						inner join segu.tusuario usu1 on usu1.id_usuario = urg.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = urg.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_urg_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 02:57:40
	***********************************/

	elsif(p_transaccion='tgv_urg_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_ultimo_registro)
					    from gev.tgv_activo_fijo_ultimo_registro urg
					    inner join segu.tusuario usu1 on usu1.id_usuario = urg.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = urg.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 761 (class 1255 OID 207183)
-- Dependencies: 3246 12
-- Name: f_tgv_agrupacion_evento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_agrupacion_evento_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_agrupacion_evento_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_agrupacion_evento'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 19:07:27
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_agrupacion_evento	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_agrupacion_evento_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_aev_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 19:07:27
	***********************************/

	if(p_transaccion='tgv_aev_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_agrupacion_evento(
			estado_reg,
			id_agrupacion,
			id_evento,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.id_agrupacion,
			v_parametros.id_evento,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_agrupacion_evento into v_id_agrupacion_evento;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Agrupacion Evento almacenado(a) con exito (id_agrupacion_evento'||v_id_agrupacion_evento||')'); 
            v_resp = f_agrega_clave(v_resp,'id_agrupacion_evento',v_id_agrupacion_evento::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_aev_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 19:07:27
	***********************************/

	elsif(p_transaccion='tgv_aev_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_agrupacion_evento set
			id_agrupacion = v_parametros.id_agrupacion,
			id_evento = v_parametros.id_evento,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_agrupacion_evento=v_parametros.id_agrupacion_evento;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Agrupacion Evento modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_agrupacion_evento',v_parametros.id_agrupacion_evento::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_aev_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 19:07:27
	***********************************/

	elsif(p_transaccion='tgv_aev_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_agrupacion_evento
            where id_agrupacion_evento=v_parametros.id_agrupacion_evento;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Agrupacion Evento eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_agrupacion_evento',v_parametros.id_agrupacion_evento::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 773 (class 1255 OID 207184)
-- Dependencies: 12 3246
-- Name: f_tgv_agrupacion_evento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_agrupacion_evento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_agrupacion_evento_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_agrupacion_evento'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 19:07:27
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_agrupacion_evento_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_aev_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 19:07:27
	***********************************/

	if(p_transaccion='tgv_aev_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						aev.id_agrupacion_evento,
						aev.estado_reg,
						aev.id_agrupacion,
						aev.id_evento,
						aev.id_usuario_reg,
						aev.fecha_reg,
						aev.id_usuario_mod,
						aev.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        eve.nombre as evento	
						from gev.tgv_agrupacion_evento aev
                        inner join gev.tgv_evento eve on eve.id_evento = aev.id_evento
						inner join segu.tusuario usu1 on usu1.id_usuario = aev.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = aev.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_aev_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 19:07:27
	***********************************/

	elsif(p_transaccion='tgv_aev_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_agrupacion_evento)
					    from gev.tgv_agrupacion_evento aev
                        inner join gev.tgv_evento eve on eve.id_evento = aev.id_evento
					    inner join segu.tusuario usu1 on usu1.id_usuario = aev.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = aev.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 805 (class 1255 OID 207185)
-- Dependencies: 12 3246
-- Name: f_tgv_agrupacion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_agrupacion_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_agrupacion_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_agrupacion'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 16:12:10
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_agrupacion	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_agrupacion_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_agr_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 16:12:10
	***********************************/

	if(p_transaccion='tgv_agr_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_agrupacion(
			estado_reg,
			nombre,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.nombre,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_agrupacion into v_id_agrupacion;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Agrupacion almacenado(a) con exito (id_agrupacion'||v_id_agrupacion||')'); 
            v_resp = f_agrega_clave(v_resp,'id_agrupacion',v_id_agrupacion::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_agr_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 16:12:10
	***********************************/

	elsif(p_transaccion='tgv_agr_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_agrupacion set
			nombre = v_parametros.nombre,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_agrupacion=v_parametros.id_agrupacion;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Agrupacion modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_agrupacion',v_parametros.id_agrupacion::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_agr_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 16:12:10
	***********************************/

	elsif(p_transaccion='tgv_agr_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_agrupacion
            where id_agrupacion=v_parametros.id_agrupacion;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Agrupacion eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_agrupacion',v_parametros.id_agrupacion::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 806 (class 1255 OID 207186)
-- Dependencies: 12 3246
-- Name: f_tgv_agrupacion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_agrupacion_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_agrupacion_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_agrupacion'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 16:12:10
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_agrupacion_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_agr_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 16:12:10
	***********************************/

	if(p_transaccion='tgv_agr_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						agr.id_agrupacion,
						agr.estado_reg,
						agr.nombre,
						agr.id_usuario_reg,
						agr.fecha_reg,
						agr.id_usuario_mod,
						agr.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gev.tgv_agrupacion agr
						inner join segu.tusuario usu1 on usu1.id_usuario = agr.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = agr.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_agr_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 16:12:10
	***********************************/

	elsif(p_transaccion='tgv_agr_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_agrupacion)
					    from gev.tgv_agrupacion agr
					    inner join segu.tusuario usu1 on usu1.id_usuario = agr.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = agr.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 807 (class 1255 OID 207187)
-- Dependencies: 3246 12
-- Name: f_tgv_bitacora_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_bitacora_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_bitacora_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_bitacora'
 AUTOR: 		 (rac)
 FECHA:	        02-02-2012 21:38:38
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_bitacora	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_bitacora_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_BIT_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:38:38
	***********************************/

	if(p_transaccion='tgv_BIT_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_bitacora(
			observaciones,
			estado_reg,
			id_servicio_det,
			combustible,
			combustible_lts,
			destino,
			origen,
			fecha,
			num_factura,
			importe,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.observaciones,
			'activo',
			v_parametros.id_servicio_det,
			v_parametros.combustible,
			v_parametros.combustible_lts,
			v_parametros.destino,
			v_parametros.origen,
			v_parametros.fecha,
			v_parametros.num_factura,
			v_parametros.importe,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_bitacora into v_id_bitacora;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Bitacora almacenado(a) con exito (id_bitacora'||v_id_bitacora||')'); 
            v_resp = f_agrega_clave(v_resp,'id_bitacora',v_id_bitacora::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_BIT_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:38:38
	***********************************/

	elsif(p_transaccion='tgv_BIT_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_bitacora set
			observaciones = v_parametros.observaciones,
			id_servicio_det = v_parametros.id_servicio_det,
			combustible = v_parametros.combustible,
			combustible_lts = v_parametros.combustible_lts,
			destino = v_parametros.destino,
			origen = v_parametros.origen,
			fecha = v_parametros.fecha,
			num_factura = v_parametros.num_factura,
			importe = v_parametros.importe,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_bitacora=v_parametros.id_bitacora;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Bitacora modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_bitacora',v_parametros.id_bitacora::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_BIT_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:38:38
	***********************************/

	elsif(p_transaccion='tgv_BIT_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_bitacora
            where id_bitacora=v_parametros.id_bitacora;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Bitacora eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_bitacora',v_parametros.id_bitacora::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 815 (class 1255 OID 207188)
-- Dependencies: 12 3246
-- Name: f_tgv_bitacora_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_bitacora_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_bitacora_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_bitacora'
 AUTOR: 		 (rac)
 FECHA:	        02-02-2012 21:38:38
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_bitacora_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_BIT_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:38:38
	***********************************/

	if(p_transaccion='tgv_BIT_SEL')then
         				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						bit.id_bitacora,
						bit.observaciones,
						bit.estado_reg,
						bit.id_servicio_det,
						bit.combustible,
						bit.combustible_lts,
						bit.destino,
						bit.origen,
						bit.fecha,
						bit.num_factura,
						bit.importe,
						bit.id_usuario_reg,
						bit.fecha_reg,
						bit.id_usuario_mod,
						bit.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gev.tgv_bitacora bit
						inner join segu.tusuario usu1 on usu1.id_usuario = bit.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = bit.id_usuario_mod
				     where  ';
                        
                        
               --Definicion de la respuesta                    
            v_consulta:=v_consulta||v_parametros.filtro;
            if(public.f_existe_parametro(p_tabla,'id_servicio_det')) then
               v_consulta:=v_consulta || '  and  bit.id_servicio_det='||COALESCE(v_parametros.id_servicio_det,0);
            end if;          
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
             
            
             raise notice '%',v_consulta;


			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_BIT_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:38:38
	***********************************/

	elsif(p_transaccion='tgv_BIT_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_bitacora)
					    from gev.tgv_bitacora bit
					    inner join segu.tusuario usu1 on usu1.id_usuario = bit.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = bit.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;
             if(public.f_existe_parametro(p_tabla,'id_servicio_det')) then
               v_consulta:=v_consulta || ' and bit.id_servicio_det='||v_parametros.id_servicio_det;
            end if;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 816 (class 1255 OID 207189)
-- Dependencies: 3246 12
-- Name: f_tgv_distancia_entre_dos_puntos(numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_distancia_entre_dos_puntos(lat1 numeric, lon1 numeric, lat2 numeric, lon2 numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
  FACOS FLOAT;
  radio INT;
  RESULTADO FLOAT;
BEGIN
	radio := 6378; -- RADIO DE LA TIERRA EN Km. ECUATORIAL
    FACOS := SIN(RADIANS(LON1)) * SIN( RADIANS(LON2)) + COS(RADIANS(LON1)) * COS(RADIANS(LON2)) * COS(RADIANS(LAT1) -  RADIANS(LAT2));

    IF FACOS > 1 then
        FACOS := 1;
    end if;
    IF FACOS < -1 then
        FACOS := -1;
	end if;
    
    RESULTADO := (Acos(FACOS) * RADIO);
    
    return resultado;
END;
$$;


--
-- TOC entry 817 (class 1255 OID 207190)
-- Dependencies: 3246 12
-- Name: f_tgv_evento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_evento_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_evento_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_evento'
 AUTOR: 		 (rcm)
 FECHA:	        02-02-2012 01:22:03
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_evento	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_evento_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_EVENT_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:22:03
	***********************************/

	if(p_transaccion='tgv_EVENT_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_evento(
			estado_reg,
			descripcion,
			nombre,
			id_tipo_evento,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.descripcion,
			v_parametros.nombre,
			v_parametros.id_tipo_evento,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_evento into v_id_evento;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Evento almacenado(a) con exito (id_evento'||v_id_evento||')'); 
            v_resp = f_agrega_clave(v_resp,'id_evento',v_id_evento::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_EVENT_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:22:03
	***********************************/

	elsif(p_transaccion='tgv_EVENT_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_evento set
			descripcion = v_parametros.descripcion,
			nombre = v_parametros.nombre,
			id_tipo_evento = v_parametros.id_tipo_evento,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_evento=v_parametros.id_evento;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Evento modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_evento',v_parametros.id_evento::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_EVENT_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:22:03
	***********************************/

	elsif(p_transaccion='tgv_EVENT_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_evento
            where id_evento=v_parametros.id_evento;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Evento eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_evento',v_parametros.id_evento::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 808 (class 1255 OID 207191)
-- Dependencies: 3246 12
-- Name: f_tgv_evento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_evento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_evento_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_evento'
 AUTOR: 		 (rcm)
 FECHA:	        02-02-2012 01:22:03
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_evento_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_EVENT_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:22:03
	***********************************/

	if(p_transaccion='tgv_EVENT_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						event.id_evento,
						event.estado_reg,
						event.descripcion,
						event.nombre,
						event.id_tipo_evento,
						event.id_usuario_reg,
						event.fecha_reg,
						event.id_usuario_mod,
						event.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gev.tgv_evento event
						inner join segu.tusuario usu1 on usu1.id_usuario = event.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = event.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_EVENT_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:22:03
	***********************************/

	elsif(p_transaccion='tgv_EVENT_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_evento)
					    from gev.tgv_evento event
					    inner join segu.tusuario usu1 on usu1.id_usuario = event.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = event.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 818 (class 1255 OID 207192)
-- Dependencies: 3246 12
-- Name: f_tgv_iboton_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_iboton_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_iboton_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_iboton'
 AUTOR: 		 (rcm)
 FECHA:	        04-02-2012 19:23:49
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_iboton				integer;
    v_id_funcionario		integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_iboton_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_IBUT_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rcm	
 	#FECHA:		04-02-2012 19:23:49
	***********************************/

	if(p_transaccion='tgv_IBUT_INS')then
					
        begin
        	--Verifica que no duplique funcionario ni codigo
            if exists(select 1 from gev.tgv_iboton
            		where id_funcionario = v_parametros.id_funcionario) then
            	raise exception 'El funcionario ya fue registrado anteriormente.';
            end if;
            if exists(select 1 from gev.tgv_iboton
            		where codigo = v_parametros.codigo) then
            	raise exception 'El Código ya fue asignado a otro Funcionario.';
            end if;
        	--Sentencia de la insercion
        	insert into gev.tgv_iboton(
			id_funcionario,
			codigo,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_funcionario,
			v_parametros.codigo,
			'activo',
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_iboton into v_id_iboton;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Ibutton almacenado(a) con exito (id_iboton'||v_id_iboton||')'); 
            v_resp = f_agrega_clave(v_resp,'id_iboton',v_id_iboton::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_IBUT_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		04-02-2012 19:23:49
	***********************************/

	elsif(p_transaccion='tgv_IBUT_MOD')then

		begin
        	--Obtiene el id_funciionario almacenado para verificar que no duplique
            select id_funcionario into v_id_funcionario from gev.tgv_iboton where id_iboton = v_parametros.id_iboton;
            
        	--Verifica que no duplique funcionario ni codigo
            if v_id_funcionario <> v_parametros.id_funcionario then
                if exists(select 1 from gev.tgv_iboton
                        where id_funcionario = v_parametros.id_funcionario) then
                    raise exception 'El funcionario ya fue registrado anteriormente.';
                end if;
            end if;
            if exists(select 1 from gev.tgv_iboton
            		where codigo = v_parametros.codigo
                    and id_funcionario <> v_id_funcionario) then
            	raise exception 'El Código ya fue asignado a otro Funcionario.';
            end if;
            
            
			--Sentencia de la modificacion
			update gev.tgv_iboton set
			id_funcionario = v_parametros.id_funcionario,
			codigo = v_parametros.codigo,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_iboton=v_parametros.id_iboton;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Ibutton modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_iboton',v_parametros.id_iboton::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_IBUT_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		04-02-2012 19:23:49
	***********************************/

	elsif(p_transaccion='tgv_IBUT_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_iboton
            where id_iboton=v_parametros.id_iboton;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Ibutton eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_iboton',v_parametros.id_iboton::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 819 (class 1255 OID 207193)
-- Dependencies: 12 3246
-- Name: f_tgv_iboton_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_iboton_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_iboton_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_iboton'
 AUTOR: 		 (rcm)
 FECHA:	        04-02-2012 19:23:49
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_iboton_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_IBUT_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rcm	
 	#FECHA:		04-02-2012 19:23:49
	***********************************/

	if(p_transaccion='tgv_IBUT_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						ibut.id_iboton,
						ibut.id_funcionario,
						ibut.codigo,
						ibut.estado_reg,
						ibut.id_usuario_reg,
						ibut.fecha_reg,
						ibut.id_usuario_mod,
						ibut.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        emplea.desc_funcionario1 as desc_funcionario
						from gev.tgv_iboton ibut
                        inner join rhum.vfuncionario emplea on emplea.id_funcionario=ibut.id_funcionario
						inner join segu.tusuario usu1 on usu1.id_usuario = ibut.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ibut.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_IBUT_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rcm	
 	#FECHA:		04-02-2012 19:23:49
	***********************************/

	elsif(p_transaccion='tgv_IBUT_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_iboton)
					    from gev.tgv_iboton ibut
                        inner join rhum.vfuncionario emplea on emplea.id_funcionario=ibut.id_funcionario
					    inner join segu.tusuario usu1 on usu1.id_usuario = ibut.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ibut.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 835 (class 1255 OID 207194)
-- Dependencies: 12 3246
-- Name: f_tgv_mantenimiento_det_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_mantenimiento_det_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_mantenimiento_det_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_mantenimiento_det'
 AUTOR: 		 (rcm)
 FECHA:	        03-02-2012 20:37:16
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_mantenimiento_det	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_mantenimiento_det_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_DETMAN_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:37:16
	***********************************/

	if(p_transaccion='tgv_DETMAN_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_mantenimiento_det(
			id_activo_fijo,
			id_evento,
			descripcion,
			estado_reg,
			id_mantenimiento,
			estado,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_activo_fijo,
			v_parametros.id_evento,
			v_parametros.descripcion,
			'activo',
			v_parametros.id_mantenimiento,
			v_parametros.estado,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_mantenimiento_det into v_id_mantenimiento_det;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Mantenmiento almacenado(a) con exito (id_mantenimiento_det'||v_id_mantenimiento_det||')'); 
            v_resp = f_agrega_clave(v_resp,'id_mantenimiento_det',v_id_mantenimiento_det::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_DETMAN_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:37:16
	***********************************/

	elsif(p_transaccion='tgv_DETMAN_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_mantenimiento_det set
			id_activo_fijo = v_parametros.id_activo_fijo,
			id_evento = v_parametros.id_evento,
			descripcion = v_parametros.descripcion,
			id_mantenimiento = v_parametros.id_mantenimiento,
			estado = v_parametros.estado,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_mantenimiento_det=v_parametros.id_mantenimiento_det;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Mantenmiento modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_mantenimiento_det',v_parametros.id_mantenimiento_det::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_DETMAN_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:37:16
	***********************************/

	elsif(p_transaccion='tgv_DETMAN_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_mantenimiento_det
            where id_mantenimiento_det=v_parametros.id_mantenimiento_det;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Detalle Mantenmiento eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_mantenimiento_det',v_parametros.id_mantenimiento_det::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 836 (class 1255 OID 207195)
-- Dependencies: 12 3246
-- Name: f_tgv_mantenimiento_det_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_mantenimiento_det_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_mantenimiento_det_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_mantenimiento_det'
 AUTOR: 		 (rcm)
 FECHA:	        03-02-2012 20:37:16
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_mantenimiento_det_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_DETMAN_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:37:16
	***********************************/

	if(p_transaccion='tgv_DETMAN_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						detman.id_mantenimiento_det,
						detman.id_activo_fijo,
						detman.id_evento,
						detman.descripcion,
						detman.estado_reg,
						detman.id_mantenimiento,
						detman.estado,
						detman.id_usuario_reg,
						detman.fecha_reg,
						detman.id_usuario_mod,
						detman.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        (actif.codigo || '' - '' || actif.descripcion)::varchar as desc_activo_fijo,
                        event.nombre
						from gev.tgv_mantenimiento_det detman
                        inner join actif.taf_activo_fijo actif on actif.id_activo_fijo = detman.id_activo_fijo
                        inner join gev.tgv_evento event on event.id_evento = detman.id_evento
						inner join segu.tusuario usu1 on usu1.id_usuario = detman.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = detman.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_DETMAN_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:37:16
	***********************************/

	elsif(p_transaccion='tgv_DETMAN_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_mantenimiento_det)
					    from gev.tgv_mantenimiento_det detman
                        inner join actif.taf_activo_fijo actif on actif.id_activo_fijo = detman.id_activo_fijo
                        inner join gev.tgv_evento event on event.id_evento = detman.id_evento
					    inner join segu.tusuario usu1 on usu1.id_usuario = detman.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = detman.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 849 (class 1255 OID 207196)
-- Dependencies: 3246 12
-- Name: f_tgv_mantenimiento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_mantenimiento_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_mantenimiento_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_mantenimiento'
 AUTOR: 		 (rcm)
 FECHA:	        03-02-2012 20:09:09
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_mantenimiento	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_mantenimiento_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_man_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:09:09
	***********************************/

	if(p_transaccion='tgv_man_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_mantenimiento(
			id_tipo_evento,
			descripcion,
			id_proveedor,
			fecha_ini,
			fecha_fin,
			id_funcionario,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.id_tipo_evento,
			v_parametros.descripcion,
			v_parametros.id_proveedor,
			v_parametros.fecha_ini,
			v_parametros.fecha_fin,
			v_parametros.id_funcionario,
			'activo',
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_mantenimiento into v_id_mantenimiento;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Mantenimiento almacenado(a) con exito (id_mantenimiento'||v_id_mantenimiento||')'); 
            v_resp = f_agrega_clave(v_resp,'id_mantenimiento',v_id_mantenimiento::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_man_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:09:09
	***********************************/

	elsif(p_transaccion='tgv_man_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_mantenimiento set
			id_tipo_evento = v_parametros.id_tipo_evento,
			descripcion = v_parametros.descripcion,
			id_proveedor = v_parametros.id_proveedor,
			fecha_ini = v_parametros.fecha_ini,
			fecha_fin = v_parametros.fecha_fin,
			id_funcionario = v_parametros.id_funcionario,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_mantenimiento=v_parametros.id_mantenimiento;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Mantenimiento modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_mantenimiento',v_parametros.id_mantenimiento::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_man_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:09:09
	***********************************/

	elsif(p_transaccion='tgv_man_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_mantenimiento
            where id_mantenimiento=v_parametros.id_mantenimiento;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Mantenimiento eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_mantenimiento',v_parametros.id_mantenimiento::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 850 (class 1255 OID 207197)
-- Dependencies: 12 3246
-- Name: f_tgv_mantenimiento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_mantenimiento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_mantenimiento_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_mantenimiento'
 AUTOR: 		 (rcm)
 FECHA:	        03-02-2012 20:09:09
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_mantenimiento_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_man_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:09:09
	***********************************/

	if(p_transaccion='tgv_man_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						man.id_mantenimiento,
						man.id_tipo_evento,
						man.descripcion,
						man.id_proveedor,
						man.fecha_ini,
						man.fecha_fin,
						man.id_funcionario,
						man.estado_reg,
						man.id_usuario_reg,
						man.fecha_reg,
						man.id_usuario_mod,
						man.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        prov.desc_proveedor,
                        fun.desc_funcionario1 as desc_person,
                        tipeve.nombre
						from gev.tgv_mantenimiento man
                        inner join param.vproveedor prov on prov.id_proveedor = man.id_proveedor
                        inner join rhum.vfuncionario fun on fun.id_funcionario = man.id_funcionario
                        inner join gev.tgv_tipo_evento tipeve on tipeve.id_tipo_evento = man.id_tipo_evento
						inner join segu.tusuario usu1 on usu1.id_usuario = man.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = man.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_man_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rcm	
 	#FECHA:		03-02-2012 20:09:09
	***********************************/

	elsif(p_transaccion='tgv_man_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_mantenimiento)
					    from gev.tgv_mantenimiento man
                        inner join param.vproveedor prov on prov.id_proveedor = man.id_proveedor
                        inner join rhum.vfuncionario fun on fun.id_funcionario = man.id_funcionario
                        inner join gev.tgv_tipo_evento tipeve on tipeve.id_tipo_evento = man.id_tipo_evento
					    inner join segu.tusuario usu1 on usu1.id_usuario = man.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = man.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 868 (class 1255 OID 207198)
-- Dependencies: 3246 12
-- Name: f_tgv_marca_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_marca_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_marca_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_marca'
 AUTOR: 		 (rac)
 FECHA:	        01-02-2012 03:36:14
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_marca	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_marca_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_mar_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		01-02-2012 03:36:14
	***********************************/

	if(p_transaccion='tgv_mar_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_marca(
			estado_reg,
			procedencia,
			marca,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.procedencia,
			v_parametros.marca,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_marca into v_id_marca;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','marca almacenado(a) con exito (id_marca'||v_id_marca||')'); 
            v_resp = f_agrega_clave(v_resp,'id_marca',v_id_marca::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_mar_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		01-02-2012 03:36:14
	***********************************/

	elsif(p_transaccion='tgv_mar_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_marca set
			procedencia = v_parametros.procedencia,
			marca = v_parametros.marca,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_marca=v_parametros.id_marca;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','marca modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_marca',v_parametros.id_marca::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_mar_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		01-02-2012 03:36:14
	***********************************/

	elsif(p_transaccion='tgv_mar_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_marca
            where id_marca=v_parametros.id_marca;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','marca eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_marca',v_parametros.id_marca::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 869 (class 1255 OID 207199)
-- Dependencies: 12 3246
-- Name: f_tgv_marca_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_marca_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_marca_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_marca'
 AUTOR: 		 (rac)
 FECHA:	        01-02-2012 03:36:14
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_marca_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_mar_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		01-02-2012 03:36:14
	***********************************/

	if(p_transaccion='tgv_mar_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						mar.id_marca,
						mar.estado_reg,
						mar.procedencia,
						mar.marca,
						mar.id_usuario_reg,
						mar.fecha_reg,
						mar.id_usuario_mod,
						mar.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gev.tgv_marca mar
						inner join segu.tusuario usu1 on usu1.id_usuario = mar.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = mar.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_mar_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		01-02-2012 03:36:14
	***********************************/

	elsif(p_transaccion='tgv_mar_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_marca)
					    from gev.tgv_marca mar
					    inner join segu.tusuario usu1 on usu1.id_usuario = mar.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = mar.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 870 (class 1255 OID 207200)
-- Dependencies: 12 3246
-- Name: f_tgv_modelo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_modelo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_modelo_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_modelo'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 01:44:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_modelo	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_modelo_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_mdl_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 01:44:30
	***********************************/

	if(p_transaccion='tgv_mdl_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_modelo(
			estado_reg,
			id_marca,
			descripcion,
			modelo,
			anio,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.id_marca,
			v_parametros.descripcion,
			v_parametros.modelo,
			v_parametros.anio,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_modelo into v_id_modelo;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','modelo almacenado(a) con exito (id_modelo'||v_id_modelo||')'); 
            v_resp = f_agrega_clave(v_resp,'id_modelo',v_id_modelo::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_mdl_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 01:44:30
	***********************************/

	elsif(p_transaccion='tgv_mdl_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_modelo set
			id_marca = v_parametros.id_marca,
			descripcion = v_parametros.descripcion,
			modelo = v_parametros.modelo,
			anio = v_parametros.anio,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_modelo=v_parametros.id_modelo;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','modelo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_modelo',v_parametros.id_modelo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_mdl_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 01:44:30
	***********************************/

	elsif(p_transaccion='tgv_mdl_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_modelo
            where id_modelo=v_parametros.id_modelo;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','modelo eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_modelo',v_parametros.id_modelo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 871 (class 1255 OID 207201)
-- Dependencies: 12 3246
-- Name: f_tgv_modelo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_modelo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_modelo_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_modelo'
 AUTOR: 		 (herman)
 FECHA:	        02-02-2012 01:44:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_modelo_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_mdl_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 01:44:30
	***********************************/

	if(p_transaccion='tgv_mdl_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						mdl.id_modelo,
						mdl.estado_reg,
						mdl.id_marca,
						mdl.descripcion,
						mdl.modelo,
						mdl.anio,
						mdl.id_usuario_reg,
						mdl.fecha_reg,
						mdl.id_usuario_mod,
						mdl.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gev.tgv_modelo mdl
						inner join segu.tusuario usu1 on usu1.id_usuario = mdl.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = mdl.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_mdl_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		herman	
 	#FECHA:		02-02-2012 01:44:30
	***********************************/

	elsif(p_transaccion='tgv_mdl_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_modelo)
					    from gev.tgv_modelo mdl
					    inner join segu.tusuario usu1 on usu1.id_usuario = mdl.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = mdl.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 820 (class 1255 OID 207202)
-- Dependencies: 12 3246
-- Name: f_tgv_obtenerFechaGPS(integer, integer); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION "f_tgv_obtenerFechaGPS"(v_date_time integer, v_gps_time integer) RETURNS timestamp without time zone
    LANGUAGE plpgsql
    AS $$
DECLARE
  pFechaAux timestamp;
  pFecha DATE;
  pStrAux varchar;
  g_registro record;
BEGIN
	pStrAux := 'SELECT TIMESTAMP ''01/01/1970 0:0:0.000'' + INTERVAL '||''''||(v_date_time-14400)::varchar || ' second''';
    
  	execute pStrAux into pFecha;
    
    pStrAux := 'SELECT TIMESTAMP '''|| pFecha::VARCHAR ||''' + INTERVAL '||''''||(v_gps_time)::varchar || ' second''';
    
    execute pStrAux into pFechaAux;
 
	return pFechaAux;
END;
$$;


--
-- TOC entry 821 (class 1255 OID 207203)
-- Dependencies: 3246 12
-- Name: f_tgv_servicio_det_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_servicio_det_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_servicio_det_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_servicio_det'
 AUTOR: 		 (rac)
 FECHA:	        02-02-2012 21:56:04
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_servicio_det	integer;    
    
    v_fecha_ini         date;
    v_fecha_fin         date;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_servicio_det_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_SDE_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:56:04
	***********************************/

	if(p_transaccion='tgv_SDE_INS')then
					
        begin     
        select fecha_asig_ini , fecha_asig_fin 
            into v_fecha_ini, v_fecha_fin
            from gev.tgv_servicio 
            where id_servicio=v_parametros.id_servicio;  
            
            if exists (select 1 from gev.tgv_servicio s inner join gev.tgv_servicio_det sd
            on sd.id_servicio=s.id_servicio where  s.estado!='concluido' and sd.id_funcionario=v_parametros.id_funcionario 
            and v_fecha_ini < s.fecha_asig_fin) then
               raise exception 'Asignacion no realizada. El funcionario tiene servicios pendientes sin concluir';  
            end if;                                                                
            
            
            --validar que el kilometraje ini no sea mayor al kilometraje fin
            if(v_parametros.kilometraje_fin<v_parametros.kilometraje_ini) then
              raise exception 'Asignacion no realizada. Revise la cantidad de kilometraje registrado';
            end if;
        
        	--Sentencia de la insercion
        	insert into gev.tgv_servicio_det(
			estado_reg,
			kilometraje_ini,
			id_activo_fijo,
			id_funcionario,
			id_servicio,
			kilometraje_fin,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.kilometraje_ini,
			v_parametros.id_activo_fijo,
			v_parametros.id_funcionario,
			v_parametros.id_servicio,
			v_parametros.kilometraje_fin,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_servicio_det into v_id_servicio_det;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','servicio_det almacenado(a) con exito (id_servicio_det'||v_id_servicio_det||')'); 
            v_resp = f_agrega_clave(v_resp,'id_servicio_det',v_id_servicio_det::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_SDE_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:56:04
	***********************************/

	elsif(p_transaccion='tgv_SDE_MOD')then

		begin
			--Sentencia de la modificacion   
            --verificar que el reponsable(funcionario) a asignar no esté en algun detalle servicio activo en el rango de fechas de la asignacion 
            select fecha_asig_ini , fecha_asig_fin 
            into v_fecha_ini, v_fecha_fin
            from gev.tgv_servicio 
            where id_servicio=v_parametros.id_servicio;  
            
            if exists (select 1 from gev.tgv_servicio s inner join gev.tgv_servicio_det sd
            on sd.id_servicio=s.id_servicio where  s.estado!='concluido' and sd.id_funcionario=v_parametros.id_funcionario 
            and v_fecha_ini < s.fecha_asig_fin and s.id_servicio!=v_parametros.id_servicio) then
               raise exception 'Asignacion no realizada. El funcionario tiene servicios pendientes sin concluir';  
            end if;                                                                
            
            
            --validar que el kilometraje ini no sea mayor al kilometraje fin
            if(v_parametros.kilometraje_fin<v_parametros.kilometraje_ini) then
              raise exception 'Asignacion no realizada. Revise la cantidad de kilometraje registrado';
            end if; 
            
			update gev.tgv_servicio_det set
			kilometraje_ini = v_parametros.kilometraje_ini,
			id_activo_fijo = v_parametros.id_activo_fijo,
			id_funcionario = v_parametros.id_funcionario,
			id_servicio = v_parametros.id_servicio,
			kilometraje_fin = v_parametros.kilometraje_fin,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_servicio_det=v_parametros.id_servicio_det;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','servicio_det modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_servicio_det',v_parametros.id_servicio_det::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_SDE_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:56:04
	***********************************/

	elsif(p_transaccion='tgv_SDE_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_servicio_det
            where id_servicio_det=v_parametros.id_servicio_det;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','servicio_det eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_servicio_det',v_parametros.id_servicio_det::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 881 (class 1255 OID 207206)
-- Dependencies: 12 3246
-- Name: f_tgv_servicio_det_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_servicio_det_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_servicio_det_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_servicio_det'
 AUTOR: 		 (rac)
 FECHA:	        02-02-2012 21:56:04
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_servicio_det_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_SDE_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:56:04
	***********************************/

	if(p_transaccion='tgv_SDE_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						sde.id_servicio_det,
						sde.estado_reg,
						sde.kilometraje_ini,
						sde.id_activo_fijo,
						sde.id_funcionario,
						sde.id_servicio,
						sde.kilometraje_fin,
						sde.id_usuario_reg,
						sde.fecha_reg,
						sde.id_usuario_mod,
						sde.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        f.desc_funcionario1,
                        adt.desc_activo_fijo
						from gev.tgv_servicio_det sde
						inner join segu.tusuario usu1 on usu1.id_usuario = sde.id_usuario_reg
                        inner join rhum.vfuncionario f on sde.id_funcionario = f.id_funcionario
                        inner join gev.vgv_activo_datos_tec adt on adt.id_activo_fijo=sde.id_activo_fijo
						left join segu.tusuario usu2 on usu2.id_usuario = sde.id_usuario_mod
				        where  ';   
                        
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;         
            
            if(public.f_existe_parametro(p_tabla,'tipo_interfaz')) then
                if(v_parametros.tipo_interfaz='SERVICIODETREGISTRO')     then     --raise exception 'id%',v_parametros.id_servicio;
                     v_consulta:=v_consulta|| ' and sde.id_servicio='|| v_parametros.id_servicio;
                end if;
            end if;
            
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_SDE_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		02-02-2012 21:56:04
	***********************************/

	elsif(p_transaccion='tgv_SDE_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_servicio_det)
					    from gev.tgv_servicio_det sde
						inner join segu.tusuario usu1 on usu1.id_usuario = sde.id_usuario_reg
                        inner join rhum.vfuncionario f on sde.id_funcionario = f.id_funcionario
                        inner join gev.vgv_activo_datos_tec adt on adt.id_activo_fijo=sde.id_activo_fijo
						left join segu.tusuario usu2 on usu2.id_usuario = sde.id_usuario_mod
				       where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;
             if(public.f_existe_parametro(p_tabla,'tipo_interfaz')) then
                if(v_parametros.tipo_interfaz='SERVICIODETREGISTRO')     then
                     v_consulta:=v_consulta|| ' and sde.id_servicio='|| v_parametros.id_servicio;
                end if;
            end if;
			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 882 (class 1255 OID 207207)
-- Dependencies: 3246 12
-- Name: f_tgv_servicio_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_servicio_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_servicio_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_servicio'
 AUTOR: 		 (rcm)
 FECHA:	        02-02-2012 02:56:44
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_servicio	integer;
			    
BEGIN
                --  raise exception 'aa%',p_transaccion;
    v_nombre_funcion = 'gev.f_tgv_servicio_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_SERVIC_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 02:56:44
	***********************************/

	if(p_transaccion='tgv_SERVIC_INS')then
					
        begin
        
        	--Verifica que el aprobador no sea el mismo que el solicitante
            if v_parametros.id_funcionario = v_parametros.id_funcionario_autoriz then
            	raise exception 'El Aprobador no puede ser el mismo que el Solicitante.';
            end if;
            if v_parametros.fecha_sol_fin < v_parametros.fecha_sol_ini then
            	raise exception 'La fecha de finalización no puede ser anterior al a fecha de inicio.';
            end if;
            
        	--Sentencia de la insercion
        	insert into gev.tgv_servicio(
			estado,
			estado_reg,
			id_lugar_destino,
			id_ep,
			--fecha_asig_fin,
			fecha_sol_ini,
			descripcion,
			id_lugar_origen,
			cant_personas,
			fecha_sol_fin,
			id_funcionario,
		--	fecha_asig_ini,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod,
            id_funcionario_autoriz,
            observaciones
          	) values(
			'borrador',
			'activo',
			v_parametros.id_lugar_destino,
			v_parametros.id_ep,
			--v_parametros.fecha_asig_fin,
			v_parametros.fecha_sol_ini,
			v_parametros.descripcion,
			v_parametros.id_lugar_origen,
			v_parametros.cant_personas,
			v_parametros.fecha_sol_fin,
			v_parametros.id_funcionario,
			--v_parametros.fecha_asig_ini,
			p_id_usuario,
			now(),
			null,
			null,
            v_parametros.id_funcionario_autoriz,
            v_parametros.observaciones
			)RETURNING id_servicio into v_id_servicio;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Servicio almacenado(a) con exito (id_servicio'||v_id_servicio||')'); 
            v_resp = f_agrega_clave(v_resp,'id_servicio',v_id_servicio::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_SERVIC_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 02:56:44
	***********************************/

	elsif(p_transaccion='tgv_SERVIC_MOD')then

		begin
        	--Verifica que el aprobador no sea el mismo que el solicitante
            if v_parametros.id_funcionario = v_parametros.id_funcionario_autoriz then
            	raise exception 'El Aprobador no puede ser el mismo que el Solicitante.';
            end if;
            if v_parametros.fecha_sol_fin < v_parametros.fecha_sol_ini then
            	raise exception 'La fecha de finalización no puede ser anterior al a fecha de inicio.';
            end if;
             
			--Sentencia de la modificacion
			update gev.tgv_servicio set
			--estado = v_parametros.estado,
			id_lugar_destino = v_parametros.id_lugar_destino,
			id_ep = v_parametros.id_ep,
			--fecha_asig_fin = v_parametros.fecha_asig_fin,
			fecha_sol_ini = v_parametros.fecha_sol_ini,
			descripcion = v_parametros.descripcion,
			id_lugar_origen = v_parametros.id_lugar_origen,
			cant_personas = v_parametros.cant_personas,
			fecha_sol_fin = v_parametros.fecha_sol_fin,
			id_funcionario = v_parametros.id_funcionario,
			--fecha_asig_ini = v_parametros.fecha_asig_ini,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now(),
            id_funcionario_autoriz = v_parametros.id_funcionario_autoriz,
            observaciones = v_parametros.observaciones
			where id_servicio=v_parametros.id_servicio;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Servicio modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_servicio',v_parametros.id_servicio::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_SERVIC_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 02:56:44
	***********************************/

	elsif(p_transaccion='tgv_SERVIC_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_servicio
            where id_servicio=v_parametros.id_servicio;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Servicio eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_servicio',v_parametros.id_servicio::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
   
  elsif(p_transaccion='tgv_SERCAMEST_MOD')then

		begin
			--Sentencia de la eliminacion   
            
            IF(public.f_existe_parametro(p_tabla,'operacion')) then   
            
              if(v_parametros.operacion='fin_solicitud') then 
                update gev.tgv_servicio
                set estado='para_asig'
                where id_servicio=v_parametros.id_servicio;
              elsif(v_parametros.operacion='anterior') then  
                update gev.tgv_servicio
                set estado='borrador',
                fecha_asig_ini=null,
                fecha_asig_fin=null
                where id_servicio=v_parametros.id_servicio; 
              
              end if;
            end if;
            
			
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Servicio finalizado para asignacio(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_servicio',v_parametros.id_servicio::varchar);
              
            --Devuelve la respuesta
            return v_resp;
    
  
  
		end; 
  
  elsif(p_transaccion='tgv_DEFFECHA_MOD')then

		begin 
            IF NOT EXISTS ( select 1 from gev.tgv_servicio  where id_servicio=v_parametros.id_servicio and estado_reg!='para_asig') THEN      
               raise exception 'Definicion no realizada. El estado del servicio debe ser para_asig';
            END IF;      
             
            update gev.tgv_servicio
            set fecha_asig_ini=v_parametros.fecha_asig_ini,
            fecha_asig_fin  =   v_parametros.fecha_asig_fin
            where id_servicio=v_parametros.id_servicio;
            
             --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Asigancion de fechas realizado'); 
            v_resp = f_agrega_clave(v_resp,'id_servicio',v_parametros.id_servicio::varchar);
              
            --Devuelve la respuesta
            return v_resp;
        
        END;
  else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 883 (class 1255 OID 207210)
-- Dependencies: 12 3246
-- Name: f_tgv_servicio_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_servicio_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_servicio_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_servicio'
 AUTOR: 		 (rcm)
 FECHA:	        02-02-2012 02:56:44
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_servicio_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_SERVIC_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 02:56:44
	***********************************/

	if(p_transaccion='tgv_SERVIC_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						servic.id_servicio,
						servic.estado,
						servic.estado_reg,
						servic.id_lugar_destino,
						servic.id_ep,
						servic.fecha_asig_fin,
						servic.fecha_sol_ini,
						servic.descripcion,
						servic.id_lugar_origen,
						servic.cant_personas,
						servic.fecha_sol_fin,
						servic.id_funcionario,
						servic.fecha_asig_ini,
						servic.id_usuario_reg,
						servic.fecha_reg,
						servic.id_usuario_mod,
						servic.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	,
                        emplea.desc_funcionario1 as desc_funcionario,
                        lug_ini.nombre as desc_lugar_ini,
                        lug_des.nombre as desc_lugar_des,
                        servic.id_funcionario_autoriz,
                        servic.observaciones,
                        empaut.desc_funcionario1 as desc_funcionario_autoriz
                        from gev.tgv_servicio servic  
						inner join segu.tusuario usu1 on usu1.id_usuario = servic.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = servic.id_usuario_mod 
                        inner join rhum.vfuncionario emplea on emplea.id_funcionario=servic.id_funcionario
                        inner join rhum.vfuncionario empaut on empaut.id_funcionario=servic.id_funcionario_autoriz
                        inner join param.tlugar lug_ini on lug_ini.id_lugar=servic.id_lugar_origen
                        inner join param.tlugar lug_des on lug_des.id_lugar=servic.id_lugar_destino
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro; 
                         
            
            IF(public.f_existe_parametro(p_tabla,'tipo_interfaz')) then  -- raise exception 'aa%', v_parametros.tipo_interfaz;  
                if(v_parametros.tipo_interfaz='SOLICITUDSERVICIO') then
                   v_consulta:=v_consulta|| ' and servic.estado=''borrador'' ';
                end if;  
                
                 if(v_parametros.tipo_interfaz='GESTIONSERVICIO') then
                   v_consulta:=v_consulta|| ' and servic.estado=''para_asig'' ';
                end if; 
         
            
            END IF;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_SERVIC_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 02:56:44
	***********************************/

	elsif(p_transaccion='tgv_SERVIC_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_servicio)
					    from gev.tgv_servicio servic
					    inner join segu.tusuario usu1 on usu1.id_usuario = servic.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = servic.id_usuario_mod
                        inner join rhum.vfuncionario empaut on empaut.id_funcionario=servic.id_funcionario_autoriz
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 895 (class 1255 OID 207211)
-- Dependencies: 3246 12
-- Name: f_tgv_testing_sel(integer); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_testing_sel(v_id_activo_fijo integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
  paux				INTEGER;
  pv_rec			RECORD;
  pRecorrido 		decimal(19, 2);
  pVelocidadMax 	decimal(19, 2);
  pVelocidadProm 	decimal(19, 2);
  pVMaxLatitud 		NUMERIC;
  pVMaxLongitud 	NUMERIC;
  pVMaxPuntoCercano varchar(150);
  pNroParadas 		INTEGER;
  pTiempoTotalMovimiento BIGINT;
  pTiempoTotalParado BIGINT;
  pVMaxFecha 		date;
  pPriMovFecha 		date;
  pPriMovLatitud 	NUMERIC;
  pPriMovLongitud 	NUMERIC;
  pPriMovPuntoCercano varchar(150);
  pUltMovFecha 		date;
  pUltMovLatitud 	NUMERIC;
  pUltMovLongitud 	NUMERIC;
  pUltMovPuntoCercano varchar(150);
BEGIN
   CREATE TEMPORARY TABLE v_resumenDia (
	id_activo_fijo INTEGER NOT NULL,
	Recorrido decimal(19, 2) NULL,
	VelocidadMax decimal(19, 2) NULL,
	VelocidadProm decimal(19, 2) NULL,
	VMaxLatitud NUMERIC NULL,
	VMaxLongitud NUMERIC NULL,
	VMaxPuntoCercano varchar(150) NULL,
	NroParadas INTEGER NULL,
	TiempoTotalMovimiento BIGINT NULL,
	TiempoTotalParado BIGINT NULL,
	VMaxFecha date NULL,
	PriMovFecha date NULL,
	PriMovLatitud NUMERIC NULL,
	PriMovLongitud NUMERIC NULL,
	PriMovPuntoCercano varchar(150) NULL,
	UltMovFecha date NULL,
	UltMovLatitud NUMERIC NULL,
	UltMovLongitud NUMERIC NULL,
	UltMovPuntoCercano varchar(150) NULL
  ) ON COMMIT DROP;

  CREATE TEMPORARY TABLE  TRAKING(  
    DATESATELITE TIMESTAMP,
    LONGITUDE NUMERIC, 
    LATITUDE NUMERIC, 
    SPEED NUMERIC, 
    PUNTO_CERCANO VARCHAR( 200 ) 
  )  ON COMMIT DROP;


  INSERT INTO TRAKING
  SELECT  fecha_satelite, longitud, latitud, velocidad, punto_cercano
			FROM gev.tgv_activo_fijo_rastreo  WHERE gev.tgv_activo_fijo_rastreo.id_activo_fijo =  v_id_activo_fijo
			ORDER BY  fecha_satelite;

  for pv_rec in select * from TRAKING loop
      return next pv_rec;
  end loop;
  
  return ;
END;
$$;


--
-- TOC entry 896 (class 1255 OID 207212)
-- Dependencies: 3246 12
-- Name: f_tgv_tipo_evento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_tipo_evento_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_tipo_evento_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'gev.tgv_tipo_evento'
 AUTOR: 		 (rcm)
 FECHA:	        02-02-2012 01:00:14
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_tipo_evento	integer;
			    
BEGIN

    v_nombre_funcion = 'gev.f_tgv_tipo_evento_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_TIPEVE_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:00:14
	***********************************/

	if(p_transaccion='tgv_TIPEVE_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into gev.tgv_tipo_evento(
			estado_reg,
			codigo,
			nombre,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.codigo,
			v_parametros.nombre,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_tipo_evento into v_id_tipo_evento;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Tipos de Eventos almacenado(a) con exito (id_tipo_evento'||v_id_tipo_evento||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_evento',v_id_tipo_evento::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'tgv_TIPEVE_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:00:14
	***********************************/

	elsif(p_transaccion='tgv_TIPEVE_MOD')then

		begin
			--Sentencia de la modificacion
			update gev.tgv_tipo_evento set
			codigo = v_parametros.codigo,
			nombre = v_parametros.nombre,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_tipo_evento=v_parametros.id_tipo_evento;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipos de Eventos modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_evento',v_parametros.id_tipo_evento::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_TIPEVE_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:00:14
	***********************************/

	elsif(p_transaccion='tgv_TIPEVE_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from gev.tgv_tipo_evento
            where id_tipo_evento=v_parametros.id_tipo_evento;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipos de Eventos eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_evento',v_parametros.id_tipo_evento::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 884 (class 1255 OID 207213)
-- Dependencies: 3246 12
-- Name: f_tgv_tipo_evento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION f_tgv_tipo_evento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Gestion Vehicular
 FUNCION: 		gev.f_tgv_tipo_evento_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'gev.tgv_tipo_evento'
 AUTOR: 		 (rcm)
 FECHA:	        02-02-2012 01:00:14
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'gev.f_tgv_tipo_evento_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'tgv_TIPEVE_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:00:14
	***********************************/

	if(p_transaccion='tgv_TIPEVE_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						tipeve.id_tipo_evento,
						tipeve.estado_reg,
						tipeve.codigo,
						tipeve.nombre,
						tipeve.id_usuario_reg,
						tipeve.fecha_reg,
						tipeve.id_usuario_mod,
						tipeve.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from gev.tgv_tipo_evento tipeve
						inner join segu.tusuario usu1 on usu1.id_usuario = tipeve.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipeve.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'tgv_TIPEVE_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rcm	
 	#FECHA:		02-02-2012 01:00:14
	***********************************/

	elsif(p_transaccion='tgv_TIPEVE_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_evento)
					    from gev.tgv_tipo_evento tipeve
					    inner join segu.tusuario usu1 on usu1.id_usuario = tipeve.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipeve.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 904 (class 1255 OID 207214)
-- Dependencies: 3246 12
-- Name: ftrig_activo_fijo_rastreo(); Type: FUNCTION; Schema: gev; Owner: -
--

CREATE FUNCTION ftrig_activo_fijo_rastreo() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
    Pid_empleado	   		INTEGER;
    Pempleado				VARCHAR;
    Pid_ultimo_registro 	INTEGER;
    Pid_activo_fijo			INTEGER;
    Pcodigo_iboton			VARCHAR;
    Pcodigo_defecto			VARCHAR;
BEGIN

/***************************************************************************
 XPHS - GESTION INTERNA DE DATOS DE VEHICULOS
***************************************************************************
 SCRITP: 		ges.ftrig_activo_fijo_rastreo
 DESCRIPCION: 	Ingreso de registros a activo_fijo_rastreo
 AUTOR: 		Daniel Araki(dav)
 FECHA:			01/02/2012
 COMENTARIOS:
***************************************************************************
	1) descripcion luego
*/

Pcodigo_defecto := 'IB';
SELECT id_activo_fijo INTO Pid_activo_fijo FROM gev.tgv_activo_datos_tec WHERE MODEM_ID = NEW.aux1;

if ( Pid_activo_fijo IS NOT NULL ) then --si el codigo del activo existe, procedemos a realizar los procesos

SELECT gev.tgv_activo_fijo_ultimo_registro.id_ultimo_registro INTO Pid_ultimo_registro
FROM gev.tgv_activo_fijo_ultimo_registro
WHERE gev.tgv_activo_fijo_ultimo_registro.id_activo_fijo = Pid_activo_fijo;


--IDENTIFICACION DEL CHOFER EN BASE AL IBOTON
  if ( position(Pcodigo_defecto in NEW.mensaje) = 1) then --si el ha llegado un mensaje con el encabezado de IBOTON

    Pcodigo_iboton := substring(NEW.mensaje from '.....$'); --si sí, obtenemos el código
      --obtenemos el nombre del funcionario y su id en base al iboton
    SELECT  SEGU.tpersona.apellido_paterno || ' ' || SEGU.tpersona.nombre,
    rhum.tfuncionario.id_funcionario INTO Pempleado, Pid_empleado
    FROM SEGU.tpersona INNER JOIN rhum.tfuncionario
    ON segu.tpersona.id_persona = rhum.tfuncionario.id_persona
    INNER JOIN gev.tgv_iboton
    ON gev.tgv_iboton.id_empleado = rhum.tfuncionario.id_funcionario
    WHERE gev.tgv_iboton.codigo = Pcodigo_defecto;

  ELSE

  	SELECT gev.tgv_activo_fijo_ultimo_registro.chofer,
    gev.tgv_activo_fijo_ultimo_registro.id_funcionario INTO Pempleado, Pid_empleado
    FROM gev.tgv_activo_fijo_ultimo_registro
    WHERE gev.tgv_activo_fijo_ultimo_registro.id_activo_fijo = Pid_activo_fijo;

  end if;

  if (  Pid_ultimo_registro IS NULL) THEN
  	SELECT MAX(id_ultimo_registro) INTO pid_ultimo_registro FROM gev.tgv_activo_fijo_ultimo_registro;

    IF ( Pid_ultimo_registro IS NULL) THEN
      Pid_ultimo_registro := 0;
    ELSE
      Pid_ultimo_registro := Pid_ultimo_registro + 1;
    END IF;

  	INSERT INTO gev.tgv_activo_fijo_ultimo_registro
    (id_usuario_reg,id_usuario_mod,fecha_reg,fecha_mod,estado_reg,id_ultimo_registro,fecha_satelite,latitud,longitud,velocidad,curso,id_funcionario,chofer,id_activo_fijo,aux1,aux2,aux3,aux4,punto_cercano)
    VALUES
    (NULL, NULL, now(),now(),null, Pid_ultimo_registro, new.fecha_satelite, new.latitud, new.longitud,
	 new.velocidad,new.curso,Pid_empleado,Pempleado,Pid_activo_fijo,new.aux1,new.aux2,new.aux3,new.aux4,new.punto_cercano);
  else
      UPDATE gev.tgv_activo_fijo_ultimo_registro
      SET
        fecha_mod = now(),
        fecha_satelite = NEW.fecha_satelite,
        latitud = NEW.latitud,
        longitud = NEW.longitud,
        velocidad = NEW.velocidad,
        curso = NEW.curso,
        id_funcionario = Pid_empleado,
        chofer = Pempleado,
        aux1 = NEW.aux1,
        aux2 = NEW.aux2,
        aux3 = NEW.aux3,
        aux4 = NEW.aux4,
        punto_cercano = NEW.punto_cercano
      WHERE id_ultimo_registro = Pid_ultimo_registro;
  end if;

  UPDATE gev.tgv_activo_fijo_rastreo
  SET id_activo_fijo = Pid_activo_fijo
  WHERE id_activo_fijo_rastreo = NEW.id_activo_fijo_rastreo;

else
	if char_length(new.aux1)>0 then
    	raise exception 'No llego el Dato MODEM';
    else
	    raise exception 'Modem % no está registrado', NEW.aux1;
    end if;
end if;
 RETURN NEW;
END;
$_$;


SET search_path = hidro, pg_catalog;

--
-- TOC entry 905 (class 1255 OID 207215)
-- Dependencies: 13 3246
-- Name: f_thd_administrador_hidro_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_administrador_hidro_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_administrador_hidro_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_rio'
 AUTOR: 		 (rac)
 FECHA:	        31-08-2011 15:32:32
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    		integer;
	v_parametros           		record;
	v_id_requerimiento     		integer;
	v_resp		            	varchar;
	v_nombre_funcion       	 	text;
	v_mensaje_error         	text;
	v_id_administrador			integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_administrador_hidro_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_ADM_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:			mflores	
 	#FECHA:			01-09-2011
	***********************************/

	if(p_transaccion='HD_ADM_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_administrador_hidro
            (
              codigo,
              estado_reg,
              hidro,
              meteo,
              nombre,
              fecha_reg,
              id_usuario_reg,
              fecha_mod,
              id_usuario_mod
          	) 
            values
            (
              v_parametros.codigo,
              'activo',
              v_parametros.hidro,
              v_parametros.meteo,
              v_parametros.nombre,
              now(),
              p_id_usuario,
              null,
              null
			)RETURNING id_administrador into v_id_administrador;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','ADMINISTRADOR almacenado(a) con exito (id_rio'||v_id_administrador||')'); 
            v_resp = f_agrega_clave(v_resp,'id_administrador',v_id_administrador::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_ADM_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:			mflores	
 	#FECHA:			01-09-2011
	***********************************/

	elsif(p_transaccion='HD_ADM_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_administrador_hidro set
			codigo = v_parametros.codigo,
            hidro = v_parametros.hidro,
			meteo = v_parametros.meteo,
			nombre = v_parametros.nombre,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_administrador =v_parametros.id_administrador;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','ADMINISTRADOR modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_administrador',v_parametros.id_administrador::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_ADM_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:			mflores	
 	#FECHA:			01-09-2011	
	***********************************/

	elsif(p_transaccion='HD_ADM_ELI')then

		begin
                
            --Sentencia de la eliminacion
			--delete from hidro.thd_administrador_hidro

            --mflores 03-10-11 estado inactivo en vez de eliminar el registro
            UPDATE hidro.thd_administrador_hidro
            SET estado_reg = 'inactivo'
            where id_administrador = v_parametros.id_administrador;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','ADMINISTRADOR eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_administrador',v_parametros.id_administrador::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 906 (class 1255 OID 207216)
-- Dependencies: 3246 13
-- Name: f_thd_administrador_hidro_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_administrador_hidro_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_administrador_hidro_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'hidro.thd_administrador_hidro'
 AUTOR: 		mflores
 FECHA:	        01-09-2011
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_administrador_hidro_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_ADM_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			mflores	
 	#FECHA:			01-09-2011
	***********************************/

	if(p_transaccion='HD_ADM_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						admhd.id_administrador,
						admhd.codigo,
                        admhd.estado_reg,
                        admhd.hidro,
                        admhd.meteo,
                        admhd.nombre,
                        admhd.fecha_reg,
                        admhd.id_usuario_reg,
                        admhd.fecha_mod,
                        admhd.id_usuario_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod
						from hidro.thd_administrador_hidro admhd
						inner join segu.tusuario usu1 on usu1.id_usuario = admhd.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = admhd.id_usuario_mod
				        where admhd.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_ADM_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:			mflores	
 	#FECHA:			01-09-2011
	***********************************/

	elsif(p_transaccion='HD_ADM_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_administrador)
					    from hidro.thd_administrador_hidro admhd
					    inner join segu.tusuario usu1 on usu1.id_usuario = admhd.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = admhd.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 908 (class 1255 OID 207217)
-- Dependencies: 13 3246
-- Name: f_thd_archivo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_archivo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_archivo_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_archivo'
 AUTOR: 		 (mflores)
 FECHA:	        23-11-2011 09:50:28
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_archivo	integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_archivo_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_ARCHIV_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:28
	***********************************/

	if(p_transaccion='HD_ARCHIV_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_archivo(
			id_operador,
			archivo_temp,
			nombre_archivo_real,
			fecha,
			id_tipo_archivo,
			estado_reg,
			obs,
			id_usuario_reg,
			fecha_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			v_parametros.id_operador,
			v_parametros.archivo_temp,
			v_parametros.nombre_archivo_real,
			v_parametros.fecha,
			v_parametros.id_tipo_archivo,
			'activo',
			v_parametros.obs,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_archivo into v_id_archivo;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Archivo almacenado(a) con exito (id_archivo'||v_id_archivo||')'); 
            v_resp = f_agrega_clave(v_resp,'id_archivo',v_id_archivo::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_ARCHIV_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:28
	***********************************/

	elsif(p_transaccion='HD_ARCHIV_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_archivo set
			id_operador = v_parametros.id_operador,
			archivo_temp = v_parametros.archivo_temp,
			nombre_archivo_real = v_parametros.nombre_archivo_real,
			fecha = v_parametros.fecha,
			id_tipo_archivo = v_parametros.id_tipo_archivo,
			obs = v_parametros.obs,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_archivo=v_parametros.id_archivo;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Archivo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_archivo',v_parametros.id_archivo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_ARCHIV_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:28
	***********************************/

	elsif(p_transaccion='HD_ARCHIV_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from hidro.thd_archivo
            where id_archivo=v_parametros.id_archivo;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Archivo eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_archivo',v_parametros.id_archivo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 909 (class 1255 OID 207218)
-- Dependencies: 13 3246
-- Name: f_thd_archivo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_archivo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_archivo_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_archivo'
 AUTOR: 		 (mflores)
 FECHA:	        23-11-2011 09:50:28
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_archivo_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_ARCHIV_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:28
	***********************************/

	if(p_transaccion='HD_ARCHIV_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						archiv.id_archivo,
						archiv.id_operador,
						archiv.archivo_temp,
						archiv.nombre_archivo_real,
						archiv.fecha,
						archiv.id_tipo_archivo,
						archiv.estado_reg,
						archiv.obs,
						archiv.id_usuario_reg,
						archiv.fecha_reg,
						archiv.fecha_mod,
						archiv.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from hidro.thd_archivo archiv
						inner join segu.tusuario usu1 on usu1.id_usuario = archiv.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = archiv.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_ARCHIV_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:28
	***********************************/

	elsif(p_transaccion='HD_ARCHIV_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_archivo)
					    from hidro.thd_archivo archiv
					    inner join segu.tusuario usu1 on usu1.id_usuario = archiv.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = archiv.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 910 (class 1255 OID 207219)
-- Dependencies: 13 3246
-- Name: f_thd_archivo_sensor_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_archivo_sensor_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_archivo_sensor_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_archivo_sensor'
 AUTOR: 		 (mflores)
 FECHA:	        23-11-2011 09:50:23
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_archivo_sensor	integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_archivo_sensor_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_ARSEN_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:23
	***********************************/

	if(p_transaccion='HD_ARSEN_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_archivo_sensor(
			id_sensor,
			orden,
			id_tipo_archivo,
			estado_reg,
			nombre_col_file,
			id_usuario_reg,
			fecha_reg,
			fecha_mod,
			id_usuario_mod,
            orden_col_fecha,
            nombre_col_fecha,
            orden_col_hora,
            nombre_col_hora
          	) values(
			v_parametros.id_sensor,
			v_parametros.orden,
			v_parametros.id_tipo_archivo,
			'activo',
			v_parametros.nombre_col_file,
			p_id_usuario,
			now(),
			null,
			null,
            v_parametros.orden_col_fecha,
            v_parametros.nombre_col_fecha,
            v_parametros.orden_col_hora,
            v_parametros.nombre_col_hora
			)RETURNING id_archivo_sensor into v_id_archivo_sensor;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Archivo Sensor almacenado(a) con exito (id_archivo_sensor'||v_id_archivo_sensor||')'); 
            v_resp = f_agrega_clave(v_resp,'id_archivo_sensor',v_id_archivo_sensor::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_ARSEN_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:23
	***********************************/

	elsif(p_transaccion='HD_ARSEN_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_archivo_sensor set
			id_sensor = v_parametros.id_sensor,
			orden = v_parametros.orden,
			id_tipo_archivo = v_parametros.id_tipo_archivo,
			nombre_col_file = v_parametros.nombre_col_file,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario,
            orden_col_fecha = v_parametros.orden_col_fecha,
            nombre_col_fecha = v_parametros.nombre_col_fecha,
            orden_col_hora = v_parametros.orden_col_hora,
            nombre_col_hora = v_parametros.nombre_col_hora
			where id_archivo_sensor=v_parametros.id_archivo_sensor;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Archivo Sensor modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_archivo_sensor',v_parametros.id_archivo_sensor::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_ARSEN_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:23
	***********************************/

	elsif(p_transaccion='HD_ARSEN_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from hidro.thd_archivo_sensor
            where id_archivo_sensor=v_parametros.id_archivo_sensor;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Archivo Sensor eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_archivo_sensor',v_parametros.id_archivo_sensor::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 911 (class 1255 OID 207220)
-- Dependencies: 13 3246
-- Name: f_thd_archivo_sensor_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_archivo_sensor_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_archivo_sensor_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_archivo_sensor'
 AUTOR: 		 (mflores)
 FECHA:	        23-11-2011 09:50:23
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_archivo_sensor_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_ARSEN_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:23
	***********************************/

	if(p_transaccion='HD_ARSEN_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						arsen.id_archivo_sensor,
						arsen.id_sensor,
						arsen.orden,
						arsen.id_tipo_archivo,
						arsen.estado_reg,
						arsen.nombre_col_file,
						arsen.id_usuario_reg,
						arsen.fecha_reg,
						arsen.fecha_mod,
						arsen.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        sen.codigo,
                        arsen.orden_col_fecha,
                        arsen.nombre_col_fecha,
                        arsen.orden_col_hora,
                        arsen.nombre_col_hora
						from hidro.thd_archivo_sensor arsen
						inner join segu.tusuario usu1 on usu1.id_usuario = arsen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = arsen.id_usuario_mod
                        inner join hidro.thd_tipo_archivo tipar on tipar.id_tipo_archivo = arsen.id_tipo_archivo
                        inner join hidro.thd_sensor sen on sen.id_sensor = arsen.id_sensor
				        where arsen.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_ARSEN_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:23
	***********************************/

	elsif(p_transaccion='HD_ARSEN_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_archivo_sensor)
					    from hidro.thd_archivo_sensor arsen
					    inner join segu.tusuario usu1 on usu1.id_usuario = arsen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = arsen.id_usuario_mod
                        inner join hidro.thd_tipo_archivo tipar on tipar.id_tipo_archivo = arsen.id_tipo_archivo
					    where arsen.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 912 (class 1255 OID 207221)
-- Dependencies: 3246 13
-- Name: f_thd_cuenca_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_cuenca_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		idro.ft_cuenca_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, 
 				modificaciones, eliminaciones de la tabla 'hidro.thd_cuenca'
 AUTOR: 		mflores
 FECHA:	        31-08-2011 10:20
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
    v_id_cuenca				integer;
    v_codigo_largo 			varchar;
    g_registros				record;
    v_sw					integer; 
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_cuenca_ime';
    v_parametros = f_get_record(p_tabla);
    
    --raise notice 'param: %',v_parametros;

	/*********************************    
 	#TRANSACCION:  'HID_CUENCA_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:			mflores	
 	#FECHA:			31-08-2011 10:20
	***********************************/

	if(p_transaccion='HID_CUENCA_INS')then
					
        begin
        
           --obtiene codigo recursivamente
            IF v_parametros.id_cuenca_fk is null THEN
               v_codigo_largo = v_parametros.codigo;
               raise notice 'cod_largo: %',v_codigo_largo;
            ELSE
            
             WITH RECURSIVE t(id,id_fk,cod,n) AS 
             (
                 SELECT l.id_cuenca,
                 		l.id_cuenca_fk, 
                        l.codigo,1 
                 FROM hidro.thd_cuenca l 
                 WHERE l.id_cuenca = v_parametros.id_cuenca_fk
                 UNION ALL
                 SELECT l.id_cuenca,
                 		l.id_cuenca_fk, 
                        l.codigo, 
                        n+1
                 FROM hidro.thd_cuenca l, t
                 WHERE l.id_cuenca = t.id_fk
            )
            SELECT textcat_all(a.cod||'.')
            into  v_codigo_largo
            FROM (SELECT  cod
                  FROM t 
                 order by n desc)  a;
                                  
               v_codigo_largo = v_codigo_largo||v_parametros.codigo;
            END IF;
            
            
        	--Sentencia de la insercion
        	insert into hidro.thd_cuenca
            (
              id_cuenca_fk,
              tipo_cuenca,
              nombre,
              codigo,
              codigo_largo,
              estado_reg,
              id_usuario_reg,
              id_usuario_mod,
              fecha_reg,			
              fecha_mod
          	) 
            values
            (
              v_parametros.id_cuenca_fk,
              v_parametros.tipo_cuenca,
              v_parametros.nombre,
              v_parametros.codigo,
              v_codigo_largo,
              'activo',
              p_id_usuario,
              null,
              now(),
              null  
            )RETURNING id_cuenca into v_id_cuenca;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Cuenca almacenado(a) con exito (id_cuenca'||v_id_cuenca||')'); 
            v_resp = f_agrega_clave(v_resp,'id_cuenca',v_id_cuenca::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HID_CUENCA_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:			mflores
 	#FECHA:			31-08-2011 11:20
	***********************************/

	elsif(p_transaccion='HID_CUENCA_MOD')then

		begin
        	
        	v_sw = 0;
            
            --raise exception  'PRUEBAa';
        
        	/*FOR g_registros in EXECUTE('select codigo from hidro.thd_cuenca') LOOP
            	
				IF (v_parametros.codigo = g_registros.codigo) THEN
                	
                	v_sw = 1; 
                    raise notice 'v_sw: %',v_sw;
                
                END IF;
            
            END LOOP;	
            
            IF (v_sw = 0) THEN*/
                                       
                --obtiene codigo recursivamente
                IF v_parametros.id_cuenca_fk is null THEN
                   v_codigo_largo = v_parametros.codigo;
                   raise notice 'cod_largo: %',v_codigo_largo;
                ELSE
                
                 WITH RECURSIVE t(id,id_fk,cod,n) AS 
                 (
                     SELECT l.id_cuenca,
                            l.id_cuenca_fk, 
                            l.codigo,1 
                     FROM hidro.thd_cuenca l 
                     WHERE l.id_cuenca = v_parametros.id_cuenca_fk
                     UNION ALL
                     SELECT l.id_cuenca,
                            l.id_cuenca_fk, 
                            l.codigo, 
                            n+1
                     FROM hidro.thd_cuenca l, t
                     WHERE l.id_cuenca = t.id_fk
                )
                SELECT textcat_all(a.cod||'.')
                into  v_codigo_largo
                FROM (SELECT  cod
                      FROM t 
                     order by n desc)  a;
                                      
                   v_codigo_largo = v_codigo_largo||v_parametros.codigo;
                END IF;
            
           
                --Sentencia de la modificacion
                update hidro.thd_cuenca set
                id_cuenca_fk = v_parametros.id_cuenca_fk,
                tipo_cuenca = v_parametros.tipo_cuenca,			
                nombre = v_parametros.nombre,
                fecha_mod = now(),
                codigo=v_parametros.codigo,
                id_usuario_mod = p_id_usuario,
                codigo_largo=v_codigo_largo
                where id_cuenca=v_parametros.id_cuenca;
                   
                --Definicion de la respuesta
                v_resp = f_agrega_clave(v_resp,'mensaje','Cuenca modificado(a)'); 
                v_resp = f_agrega_clave(v_resp,'id_cuenca',v_parametros.id_cuenca::varchar);
            /*
            ELSE
            	
                v_resp='';
                v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
                v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
                v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
                raise exception '%',v_resp;

            END IF;*/
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HID_CUENCA_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:			mflores	
 	#FECHA:			31-08-2011 11:36
	***********************************/

	elsif(p_transaccion='HID_CUENCA_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from hidro.thd_cuenca
            where id_cuenca=v_parametros.id_cuenca;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Cuenca eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_cuenca',v_parametros.id_cuenca::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 1842 (class 1255 OID 207223)
-- Dependencies: 3246 13
-- Name: f_thd_cuenca_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_cuenca_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		hidro.ft_cuenca_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'hidro.thd_cuenca'
 AUTOR: 		mflores
 FECHA:	        30-08-2011 18:38
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_where varchar;
    v_join varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_cuenca_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HID_CUENCA_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			mflores	
 	#FECHA:			30-08-2011 18:38
	***********************************/

	if(p_transaccion='HID_CUENCA_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						hid.id_cuenca,
						hid.id_cuenca_fk,
						hid.tipo_cuenca,
						hid.nombre,	
                        hid.codigo,
                        hid.codigo_largo,
                        hid.estado_reg,
            			hid.id_usuario_reg,
                        hid.id_usuario_mod,
						hid.fecha_reg,
						hid.fecha_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod				
							
						from hidro.thd_cuenca hid
                        inner join segu.tusuario usu1 on usu1.id_usuario = hid.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = hid.id_usuario_mod                        					
				        						
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;
        
        /*********************************    
        #TRANSACCION:  'HID_CUENCA_SEL'
        #DESCRIPCION:	Consulta de datos
        #AUTOR:			mflores	
        #FECHA:			30-08-2011 18:38
        ***********************************/
        elsif p_transaccion = 'HID_CUENCACOM_SEL' then

        begin
        	v_consulta:='SELECT cu.id_cuenca,
            					cu.id_cuenca_fk,
                                cu.tipo_cuenca,
                                cu.nombre,
                                cu.codigo,
                                cu.codigo_largo
                        FROM hidro.thd_cuenca cu
                        inner join segu.tusuario usu1 on usu1.id_usuario = cu.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = cu.id_usuario_mod
                        where cu.tipo_cuenca = ''Microcuenca'' and ';
                        
            v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:=v_consulta||' order by cu.nombre limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            return v_consulta;
        end;
        
        elsif(p_transaccion='HID_CUENCACOM_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_cuenca)
					    from hidro.thd_cuenca cu
					    inner join segu.tusuario usu1 on usu1.id_usuario = cu.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = cu.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
        
     /*********************************    
 	#TRANSACCION:  'HID_CUENCA_ARB_SEL'
 	#DESCRIPCION:	Consulta de datos
        #AUTOR:		mflores	
 	#FECHA:			30-08-2011 18:38
	***********************************/

	elseif(p_transaccion='HID_CUENCA_ARB_SEL')then
     				
    	begin
        
              if(v_parametros.id_padre = '%') then
                v_where := ' hid.id_cuenca_fk is NULL';
                 v_join:= 'LEFT';      
                      
              else
                v_where := ' hid.id_cuenca_fk = '||v_parametros.id_padre;
                v_join := 'INNER';
              end if;
        
        
    		--Sentencia de la consulta
			v_consulta:='select
						hid.id_cuenca,
						hid.id_cuenca_fk,
						hid.tipo_cuenca,
						hid.nombre,		
                        hid.codigo,
                        hid.codigo_largo,
                        hid.estado_reg,
            			hid.id_usuario_reg,
                        hid.id_usuario_mod,
						hid.fecha_reg,
						hid.fecha_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod
						from hidro.thd_cuenca hid	
					    inner join segu.tusuario usu1 on usu1.id_usuario = hid.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = hid.id_usuario_mod                        					
				        where  '||v_where|| '  
                        ORDER BY hid.id_cuenca';
			
			
			--Devuelve la respuesta
			return v_consulta;
						
		end;   

	/*********************************    
 	#TRANSACCION:  'HID_CUENCA_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		30-08-11
	***********************************/

	elsif(p_transaccion='HID_CUENCA_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_cuenca)
					    from hidro.thd_cuenca cu
					    inner join segu.tusuario usu1 on usu1.id_usuario = cu.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = cu.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 913 (class 1255 OID 207224)
-- Dependencies: 13 3246
-- Name: f_thd_estacion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_estacion_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_estacion_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_estacion'
 AUTOR: 		mflores
 FECHA:	        05-09-2011 10:30:01
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_estacion			integer;
    
    v_sensor				integer;
    v_coord_lat				text[];
    v_coord_long			text[];
    v_grados_lat			numeric;
    v_min_lat				numeric;
    v_seg_lat				numeric;
    v_orientacion_lat		text;
    v_latitud				numeric;
    
    v_grados_lon			numeric;
    v_min_lon				numeric;
    v_seg_lon				numeric;
    v_orientacion_lon		text;
    v_longitud				numeric;
    
    vec_proy				text[];
    tam_vec_proy			numeric;
    v_i 					integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_estacion_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_EST_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	if(p_transaccion='HD_EST_INS')then
        
    --CALCULOS PARA LATITUD
    v_coord_lat := string_to_array(v_parametros.latitud_carto,'°');
    v_grados_lat := v_coord_lat[1]::numeric;
    
    v_coord_lat := string_to_array(v_coord_lat[2],'''');
    v_min_lat := v_coord_lat[1]::numeric;
    
    v_coord_lat := string_to_array(v_coord_lat[2],'"');
    v_seg_lat := v_coord_lat[1]::numeric;
    v_orientacion_lat := v_coord_lat[2];
    
    v_latitud := (v_grados_lat + (v_min_lat / 60) + (v_seg_lat / 3600)); 
    
    if (v_orientacion_lat = 'S')then
    	v_latitud := v_latitud * (-1);
    
    end if;
            
        --CALCULOS PARA LONGITUD
    
    v_coord_long := string_to_array(v_parametros.longitud_carto,'°');
    v_grados_lon := v_coord_long[1]::numeric;
    
    v_coord_long := string_to_array(v_coord_long[2],'''');
    v_min_lon := v_coord_long[1]::numeric;
    
    v_coord_long := string_to_array(v_coord_long[2],'"');
    v_seg_lon := v_coord_long[1]::numeric;
    v_orientacion_lon := v_coord_long[2];
    
    v_longitud := (v_grados_lon + (v_min_lon / 60) + (v_seg_lon / 3600)); 
    
    if (v_orientacion_lon = 'O')then
    	v_longitud := v_longitud * (-1);
    
    end if;
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_estacion(
			altitud,
			codigo,
			comentario,
			direccion,
			estado,
			estado_reg,
			fecha_fin,
			fecha_ini,
			id_administrador,
			id_cuenca,
			id_lugar,
			id_rio,
			latitud_carto,
			longitud_carto,
            latitud,
            longitud,
			observador,
			superficie_cuenca,
			teletransmision,
			tipo,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod            
          	) 
            values
            (
			v_parametros.altitud,
			v_parametros.codigo,
			v_parametros.comentario,
			v_parametros.direccion,
			v_parametros.estado,
			'activo',
			v_parametros.fecha_fin,
			v_parametros.fecha_ini,
			v_parametros.id_administrador,
			v_parametros.id_cuenca,
			v_parametros.id_lugar,
			v_parametros.id_rio,
			v_parametros.latitud_carto,
			v_parametros.longitud_carto,
            v_latitud,
            v_longitud,
			v_parametros.observador,
			v_parametros.superficie_cuenca,
			v_parametros.teletransmision,
			v_parametros.tipo,
			now(),
			p_id_usuario,
			null,
			null
			)RETURNING id_estacion into v_id_estacion;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','EstaciÃ³n almacenado(a) con exito (id_estacion'||v_id_estacion||')'); 
            v_resp = f_agrega_clave(v_resp,'id_estacion',v_id_estacion::varchar);
            
            vec_proy := string_to_array(v_parametros.id_proyectos,',');
            raise notice '%',vec_proy;
          	select array_upper(vec_proy,1) into tam_vec_proy;
          
          	FOR v_i IN 1..tam_vec_proy LOOP
               
              --insertamos  registro si no esta presente como activo
              insert into hidro.thd_estacion_proyecto
              (
              	id_proyecto, 
               	id_estacion
              ) 
              values
              (
              	vec_proy[v_i]::integer,
              	v_id_estacion
              ); 
             
            END LOOP;

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_EST_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	elsif(p_transaccion='HD_EST_MOD')then
	
    --CALCULOS PARA LATITUD            
    v_coord_lat := string_to_array(v_parametros.latitud_carto,'°');
    v_grados_lat := v_coord_lat[1]::numeric;
    
    v_coord_lat := string_to_array(v_coord_lat[2],'''');
    v_min_lat := v_coord_lat[1]::numeric;
    
    v_coord_lat := string_to_array(v_coord_lat[2],'"');
    v_seg_lat := v_coord_lat[1]::numeric;
    v_orientacion_lat := v_coord_lat[2];
    
    v_latitud := (v_grados_lat + (v_min_lat / 60) + (v_seg_lat / 3600)); 
    
    if (v_orientacion_lat = 'S')then
    	v_latitud := v_latitud * (-1);
    
    end if;
            
	--CALCULOS PARA LONGITUD    
    v_coord_long := string_to_array(v_parametros.longitud_carto,'°');
    v_grados_lon := v_coord_long[1]::numeric;
    
    v_coord_long := string_to_array(v_coord_long[2],'''');
    v_min_lon := v_coord_long[1]::numeric;
    
    v_coord_long := string_to_array(v_coord_long[2],'"');
    v_seg_lon := v_coord_long[1]::numeric;
    v_orientacion_lon := v_coord_long[2];
    
    v_longitud := (v_grados_lon + (v_min_lon / 60) + (v_seg_lon / 3600)); 
    
    if (v_orientacion_lon = 'O')then
    	v_longitud := v_longitud * (-1);
    
    end if;

		begin
			--Sentencia de la modificacion
			update hidro.thd_estacion set
			altitud = v_parametros.altitud,
			codigo = v_parametros.codigo,
			comentario = v_parametros.comentario,
			direccion = v_parametros.direccion,
			estado = v_parametros.estado,
			fecha_fin = v_parametros.fecha_fin,
			fecha_ini = v_parametros.fecha_ini,
			id_administrador = v_parametros.id_administrador,
			id_cuenca = v_parametros.id_cuenca,
			id_lugar = v_parametros.id_lugar,
			id_rio = v_parametros.id_rio,
			latitud_carto = v_parametros.latitud_carto,
			longitud_carto = v_parametros.longitud_carto,
            latitud = v_latitud,
			longitud = v_longitud,
			observador = v_parametros.observador,
			superficie_cuenca = v_parametros.superficie_cuenca,
			teletransmision = v_parametros.teletransmision,
			tipo = v_parametros.tipo,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_estacion=v_parametros.id_estacion;
            
            --se obtiene un vector con los id de proyectos seleccionados            
            vec_proy := string_to_array(v_parametros.id_proyectos,',');
          	select array_upper(vec_proy,1) into tam_vec_proy;
            
            -- eliminamos todos los roles que no estan seleccionados
			delete from hidro.thd_estacion_proyecto
            where id_estacion = v_parametros.id_estacion;
			--and (id_proyecto::text != ANY(vec_proy));
          
            if (tam_vec_proy <> 0) then
            
                --insertar los id de proyecto que faltan
                FOR v_i IN 1..tam_vec_proy LOOP
                       
                    --preguntamos si el id_rol ya se encuentra asignado si no insertamos
                    IF (NOT EXISTS (select 1 from hidro.thd_estacion_proyecto
                            where id_estacion = v_parametros.id_estacion
                            and id_proyecto = vec_proy[v_i]::integer)) THEN
                                
                        --insertamos  registro si no esta presente
                        insert into hidro.thd_estacion_proyecto
                         (id_proyecto, 
                         id_estacion) 
                        values(
                        vec_proy[v_i]::integer,
                        v_parametros.id_estacion); 

                    end if;
                END LOOP;
            end if;
            
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','EstaciÃ³n modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_estacion',v_parametros.id_estacion::varchar);
               
            --Devuelve la respuesta
            return v_resp;                      
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_EST_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	elsif(p_transaccion='HD_EST_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from hidro.thd_estacion
            
            --mflores 03-10-11 estado inactivo en vez de eliminar el registro
            select id_sensor
            into v_sensor
            from hidro.thd_sensor
            where id_estacion=v_parametros.id_estacion;
            
            update hidro.thd_medicion
            SET estado_reg = 'inactivo'
            where id_sensor=v_sensor;
            
            UPDATE hidro.thd_sensor
            SET estado_reg = 'inactivo'
            where id_estacion=v_parametros.id_estacion;
            
            UPDATE hidro.thd_estacion
            SET estado_reg = 'inactivo'
            where id_estacion=v_parametros.id_estacion;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','EstaciÃ³n eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_estacion',v_parametros.id_estacion::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
        
 /*******************************
 #TRANSACCION:  HD_UPFOTOEST_MOD
 #DESCRIPCION:	Modifica la foto de la estación
 #AUTOR:		mflores		
 #FECHA:		27/10/11	
***********************************/
     elsif(p_transaccion='HD_UPFOTOEST_MOD')then

          BEGIN
               update hidro.thd_estacion
               set 
               foto=v_parametros.foto,
               extension=v_parametros.extension
               where id_estacion=v_parametros.id_estacion;
             
             v_resp = f_agrega_clave(v_resp,'mensaje','Foto de la estacion modificada con exito '||v_parametros.id_estacion); 
             v_resp = f_agrega_clave(v_resp,'id_estacion',v_parametros.id_estacion::varchar);

               
          END;        
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;
    
    return v_resp;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 914 (class 1255 OID 207226)
-- Dependencies: 3246 13
-- Name: f_thd_estacion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_estacion_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_estacion_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'hidro.thd_estacion'
 AUTOR: 		mflores
 FECHA:	        05-09-2011 10:30:01
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_addfil 			varchar;
    v_filtro			varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_estacion_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_EST_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	if(p_transaccion='HD_EST_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select est.id_estacion,
                                 est.altitud,
                                 est.codigo,
                                 est.comentario,
                                 est.direccion,
                                 est.estado,
                                 est.estado_reg,
                                 est.fecha_fin,
                                 est.fecha_ini,
                                 est.id_administrador,
                                 est.id_cuenca,
                                 est.id_lugar,
                                 est.id_rio,
                                 est.latitud,
                                 est.longitud,
                                 est.latitud_carto,
                                 est.longitud_carto,
                                 est.observador,
                                 est.superficie_cuenca,
                                 est.teletransmision,
                                 est.tipo,
                                 est.fecha_reg,
                                 est.id_usuario_reg,
                                 est.fecha_mod,
                                 est.id_usuario_mod,
                                 usu1.cuenta as usr_reg,
                                 usu2.cuenta as usr_mod,
                                 admhd.nombre as admin,
                                 cu.nombre as cuenca,
                                 lug.nombre as lugar,
                                 rio.nombre as rio,
                                 text_concat(estproy.id_proyecto::text) as id_proyectos,
                                 text_concat(proy.codigo_proyecto::text) as proyectos
                          from hidro.thd_estacion est
                               inner join hidro.thd_administrador_hidro admhd on admhd.id_administrador = est.id_administrador
                               inner join hidro.thd_rio rio on rio.id_rio = est.id_rio
                               inner join hidro.thd_cuenca cu on est.id_cuenca = cu.id_cuenca
                               inner join param.tlugar lug on lug.id_lugar = est.id_lugar
                               inner join segu.tusuario usu1 on usu1.id_usuario = est.id_usuario_reg
                               left join segu.tusuario usu2 on usu2.id_usuario = est.id_usuario_mod
                               left join hidro.thd_estacion_proyecto estproy on estproy.id_estacion = est.id_estacion
                               left join param.tpm_proyecto proy on proy.id_proyecto = estproy.id_proyecto
				        where est.estado_reg = ''activo'' and ';  
                        
                        v_consulta:=v_consulta||v_parametros.filtro;              
               			v_consulta:=v_consulta||' group by est.id_estacion,
                                                           est.altitud,
                                                           est.codigo,
                                                           est.comentario,
                                                           est.direccion,
                                                           est.estado,
                                                           est.estado_reg,
                                                           est.fecha_fin,
                                                           est.fecha_ini,
                                                           est.id_administrador,
                                                           est.id_cuenca,
                                                           est.id_lugar,
                                                           est.id_rio,
                                                           est.latitud,
                                                           est.longitud,
                                                           est.latitud_carto,
                                                           est.longitud_carto,
                                                           est.observador,
                                                           est.superficie_cuenca,
                                                           est.teletransmision,
                                                           est.tipo,
                                                           est.fecha_reg,
                                                           est.id_usuario_reg,
                                                           est.fecha_mod,
                                                           est.id_usuario_mod,
                                                           usr_reg,
                                                           usr_mod,
                                                           admin,
                                                           cuenca,
                                                           lugar,
                                                           rio';
          
			--Definicion de la respuesta
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_EST_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	elsif(p_transaccion='HD_EST_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(est.id_estacion)
					    from hidro.thd_estacion est 
                        inner join hidro.thd_cuenca cu on est.id_cuenca = cu.id_cuenca                     
					    inner join segu.tusuario usu1 on usu1.id_usuario = est.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = est.id_usuario_mod
                      --  left join hidro.thd_estacion_proyecto estproy on estproy.id_estacion = est.id_estacion
                            
					    where est.estado_reg = ''activo'' and';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;
--            v_consulta:=v_consulta||' group by est.id_estacion';

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	/*********************************    
 	#TRANSACCION:  'HD_ESTPRO_SEL'
 	#DESCRIPCION:	Consulta estaciones segun vector de proyectos
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	elsif(p_transaccion='HD_ESTPRO_SEL')then
     				
    	begin
        
            --si no existe el parametro id_proyectos sacamos un error
             v_addfil='0';
            if(f_existe_parametro(p_tabla,'id_proyectos'))THEN
                
              if(v_parametros.id_proyectos!='')then
                 v_addfil=v_parametros.id_proyectos;
              else
                v_addfil='0';
              
              end if;

            END IF;

    		--Sentencia de la consulta
			v_consulta:='select est.id_estacion,
                                 est.altitud,
                                 est.codigo,
                                 est.comentario,
                                 est.direccion,
                                 est.estado,
                                 est.estado_reg,
                                 est.fecha_fin,
                                 est.fecha_ini,
                                 est.id_administrador,
                                 est.id_cuenca,
                                 est.id_lugar,
                                 est.id_rio,
                                 est.latitud,
                                 est.longitud,
                                 est.latitud_carto,
                                 est.longitud_carto,
                                 est.observador,
                                 est.superficie_cuenca,
                                 est.teletransmision,
                                 est.tipo,
                                 est.fecha_reg,
                                 est.id_usuario_reg,
                                 est.fecha_mod,
                                 est.id_usuario_mod,
                                 usu1.cuenta as usr_reg,
                                 usu2.cuenta as usr_mod,
                                 admhd.nombre as admin,
                                 cu.nombre as cuenca,
                                 lug.nombre as lugar,
                                 rio.nombre as rio,
                                 text_concat(estproy.id_proyecto::text) as id_proyectos,
                                 text_concat(proy.codigo_proyecto::text) as proyectos
                          from hidro.thd_estacion est
                               inner join hidro.thd_administrador_hidro admhd on admhd.id_administrador = est.id_administrador
                               inner join hidro.thd_rio rio on rio.id_rio = est.id_rio
                               inner join hidro.thd_cuenca cu on est.id_cuenca = cu.id_cuenca
                               inner join param.tlugar lug on lug.id_lugar = est.id_lugar
                               inner join segu.tusuario usu1 on usu1.id_usuario = est.id_usuario_reg
                               left join segu.tusuario usu2 on usu2.id_usuario = est.id_usuario_mod
                               inner join hidro.thd_estacion_proyecto estproy on estproy.id_estacion = est.id_estacion AND estproy.id_proyecto in ('||v_addfil||')
                               left join param.tpm_proyecto proy on proy.id_proyecto = estproy.id_proyecto
                              
				        where est.estado_reg = ''activo'' and ';  
                        
                        v_consulta:=v_consulta||v_parametros.filtro;              
               			v_consulta:=v_consulta||' group by est.id_estacion,
                                                           est.altitud,
                                                           est.codigo,
                                                           est.comentario,
                                                           est.direccion,
                                                           est.estado,
                                                           est.estado_reg,
                                                           est.fecha_fin,
                                                           est.fecha_ini,
                                                           est.id_administrador,
                                                           est.id_cuenca,
                                                           est.id_lugar,
                                                           est.id_rio,
                                                           est.latitud,
                                                           est.longitud,
                                                           est.latitud_carto,
                                                           est.longitud_carto,
                                                           est.observador,
                                                           est.superficie_cuenca,
                                                           est.teletransmision,
                                                           est.tipo,
                                                           est.fecha_reg,
                                                           est.id_usuario_reg,
                                                           est.fecha_mod,
                                                           est.id_usuario_mod,
                                                           usr_reg,
                                                           usr_mod,
                                                           admin,
                                                           cuenca,
                                                           lugar,
                                                           rio';
          
			--Definicion de la respuesta
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
raise notice '%',v_consulta;
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_ESTRO_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	elsif(p_transaccion='HD_ESTPRO_CONT')then

		begin
        
               v_addfil='0';
            if(f_existe_parametro(p_tabla,'id_proyectos'))THEN
                
              if(v_parametros.id_proyectos!='')then
                 v_addfil=v_parametros.id_proyectos;
              else
                v_addfil='0';
              
              end if;

            END IF;
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(est.id_estacion)
					    from hidro.thd_estacion est 
                        inner join hidro.thd_cuenca cu on est.id_cuenca = cu.id_cuenca                     
					    inner join segu.tusuario usu1 on usu1.id_usuario = est.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = est.id_usuario_mod
                        inner join hidro.thd_estacion_proyecto estproy 
                        on estproy.id_estacion = est.id_estacion AND
                                estproy.id_proyecto in ('||v_addfil||')

					    where est.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;
           
        

			--Devuelve la respuesta
			return v_consulta;

		end;
        
    /*********************************    
 	#TRANSACCION:  'HD_PROEST_SEL'
 	#DESCRIPCION:	Consulta estaciones segun vector de proyectos
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	elsif(p_transaccion='HD_PROEST_SEL')then
     				
    	begin
        
        --raise notice '%',v_parametros.id_proyectos;  
        v_addfil='0';
        
        if(f_existe_parametro(p_tabla,'id_proyectos'))THEN
                
          if(v_parametros.id_proyectos!='')then
             v_addfil=v_parametros.id_proyectos;
          else
            v_addfil='0';
          
          end if;
              
        end if;
        
        
        if (select strpos(v_parametros.id_proyectos, '00000') > 0) then --todos los proyectos
            
            v_parametros.filtro = 'est.id_estacion::varchar like ''%'' and ' || v_parametros.filtro;
            v_filtro = 'inner join hidro.thd_estacion_proyecto estproy on estproy.id_estacion = est.id_estacion AND estproy.id_proyecto::varchar like ''%''';

        else
        	if (v_parametros.id_proyectos <> '') then --de acuerdo a la seleccion
            	v_filtro = 'inner join hidro.thd_estacion_proyecto estproy on estproy.id_estacion = est.id_estacion AND estproy.id_proyecto in ('||v_parametros.id_proyectos||')';
        
        	else
        		v_filtro = 'inner join hidro.thd_estacion_proyecto estproy on estproy.id_estacion = est.id_estacion AND estproy.id_proyecto in ('||v_addfil||')';
            end if;

        end if;           

    		--Sentencia de la consulta
			v_consulta:='select est.id_estacion,
                                 est.altitud,
                                 est.codigo,
                                 est.comentario,
                                 est.direccion,
                                 est.estado,
                                 est.estado_reg,
                                 est.fecha_fin,
                                 est.fecha_ini,
                                 est.id_administrador,
                                 est.id_cuenca,
                                 est.id_lugar,
                                 est.id_rio,
                                 est.latitud,
                                 est.longitud,
                                 est.latitud_carto,
                                 est.longitud_carto,
                                 est.observador,
                                 est.superficie_cuenca,
                                 est.teletransmision,
                                 est.tipo,
                                 est.fecha_reg,
                                 est.id_usuario_reg,
                                 est.fecha_mod,
                                 est.id_usuario_mod,
                                 usu1.cuenta as usr_reg,
                                 usu2.cuenta as usr_mod,
                                 admhd.nombre as admin,
                                 cu.nombre as cuenca,
                                 lug.nombre as lugar,
                                 rio.nombre as rio,
                                 text_concat(estproy.id_proyecto::text) as id_proyectos,
                                 text_concat(proy.codigo_proyecto::text) as proyectos
                          from hidro.thd_estacion est
                               inner join hidro.thd_administrador_hidro admhd on admhd.id_administrador = est.id_administrador
                               inner join hidro.thd_rio rio on rio.id_rio = est.id_rio
                               inner join hidro.thd_cuenca cu on est.id_cuenca = cu.id_cuenca
                               inner join param.tlugar lug on lug.id_lugar = est.id_lugar
                               inner join segu.tusuario usu1 on usu1.id_usuario = est.id_usuario_reg
                               left join segu.tusuario usu2 on usu2.id_usuario = est.id_usuario_mod
                               '|| v_filtro ||'
                               left join param.tpm_proyecto proy on proy.id_proyecto = estproy.id_proyecto
                              
				        where est.estado_reg = ''activo'' and ';  
                        
                        v_consulta:=v_consulta||v_parametros.filtro;              
               			v_consulta:=v_consulta||' group by est.id_estacion,
                                                           est.altitud,
                                                           est.codigo,
                                                           est.comentario,
                                                           est.direccion,
                                                           est.estado,
                                                           est.estado_reg,
                                                           est.fecha_fin,
                                                           est.fecha_ini,
                                                           est.id_administrador,
                                                           est.id_cuenca,
                                                           est.id_lugar,
                                                           est.id_rio,
                                                           est.latitud,
                                                           est.longitud,
                                                           est.latitud_carto,
                                                           est.longitud_carto,
                                                           est.observador,
                                                           est.superficie_cuenca,
                                                           est.teletransmision,
                                                           est.tipo,
                                                           est.fecha_reg,
                                                           est.id_usuario_reg,
                                                           est.fecha_mod,
                                                           est.id_usuario_mod,
                                                           usr_reg,
                                                           usr_mod,
                                                           admin,
                                                           cuenca,
                                                           lugar,
                                                           rio';
          
			--Definicion de la respuesta
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			
            raise notice '%',v_consulta;
            
			--Devuelve la respuesta
			return v_consulta;                
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_PROEST_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		05-09-2011 10:30:01
	***********************************/

	elsif(p_transaccion='HD_PROEST_CONT')then

		begin
        
               v_addfil='0';
            if(f_existe_parametro(p_tabla,'id_proyectos'))THEN
                
              if(v_parametros.id_proyectos!='')then
                 v_addfil=v_parametros.id_proyectos;
              else
                v_addfil='0';
              
              end if;

            END IF;
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(est.id_estacion)
					    from hidro.thd_estacion est 
                        inner join hidro.thd_cuenca cu on est.id_cuenca = cu.id_cuenca                     
					    inner join segu.tusuario usu1 on usu1.id_usuario = est.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = est.id_usuario_mod
                        inner join hidro.thd_estacion_proyecto estproy 
                        on estproy.id_estacion = est.id_estacion AND
                                estproy.id_proyecto in ('||v_addfil||')

					    where est.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;                 

			--Devuelve la respuesta
			return v_consulta;

		end;
    
	/*********************************    
 	#TRANSACCION:  'HD_OBTFOTOEST_SEL'
 	#DESCRIPCION:	Obtiene la foto de una estación
 	#AUTOR:		rac	
 	#FECHA:		09-11-2011 10:30:01
	***********************************/

	elseif(p_transaccion='HD_OBTFOTOEST_SEL')then
     				
   	begin
    		--Sentencia de la consulta
			v_consulta:='SELECT est.id_estacion,
                                est.foto,
                                est.extencion
                         FROM hidro.thd_estacion est
                         WHERE est.estado_reg = ''activo'' and est.id_estacion = '||v_parametros.id_estacion;  
               			                    	
     end;
    else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 915 (class 1255 OID 207228)
-- Dependencies: 13 3246
-- Name: f_thd_medame_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_medame_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_medame_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, 
 				eliminaciones de la tabla 'hidro.thd_medicion'
 AUTOR: 		(mflores)
 FECHA:	        07-09-2011 15:50:29
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_medicion			integer;
    v_id_dato_medida		integer;
    
    --para insercion de CSV 
    v_tabla					varchar;
    v_consulta    			varchar;
	v_resultado				text[];
    
    v_registros				record;
    v_id_operador			integer;
    v_aux					varchar;	
    v_titulo				VARCHAR[];				
	--fin
    		    
BEGIN
	
	--para insercion de CSV 
    v_tabla := 'tt_excel';
    --fin

    v_nombre_funcion = 'hidro.f_thd_medame_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_MEDAME_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:			mflores	
 	#FECHA:			07-09-2011 15:50:29
	***********************************/

	if(p_transaccion='HD_MEDAME_INS')then
		
     begin
    	                                                
            --Sentencia de la insercion
            insert into hidro.thd_medicion
            (
                --id_tipo_medicion,
                id_sensor,
                id_operador,  
                hora_medida,     
                fecha_medida,
                --fecha_fin,                
                valor_numeric,                
                estado_reg,
                fecha_reg,
                id_usuario_reg,
                fecha_mod,
                id_usuario_mod                   
            ) 
            values
            (
                --v_parametros.id_tipo_medicion,
                v_parametros.id_sensor,
                v_parametros.id_operador,  
                v_parametros.hora_medida, 
                v_parametros.fecha_medida,     
               -- v_parametros.fecha_fin,                             
                v_parametros.valor_numeric,                
                'activo',
                now(),
                p_id_usuario,
                null,
                null                           
            )RETURNING id_medicion into v_id_medicion;                          
        
        --Definicion de la respuesta
		v_resp = f_agrega_clave(v_resp,'mensaje','MediciÃ³n almacenado(a) con exito (id_medicion'||v_id_medicion||')'); 
        v_resp = f_agrega_clave(v_resp,'id_medicion',v_id_medicion::varchar);

        --Devuelve la respuesta
         return v_resp;
        
		end;

	/*********************************    
 	#TRANSACCION:  'HD_MEDAME_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	elsif(p_transaccion='HD_MEDAME_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_medicion 
            	set			
                    id_sensor = v_parametros.id_sensor,
                    id_operador = v_parametros.id_operador,
                    fecha_medida = v_parametros.fecha_medida,
                    --fecha_fin = v_parametros.fecha_fin,
                    hora_medida = v_parametros.hora_medida,
                    valor_numeric = v_parametros.valor_numeric,                  
                    fecha_mod = now(),
                    id_usuario_mod = p_id_usuario
				
                where id_medicion = v_parametros.id_medicion;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','MediciÃ³n modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_medicion',v_parametros.id_medicion::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_MED_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	elsif(p_transaccion='HD_MEDAME_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from hidro.thd_medicion
            
            --mflores 03-10-11 estado inactivo en vez de eliminar el registro
            UPDATE hidro.thd_medicion
            SET estado_reg = 'inactivo'
            where id_medicion=v_parametros.id_medicion;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','MediciÃ³n eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_medicion',v_parametros.id_medicion::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
    /*********************************    
 	#TRANSACCION:  'HD_EXL_INS'
 	#DESCRIPCION:	Insertar datos de EXCEL (CSV)
 	#AUTOR:			mflores	
 	#FECHA:			11-10-2011
	***********************************/

	elsif(p_transaccion='HD_EXL_INS')then
    
      BEGIN

       update hidro.thd_sensor set       
       medidas = v_parametros.excel
       where id_sensor = v_parametros.id_sensor;                            
       
       	v_titulo[1] := 'fecha_medida';
        v_titulo[2] := 'hora_medida';
        v_titulo[3] := 'valor_numeric';
        v_titulo[4] := 'codigo';
       
        v_consulta := 'create temp table '|| v_tabla ||' (fecha_medida date,hora_medida time,valor_numeric numeric, codigo varchar) on commit drop ';
        execute v_consulta;        		
          
        v_resultado := (select f_excel((select medidas from hidro.thd_sensor where id_sensor = v_parametros.id_sensor), v_tabla, v_titulo));
        v_consulta := 'select * from '|| v_tabla;        
        v_aux := NULL;                
                  	
        FOR v_registros in EXECUTE(v_consulta) LOOP
            
          if(v_aux = v_registros.codigo) then                    
            
            --Sentencia de la insercion
            insert into hidro.thd_medicion
            (
                --id_tipo_medicion,
                id_sensor,
                id_operador,  
                hora_medida,     
                fecha_medida,
                valor_numeric,
                estado_reg,
                fecha_reg,
                id_usuario_reg,
                fecha_mod,
                id_usuario_mod                   
            )             
            values
            (               
               -- v_parametros.id_tipo_medicion,
                v_parametros.id_sensor,
                v_id_operador,  
                v_registros.hora_medida::time,
                v_registros.fecha_medida::date,                
                v_registros.valor_numeric::numeric,                
                'activo',
                now(),
                p_id_usuario,
                null,
                null         
            );  
          
          else
          
          	v_id_operador := (select id_operador from hidro.thd_operador where codigo = v_registros.codigo);
            v_aux := v_registros.codigo;
            
            --Sentencia de la insercion
            insert into hidro.thd_medicion
            (
                --id_tipo_medicion,
                id_sensor,
                id_operador,  
                hora_medida,     
                fecha_medida,
                valor_numeric,
                estado_reg,
                fecha_reg,
                id_usuario_reg,
                fecha_mod,
                id_usuario_mod                   
            )             
            values
            (               
                --v_parametros.id_tipo_medicion,
                v_parametros.id_sensor,
                v_id_operador,  
                v_registros.hora_medida::time,
                v_registros.fecha_medida::date,                
                v_registros.valor_numeric::numeric,                
                'activo',
                now(),
                p_id_usuario,
                null,
                null         
            );
            
          end if;  
                            
       END LOOP;     
                  
       update hidro.thd_sensor set       
       medidas = NULL
       where id_sensor = v_parametros.id_sensor;
        
        --Definicion de la respuesta
        v_resp = f_agrega_clave(v_resp,'mensaje','MediciÃ³n almacenado(a) con exito (id_medicion'||v_id_medicion||')'); 
        v_resp = f_agrega_clave(v_resp,'id_medicion',v_id_medicion::varchar);

        --Devuelve la respuesta
        return v_resp;
          
      end;   
      
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 916 (class 1255 OID 207230)
-- Dependencies: 13 3246
-- Name: f_thd_medame_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_medame_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_medame_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_medicion'
 AUTOR: 		 (mflores)
 FECHA:	        07-09-2011 15:50:29
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_tabla				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_medame_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_MEDAME_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	if(p_transaccion='HD_MEDAME_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select med.id_medicion,
                                 --med.id_tipo_medicion,
                                 med.id_sensor,                                 
                                 med.id_operador,
                                 med.fecha_medida,
                                 --med.fecha_fin,  
                                 med.hora_medida,
                                 med.valor_numeric,
                                 med.estado_reg,
                                 med.fecha_reg,
                                 med.id_usuario_reg,
                                 med.fecha_mod,
                                 med.id_usuario_mod,
                                 usu1.cuenta as usr_reg,
                                 usu2.cuenta as usr_mod,
                                 per.nombre_completo1
                                 --,tipme.unidad_medida
                          from hidro.thd_medicion med
                               left join hidro.thd_operador ope on ope.id_operador = med.id_operador
                               left join segu.vpersona per on ope.id_persona = per.id_persona
                               left join hidro.thd_sensor sen on sen.id_sensor = med.id_sensor
                               --left join hidro.thd_tipo_medicion tipme on tipme.id_tipo_medicion = med.id_tipo_medicion
                               inner join segu.tusuario usu1 on usu1.id_usuario = med.id_usuario_reg                               
                               left join segu.tusuario usu2 on usu2.id_usuario = med.id_usuario_mod
                          where med.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			
            raise notice '%',v_consulta;
            
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_MEDAME_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	elsif(p_transaccion='HD_MEDAME_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(med.id_medicion)
					    	from hidro.thd_medicion med
                               left join hidro.thd_operador ope on ope.id_operador = med.id_operador
                               left join segu.vpersona per on ope.id_persona = per.id_persona
                               left join hidro.thd_sensor sen on sen.id_sensor = med.id_sensor
                               --left join hidro.thd_tipo_medicion tipme on tipme.id_tipo_medicion = med.id_tipo_medicion
                               inner join segu.tusuario usu1 on usu1.id_usuario = med.id_usuario_reg                               
                               left join segu.tusuario usu2 on usu2.id_usuario = med.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
    
    /*********************************    
 	#TRANSACCION:  'HD_REPORTE'
 	#DESCRIPCION:	Prueba de reporte
 	#AUTOR:		mflores	
 	#FECHA:		14-11-2011 12:17
	***********************************/

	elsif(p_transaccion='HD_REPORTE')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select med.fecha_medida,
                                med.valor_numeric
                          from hidro.thd_medicion med
                               left join hidro.thd_operador ope on ope.id_operador = med.id_operador
                               left join segu.vpersona per on ope.id_persona = per.id_persona
                               left join hidro.thd_sensor sen on sen.id_sensor = med.id_sensor                               
                               inner join segu.tusuario usu1 on usu1.id_usuario = med.id_usuario_reg                               
                               left join segu.tusuario usu2 on usu2.id_usuario = med.id_usuario_mod
                          where med.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion; -- || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			
            raise notice '%',v_consulta;
            
			--Devuelve la respuesta
			return v_consulta;
						
		end;
	    
    /*********************************    
 	#TRANSACCION:  'HD_OBT_FECHA'
 	#DESCRIPCION:	Obtener fechas maxima y minima para precargar la vista de reporte
 	#AUTOR:			mflores	
 	#FECHA:			19-04-2012 10:08
	***********************************/

	elsif(p_transaccion='HD_OBT_FECHA')then
     			
   v_tabla := (select replace(v_parametros.tabla,'id_','thd_'));
   
   --raise notice 'v_tabla: %', v_tabla;
    	
    	begin
    		--Sentencia de la consulta
			v_consulta:='select min(med.'||v_parametros.columna_fecha||') as fecha_min,
	   							max(med.'||v_parametros.columna_fecha||') as fecha_max
                          from hidro.'||v_tabla||' med
                          where med.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			--v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion; -- || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			
            raise notice '%',v_consulta;
            
			--Devuelve la respuesta
			return v_consulta;
						
		end;
        
    /*********************************    
 	#TRANSACCION:  'HD_OBT_PROME'
 	#DESCRIPCION:	Obtener promedios
 	#AUTOR:			mflores	
 	#FECHA:			22-05-2012 16:30
	***********************************/

	elsif(p_transaccion='HD_OBT_PROME')then
     			
   v_tabla := (select replace(v_parametros.tabla,'id_','thd_'));
   
   --raise notice 'v_tabla: %', v_tabla;
    	
    	begin
    		--Sentencia de la consulta
			v_consulta:='select min(med.'||v_parametros.columna_fecha||') as fecha_min,
	   							max(med.'||v_parametros.columna_fecha||') as fecha_max
                          from hidro.'||v_tabla||' med
                          where med.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			--v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion; -- || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			
            raise notice '%',v_consulta;
            
			--Devuelve la respuesta
			return v_consulta;
						
		end;
   
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 917 (class 1255 OID 207232)
-- Dependencies: 13 3246
-- Name: f_thd_medicion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_medicion_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_medicion_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_medicion'
 AUTOR: 		 (mflores)
 FECHA:	        07-09-2011 15:50:29
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_medicion	integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_medicion_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_MED_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	if(p_transaccion='HD_MED_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_medicion(
			estado_reg,
			fecha_fin,
            hora_medida,
			fecha_ini,
            valor_numeric,
			valor_varchar,
			h,
			h_fin,
			h_ini,
			h_maxi,
			h_mini,
			h_original,
			id_operador,
			id_sensor,
			q,
			q_original,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod
--            ,id_tipo_medicion
          	) values(
			'activo',
			v_parametros.fecha_fin,
            v_parametros.hora_medida,
			v_parametros.fecha_ini,
            v_parametros.valor_numeric,
			v_parametros.valor_varchar,
			v_parametros.h,
			v_parametros.h_fin,
			v_parametros.h_ini,
			v_parametros.h_maxi,
			v_parametros.h_mini,
			v_parametros.h_original,
			v_parametros.id_operador,
			v_parametros.id_sensor,
			v_parametros.q,
			v_parametros.q_original,
			now(),
			p_id_usuario,
			null,
			null
            --,v_parametros.id_tipo_medicion
			)RETURNING id_medicion into v_id_medicion;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','MediciÃ³n almacenado(a) con exito (id_medicion'||v_id_medicion||')'); 
            v_resp = f_agrega_clave(v_resp,'id_medicion',v_id_medicion::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_MED_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	elsif(p_transaccion='HD_MED_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_medicion set
			fecha_fin = v_parametros.fecha_fin,
            hora_medida = v_parametros.hora_medida,
			fecha_ini = v_parametros.fecha_ini,
            valor_numeric = v_parametros.valor_numeric,
			valor_varchar = v_parametros.valor_varchar,
			h = v_parametros.h,
			h_fin = v_parametros.h_fin,
			h_ini = v_parametros.h_ini,
			h_maxi = v_parametros.h_maxi,
			h_mini = v_parametros.h_mini,
			h_original = v_parametros.h_original,
			id_operador = v_parametros.id_operador,
			id_sensor = v_parametros.id_sensor,
			q = v_parametros.q,
			q_original = v_parametros.q_original,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_medicion=v_parametros.id_medicion;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','MediciÃ³n modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_medicion',v_parametros.id_medicion::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_MED_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	elsif(p_transaccion='HD_MED_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from hidro.thd_medicion
            
            --mflores 03-10-11 estado inactivo en vez de eliminar el registro
            UPDATE hidro.thd_medicion
            SET estado_reg = 'inactivo'
            where id_medicion=v_parametros.id_medicion;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','MediciÃ³n eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_medicion',v_parametros.id_medicion::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 918 (class 1255 OID 207233)
-- Dependencies: 13 3246
-- Name: f_thd_medicion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_medicion_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_medicion_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_medicion'
 AUTOR: 		 (mflores)
 FECHA:	        07-09-2011 15:50:29
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_medicion_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_MED_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	if(p_transaccion='HD_MED_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						med.id_medicion,
						med.estado_reg,
						med.fecha_fin,
                        med.hora_medida,
						med.fecha_ini,
						med.h,
						med.h_fin,
						med.h_ini,
						med.h_maxi,
						med.h_mini,
						med.h_original,
						med.id_operador,
						med.id_sensor,
						med.q,
						med.q_original,
						med.fecha_reg,
						med.id_usuario_reg,
						med.fecha_mod,
						med.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        per.nombre_completo1,
                       -- med.id_tipo_medicion,
                        med.valor_numeric,
						med.valor_varchar
						from hidro.thd_medicion med
                        inner join hidro.thd_operador ope on ope.id_operador = med.id_operador
                        inner join segu.vpersona per on ope.id_persona = per.id_persona
                        inner join hidro.thd_sensor sen on sen.id_sensor = med.id_sensor
						inner join segu.tusuario usu1 on usu1.id_usuario = med.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = med.id_usuario_mod
				        where med.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_MED_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		07-09-2011 15:50:29
	***********************************/

	elsif(p_transaccion='HD_MED_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_medicion)
					    from hidro.thd_medicion med
                        inner join hidro.thd_sensor sen on sen.id_sensor = med.id_sensor
					    inner join segu.tusuario usu1 on usu1.id_usuario = med.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = med.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 921 (class 1255 OID 207234)
-- Dependencies: 13 3246
-- Name: f_thd_operador_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_operador_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_operador_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas 
 				(inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_operador'
 AUTOR: 		mflores
 FECHA:	        02-09-2011 15:10
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    		integer;
	v_parametros           		record;
	v_id_requerimiento     		integer;
	v_resp		            	varchar;
	v_nombre_funcion       	 	text;
	v_mensaje_error         	text;
	v_id_operador				integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_operador_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_OPE_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:			mflores	
 	#FECHA:			02-09-2011
	***********************************/

	if(p_transaccion='HD_OPE_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_operador
            (
              estado_reg,
              fecha_presentacion,
              id_persona,
              id_proyecto,
              fecha_reg,
              id_usuario_reg,
              fecha_mod,
              id_usuario_mod,
              codigo
          	) 
            values
            (
              'activo',
              v_parametros.fecha_presentacion,
              v_parametros.id_persona,
              v_parametros.id_proyecto,
              now(),
              p_id_usuario,
              null,
              null,
              v_parametros.codigo
			)RETURNING id_operador into v_id_operador;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','OPERADOR almacenado(a) con exito (id_operador'||v_id_operador||')'); 
            v_resp = f_agrega_clave(v_resp,'id_operador',v_id_operador::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_OPE_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:			mflores	
 	#FECHA:			02-09-2011
	***********************************/

	elsif(p_transaccion='HD_OPE_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_operador set
			fecha_presentacion = v_parametros.fecha_presentacion,
            id_persona = v_parametros.id_persona,
			id_proyecto = v_parametros.id_proyecto,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario,
            codigo = v_parametros.codigo
 			where id_operador = v_parametros.id_operador;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','OPERADOR modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_operador',v_parametros.id_operador::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_OPE_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:			mflores	
 	#FECHA:			02-09-2011	
	***********************************/

	elsif(p_transaccion='HD_OPE_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from hidro.thd_operador
            
            --mflores 03-10-11 estado inactivo en vez de eliminar el registro
            UPDATE hidro.thd_operador
            SET estado_reg = 'inactivo'
            where id_operador = v_parametros.id_operador;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','OPERADOR eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_operador',v_parametros.id_operador::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 922 (class 1255 OID 207235)
-- Dependencies: 13 3246
-- Name: f_thd_operador_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_operador_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_operador_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'hidro.thd_operador'
 AUTOR: 		mflores
 FECHA:	        02-09-2011
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_operador_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_OPE_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			mflores	
 	#FECHA:			02-09-2011
	***********************************/

	if(p_transaccion='HD_OPE_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select ope.id_operador,
                                 ope.estado_reg,
                                 ope.fecha_presentacion,
                                 ope.id_persona,
                                 ope.id_proyecto,
                                 ope.fecha_reg,
                                 ope.id_usuario_reg,
                                 ope.fecha_mod,
                                 ope.id_usuario_mod,
                                 usu1.cuenta as usr_reg,
                                 usu2.cuenta as usr_mod,
                                 per.nombre_completo1,
                                 per.ap_materno,
                                 per.ap_paterno,
                                 per.nombre,
                                 proy.nombre as proyecto,
                                 ope.codigo,
                                 perso.extension,
                                 perso.foto
                          from hidro.thd_operador ope
                               inner join segu.vpersona per on ope.id_persona = per.id_persona
                               inner join segu.tproyecto proy on ope.id_proyecto = proy.id_proyecto
                               inner join segu.tusuario usu1 on usu1.id_usuario = ope.id_usuario_reg
                               left join segu.tusuario usu2 on usu2.id_usuario = ope.id_usuario_mod
                               left join segu.tpersona perso on perso.id_persona = ope.id_persona
				          where ope.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_OPE_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:			mflores	
 	#FECHA:			01-09-2011
	***********************************/

	elsif(p_transaccion='HD_OPE_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_operador)
					    from hidro.thd_operador ope
                        inner join segu.vpersona per on ope.id_persona = per.id_persona
                        inner join segu.tproyecto proy on ope.id_proyecto = proy.id_proyecto
					    inner join segu.tusuario usu1 on usu1.id_usuario = ope.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ope.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;
            
            raise notice '%',v_consulta;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 923 (class 1255 OID 207236)
-- Dependencies: 3246 13
-- Name: f_thd_rio_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_rio_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_rio_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_rio'
 AUTOR: 		 (rac)
 FECHA:	        31-08-2011 15:32:32
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_rio	integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_rio_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_RIO_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		31-08-2011 15:32:32
	***********************************/

	if(p_transaccion='HD_RIO_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_rio(
			codigo,
			estado_reg,
			nombre,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			v_parametros.codigo,
			'activo',
			v_parametros.nombre,
			now(),
			p_id_usuario,
			null,
			null
			)RETURNING id_rio into v_id_rio;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','RIO almacenado(a) con exito (id_rio'||v_id_rio||')'); 
            v_resp = f_agrega_clave(v_resp,'id_rio',v_id_rio::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_RIO_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		31-08-2011 15:32:32
	***********************************/

	elsif(p_transaccion='HD_RIO_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_rio set
			codigo = v_parametros.codigo,
			nombre = v_parametros.nombre,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_rio=v_parametros.id_rio;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','RIO modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_rio',v_parametros.id_rio::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_RIO_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		31-08-2011 15:32:32
	***********************************/

	elsif(p_transaccion='HD_RIO_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from hidro.thd_rio
            
            --mflores 03-10-11 estado inactivo en vez de eliminar el registro
            UPDATE hidro.thd_rio
            SET estado_reg = 'inactivo'
            where id_rio=v_parametros.id_rio;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','RIO eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_rio',v_parametros.id_rio::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 924 (class 1255 OID 207237)
-- Dependencies: 13 3246
-- Name: f_thd_rio_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_rio_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_rio_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_rio'
 AUTOR: 		 (rac)
 FECHA:	        31-08-2011 15:32:32
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_rio_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_RIO_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		31-08-2011 15:32:32
	***********************************/

	if(p_transaccion='HD_RIO_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						rio.id_rio,
						rio.codigo,
						rio.estado_reg,
						rio.nombre,
						rio.fecha_reg,
						rio.id_usuario_reg,
						rio.fecha_mod,
						rio.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from hidro.thd_rio rio
						inner join segu.tusuario usu1 on usu1.id_usuario = rio.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = rio.id_usuario_mod
				        where rio.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_RIO_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		31-08-2011 15:32:32
	***********************************/

	elsif(p_transaccion='HD_RIO_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_rio)
					    from hidro.thd_rio rio
					    inner join segu.tusuario usu1 on usu1.id_usuario = rio.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = rio.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 931 (class 1255 OID 207238)
-- Dependencies: 13 3246
-- Name: f_thd_sensor_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_sensor_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_sensor_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_sensor'
 AUTOR: 		 (mflores)
 FECHA:	        06-09-2011 11:45:42
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_sensor				integer;   
    
    v_codigo_sensor			varchar;
    v_codigo_est			varchar;
    v_abreviacion			varchar;
    v_contador				numeric;
    			    
BEGIN
	    
    v_nombre_funcion = 'hidro.f_thd_sensor_ime';
    v_parametros = f_get_record(p_tabla);    
        
	/*********************************    
 	#TRANSACCION:  'HD_SEN_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	if(p_transaccion='HD_SEN_INS')then
    
    select codigo
    into v_codigo_est
    from hidro.thd_estacion
    where id_estacion = v_parametros.id_estacion;
    
    select abreviacion
    into v_abreviacion
    from hidro.thd_tipo_sensor
    where id_tipo_sensor = v_parametros.id_tipo_sensor;
    
    select count(id_sensor)
    into v_contador
    from hidro.thd_sensor
    where id_estacion = v_parametros.id_estacion;
    
    v_contador := v_contador + 1;
    
    v_codigo_sensor := COALESCE(v_codigo_est || '-' || v_abreviacion || '-' || v_contador::varchar);
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_sensor(
			estado,
			estado_reg,
			fecha_fin,
			fecha_ini,
			ficticio,
			id_estacion,
            id_tipo_sensor,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod,
            codigo,
            id_sensor_fk
          	) values(
			'borrador',
			'activo',
			v_parametros.fecha_fin,
			v_parametros.fecha_ini,
			v_parametros.ficticio,
			v_parametros.id_estacion,
            v_parametros.id_tipo_sensor,
			now(),
			p_id_usuario,
			null,
			null,
            v_codigo_sensor,
            v_parametros.id_sensor_fk
			)RETURNING id_sensor into v_id_sensor;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Sensor almacenado(a) con exito (id_sensor'||v_id_sensor||')'); 
            v_resp = f_agrega_clave(v_resp,'id_sensor',v_id_sensor::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_SEN_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	elsif(p_transaccion='HD_SEN_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_sensor set
			--estado = v_parametros.estado,
			fecha_fin = v_parametros.fecha_fin,
			fecha_ini = v_parametros.fecha_ini,
			ficticio = v_parametros.ficticio,
			id_estacion = v_parametros.id_estacion,
            id_tipo_sensor = v_parametros.id_tipo_sensor,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario,
            id_sensor_fk = v_parametros.id_sensor_fk
			where id_sensor=v_parametros.id_sensor;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Sensor modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_sensor',v_parametros.id_sensor::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;
        
     

	/*********************************    
 	#TRANSACCION:  'HD_SEN_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	elsif(p_transaccion='HD_SEN_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from hidro.thd_sensor
            
            update hidro.thd_medicion
            SET estado_reg = 'inactivo'
            where id_sensor=v_parametros.id_sensor;
            
            UPDATE hidro.thd_sensor
            SET estado_reg = 'inactivo'
            where id_sensor=v_parametros.id_sensor;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Sensor eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_sensor',v_parametros.id_sensor::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;             
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 932 (class 1255 OID 207239)
-- Dependencies: 13 3246
-- Name: f_thd_sensor_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_sensor_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_sensor_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_sensor'
 AUTOR: 		 (mflores)
 FECHA:	        06-09-2011 11:45:42
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_sensor_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_SEN_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	if(p_transaccion='HD_SEN_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						sen.id_sensor,
						sen.estado,
						sen.estado_reg,
						sen.fecha_fin,
						sen.fecha_ini,
						sen.ficticio,
						sen.id_estacion,
						sen.fecha_reg,
						sen.id_usuario_reg,
						sen.fecha_mod,
						sen.id_usuario_mod,
                        sen.id_tipo_sensor,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        est.codigo as estacion,
                        tipsen.nombre_sensor as tipo_sensor,
					    --tipcol.nombre_medida,
                        sen.codigo,
                        tipcols.unidad_medida,
                        (select codigo
                         from hidro.thd_sensor
                         where id_sensor = sen.id_sensor_fk) as sen_asociado,
                        tipsen.codigo as tipo_sensor_codigo
						from hidro.thd_sensor sen
                        inner join hidro.thd_estacion est on est.id_estacion = sen.id_estacion
                        inner join hidro.thd_tipo_sensor tipsen on tipsen.id_tipo_sensor = sen.id_tipo_sensor
                        inner join hidro.thd_tipo_columna_sensor tipcols on tipcols.id_tipo_sensor = sen.id_tipo_sensor
						inner join segu.tusuario usu1 on usu1.id_usuario = sen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = sen.id_usuario_mod
				        where sen.estado_reg = ''activo'' and ';
			
            raise notice '%',v_consulta;
            
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;
        
    /*********************************    
 	#TRANSACCION:  'HD_SENC_SEL'
 	#DESCRIPCION:	Consulta de datos para el combo de sensores
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	elsif(p_transaccion='HD_SENC_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						sen.id_sensor,
						sen.estado,
						sen.estado_reg,
						sen.fecha_fin,
						sen.fecha_ini,
						sen.ficticio,
						sen.id_estacion,
						sen.fecha_reg,
						sen.id_usuario_reg,
						sen.fecha_mod,
						sen.id_usuario_mod,
                        sen.id_tipo_sensor,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        est.codigo as estacion,
                        tipsen.nombre_sensor as tipo_sensor,
					   -- tipcol.nombre_medida,
                        sen.codigo
						from hidro.thd_sensor sen
                        inner join hidro.thd_estacion est on est.id_estacion = sen.id_estacion
                        inner join hidro.thd_tipo_sensor tipsen on tipsen.id_tipo_sensor = sen.id_tipo_sensor
                        inner join hidro.thd_tipo_columna_sensor tipcol on tipcol.id_tipo_sensor = sen.id_tipo_sensor
						inner join segu.tusuario usu1 on usu1.id_usuario = sen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = sen.id_usuario_mod
				        where sen.estado_reg = ''activo'' and sen.id_estacion = '|| v_parametros.id_estacion ||' and ';
			
            raise notice '%',v_consulta;
            
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;
    
    /*********************************    
 	#TRANSACCION:  'HD_SENFIC_SEL'
 	#DESCRIPCION:	Consulta de datos para el caso ficticio
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	elsif(p_transaccion='HD_SENFIC_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select distinct
						sen.id_sensor,
						sen.estado,
						sen.estado_reg,
						sen.fecha_fin,
						sen.fecha_ini,
						sen.ficticio,
						sen.id_estacion,
						sen.fecha_reg,
						sen.id_usuario_reg,
						sen.fecha_mod,
						sen.id_usuario_mod,
                        sen.id_tipo_sensor,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        est.codigo as estacion,
                        tipsen.nombre_sensor as tipo_sensor,
					    --tipcol.nombre_medida,
                        sen.codigo
						from hidro.thd_sensor sen
                        inner join hidro.thd_estacion est on est.id_estacion = sen.id_estacion
                        inner join hidro.thd_tipo_sensor tipsen on tipsen.id_tipo_sensor = sen.id_tipo_sensor
                        inner join hidro.thd_tipo_columna_sensor tipcol on tipcol.id_tipo_sensor = sen.id_tipo_sensor
						inner join segu.tusuario usu1 on usu1.id_usuario = sen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = sen.id_usuario_mod
				        where sen.estado_reg = ''activo'' and sen.ficticio = false and ';
			
            raise notice '%',v_consulta;
            
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_SEN_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	elsif(p_transaccion='HD_SEN_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_sensor)
					    from hidro.thd_sensor sen
                        inner join hidro.thd_estacion est on est.id_estacion = sen.id_estacion
					    inner join segu.tusuario usu1 on usu1.id_usuario = sen.id_usuario_reg
                        inner join hidro.thd_tipo_columna_sensor tipcols on tipcols.id_tipo_sensor = sen.id_tipo_sensor
						left join segu.tusuario usu2 on usu2.id_usuario = sen.id_usuario_mod
					    where sen.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
        
    /*********************************    
 	#TRANSACCION:  'HD_SENC_CONT'
 	#DESCRIPCION:	Conteo de registros para los datos del combo de sensores
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	elsif(p_transaccion='HD_SENC_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_sensor)
					    from hidro.thd_sensor sen
                        inner join hidro.thd_estacion est on est.id_estacion = sen.id_estacion
                        inner join hidro.thd_tipo_columna_sensor tipcols on tipcols.id_tipo_sensor = sen.id_tipo_sensor
					    inner join segu.tusuario usu1 on usu1.id_usuario = sen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = sen.id_usuario_mod
					    where sen.estado_reg = ''activo'' and sen.id_estacion = '|| v_parametros.id_estacion ||' and ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
    
    /*********************************    
 	#TRANSACCION:  'HD_SENFIC_CONT'
 	#DESCRIPCION:	Conteo de registros para los datos del combo de sensores
 	#AUTOR:		mflores	
 	#FECHA:		06-09-2011 11:45:42
	***********************************/

	elsif(p_transaccion='HD_SENFIC_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_sensor)
					    from hidro.thd_sensor sen
                        inner join hidro.thd_estacion est on est.id_estacion = sen.id_estacion
                        inner join hidro.thd_tipo_columna_sensor tipcols on tipcols.id_tipo_sensor = sen.id_tipo_sensor
					    inner join segu.tusuario usu1 on usu1.id_usuario = sen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = sen.id_usuario_mod
					    where sen.estado_reg = ''activo'' and sen.ficticio = false and ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 933 (class 1255 OID 207241)
-- Dependencies: 13 3246
-- Name: f_thd_tipo_archivo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_tipo_archivo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_archivo_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_tipo_archivo'
 AUTOR: 		 (mflores)
 FECHA:	        23-11-2011 09:48:02
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_tipo_archivo	integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_tipo_archivo_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPAR_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:48:02
	***********************************/

	if(p_transaccion='HD_TIPAR_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_tipo_archivo(
			patron_nombre_archivo,
			num_file_ini,
			fecha_fin,
			periodo,
			estado_reg,
			fecha_ini,
			id_estacion,
			id_usuario_reg,
			fecha_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			v_parametros.patron_nombre_archivo,
			v_parametros.num_file_ini,
			v_parametros.fecha_fin,
			v_parametros.periodo,
			'activo',
			v_parametros.fecha_ini,
			v_parametros.id_estacion,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_tipo_archivo into v_id_tipo_archivo;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Archivo almacenado(a) con exito (id_tipo_archivo'||v_id_tipo_archivo||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_archivo',v_id_tipo_archivo::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPAR_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:48:02
	***********************************/

	elsif(p_transaccion='HD_TIPAR_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_tipo_archivo set
			patron_nombre_archivo = v_parametros.patron_nombre_archivo,
			num_file_ini = v_parametros.num_file_ini,
			fecha_fin = v_parametros.fecha_fin,
			periodo = v_parametros.periodo,
			fecha_ini = v_parametros.fecha_ini,
			id_estacion = v_parametros.id_estacion,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_tipo_archivo=v_parametros.id_tipo_archivo;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Archivo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_archivo',v_parametros.id_tipo_archivo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPAR_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:48:02
	***********************************/

	elsif(p_transaccion='HD_TIPAR_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from hidro.thd_tipo_archivo
            --where id_tipo_archivo=v_parametros.id_tipo_archivo;
            
            UPDATE hidro.thd_tipo_archivo
            SET estado_reg = 'inactivo'
            where id_tipo_archivo = v_parametros.id_tipo_archivo;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Archivo eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_archivo',v_parametros.id_tipo_archivo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 934 (class 1255 OID 207242)
-- Dependencies: 13 3246
-- Name: f_thd_tipo_archivo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_tipo_archivo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_archivo_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_tipo_archivo'
 AUTOR: 		 (mflores)
 FECHA:	        23-11-2011 09:48:02
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_tipo_archivo_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPAR_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:48:02
	***********************************/

	if(p_transaccion='HD_TIPAR_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						tipar.id_tipo_archivo,
						tipar.patron_nombre_archivo,
						tipar.num_file_ini,
						tipar.fecha_fin,
						tipar.periodo,
						tipar.estado_reg,
						tipar.fecha_ini,
						tipar.id_estacion,
						tipar.id_usuario_reg,
						tipar.fecha_reg,
						tipar.fecha_mod,
						tipar.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        esta.codigo
						from hidro.thd_tipo_archivo tipar
						inner join segu.tusuario usu1 on usu1.id_usuario = tipar.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipar.id_usuario_mod
                        inner join hidro.thd_estacion esta on esta.id_estacion = tipar.id_estacion
				        where tipar.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPAR_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:48:02
	***********************************/

	elsif(p_transaccion='HD_TIPAR_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_archivo)
					    from hidro.thd_tipo_archivo tipar
					    inner join segu.tusuario usu1 on usu1.id_usuario = tipar.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipar.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 935 (class 1255 OID 207243)
-- Dependencies: 13 3246
-- Name: f_thd_tipo_columna_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_tipo_columna_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_columna_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_tipo_columna'
 AUTOR: 		 (mflores)
 FECHA:	        15-03-2012 10:27:40
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_tipo_columna	integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_tipo_columna_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPCOL_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:40
	***********************************/

	if(p_transaccion='HD_TIPCOL_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_tipo_columna(
			estado_reg,
			codigo,
			tipo_dato,
			nombre_columna,
			tipo_columna,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.codigo,
			v_parametros.tipo_dato,
			v_parametros.nombre_columna,
			v_parametros.tipo_columna,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_tipo_columna into v_id_tipo_columna;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Columna almacenado(a) con exito (id_tipo_columna'||v_id_tipo_columna||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_columna',v_id_tipo_columna::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPCOL_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:40
	***********************************/

	elsif(p_transaccion='HD_TIPCOL_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_tipo_columna set
			codigo = v_parametros.codigo,
			tipo_dato = v_parametros.tipo_dato,
			nombre_columna = v_parametros.nombre_columna,
			tipo_columna = v_parametros.tipo_columna,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_tipo_columna=v_parametros.id_tipo_columna;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Columna modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_columna',v_parametros.id_tipo_columna::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPCOL_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:40
	***********************************/

	elsif(p_transaccion='HD_TIPCOL_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from hidro.thd_tipo_columna
            where id_tipo_columna=v_parametros.id_tipo_columna;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Columna eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_columna',v_parametros.id_tipo_columna::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 940 (class 1255 OID 207244)
-- Dependencies: 13 3246
-- Name: f_thd_tipo_columna_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_tipo_columna_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_columna_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_tipo_columna'
 AUTOR: 		 (mflores)
 FECHA:	        15-03-2012 10:27:40
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_tipo_columna_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPCOL_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:40
	***********************************/

	if(p_transaccion='HD_TIPCOL_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						tipcol.id_tipo_columna,
						tipcol.estado_reg,
						tipcol.codigo,
						tipcol.tipo_dato,
						tipcol.nombre_columna,
						tipcol.tipo_columna,
						tipcol.id_usuario_reg,
						tipcol.fecha_reg,
						tipcol.id_usuario_mod,
						tipcol.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from hidro.thd_tipo_columna tipcol
						inner join segu.tusuario usu1 on usu1.id_usuario = tipcol.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipcol.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPCOL_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:40
	***********************************/

	elsif(p_transaccion='HD_TIPCOL_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_columna)
					    from hidro.thd_tipo_columna tipcol
					    inner join segu.tusuario usu1 on usu1.id_usuario = tipcol.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipcol.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 941 (class 1255 OID 207245)
-- Dependencies: 13 3246
-- Name: f_thd_tipo_columna_sensor_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_tipo_columna_sensor_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_columna_sensor_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_tipo_columna_sensor'
 AUTOR: 		 (rac)
 FECHA:	        16-03-2012 17:06:17
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_tipo_columna_sensor	integer;
    
    var_cod_1				varchar;
    var_codigo				varchar;
    v_aux					varchar;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_tipo_columna_sensor_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TICOSEN_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	if(p_transaccion='HD_TICOSEN_INS')then
    
     	var_codigo := '';
        v_aux := trim(both ' ' from v_parametros.codigo_columna);
        raise notice '%', v_aux;
        
        while (select position(' ' in v_aux)) > 0 loop                    
            
            var_cod_1 := (select substr(v_aux,1, (select position(' ' in v_aux)) -1));            
            v_aux := (select substr(v_aux, (select position(' ' in v_aux))));
            var_codigo := COALESCE(var_codigo||var_cod_1);                   
            v_aux := trim(both ' ' from v_aux);               
              
        end loop;
              
        v_aux := trim(both ' ' from v_aux);
        var_codigo := COALESCE(var_codigo||v_aux);
        raise notice '%', var_codigo;

        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_tipo_columna_sensor(
			estado_reg,
			unidad_medida,
			prioridad,
			tipo_dato,
			nombre_columna,
			codigo_columna,
			id_tipo_sensor,
			mapeo_archivo,
			orden,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.unidad_medida,
			v_parametros.prioridad,
			v_parametros.tipo_dato,
			v_parametros.nombre_columna,
			lower(var_codigo),   --lower(v_parametros.codigo_columna),
			v_parametros.id_tipo_sensor,
			v_parametros.mapeo_archivo,
			v_parametros.orden,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_tipo_columna_sensor into v_id_tipo_columna_sensor;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Columna Sensor almacenado(a) con exito (id_tipo_columna_sensor'||v_id_tipo_columna_sensor||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_columna_sensor',v_id_tipo_columna_sensor::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_TICOSEN_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	elsif(p_transaccion='HD_TICOSEN_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_tipo_columna_sensor set
			unidad_medida = v_parametros.unidad_medida,
			prioridad = v_parametros.prioridad,
			tipo_dato = v_parametros.tipo_dato,
			nombre_columna = v_parametros.nombre_columna,
			codigo_columna = lower(v_parametros.codigo_columna),
			id_tipo_sensor = v_parametros.id_tipo_sensor,
			mapeo_archivo = v_parametros.mapeo_archivo,
			orden = v_parametros.orden,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_tipo_columna_sensor=v_parametros.id_tipo_columna_sensor;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Columna Sensor modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_columna_sensor',v_parametros.id_tipo_columna_sensor::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TICOSEN_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	elsif(p_transaccion='HD_TICOSEN_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from hidro.thd_tipo_columna_sensor
            /*update hidro.thd_tipo_columna_sensor set
            estado_reg = 'inactivo'*/
            where id_tipo_columna_sensor=v_parametros.id_tipo_columna_sensor;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Columna Sensor eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_columna_sensor',v_parametros.id_tipo_columna_sensor::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 942 (class 1255 OID 207247)
-- Dependencies: 3246 13
-- Name: f_thd_tipo_columna_sensor_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_tipo_columna_sensor_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_columna_sensor_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_tipo_columna_sensor'
 AUTOR: 		 (rac)
 FECHA:	        16-03-2012 17:06:17
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_tipo_columna_sensor_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TICOSEN_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	if(p_transaccion='HD_TICOSEN_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						ticosen.id_tipo_columna_sensor,
						ticosen.estado_reg,
						ticosen.unidad_medida,
						ticosen.prioridad,
						ticosen.tipo_dato,
						ticosen.nombre_columna,
						ticosen.codigo_columna,
						ticosen.id_tipo_sensor,
						ticosen.mapeo_archivo,
						ticosen.orden,
						ticosen.id_usuario_reg,
						ticosen.fecha_reg,
						ticosen.id_usuario_mod,
						ticosen.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from hidro.thd_tipo_columna_sensor ticosen
						inner join segu.tusuario usu1 on usu1.id_usuario = ticosen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ticosen.id_usuario_mod
				        where ticosen.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;           
            
             if(public.f_existe_parametro(p_tabla,'id_tipo_sensor')) then
               v_consulta:=v_consulta || ' and ticosen.id_tipo_sensor ='||v_parametros.id_tipo_sensor;
            end if;
             
             if(public.f_existe_parametro(p_tabla,'par_filtro')) then
                 if v_parametros.par_filtro='fecha' then
                  v_consulta:=v_consulta || ' and ticosen.tipo_dato in (''date'',''timestamp'')';
                 else
                   v_consulta:=v_consulta || ' and ticosen.tipo_dato in (''numeric'',''integuer'')';
                 
                 end if;                   
           
             end if;
             
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            
            
            raise notice  '%',v_consulta;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TICOSEN_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	elsif(p_transaccion='HD_TICOSEN_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_columna_sensor)
					    from hidro.thd_tipo_columna_sensor ticosen
					    inner join segu.tusuario usu1 on usu1.id_usuario = ticosen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ticosen.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 943 (class 1255 OID 207248)
-- Dependencies: 13 3246
-- Name: f_thd_tipo_dato_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_tipo_dato_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_dato_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_tipo_dato'
 AUTOR: 		 (mflores)
 FECHA:	        02-04-2012 17:34:04
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_tipo_dato	integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_tipo_dato_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPDAT_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:04
	***********************************/

	if(p_transaccion='HD_TIPDAT_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_tipo_dato(
			estado_reg,
			tipo_dato,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.tipo_dato,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_tipo_dato into v_id_tipo_dato;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Tipo dato almacenado(a) con exito (id_tipo_dato'||v_id_tipo_dato||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_dato',v_id_tipo_dato::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPDAT_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:04
	***********************************/

	elsif(p_transaccion='HD_TIPDAT_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_tipo_dato set
			tipo_dato = v_parametros.tipo_dato,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_tipo_dato=v_parametros.id_tipo_dato;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo dato modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_dato',v_parametros.id_tipo_dato::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPDAT_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:04
	***********************************/

	elsif(p_transaccion='HD_TIPDAT_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from hidro.thd_tipo_dato
            where id_tipo_dato=v_parametros.id_tipo_dato;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo dato eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_dato',v_parametros.id_tipo_dato::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 944 (class 1255 OID 207249)
-- Dependencies: 13 3246
-- Name: f_thd_tipo_dato_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_tipo_dato_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_dato_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_tipo_dato'
 AUTOR: 		 (mflores)
 FECHA:	        02-04-2012 17:34:04
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_tipo_dato_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPDAT_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:04
	***********************************/

	if(p_transaccion='HD_TIPDAT_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						tipdat.id_tipo_dato,
						tipdat.estado_reg,
						tipdat.tipo_dato,
						tipdat.id_usuario_reg,
						tipdat.fecha_reg,
						tipdat.id_usuario_mod,
						tipdat.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from hidro.thd_tipo_dato tipdat
						inner join segu.tusuario usu1 on usu1.id_usuario = tipdat.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipdat.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPDAT_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:04
	***********************************/

	elsif(p_transaccion='HD_TIPDAT_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_dato)
					    from hidro.thd_tipo_dato tipdat
					    inner join segu.tusuario usu1 on usu1.id_usuario = tipdat.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipdat.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 947 (class 1255 OID 207250)
-- Dependencies: 13 3246
-- Name: f_thd_tipo_muestra_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_tipo_muestra_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_muestra_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_tipo_muestra'
 AUTOR: 		 (mflores)
 FECHA:	        23-11-2011 09:50:17
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_tipo_muestra	integer;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_tipo_muestra_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPMU_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:17
	***********************************/

	if(p_transaccion='HD_TIPMU_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_tipo_muestra(
			nombre,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.nombre,
			'activo',
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_tipo_muestra into v_id_tipo_muestra;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Muestra almacenado(a) con exito (id_tipo_muestra'||v_id_tipo_muestra||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_muestra',v_id_tipo_muestra::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPMU_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:17
	***********************************/

	elsif(p_transaccion='HD_TIPMU_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_tipo_muestra set
			nombre = v_parametros.nombre,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_tipo_muestra=v_parametros.id_tipo_muestra;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Muestra modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_muestra',v_parametros.id_tipo_muestra::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPMU_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:17
	***********************************/

	elsif(p_transaccion='HD_TIPMU_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from hidro.thd_tipo_muestra
            where id_tipo_muestra=v_parametros.id_tipo_muestra;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Muestra eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_muestra',v_parametros.id_tipo_muestra::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 1843 (class 1255 OID 207251)
-- Dependencies: 13 3246
-- Name: f_thd_tipo_muestra_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_tipo_muestra_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_muestra_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_tipo_muestra'
 AUTOR: 		 (mflores)
 FECHA:	        23-11-2011 09:50:17
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_tipo_muestra_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPMU_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:17
	***********************************/

	if(p_transaccion='HD_TIPMU_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						tipmu.id_tipo_muestra,
						tipmu.nombre,
						tipmu.estado_reg,
						tipmu.id_usuario_reg,
						tipmu.fecha_reg,
						tipmu.id_usuario_mod,
						tipmu.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from hidro.thd_tipo_muestra tipmu
						inner join segu.tusuario usu1 on usu1.id_usuario = tipmu.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipmu.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPMU_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		23-11-2011 09:50:17
	***********************************/

	elsif(p_transaccion='HD_TIPMU_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_muestra)
					    from hidro.thd_tipo_muestra tipmu
					    inner join segu.tusuario usu1 on usu1.id_usuario = tipmu.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipmu.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 948 (class 1255 OID 207252)
-- Dependencies: 13 3246
-- Name: f_thd_tipo_sensor_codigo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_tipo_sensor_codigo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_sensor_codigo_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_tipo_columna_sensor'
 AUTOR: 		 (rac)
 FECHA:	        16-03-2012 17:06:17
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_tipo_columna_sensor	integer;
    v_consulta varchar;
    v_consulta2 varchar;
    v_param varchar[]; 
    v_param_det varchar[]; 
    v_tamano  integer;
    v_i integer;
    v_array_tipos varchar[];
    v_array_codigos varchar[];
    v_array_orden integer[];
    v_cont integer;
    v_cont_reg integer;
    aux varchar;
    vector varchar[];
    fila varchar[];
    cols_titulo  integer;
    cant_filas integer;
    cant_cols integer;
    registros varchar[];
    v_registros record;
    v_registros_excel record;
   
    v_consulta_final varchar;
    v_consulta_final2 varchar;
    v_k integer;
    
    v_aux_val varchar;
    
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_tipo_sensor_codigo_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TISENCO_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	if(p_transaccion='HD_TISENCO_INS')then
					
        begin
        
        
        --Sentencia de la consulta
			  v_consulta:='insert into hidro.thd_tipo_sensor_'|| v_parametros.tipo_sensor_codigo ||' (';
                        
              v_consulta2:='	estado_reg,id_usuario_reg,fecha_reg) values(';
           
              raise notice '%',v_parametros.datos;
                        
              v_param= string_to_array(v_parametros.datos,'@');
              
              v_tamano = coalesce(array_length(v_param, 1),0);
             
	      raise notice '#####  % %','id_tipo_sensor_'||v_parametros.tipo_sensor_codigo,v_parametros.tipo_sensor_codigo;
            
            FOR v_i IN 1..v_tamano LOOP
            
              raise notice '>>> %',v_consulta;
              raise notice '<<< %',v_consulta2;
              raise notice 'v_i % v_tamano %',v_i,v_tamano;
            
            
              v_param_det= string_to_array(v_param[v_i],'#');
      
              --verifica que no sea la llave        
              
              --raise notice 'XXXXXXXXXX';
              
              if ( v_param_det[1] != ('id_tipo_sensor_'||v_parametros.tipo_sensor_codigo)) THEN
                
                
                --raise notice 'YYYYYYYYYYY';
              
                    v_consulta:=v_consulta||trim(v_param_det[1]::varchar)||',';
                    
                    IF(v_param_det[2]='varchar' or v_param_det[2]='text' or v_param_det[2]='date' or v_param_det[2]='timestamp' or v_param_det[2]='time')THEN
                      

                       v_consulta2:=v_consulta2||''''||trim(f_get_parametro(p_tabla,v_param_det[1]))||''',';
                      
                      
                    ELSE
                      
                       v_consulta2:=v_consulta2||trim(f_get_parametro(p_tabla,v_param_det[1]))||',';
                   
                    END IF;
                    
                    
                    
                    
              ELSE      
	              raise notice '#####  % %','id_tipo_sensor_'||v_parametros.tipo_sensor_codigo,v_parametros.tipo_sensor_codigo;
              
              END IF;
              
              
            END LOOP;
            
            v_consulta=v_consulta||v_consulta2||'''activo'','||p_id_usuario::varchar||','''||now()::varchar||''')';
           
            raise notice '%',v_consulta;
        
	        execute(v_consulta);
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Sensor Codigo insertado hidro.thd_tipo_sensor_'||v_parametros.tipo_sensor_codigo); 
         

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_TISENCO_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	elsif(p_transaccion='HD_TISENCO_MOD')then

		begin
        
          v_consulta:='update  hidro.thd_tipo_sensor_'|| v_parametros.tipo_sensor_codigo ||' set  ';
                        
        
           
              raise notice '%',v_parametros.datos;
                        
              v_param= string_to_array(v_parametros.datos,'@');
              
              v_tamano = coalesce(array_length(v_param, 1),0);
             
	        
            FOR v_i IN 1..v_tamano LOOP
             v_param_det= string_to_array(v_param[v_i],'#');
             
              v_consulta:=v_consulta||trim(v_param_det[1]::varchar)||'=';
             
             IF(v_param_det[2]='varchar' or v_param_det[2]='text' or v_param_det[2]='date' or v_param_det[2]='timestamp' or v_param_det[2]='time')THEN

                  v_consulta:=v_consulta||''''||trim(f_get_parametro(p_tabla,v_param_det[1]))||''',';
               ELSE 
               
                  v_consulta:=v_consulta||trim(f_get_parametro(p_tabla,v_param_det[1]))||',';
                   
              END IF ;      
            END LOOP;
            
            v_consulta=v_consulta||'id_usuario_mod ='|| p_id_usuario||',
			                        fecha_mod ='''||now()||'''
			                        where id_tipo_sensor_'|| v_parametros.tipo_sensor_codigo ||'='||trim(f_get_parametro(p_tabla,'id_tipo_sensor_'||v_parametros.tipo_sensor_codigo));
            
            
            raise notice '%',v_consulta;
        
	        execute(v_consulta);
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo id_tipo_sensor_'||v_parametros.tipo_sensor_codigo ||' '||trim(f_get_parametro(p_tabla,'id_tipo_sensor_'||v_parametros.tipo_sensor_codigo))); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_sensor_'||v_parametros.tipo_sensor_codigo,trim(f_get_parametro(p_tabla,'id_tipo_sensor_'||v_parametros.tipo_sensor_codigo)));
               
            --Devuelve la respuesta
            return v_resp;
            
		end;
    /*********************************    
 	#TRANSACCION:  'HD_TISECOFI_IME'
 	#DESCRIPCION:	Inserta un archivo excel de manera dinamica
 	#AUTOR:			rac	
 	#FECHA:			07-09-2011 15:50:29
	***********************************/

	elseif(p_transaccion='HD_TISECOFI_IME')then
		
     begin
     
      --crea una tabla temporal con las columnas del archivo excel
      
      --se obtiene el bytea y se quita la codificación
      aux := (select decode(v_parametros.excel::text,'base64')); 
    
      --descomponer el bytea en un vector que contenga una fila del CSV cada uno
	  --\\015\\012 --> ENTER o salto de linea/retorno de carro en el bytea	
    
      vector := string_to_array(aux,'\\015\\012'); 
      
      --desconpone la primera fila suponiendo que son los nombres de las columnas separados por ';'
      
      fila:= string_to_array(vector[1],';');
      
      
      --obtiene la cantidad de columnas
      cols_titulo = array_upper(fila,1);
      
      
    
      --creamo una tabla temporal con los valores y columnas del archivo
      v_consulta := 'create temp table valores_importados (id integer';
      
      for v_k in 1..cols_titulo loop
        
            v_consulta :=  v_consulta ||','||fila[v_k]||' varchar';
        
       
       end loop;
       
       
      
       
       v_consulta :=  v_consulta ||'  ) on commit drop';
       
       
      
       execute v_consulta; 
       
        
      
     --recorre los registro del archivo excel desde la segunda fila
      select array_upper(vector,1) into cant_filas; --cantidad de registros del CSV
      v_cont_reg =1;
      
      
      FOR v_i in 2..(cant_filas-1) loop
      
      
      
            v_consulta := 'insert into valores_importados values ('||v_cont_reg::varchar||','; --inicio de la consulta del insert
            
            v_cont_reg=v_cont_reg+1;
            
            
           --descomponer cada fila para obtener las columnas del CSV
            
            registros := string_to_array(vector[v_i],';'); 
            
            
             
             select array_upper(registros,1) into cant_cols; --cantidad de columnas del CSV
            
            
            for v_j in 1..(cant_cols-1) loop
                
                 --si el formato decimal csv  esta dividio por comas replazamos por puntos           
               
                 registros[v_j] := (select replace(registros[v_j]::text,',','.')); --reemplazar las comas por puntos
                
                v_consulta := v_consulta ||''''|| registros[v_j] || ''','; --continuar con la insercion hasta la columna N-1
                     	
            end loop;
           
            registros[cant_cols] := (select replace(registros[cant_cols]::text,',','.')); --reemplazar las comas por puntos
                
            
            v_consulta := v_consulta ||''''||  registros[cant_cols] || ''');'; --insertar la ultima columna 
            execute v_consulta; --ejecutar el inser
            
              
      END LOOP;
      
      
       
      
      -- consultas la columnas del tipo sensor correpondientes ordenadas por la columnas orden
         
       v_consulta_final:='insert into hidro.thd_tipo_sensor_'|| v_parametros.tipo_sensor_codigo ||' (id_sensor';
                           
    

         v_cont=0;
         
         FOR v_registros in ( Select cs.codigo_columna, cs.nombre_columna, 
         							 cs.mapeo_archivo,cs.tipo_dato,cs.orden
                              from hidro.thd_tipo_columna_sensor cs  
                              where cs.id_tipo_sensor=v_parametros.id_tipo_sensor) LOOP
                              
           --arma la primera parte de la consuulta
           v_consulta_final=v_consulta_final||','||v_registros.codigo_columna;
          v_cont=v_cont+1; 
          
           --arma vector con los nombre de las columnas y tipos para la segunda parte
           v_array_codigos[v_cont] = v_registros.codigo_columna;
           v_array_tipos[v_cont] = v_registros.tipo_dato;
           v_array_orden[v_cont] = v_registros.orden;
          
         
                              
         END LOOP;
         
    
         --consulta las columnas del tipo snsor
       
         v_consulta := 'select * from valores_importados'; 
       
         v_cont_reg=0;
       
        FOR v_registros_excel in (select * from valores_importados) LOOP
        
          v_cont_reg=v_cont_reg+1;
        
          v_consulta_final2:=',estado_reg,id_usuario_reg,fecha_reg) values('||v_parametros.id_sensor;
          
               FOR v_i IN 1..v_cont LOOP
                 v_aux_val=f_get_parametro_by_id('valores_importados',v_array_codigos[v_i],'id='||v_cont_reg::varchar);
                   -- 
                   
                   IF v_aux_val<> '' THEN
                     IF( v_array_tipos[v_i]='varchar' or  v_array_tipos[v_i]='text' or  v_array_tipos[v_i]='date' or  v_array_tipos[v_i]='timestamp' or  v_array_tipos[v_i]='time')THEN
                         
                         v_consulta_final2=v_consulta_final2||','''||v_aux_val||'''';
                      ELSE
                         v_consulta_final2=v_consulta_final2||','||v_aux_val;
                      END IF;
                    ELSE
                    v_consulta_final2=v_consulta_final2||','||'NULL';
                    END IF;
                
                
                END LOOP;
                 
                
                v_consulta_final2=v_consulta_final||v_consulta_final2||',''activo'','||p_id_usuario::varchar||','''||now()||''');';
                  
                --raise exception '%',v_consulta_final2;
                
                execute (v_consulta_final2);
              

          
          END LOOP;                     
        
        --Definicion de la respuesta
		v_resp = f_agrega_clave(v_resp,'mensaje','Mediciones importadas'); 
       

        --Devuelve la respuesta*/
         return v_resp;
        
		end;   
        

	/*********************************    
 	#TRANSACCION:  'HD_TISECO_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	elsif(p_transaccion='HD_TISECO_ELI')then

		begin
        
            --Sentencia de la eliminacion
            v_consulta='delete from hidro.thd_tipo_sensor_'||v_parametros.tipo_sensor_codigo ||'
                    where id_tipo_sensor_'||v_parametros.tipo_sensor_codigo||'='||v_parametros.id_tipo_sensor_codigo;
                    
             execute(v_consulta);
                    
			 --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Sensor Codigo  hidro.thd_tipo_sensor_'||v_parametros.tipo_sensor_codigo ||' eliminado(a)'||v_parametros.id_tipo_sensor_codigo); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_columna_sensor',v_parametros.id_tipo_sensor_codigo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 949 (class 1255 OID 207254)
-- Dependencies: 13 3246
-- Name: f_thd_tipo_sensor_codigo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_tipo_sensor_codigo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_sensor_codigo_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_tipo_columna_sensor'
 AUTOR: 		 (rac)
 FECHA:	        16-03-2012 17:06:17
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_param  varchar[];
    v_tamano integer;
    v_i integer;
    v_param_det varchar[];
      
BEGIN

	v_nombre_funcion = 'hidro.f_thd_tipo_sensor_codigo_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TISENCOD_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	if(p_transaccion='HD_TISENCOD_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select  ';
                        
                        
                        
              v_param= string_to_array(v_parametros.datos,'@');
              
              v_tamano = coalesce(array_length(v_param, 1),0);
             

            
            FOR v_i IN 1..v_tamano LOOP
              v_param_det= string_to_array(v_param[v_i],'#');
              v_consulta:=v_consulta||'ticosen.'||trim(v_param_det[1]::varchar)||',';
            END LOOP;          
                        
						
						
            v_consulta:=v_consulta||'
                        ticosen.estado_reg,
                        ticosen.id_usuario_reg,
						ticosen.fecha_reg,
						ticosen.id_usuario_mod,
						ticosen.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from hidro.thd_tipo_sensor_'|| v_parametros.tipo_sensor_codigo ||' ticosen
						inner join segu.tusuario usu1 on usu1.id_usuario = ticosen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ticosen.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
             if(public.f_existe_parametro(p_tabla,'id_sensor')) then
               v_consulta:=v_consulta || ' and ticosen.id_sensor='||v_parametros.id_sensor;
            end if;
            
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;	
            
            
            raise notice '%',v_consulta;



			--Devuelve la respuesta
			return v_consulta;
						
		end;



	/*********************************    
 	#TRANSACCION:  'HD_TISENCODREP_SEL'
 	#DESCRIPCION:	Consulta de datos dinamica para reportes
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	elseif(p_transaccion='HD_TISENCODREP_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select  
            			ticosen.'||v_parametros.tipo_columna_sensor_valor||'::numeric as valor,
						ticosen.'||v_parametros.tipo_columna_sensor_fecha||'::timestamp as fecha
						from hidro.thd_tipo_sensor_'||v_parametros.tipo_sensor_codigo||' ticosen
						where   
                        ticosen.id_sensor='||v_parametros.id_sensor||'
                        and ticosen.'||v_parametros.tipo_columna_sensor_fecha||'<='''||v_parametros.fecha_fin||'''
                        and ticosen.'||v_parametros.tipo_columna_sensor_fecha||'>='''||v_parametros.fecha_ini||'''';

            
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion;	
            
            
            raise notice '%',v_consulta;



			--Devuelve la respuesta
			return v_consulta;
						
		end;
        
    /*********************************    
 	#TRANSACCION:  'HD_PROM_HIDRO'
 	#DESCRIPCION:	Consulta de datos dinamica para reportes
 	#AUTOR:			mflores	
 	#FECHA:			23-05-2012 17:00
	***********************************/

	elseif(p_transaccion='HD_PROM_HIDRO')then     				    

    raise notice 'param: %',v_parametros;
    
    	begin
        
        
    		--Sentencia de la consulta
			v_consulta:='select  
            			ticosen.'||v_parametros.tipo_columna_sensor_valor||'::numeric as valor,
						ticosen.'||v_parametros.tipo_columna_sensor_fecha||'::timestamp as fecha
						from hidro.thd_tipo_sensor_'||v_parametros.tipo_sensor_codigo||' ticosen
						where   
                        ticosen.id_sensor='||v_parametros.id_sensor||'
                        and ticosen.'||v_parametros.tipo_columna_sensor_fecha||'<='''||v_parametros.fecha_fin||'''
                        and ticosen.'||v_parametros.tipo_columna_sensor_fecha||'>='''||v_parametros.fecha_ini||'''';

            
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion;	
            
            
            raise notice '%',v_consulta;



			--Devuelve la respuesta
			return v_consulta;
						
		end;           
    
	/*********************************    
 	#TRANSACCION:  'HD_TISENCOD_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	elsif(p_transaccion='HD_TISENCOD_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_sensor_'||v_parametros.tipo_sensor_codigo ||')
					    from hidro.thd_tipo_sensor_'||v_parametros.tipo_sensor_codigo ||' ticosen
					    inner join segu.tusuario usu1 on usu1.id_usuario = ticosen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ticosen.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta	
            raise notice '%',v_consulta;	    
			v_consulta:=v_consulta||v_parametros.filtro;
            if(public.f_existe_parametro(p_tabla,'id_sensor')) then
               v_consulta:=v_consulta || ' and ticosen.id_sensor='||v_parametros.id_sensor;
            end if;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 950 (class 1255 OID 207256)
-- Dependencies: 13 3246
-- Name: f_thd_tipo_sensor_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_tipo_sensor_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_sensor_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_tipo_sensor'
 AUTOR: 		 (mflores)
 FECHA:	        15-03-2012 10:27:35
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_tipo_sensor		integer;
    v_codigo				varchar;
    v_estado_ts 			varchar;
    v_consulta 				varchar;
    v_record 				record;
    
    var_cod_1				varchar;
    var_codigo				varchar;
    v_aux					varchar;
			    
BEGIN	

    v_nombre_funcion = 'hidro.f_thd_tipo_sensor_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPSEN_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:35
	***********************************/

	if (p_transaccion = 'HD_TIPSEN_INS') then
		
        var_codigo := '';
        v_aux := trim(both ' ' from v_parametros.codigo);
        raise notice '%', v_aux;
        
        while (select position(' ' in v_aux)) > 0 loop                    
            
            var_cod_1 := (select substr(v_aux,1, (select position(' ' in v_aux)) -1));            
            v_aux := (select substr(v_aux, (select position(' ' in v_aux))));
            var_codigo := COALESCE(var_codigo||var_cod_1);                   
            v_aux := trim(both ' ' from v_aux);               
              
        end loop;
              
        v_aux := trim(both ' ' from v_aux);
        var_codigo := COALESCE(var_codigo||v_aux);
        raise notice '%', var_codigo;
                      		
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_tipo_sensor(
			estado_reg,
			abreviacion,
			--tipo_dato,
			codigo,
			--equivalente_hidra,
			descrip,
			nombre_sensor,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.abreviacion,
			--v_parametros.tipo_dato,			
            lower(var_codigo), --v_parametros.codigo,
			--v_parametros.equivalente_hidra,
			v_parametros.descrip,
			v_parametros.nombre_sensor,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_tipo_sensor into v_id_tipo_sensor;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Sensor almacenado(a) con exito (id_tipo_sensor'||v_id_tipo_sensor||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_sensor',v_id_tipo_sensor::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPSEN_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:35
	***********************************/

	elsif(p_transaccion='HD_TIPSEN_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_tipo_sensor set
			abreviacion = v_parametros.abreviacion,
			--tipo_dato = v_parametros.tipo_dato,
			codigo = v_parametros.codigo,
			--equivalente_hidra = v_parametros.equivalente_hidra,
			descrip = v_parametros.descrip,
			nombre_sensor = v_parametros.nombre_sensor,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_tipo_sensor=v_parametros.id_tipo_sensor;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Sensor modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_sensor',v_parametros.id_tipo_sensor::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;
        
    /*********************************    
 	#TRANSACCION:  'HD_GENTAB_MOD'
 	#DESCRIPCION:	Genera la tabla dinamica para el tipo sensor y cambia de estado
 	#AUTOR:		rac	
 	#FECHA:		15-03-2012 10:27:35
	***********************************/

	elsif(p_transaccion='HD_GENTAB_MOD')then

		begin
          --0) obtiene datos iniciales
             select ts.estado_ts, ts.codigo into v_estado_ts, v_codigo
             from hidro.thd_tipo_sensor ts
             where ts.id_tipo_sensor=v_parametros.id_tipo_sensor;
             
          --1) verifica que este en estado borrado
          
            if(v_estado_ts <> 'borrador') then
            	raise exception  'Solo se puede generar tablas para el estado borrador';
            end if;
          
          --2) preprara prefijo de creacion de tabla
          
          v_consulta = 'CREATE TABLE hidro.thd_tipo_sensor_'||v_codigo||' (
                          id_tipo_sensor_'||v_codigo||' SERIAL NOT NULL, 
                          id_tipo_sensor INTEGER,
                          id_sensor INTEGER
                          ';
                          
          
          --3) FOR  consulta llas columas en orden de prioridad
          
          IF  exists (select 1 
                    from hidro.thd_tipo_columna_sensor tcs 
                    where tcs.id_tipo_sensor =v_parametros.id_tipo_sensor) THEN
          
                  FOR v_record in (select tcs.codigo_columna, tcs.tipo_dato 
                                   from hidro.thd_tipo_columna_sensor tcs 
                                   where tcs.id_tipo_sensor =v_parametros.id_tipo_sensor )LOOP
                  
                  --2.3) 
                  --2.4) va armando columnas para la creacion de la tabla
                   v_consulta = v_consulta ||','||v_record.codigo_columna ||'  '||v_record.tipo_dato;
                  
                  
                  END LOOP;
                  --4) cierra prefijo
                  
                 v_consulta = v_consulta ||', CONSTRAINT thd_tipo_sensor_'||v_codigo||'_pkey PRIMARY KEY(id_tipo_sensor_'||v_codigo||'), 
                                  CONSTRAINT fk_thd_tipo_sensor_'||v_codigo||'__id_tipo_sensor FOREIGN KEY (id_tipo_sensor)
                                  REFERENCES hidro.thd_tipo_sensor(id_tipo_sensor)
                                  ON DELETE NO ACTION
                                  ON UPDATE NO ACTION
                                  NOT DEFERRABLE,
                                  CONSTRAINT fk_thd_sensor_'||v_codigo||'__id_sensor FOREIGN KEY (id_sensor)
                                  REFERENCES hidro.thd_sensor(id_sensor)
                                  ON DELETE NO ACTION
                                  ON UPDATE NO ACTION
                                  NOT DEFERRABLE
                                  
                                ) INHERITS (public.tbase)
                                WITHOUT OIDS;';
                  
                  --5) crea tabla
                  RAISE NOTICE  '%',v_consulta;
                  execute (v_consulta);
                   RAISE NOTICE  '>>>>>>>>>>>';
                  
                  
                  --6) otorga permisos al rol generico de usuarios para base de datos sobre esquema hidro
                  
                   v_consulta= 'GRANT ALL PRIVILEGES ON hidro.thd_tipo_sensor_'||v_codigo||'  TO "rol_usuario_'||(current_database()::text)||'"';
                   RAISE NOTICE  '%',v_consulta;
                   EXECUTE (v_consulta);
                  
                  
                  --7)cambia estado del tipo sensor
                    update hidro.thd_tipo_sensor set
                    estado_ts='generado',
                    id_usuario_mod = p_id_usuario,
                    fecha_mod = now()
                    where id_tipo_sensor=v_parametros.id_tipo_sensor;
                       
                    --Definicion de la respuesta
                    v_resp = f_agrega_clave(v_resp,'mensaje','Tabla generada para el tipo sensor ' ||v_codigo); 
                    v_resp = f_agrega_clave(v_resp,'id_tipo_sensor',v_parametros.id_tipo_sensor::varchar);
                       
                    --Devuelve la respuesta
                    return v_resp;

           ELSE

             raise exception 'El tipo de sensor no tiene columnas definidas';

           END IF;
            
		end;
           

	/*********************************    
 	#TRANSACCION:  'HD_TIPSEN_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:35
	***********************************/

	elsif(p_transaccion='HD_TIPSEN_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from hidro.thd_tipo_sensor
            
            update hidro.thd_tipo_columna_sensor set
            estado_reg = 'inactivo'
            where id_tipo_sensor=v_parametros.id_tipo_sensor;
            
            update hidro.thd_tipo_sensor set
            estado_reg = 'inactivo'
            where id_tipo_sensor=v_parametros.id_tipo_sensor;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo Sensor eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_sensor',v_parametros.id_tipo_sensor::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 951 (class 1255 OID 207258)
-- Dependencies: 13 3246
-- Name: f_thd_tipo_sensor_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_tipo_sensor_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_tipo_sensor_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_tipo_sensor'
 AUTOR: 		 (mflores)
 FECHA:	        15-03-2012 10:27:35
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_tipo_sensor_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_TIPSEN_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:35
	***********************************/

	if(p_transaccion='HD_TIPSEN_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						tipsen.id_tipo_sensor,
						tipsen.estado_reg,
						tipsen.abreviacion,
						--tipsen.tipo_dato,
						tipsen.codigo,
						-- tipsen.equivalente_hidra,
						tipsen.descrip,
						tipsen.nombre_sensor,
						tipsen.id_usuario_reg,
						tipsen.fecha_reg,
						tipsen.id_usuario_mod,
						tipsen.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        tipsen.estado_ts	
						from hidro.thd_tipo_sensor tipsen
						inner join segu.tusuario usu1 on usu1.id_usuario = tipsen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipsen.id_usuario_mod
				        where tipsen.estado_reg = ''activo'' and  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

--			raise notice '%', v_consulta;
            --Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_TIPSEN_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		15-03-2012 10:27:35
	***********************************/

	elsif(p_transaccion='HD_TIPSEN_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_sensor)
					    from hidro.thd_tipo_sensor tipsen
					    inner join segu.tusuario usu1 on usu1.id_usuario = tipsen.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipsen.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 952 (class 1255 OID 207259)
-- Dependencies: 13 3246
-- Name: f_thd_unidad_medida_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_unidad_medida_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_unidad_medida_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'hidro.thd_unidad_medida'
 AUTOR: 		 (mflores)
 FECHA:	        02-04-2012 17:34:59
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_simbolo				varchar;
			    
BEGIN

    v_nombre_funcion = 'hidro.f_thd_unidad_medida_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_UNIMED_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:59
	***********************************/

	if(p_transaccion='HD_UNIMED_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into hidro.thd_unidad_medida(
			estado_reg,
			simbolo,
			unidad_medida,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.simbolo,
			v_parametros.unidad_medida,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING simbolo into v_simbolo;
               
            raise exception '%', v_simbolo;
            
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Unidad medida almacenado(a) con exito (simbolo'||v_simbolo||')'); 
            v_resp = f_agrega_clave(v_resp,'simbolo',v_simbolo::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'HD_UNIMED_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:59
	***********************************/

	elsif(p_transaccion='HD_UNIMED_MOD')then

		begin
			--Sentencia de la modificacion
			update hidro.thd_unidad_medida set
			simbolo = v_parametros.simbolo,
			unidad_medida = v_parametros.unidad_medida,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where simbolo = v_parametros.simbolo;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Unidad medida modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'simbolo',v_parametros.simbolo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'HD_UNIMED_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:59
	***********************************/

	elsif(p_transaccion='HD_UNIMED_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from hidro.thd_unidad_medida
            where simbolo=v_parametros.simbolo;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Unidad medida eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'simbolo',v_parametros.simbolo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 953 (class 1255 OID 207260)
-- Dependencies: 13 3246
-- Name: f_thd_unidad_medida_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: hidro; Owner: -
--

CREATE FUNCTION f_thd_unidad_medida_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Hidrologia
 FUNCION: 		hidro.f_thd_unidad_medida_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'hidro.thd_unidad_medida'
 AUTOR: 		 (mflores)
 FECHA:	        02-04-2012 17:34:59
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'hidro.f_thd_unidad_medida_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'HD_UNIMED_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:59
	***********************************/

	if(p_transaccion='HD_UNIMED_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						--unimed.id_unidad_medida,
						unimed.estado_reg,
						unimed.simbolo,
						unimed.unidad_medida,
						unimed.id_usuario_reg,
						unimed.fecha_reg,
						unimed.id_usuario_mod,
						unimed.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from hidro.thd_unidad_medida unimed
						inner join segu.tusuario usu1 on usu1.id_usuario = unimed.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = unimed.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'HD_UNIMED_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mflores	
 	#FECHA:		02-04-2012 17:34:59
	***********************************/

	elsif(p_transaccion='HD_UNIMED_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(simbolo)
					    from hidro.thd_unidad_medida unimed
					    inner join segu.tusuario usu1 on usu1.id_usuario = unimed.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = unimed.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


SET search_path = param, pg_catalog;

--
-- TOC entry 954 (class 1255 OID 207261)
-- Dependencies: 15 3246
-- Name: ___f_obtener_correlativo(integer, integer, integer, integer); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ___f_obtener_correlativo(par_id_documento integer, par_id_periodo integer, par_id_gestion integer, par_id_usuario integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.f_obtener_correlativo
 DESCRIPCION:   Obtiene el correlativo de acuerdo al documento y periodo/gestion especificado
 AUTOR: 	    KPLIAN
 FECHA:	        03/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE

    
    v_resp                      varchar;
    v_nombre_funcion            text;
    v_mensaje_error             text;
    
    v_correlativo               integer;
    v_cadena                    varchar;
BEGIN
    v_nombre_funcion:='param.f_obtener_correlativo';
    -- verificar que los parametros de entrada no sean nulos (id_periodo e id_gestion) al mismo tiempo
    if(par_id_periodo is null and par_id_gestion is null) then
        raise exception 'Se debe indicar un modo de obtencion de Correlativos. Por PERIODO o GESTION';
    end if;
    
    if(par_id_periodo is not null and par_id_gestion is not null) then
        raise exception 'Solo se debe indicar un modo de obtencion de Correlativos. Por PERIODO o GESTION';
    end if;
    -- validar la existencia del documento para el que se quiere obtener el correlativo
    if not exists (select 1 from param.tdocumento where id_documento=par_id_documento) then
        raise exception 'Obtencion de correlativo no realizada. Documento inexistente';
    end if;
    
    if(par_id_periodo is null) then
      -- validar gestion activa
      if exists (select 1 from param.tgestion where id_gestion=par_id_gestion and estado_reg!='activo') then
         raise exception 'La gestion no esta activa';
      end if;
    else
      if exists (select 1 from param.tperiodo where id_periodo=par_id_periodo and estado_reg!='activo') then
         raise exception 'El periodo solicitado no esta activo';
      end if;
    end if;
    -- validar si existe alguna numeracion generada de acuerdo a los parametros de entrada
    if((select count(*) from param.tcorrelativo where id_documento=par_id_documento and (id_periodo=par_id_periodo or id_gestion=par_id_gestion))>0) then
         v_correlativo:=(select coalesce(num_actual,0) from param.tcorrelativo where id_documento=par_id_documento and ||' '||v_cadena );
    else
         v_correlativo:=0;
    end if;

   if (v_correlativo=0) then
     insert into param.tcorrelativo (id_documento,id_gestion, id_periodo,num_actual, num_siguiente, estado_reg, fecha_reg, id_usuario_reg )
     values (par_id_documento, par_id_gestion, par_id_periodo, v_correlativo+1, v_correlativo+2, 'activo', now(), par_id_usuario);
   else
        -- validar que el correlativo que se quiere generar siga el mismo tipo de periodicidad
        if not exists (select 1 from param.tcorrelativo where id_documento=par_id_documento and (
                   (par_id_periodo is null and id_periodo is null) and (par_id_gestion is not null and id_gestion is not null)
                 or (par_id_periodo is not null and id_periodo is not null) and (par_id_gestion is null and id_gestion is null)
                   )
        ) then
        raise exception 'No es posible obtener un correlativo por % ',f_iif (par_id_periodo is null, 'Gestion', 'Periodo') || 'pues el documento tiene periodicidad de ' ||f_iif (par_id_periodo is null, 'Periodo', 'Gestion');

        end if;
     
        update param.tcorrelativo set
            num_siguiente=num_actual+2,
            num_actual=num_actual+1
        where id_documento=par_id_documento
        and  (id_periodo=par_id_periodo or id_gestion=par_id_gestion);
   end if;

   return v_correlativo+1;
EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 955 (class 1255 OID 207262)
-- Dependencies: 15 3246
-- Name: f_convertir_moneda(integer, integer, numeric, date, character varying, integer); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION f_convertir_moneda(p_id_moneda_1 integer, p_id_moneda_2 integer, p_importe numeric, p_fecha date, p_tipo character varying, p_num_decimales integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.f_convertir_moneda
 DESCRIPCION:   Convierte el importe de la moneda1 a la moneda2 con el tipo
                de cambio "O" Oficial "C" Compra y "V" venta por defecto "O" y con el redondeo
                p_num_decimales por defecto 2
 AUTOR: 	    KPLIAN (jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE


    v_resp                      varchar;
    v_nombre_funcion            text;
    v_mensaje_error             text;
    v_id_moneda_2               integer;
    v_registro                  record;
    v_id_moneda_base            integer;
    v_res                       numeric;
    v_id_moneda_1               integer;
    v_moneda                    varchar;
    v_tipo                      varchar;
    v_num_decimales             integer;
BEGIN
    v_nombre_funcion:='param.f_convertir_moneda';
    
    /*Dar valores por defecto*/
    if(p_tipo is null)then
        v_tipo='O';
    else
        v_tipo='O';
    end if;
    if(p_num_decimales is null)then
        v_num_decimales=2;
    else
        v_num_decimales=p_num_decimales;
    end if;
    
    if(p_fecha is null)then
        raise exception 'Debe definir una fecha para realizar la conversion de monedas';
    end if;
    
    /*Obtener la moneda base*/
    v_id_moneda_base=param.f_get_moneda_base();

    /*Si la moneda 2 es null obtener la moneda base*/
    if(p_id_moneda_2 is null)then
        v_id_moneda_2=v_id_moneda_base;
    else
        v_id_moneda_2=p_id_moneda_2;
    end if;
    
    /*Si la moneeda 1 y la 2 son la misma se devuelve el mismo importe*/
    if(p_id_moneda_1=v_id_moneda_2)then
        return p_importe;
    end if;
    
    /*Si la moneda 1 y la moneda 2 no son la moneda base se convierte la moneda 1 a la moneda base*/
    if(p_id_moneda_1!=v_id_moneda_base and v_id_moneda_2!=v_id_moneda_base)then
        v_res=  param.f_convertir_moneda(p_id_moneda_1,v_id_moneda_base,
                p_importe,p_fecha,v_tipo,-1);
        
        v_id_moneda_1=v_id_moneda_base;
    else
        v_id_moneda_1=p_id_moneda_1;
        v_res=p_importe;
    end if;

    /*Si la moneda base es la moneda 1 se divide por el tipo de cambio*/
    if(v_id_moneda_base=v_id_moneda_1)then
        select tc.oficial as tipo_cambio,
        (v_res/tc.oficial)as oficial ,
        (v_res/tc.compra) as compra,(v_res/tc.venta) as venta
        into v_registro
        from param.ttipo_cambio tc
        where   tc.id_moneda=v_id_moneda_2 and
                tc.fecha=p_fecha;
                
    /*Si la moneda base es la moneda 2 se multiplica por el tipo de cambio*/
    elsif(v_id_moneda_base=v_id_moneda_2)then
        
        select tc.oficial as tipo_cambio,
        (v_res*tc.oficial) as oficial,
        (v_res*tc.compra) as compra,(v_res*tc.venta)as venta
        into v_registro
        from param.ttipo_cambio tc
        where   tc.id_moneda=v_id_moneda_1 and
                tc.fecha=p_fecha;
        
                
        v_id_moneda_2=v_id_moneda_1;
    else
        raise exception 'Ha ocurrido un error al realizar la conversion de monedas';
    end if;
    
    if(v_registro.tipo_cambio is null)then
        select m.moneda
        into v_moneda
        from param.tmoneda m
        where id_moneda=v_id_moneda_2;
        raise exception 'No existe tipo de cambio para la fecha: % y la moneda: % ',
                        to_char(p_fecha,'DD/MM/YYYY'),v_moneda;
    end if;
    
    /*Retorna el valor q corresponda segun sea oficial, compra o venta y con el redondeo*/
    if(v_tipo='O')then
        if(v_num_decimales=-1)then
            return v_registro.oficial;
        else
            return round(v_registro.oficial,v_num_decimales);
        end if;
    elsif(v_tipo='C')then
        if(v_num_decimales=-1)then
            return v_registro.compra;
        else
            return round(v_registro.compra,v_num_decimales);
        end if;
    elsif(v_tipo='V')then
        if(v_num_decimales=-1)then
            return round(v_registro.venta,v_num_decimales);
        else
            return v_registro.venta;
        end if;
    ELSE
        raise exception 'No existe el tipo % para convertir las monedas',v_tipo;
    end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 956 (class 1255 OID 207263)
-- Dependencies: 15 3246
-- Name: f_get_moneda_base(); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION f_get_moneda_base() RETURNS integer
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.f_get_moneda_base
 DESCRIPCION:   Devuelve la moneda base de la empresa
 AUTOR: 	    KPLIAN (jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE

    
    v_resp                      varchar;
    v_nombre_funcion            text;
    v_mensaje_error             text;
    v_id_moneda                 integer;
BEGIN
    v_nombre_funcion:='param.f_get_moneda_base';
    
    select id_moneda
    into v_id_moneda
    from param.tmoneda
    where tipo_moneda='base';
    
    if(v_id_moneda is null)then
        raise exception 'No se ha definido una moneda base en el sistema';
    end if;
    return v_id_moneda;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 957 (class 1255 OID 207264)
-- Dependencies: 15 3246
-- Name: f_inserta_alarma(integer, character varying, character varying, date, character varying, character varying, integer, character varying, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION f_inserta_alarma(par_id_funcionario integer, par_descripcion character varying, par_acceso_directo character varying, par_fecha date, par_tipo character varying, par_obs character varying, par_id_usuario integer, par_clase character varying, par_titulo character varying, par_parametros character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/************************************
FUNCION: f_inserta_alarma
AUTOR: 	    fprudencio
PARAMETROS: par_id_funcionario : indica el funcionario para el que se genera la alrma
            par_descripcion: una descripción de la alarma
            par_acceso_directo: es el link que lleva a la relacion de la alarma generada
            par_fecha: Indica la fecha de vencimiento de la alarma
            par_tipo: indica el tipo de alarma, puede ser alarma o notificacion
            par_obs: son las observaciones de la alarma

************************************/
DECLARE
    
    v_id_alarma                             integer;
    v_nombre_funcion						text;  
    v_resp                                  varchar;
BEGIN

v_nombre_funcion:='param.f_inserta_alarma';
   
   --realizamos la inserción de datos en alarma
   
   insert into param.talarma(
			acceso_directo,
			id_funcionario,
			fecha,
			estado_reg,
			descripcion,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod,
            tipo,
            obs,
            clase,
            titulo,
            parametros
          	) values(
			par_acceso_directo,
			par_id_funcionario,
			par_fecha,
			'activo',
			par_descripcion,
			par_id_usuario,
			now()::date,
			null,
			null,
            par_tipo,
            par_obs,
            par_clase,
            par_titulo,
            par_parametros
			)RETURNING id_alarma into v_id_alarma;
    
    return v_id_alarma;
    


EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 897 (class 1255 OID 207265)
-- Dependencies: 15 3246
-- Name: f_obtener_correlativo(character varying, integer, integer, integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION f_obtener_correlativo(par_codigo_documento character varying, par_id integer, par_id_uo integer, par_id_depto integer, par_id_usuario integer, par_codigo_subsistema character varying, par_formato character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.f_obtener_correlativo
 DESCRIPCION:   Obtiene el correlativo de acuerdo al id_documento y su configuracion
               periodo/gestion  depto/uo/depto_uo, el formato
 
 AUTOR: 	    KPLIAN (mzm)
 FECHA:	        03/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:  1)se cambia los parametros de entra  id_documento por codigo_documento
               2)se agregan los parametro par_codigo_subsistema
               3) se agrega la variable par_formato 
                 'sin' => solo devuelve el correlativo correspondiente solo numero
                 'is not NULL'=> evalua  las palabra clave :'depto','uo', 'codsub',
                 											'coddoc','periodo','gestion'
                                                            'correlativo' 
                                 y las remplaza por su valor correpondiente                           
                                                            
                 'NULL' => si el valor es nulo obtiene le formato por defecto
                           revisa el formato configurado en el documento si no existe 
                           usa formato por defecto segun tipo depto/uo/depto_uo
 
               4) cambia el tipo de dato de vuelto, antes integer ahora varchar
               
               
 AUTOR:		KPLIAN (rac)
 FECHA:		1/12/2011
 ***************************************************************************/
DECLARE

    
    v_resp                      varchar;
    v_nombre_funcion            text;
    v_mensaje_error             text;
    
    v_correlativo               integer;
    v_cadena                    varchar;
    v_periodo_gestion           varchar;
    v_tipo_numeracion           varchar;
    v_id                        integer;
    par_id_documento		integer;
    v_num_periodo integer;
    v_num_gestion integer;
    v_codigo_uo varchar;
    v_codigo_depto varchar;
    v_formula varchar;
    v_formato_doc varchar;
    g_registros record;
    v_consulta varchar;
    v_where varchar;
BEGIN
    
    v_nombre_funcion:='param.f_obtener_correlativo';
    
    --0)obtenemos el id_documento segun el codigo indicado
      --por tipo_documento se tiene la informacion de si se numera por periodo o gestion
      --si se envia null en un doc q se numera por periodo==> numerar de acuerdo a la fecha_actual(defecto)
 
 
         raise notice 'par_codigo_documento =% par_codigo_subsistema=%',par_codigo_documento,par_codigo_subsistema;
    
          SELECT d.id_documento, d.periodo_gestion, d.tipo_numeracion , d.formato
          into   par_id_documento,v_periodo_gestion, v_tipo_numeracion,v_formato_doc
          FROM param.tdocumento d
          INNER JOIN segu.tsubsistema s 
          on s.id_subsistema = d.id_subsistema and s.codigo = par_codigo_subsistema
          WHERE d.estado_reg='activo' and d.codigo = par_codigo_documento;
    
    
   -- raise exception 'par_id_documento=%',v_formato_doc;
    
     --     raise exception 'aa%',v_formato_doc;
    --1) validar la existencia del documento para el que se quiere obtener el correlativo
    if par_id_documento is NULL then
        raise exception 'Obtencion de correlativo no realizada. Documento inexistente % o esta inactivo',par_codigo_documento;
    end if;
    
    --2) verifica si el  tipo de numeracio es depto y si es asi que  exista la variable id_depto
    if (v_tipo_numeracion  in ('depto','depto_uo') and par_id_depto is null) then
        raise exception 'La numeracion del documento requiere indicar DEPTO';
    else
    --obtenemos codigo depto
     select d.codigo into v_codigo_depto from param.tdepto d where d.id_depto = par_id_depto;
    
    end if;
    
    --3) verifica si el  tipo de numeracio se UO y si es asi que  exista la variable id_uo
    if (v_tipo_numeracion  in ('uo','depto_uo') and par_id_uo is null) then
        raise exception 'La numeracion del documento requiere indicar UO';
    else
      --obtenemos codigo UO
      select u.codigo into v_codigo_uo from rhum.tuo u where u.id_uo = par_id_uo;
    end if;
    
    
    -- 4) IF - Si la numeracion se realiza por periodo obtiene el periodo correspondiente
        --     NOTA si el par_id esta definido indica le periodo al que se quiere
        --     obtener el correlativo
    v_id:=par_id;
    
    raise notice '% %',par_id,v_periodo_gestion;
    
    if(v_periodo_gestion='periodo') then
    
     raise notice 'periodo % %',v_id,v_num_periodo;
         
         --4.1) obtiene la id del periodo
         IF(par_id is null) THEN
         
            -- la numeracion se genera en base al periodo de la fecha actual
            select p.id_periodo, p.periodo,ges.gestion
            into v_id, v_num_periodo ,v_num_gestion
            from param.tperiodo p
            inner join param.tgestion ges on ges.id_gestion = p.id_gestion and ges.estado_reg ='activo'
            where p.estado_reg='activo' and  now()::date between fecha_ini and fecha_fin ;
            
            if(v_id is null) then
               raise exception 'Periodo para la fecha % inexistente', now()::date ;
            end if;
         ELSE 
         
            select p.id_periodo, p.periodo, ges.gestion
            into v_id, v_num_periodo,v_num_gestion
            from param.tperiodo p
            inner join param.tgestion ges on ges.id_gestion = p.id_gestion and ges.estado_reg ='activo'
            where  p.estado_reg='activo' and p.id_periodo = par_id;  
    
         END IF; 
         -- en funcion al id enviado
         if exists (select 1 from param.tperiodo where id_periodo=v_id and estado_reg!='activo') then
               raise exception 'El periodo solicitado no esta activo';
         end if;

        
       
   ELSE
    
       -- 5.1) obtiene el id de la gestion 
         IF(par_id is null) then
               select g.id_gestion , g.gestion
               into v_id, v_num_gestion
               from param.tgestion g
               where g.estado_reg='activo' and g.gestion=to_char(now()::date,'YYYY')::integer;
               
              if(v_id is null) then
                 raise exception 'Gestion % no existente', to_char(now()::date,'YYYY');
              end if;
              
         ELSE 
               select g.id_gestion , g.gestion
               into v_id, v_num_gestion
               from param.tgestion g
               where g.id_gestion = par_id; 
         END IF;

         if exists (select 1 from param.tgestion where id_gestion=v_id and estado_reg!='activo') then
               raise exception 'La gestion no esta activa';
         end if;
      
    end if;
    
   
    
    -- verifica si existe un registro de correlativo para este documento
                raise notice '0 id_documento % ',par_id_documento;
                raise notice '1 gestion >>> %',f_iif(v_periodo_gestion='gestion',v_id::varchar,0::varchar)::integer ;
                raise notice '2 periodo >>> %',f_iif (v_periodo_gestion='periodo',v_id::varchar,0::varchar)::integer;
                raise notice '3 uo >>> %',f_iif(v_tipo_numeracion in ('uo','depto_uo'), par_id_uo::varchar, 0::varchar)::integer;
                raise notice '4 depto >>> %',f_iif(v_tipo_numeracion in ('depto','depto_uo'),par_id_depto::varchar, 0::varchar)::integer;

    
    
    v_where = '   id_documento='||par_id_documento::varchar ||'
                  and id_gestion '|| f_iif(v_periodo_gestion='gestion','= '||v_id::varchar,'is NULL') ||'
                  and id_periodo '|| f_iif (v_periodo_gestion='periodo','= '||v_id::varchar,'is NULL')||'
                  and id_uo      '||  f_iif(v_tipo_numeracion in ('uo','depto_uo'), '= '||par_id_uo::varchar,'is NULL')||'
                  and id_depto   '|| f_iif(v_tipo_numeracion in ('depto','depto_uo'),'= '||par_id_depto::varchar, 'is NULL');
     
     
     FOR g_registros in EXECUTE('select 0 as res
                          from param.tcorrelativo 
                          where '|| v_where)
     LOOP
     
       
           v_correlativo:=g_registros.res;
            
       
     
     END LOOP;
     
     
     
raise notice '>> % correlativo ini %',v_where,v_correlativo;
            
    
    
    
   -- 6) si no existe correlativo para el periodo o gestion se crea un registro
   
      if(v_correlativo is NULL) then
      
      v_correlativo=0;

         insert into param.tcorrelativo 
         (id_documento,	 
          id_gestion, 
          id_periodo,  
          num_actual, 
          num_siguiente, 
          estado_reg, 
          fecha_reg,   
          id_usuario_reg , 
          id_uo,
          id_depto)
         values (
         	par_id_documento, 
            f_iif(v_periodo_gestion='gestion',v_id::varchar,NULL)::integer, 
            f_iif (v_periodo_gestion='periodo',v_id::varchar,NULL)::integer,
         	v_correlativo+1, 
            v_correlativo+2, 
            'activo', 
            now(), 
            par_id_usuario, 
            f_iif(v_tipo_numeracion in ('uo','depto_uo'), par_id_uo::varchar, NULL)::integer, 
            f_iif((v_tipo_numeracion in ('depto','depto_uo')),par_id_depto::varchar, NULL)::integer
            );
         	v_correlativo:=1;
      else
      
         -- 7) si  existe correlativo se actualiza la numeracion para el registro
         --    seleciona el registro bloqueando la tabla para evitar duplicados
         
             FOR g_registros in EXECUTE('SELECT
                                          id_correlativo,
                                          num_actual 
                                          FROM param.tcorrelativo
                                          WHERE '|| v_where ||'
                                          FOR UPDATE
                                          ')
             LOOP
             
              	update param.tcorrelativo
         	 	set num_siguiente=g_registros.num_actual+2,
          		num_actual=g_registros.num_actual+1
         		where 
            	id_correlativo=g_registros.id_correlativo;
            
               v_correlativo=g_registros.num_actual+1;
             
             END LOOP;
        
                       
         
    end if;
    
    raise notice 'correlativo % tipo  % gestion %',v_correlativo,v_tipo_numeracion,v_num_gestion;

 --9) verifica si es necesario retorna el numero con formato   
                        --raise exception 'aa%',par_formato;
  IF(par_formato = 'sin')THEN
                raise exception 'sinnn%',par_formato;
    return v_correlativo::varchar;
    
  ELSEIF par_formato is  not null THEN
                    raise exception 'not null%',par_formato;
     
       --validar q el valor enviado sea uno de los siguientes
       if(par_formato not in ('depto','uo','codsub','coddoc','periodo','gestion','correlativo')) then
             raise exception 'Formato no conocido para generacion de numeracion';
       end if;
      --'depto-docdoc-periodo/correlativo'
    
      v_formula = replace(par_formato,'depto', COALESCE(v_codigo_depto,'')::varchar);  
      v_formula = replace(v_formula,'uo', COALESCE(v_codigo_uo,'')::varchar);  
      v_formula = replace(v_formula,'codsub', COALESCE(par_codigo_subsistema,'')::varchar);
      v_formula = replace(v_formula,'coddoc', COALESCE(par_codigo_documento,'')::varchar);
      v_formula = replace(v_formula,'periodo', COALESCE(v_num_periodo::varchar,'')::varchar);
      v_formula = replace(v_formula,'gestion', COALESCE(v_num_gestion::varchar,'')::varchar);
      v_formula = replace(v_formula,'correlativo', COALESCE(v_correlativo::varchar,'')::varchar);
  
     return  v_formula;
  ELSE
        ---raise exception 'llega aqui%',par_formato ;
     IF(v_formato_doc is not null) THEN
                        raise exception 'iiiiffff%',par_formato;
          v_formula = replace(v_formato_doc,'depto', COALESCE(v_codigo_depto,'')::varchar);  
          v_formula = replace(v_formula,'uo', COALESCE(v_codigo_uo,'')::varchar);  
          v_formula = replace(v_formula,'codsub', COALESCE(par_codigo_subsistema,'')::varchar);
          v_formula = replace(v_formula,'coddoc', COALESCE(par_codigo_documento,'')::varchar);
          v_formula = replace(v_formula,'periodo', COALESCE(v_num_periodo::varchar,'')::varchar);
          v_formula = replace(v_formula,'gestion', COALESCE(v_num_gestion::varchar,'')::varchar);
          v_formula = replace(v_formula,'correlativo', COALESCE(v_correlativo::varchar,'')::varchar);
      
         return  v_formula;

     ELSE      --raise exception 'elseeeee%',par_formato;
             v_formula='';
              IF v_tipo_numeracion = 'uo' THEN
              
                  v_formula = v_codigo_uo;        
            
              ELSEIF v_tipo_numeracion = 'depto_uo' THEN  

                  v_formula = COALESCE(v_codigo_depto,'')||'-'||COALESCE(v_codigo_uo,'');  
                
              ELSEIF v_tipo_numeracion = 'depto' THEN  
                  v_formula = v_codigo_depto;        
                
              END IF;
            
               IF  v_periodo_gestion = 'periodo' THEN
                 v_formula = v_formula||'-'||COALESCE(par_codigo_documento,'')||'-'||COALESCE(v_num_periodo::varchar,'')||'/'||COALESCE(v_correlativo::varchar,'')||'-'||COALESCE(v_num_gestion::varchar,'');
               ELSE
                 v_formula = v_formula||'-'||COALESCE(par_codigo_documento,'')||'-'||COALESCE(v_correlativo::varchar,'')||'-'||COALESCE(v_num_gestion::varchar,'');     
               END IF;
               
             return  v_formula; 
               
      END IF;
        --raise exception 'finoooooo%',par_formato;
  END IF;
        --raise exception 'fin%',par_formato;
EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 898 (class 1255 OID 207267)
-- Dependencies: 15 3246
-- Name: f_sincroniza_proveedor_entre_bd(integer, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION f_sincroniza_proveedor_entre_bd(p_id_proveedor integer, p_host_destino character varying, p_port_destino character varying, p_user_destino character varying, p_pwd_destino character varying, p_bd_destino character varying, p_opcion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    
v_consulta  varchar;
v_respuesta varchar;
v_registros record;

BEGIN
                           
   
       
        IF p_opcion = 'INSERT' THEN
            BEGIN   
                              
             --raise exception 'host%, port%, user%, pwd%, bd%', p_host_destino, p_port_destino, p_user_destino, p_pwd_destino, p_bd_destino;
            /*
              v_consulta:='SELECT id_persona
                                               FROM segu.tpersona where id_persona='||p_id_persona;   */
                  --raise exception 'aa%',coalesce(new.genero,'');          
              if not exists (select P.id_proveedor from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_proveedor
                                               FROM compro.tad_proveedor where id_proveedor='||p_id_proveedor) AS P(
                                                                                id_proveedor integer) ) then
                     
                  select * into v_registros from param.tproveedor where id_proveedor=p_id_proveedor;                                       
                     
                    
                    --raise exception 'nombre_unidad%,v_registros.nombre_cargo%,v_registros.cargo_individual%,v_registros.descripcion%,v_registros.sw_presto%',v_registros.nombre_unidad,v_registros.nombre_cargo,v_registros.cargo_individual,v_registros.descripcion,v_registros.sw_presto;
                  if(v_registros.id_institucion is not null) then   
                       v_consulta:='insert into compro.tad_proveedor(id_proveedor, id_institucion, tipo,
                                    codigo,  fecha_reg, id_usuario_reg) 
                                    values ('||p_id_proveedor||','||v_registros.id_institucion||',
                                    '''||coalesce(v_registros.tipo,'-')||''','''||v_registros.codigo||''','''||now()::date||''','||1||'
                                    );';     
                  else
                       v_consulta:='insert into compro.tad_proveedor(id_proveedor,  id_persona, tipo,
                                    codigo, fecha_reg, id_usuario_reg) 
                                    values ('||p_id_proveedor||','||v_registros.id_persona||',
                                    '''||coalesce(v_registros.tipo,'-')||''','''||v_registros.codigo||''','''||now()::date||''','||1||'
                                    );';
                  end if;

                  v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                        
                  
                  return 'si';
             else 
                  raise exception 'ya existe';
             end if;                                   
            
          end;
        ELSEIF p_opcion='UPDATE' THEN
               BEGIN      
                      if exists (select P.id_proveedor from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_proveedor
                                               FROM compro.tad_proveedor where id_proveedor='||p_id_proveedor) AS P(
                                                                                id_proveedor integer) ) then
                                                                                
                          select * into v_registros from param.tproveedor where id_proveedor=p_id_proveedor;                                        
                     
                          v_consulta:='update compro.tad_proveedor
                          set 
                          id_institucion='||v_registros.id_institucion||', 
                          id_persona='||v_registros.id_persona||', 
                          tipo='''||coalesce(v_registros.tipo,'-')||''',
                          
                          codigo='''||v_registros.codigo||'''
                          where id_proveedor='||p_id_proveedor;   
                          
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);  
                           
                           /*----pendiente adicionar control para actualizacion de informacion de relacion entre uo's ----*/
                           
                            
                           return 'si';
                     else
                           return 'no';          
                     end if;
               END;
        ELSIF p_opcion='DELETE' THEN               
               BEGIN     
                      if exists (select P.id_proveedor from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_proveedor
                                               FROM compro.tad_proveedor where id_proveedor='||p_id_proveedor) AS P(
                                                                                id_proveedor integer) ) then
                                                                                

                           --eliminamos la relacion en estructura_uo                                                                                
                           v_consulta:='delete from compro.tproveedor where id_proveedor='||p_id_proveedor;
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
 
                           return 'si';                                                      
                     else
                       return 'no';
                     end if;
                   
               END;
        END IF;     
        
--RETURN NEW;
            
            
           
  RETURN NULL;
END;
$$;


--
-- TOC entry 899 (class 1255 OID 207268)
-- Dependencies: 15 3246
-- Name: f_tdepto_usuario_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION f_tdepto_usuario_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.f_tdepto_usuario_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.tdepto_usuario'
 AUTOR: 		 (mzm)
 FECHA:	        24-11-2011 18:26:47
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_depto_usuario	integer;
			    
BEGIN

    v_nombre_funcion = 'param.f_tdepto_usuario_ime';
    v_parametros = f_get_record(p_tabla);

    /*********************************    
     #TRANSACCION:  'PM_DEPUSU_INS'
     #DESCRIPCION:    Insercion de registros
     #AUTOR:        mzm    
     #FECHA:        24-11-2011 18:26:47
    ***********************************/

    if(p_transaccion='PM_DEPUSU_INS')then
                    
        begin
            --Sentencia de la insercion
            insert into param.tdepto_usuario(
            estado_reg,
            id_depto,
            id_usuario,
            id_usuario_reg,
            fecha_reg,
            id_usuario_mod,
            fecha_mod    ,
            cargo
              ) values(
            'activo',
            v_parametros.id_depto,
            v_parametros.id_usuario,
            p_id_usuario,
            now(),
            null,
            null ,
            v_parametros.cargo
            )RETURNING id_depto_usuario into v_id_depto_usuario;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Usuario por Depto almacenado(a) con exito (id_depto_usuario'||v_id_depto_usuario||')'); 
            v_resp = f_agrega_clave(v_resp,'id_depto_usuario',v_id_depto_usuario::varchar);

            --Devuelve la respuesta
            return v_resp;

        end;

    /*********************************    
     #TRANSACCION:  'PM_DEPUSU_MOD'
     #DESCRIPCION:    Modificacion de registros
     #AUTOR:        mzm    
     #FECHA:        24-11-2011 18:26:47
    ***********************************/

    elsif(p_transaccion='PM_DEPUSU_MOD')then

        begin
            --Sentencia de la modificacion
            update param.tdepto_usuario set
            id_depto = v_parametros.id_depto,
            id_usuario = v_parametros.id_usuario,
            id_usuario_mod = p_id_usuario,
            fecha_mod = now() ,
            cargo=v_parametros.cargo
            where id_depto_usuario=v_parametros.id_depto_usuario;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Usuario por Depto modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_depto_usuario',v_parametros.id_depto_usuario::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end;

    /*********************************    
     #TRANSACCION:  'PM_DEPUSU_ELI'
     #DESCRIPCION:    Eliminacion de registros
     #AUTOR:        mzm    
     #FECHA:        24-11-2011 18:26:47
    ***********************************/

    elsif(p_transaccion='PM_DEPUSU_ELI')then

        begin
            --Sentencia de la eliminacion
            delete from param.tdepto_usuario
            where id_depto_usuario=v_parametros.id_depto_usuario;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Usuario por Depto eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_depto_usuario',v_parametros.id_depto_usuario::varchar);
              
            --Devuelve la respuesta
            return v_resp;

        end;
         
    else
     
        raise exception 'Transaccion inexistente: %',p_transaccion;

    end if;

EXCEPTION
                
    WHEN OTHERS THEN
        v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
        raise exception '%',v_resp;
                        
END;
$$;


--
-- TOC entry 959 (class 1255 OID 207269)
-- Dependencies: 3246 15
-- Name: f_tdepto_usuario_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION f_tdepto_usuario_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:        Parametros Generales
 FUNCION:         param.f_tdepto_usuario_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'param.tdepto_usuario'
 AUTOR:          (mzm)
 FECHA:            24-11-2011 18:26:47
 COMENTARIOS:    
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:    
 AUTOR:            
 FECHA:        
***************************************************************************/

DECLARE

    v_consulta            varchar;
    v_parametros          record;
    v_nombre_funcion       text;
    v_resp                varchar;
                
BEGIN

    v_nombre_funcion = 'param.f_tdepto_usuario_sel';
    v_parametros = f_get_record(p_tabla);

    /*********************************    
     #TRANSACCION:  'PM_DEPUSU_SEL'
     #DESCRIPCION:    Consulta de datos
     #AUTOR:        mzm    
     #FECHA:        24-11-2011 18:26:47
    ***********************************/

    if(p_transaccion='PM_DEPUSU_SEL')then
                     
        begin
            --Sentencia de la consulta
            v_consulta:='select
                        depusu.id_depto_usuario,
                        depusu.estado_reg,
                        depusu.id_depto,
                        depusu.id_usuario,
                        depusu.id_usuario_reg,
                        depusu.fecha_reg,
                        depusu.id_usuario_mod,
                        depusu.fecha_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod   ,
                        person.nombre_completo1 as desc_usuario     ,
                        depusu.cargo
                        from param.tdepto_usuario depusu 
                        inner join segu.tusuario usudep on usudep.id_usuario=depusu.id_usuario
                        inner join segu.vpersona person on person.id_persona=usudep.id_persona
                        inner join segu.tusuario usu1 on usu1.id_usuario = depusu.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = depusu.id_usuario_mod
                        where  ';
            
            --Definicion de la respuesta
            v_consulta:=v_consulta||v_parametros.filtro;
            
            if (public.f_existe_parametro(p_tabla,'id_depto')) then         
                v_consulta:= v_consulta || ' and depusu.id_depto='||v_parametros.id_depto;
            end if;
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

            --Devuelve la respuesta
            return v_consulta;
                        
        end;

    /*********************************    
     #TRANSACCION:  'PM_DEPUSU_CONT'
     #DESCRIPCION:    Conteo de registros
     #AUTOR:        mzm    
     #FECHA:        24-11-2011 18:26:47
    ***********************************/

    elsif(p_transaccion='PM_DEPUSU_CONT')then

        begin
            --Sentencia de la consulta de conteo de registros
            v_consulta:='select count(id_depto_usuario)
                        from param.tdepto_usuario depusu 
                        inner join segu.tusuario usudep on usudep.id_usuario=depusu.id_usuario
                        inner join segu.vpersona person on person.id_persona=usudep.id_persona
                        inner join segu.tusuario usu1 on usu1.id_usuario = depusu.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = depusu.id_usuario_mod
                        where  ';
            
            --Definicion de la respuesta            
            v_consulta:=v_consulta||v_parametros.filtro;
            if (public.f_existe_parametro(p_tabla,'id_depto')) then         
                v_consulta:= v_consulta || ' and depusu.id_depto='||v_parametros.id_depto;
            end if;
            --Devuelve la respuesta
            return v_consulta;

        end;
                    
    else
                         
        raise exception 'Transaccion inexistente';
                             
    end if;
                    
EXCEPTION
                    
    WHEN OTHERS THEN
            v_resp='';
            v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
            v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
            v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
            raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 960 (class 1255 OID 207270)
-- Dependencies: 15 3246
-- Name: f_tpm_proyecto_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION f_tpm_proyecto_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.f_tpm_proyecto_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.tpm_proyecto'
 AUTOR: 		 (rac)
 FECHA:	        26-10-2011 11:40:13
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_proyecto	integer;
			    
BEGIN

    v_nombre_funcion = 'param.f_tpm_proyecto_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_PRO_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		26-10-2011 11:40:13
	***********************************/

	if(p_transaccion='PM_PRO_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into param.tpm_proyecto(
			id_usuario,
			descripcion_proyecto,
			codigo_sisin,
			hora_ultima_modificacion,
			codigo_proyecto,
			hora_registro,
			nombre_corto,
			fecha_ultima_modificacion,
			fecha_registro,
			nombre_proyecto,
			id_proyecto_actif
          	) values(
			v_parametros.id_usuario,
			v_parametros.descripcion_proyecto,
			v_parametros.codigo_sisin,
			v_parametros.hora_ultima_modificacion,
			v_parametros.codigo_proyecto,
			v_parametros.hora_registro,
			v_parametros.nombre_corto,
			v_parametros.fecha_ultima_modificacion,
			v_parametros.fecha_registro,
			v_parametros.nombre_proyecto,
			v_parametros.id_proyecto_actif
			)RETURNING id_proyecto into v_id_proyecto;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','PRO almacenado(a) con exito (id_proyecto'||v_id_proyecto||')'); 
            v_resp = f_agrega_clave(v_resp,'id_proyecto',v_id_proyecto::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'PM_PRO_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		26-10-2011 11:40:13
	***********************************/

	elsif(p_transaccion='PM_PRO_MOD')then

		begin
			--Sentencia de la modificacion
			update param.tpm_proyecto set
			id_usuario = v_parametros.id_usuario,
			descripcion_proyecto = v_parametros.descripcion_proyecto,
			codigo_sisin = v_parametros.codigo_sisin,
			hora_ultima_modificacion = v_parametros.hora_ultima_modificacion,
			codigo_proyecto = v_parametros.codigo_proyecto,
			hora_registro = v_parametros.hora_registro,
			nombre_corto = v_parametros.nombre_corto,
			fecha_ultima_modificacion = v_parametros.fecha_ultima_modificacion,
			fecha_registro = v_parametros.fecha_registro,
			nombre_proyecto = v_parametros.nombre_proyecto,
			id_proyecto_actif = v_parametros.id_proyecto_actif
			where id_proyecto=v_parametros.id_proyecto;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','PRO modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proyecto',v_parametros.id_proyecto::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'PM_PRO_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		26-10-2011 11:40:13
	***********************************/

	elsif(p_transaccion='PM_PRO_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from param.tpm_proyecto
            where id_proyecto=v_parametros.id_proyecto;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','PRO eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proyecto',v_parametros.id_proyecto::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 961 (class 1255 OID 207271)
-- Dependencies: 15 3246
-- Name: f_tpm_proyecto_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION f_tpm_proyecto_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.f_tpm_proyecto_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'param.tpm_proyecto'
 AUTOR: 		 (rac)
 FECHA:	        26-10-2011 11:40:13
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_addfil varchar;
			    
BEGIN

	v_nombre_funcion = 'param.f_tpm_proyecto_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_PRO_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		26-10-2011 11:40:13
	***********************************/

	if(p_transaccion='PM_PRO_SEL')then
     				
    	begin
            --si existe el parametro hidro lo aplicamos en un filtro
            v_addfil='';
            if(f_existe_parametro(p_tabla,'hidro'))THEN
            v_addfil=' ( pro.hidro='''||v_parametros.hidro||''') AND ';
            
            END IF;
        
    		--Sentencia de la consulta
			v_consulta:='select
						pro.id_proyecto,
						pro.id_usuario,
						pro.descripcion_proyecto,
						pro.codigo_sisin,
						pro.hora_ultima_modificacion,
						pro.codigo_proyecto,
						pro.hora_registro,
						pro.nombre_corto,
						pro.fecha_ultima_modificacion,
						pro.fecha_registro,
						pro.nombre_proyecto,
						pro.id_proyecto_actif
						from param.tpm_proyecto pro
						where  '||v_addfil;
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'PM_PRO_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		26-10-2011 11:40:13
	***********************************/

	elsif(p_transaccion='PM_PRO_CONT')then

		begin
            v_addfil='';
            if(f_existe_parametro(p_tabla,'hidro'))THEN
            v_addfil=' (pro.hidro='''||v_parametros.hidro||''') AND ';
            
            END IF;
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_proyecto)
					    from param.tpm_proyecto pro
					    where '||v_addfil;
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
        
   
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 962 (class 1255 OID 207272)
-- Dependencies: 3246 15
-- Name: f_tproveedor_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION f_tproveedor_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.f_tproveedor_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.tproveedor'
 AUTOR: 		 (mzm)
 FECHA:	        15-11-2011 10:44:58
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento         integer;
    v_resp                    varchar;
    v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_proveedor          integer;
    v_codigo                varchar;
    
    --10abr12   
    v_respuesta_sinc       varchar;            
BEGIN
                           
    v_nombre_funcion = 'param.f_tproveedor_ime';
    v_parametros = f_get_record(p_tabla);

    /*********************************    
     #TRANSACCION:  'PM_PROVEE_INS'
     #DESCRIPCION:    Insercion de registros
     #AUTOR:        mzm    
     #FECHA:        15-11-2011 10:44:58
    ***********************************/

    if(p_transaccion='PM_PROVEE_INS')then
                    
        begin      
          
           --verificar que el proveedor no se duplique  para la misma institucion 
           -- o persona
           
           IF( v_parametros.id_institucion is not NULL 
                and (exists (select 1 from param.tproveedor  p
                      where p.id_institucion =  v_parametros.id_institucion
                      and p.estado_reg ='activo'))) THEN
                      
               raise exception 'ya esxiste un proveedor para esta institución';
           
           
           END IF;
           
           
           IF( v_parametros.id_persona is Not NULL 
               and (exists (select 1 from param.tproveedor  p
                      where p.id_persona =  v_parametros.id_persona
                      and p.estado_reg ='activo'))) THEN
                      
               raise exception 'ya esxiste un proveedor para esta persona';
           END IF;
           
           
        
            
            --Sentencia de la insercion
            insert into param.tproveedor(
              id_persona,
              --codigo,
             
              numero_sigma,
              tipo,
              estado_reg,
              id_institucion,
              id_usuario_reg,
              fecha_reg,
              id_usuario_mod,
              fecha_mod,
              nit
              ) values(
              v_parametros.id_persona,
              --v_codigo,
             
              v_parametros.numero_sigma,
              v_parametros.tipo,
              'activo',
              v_parametros.id_institucion,
              p_id_usuario,
              now(),
              null,
              null,
              v_parametros.nit
            )RETURNING id_proveedor into v_id_proveedor;
            
            v_codigo:=('PROV'||f_llenar_ceros(v_id_proveedor::numeric,4))::varchar;      
           
           
           
            update param.tproveedor
            set codigo=v_codigo
            where id_proveedor=v_id_proveedor;
            
            --10-04-2012: sincronizacion de UO entre BD
            v_respuesta_sinc:=param.f_sincroniza_proveedor_entre_bd(v_id_proveedor,'10.172.0.13','5432','db_link','db_link','dbendesis' ,'INSERT');
          
            if(v_respuesta_sinc!='si')  then
               raise exception 'Sincronizacion de proveedor en BD externa no realizada%',v_respuesta_sinc;
            end if;
            
                         
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proveedores almacenado(a) con exito (id_proveedor'||v_id_proveedor||')'); 
            v_resp = f_agrega_clave(v_resp,'id_proveedor',v_id_proveedor::varchar);

            --Devuelve la respuesta
            return v_resp;

        end;

    /*********************************    
     #TRANSACCION:  'PM_PROVEE_MOD'
     #DESCRIPCION:    Modificacion de registros
     #AUTOR:        mzm    
     #FECHA:        15-11-2011 10:44:58
    ***********************************/

    elsif(p_transaccion='PM_PROVEE_MOD')then

        begin
            --Sentencia de la modificacion
            update param.tproveedor set
            id_persona = v_parametros.id_persona,
             nit=v_parametros.nit,
            --codigo = v_parametros.codigo,
           
            numero_sigma = v_parametros.numero_sigma,
            tipo = v_parametros.tipo,
            id_institucion = v_parametros.id_institucion,
            id_usuario_mod = p_id_usuario,
            fecha_mod = now()
            where id_proveedor=v_parametros.id_proveedor;
           
        
            --10-04-2012: sincronizacion de UO entre BD
            v_respuesta_sinc:=param.f_sincroniza_proveedor_entre_bd(v_parametros.id_proveedor,'10.172.0.13','5432','db_link','db_link','dbendesis' ,'UPDATE');
                     
            if(v_respuesta_sinc!='si')  then
               raise exception 'Sincronizacion de proveedor en BD externa no realizada%',v_respuesta_sinc;
            end if;
            
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proveedores modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proveedor',v_parametros.id_proveedor::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end;

    /*********************************    
     #TRANSACCION:  'PM_PROVEE_ELI'
     #DESCRIPCION:    Eliminacion de registros
     #AUTOR:        mzm    
     #FECHA:        15-11-2011 10:44:58
    ***********************************/

    elsif(p_transaccion='PM_PROVEE_ELI')then

        begin
            --Sentencia de la eliminacion
            delete from param.tproveedor
            where id_proveedor=v_parametros.id_proveedor;
             
            --10-04-2012: sincronizacion de UO entre BD
            v_respuesta_sinc:=param.f_sincroniza_proveedor_entre_bd(v_parametros.id_proveedor,'10.172.0.13','5432','db_link','db_link','dbendesis','DELETE');
                     
            if(v_respuesta_sinc!='si')  then
               raise exception 'Sincronizacion de proveedor en BD externa no realizada%',v_respuesta_sinc;
            end if;
              
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proveedores eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proveedor',v_parametros.id_proveedor::varchar);
              
            --Devuelve la respuesta
            return v_resp;

        end;
         
    else
     
        raise exception 'Transaccion inexistente: %',p_transaccion;

    end if;

EXCEPTION
                
    WHEN OTHERS THEN
        v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
    raise exception '%',v_resp;
                        
END;
$$;


--
-- TOC entry 963 (class 1255 OID 207274)
-- Dependencies: 15 3246
-- Name: f_tproveedor_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION f_tproveedor_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.f_tproveedor_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'param.tproveedor'
 AUTOR: 		 (mzm)
 FECHA:	        15-11-2011 10:44:58
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'param.f_tproveedor_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_PROVEE_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mzm	
 	#FECHA:		15-11-2011 10:44:58
	***********************************/

	if(p_transaccion='PM_PROVEE_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						provee.id_proveedor,
						provee.id_persona,
						provee.codigo,
					    provee.numero_sigma,
						provee.tipo,
						provee.estado_reg,
						provee.id_institucion,
						provee.id_usuario_reg,
						provee.fecha_reg,
						provee.id_usuario_mod,
						provee.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	,
                        person.nombre_completo1,
                        instit.nombre,
                        provee.nit
						from param.tproveedor provee
						inner join segu.tusuario usu1 on usu1.id_usuario = provee.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = provee.id_usuario_mod   
                        left join segu.vpersona person on person.id_persona=provee.id_persona
                        left join param.tinstitucion instit on instit.id_institucion=provee.id_institucion
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'PM_PROVEE_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mzm	
 	#FECHA:		15-11-2011 10:44:58
	***********************************/

	elsif(p_transaccion='PM_PROVEE_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_proveedor)
					    from param.tproveedor provee
					    inner join segu.tusuario usu1 on usu1.id_usuario = provee.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = provee.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
    
    /*********************************    
 	#TRANSACCION:  'PM_PROVEEV_SEL'
 	#DESCRIPCION:	Consulta de datos de proveedores a partir de una vista de base
                    de datos
 	#AUTOR:		rac	
 	#FECHA:		08-12-2011 10:44:58
	***********************************/    
        
					
	elseif(p_transaccion='PM_PROVEEV_SEL')then
     				
    	begin
        	
    		--Sentencia de la consulta
			v_consulta:='select
						id_proveedor,
                        id_persona,
                        codigo,
                        numero_sigma,
                        tipo,
                        id_institucion,
                        desc_proveedor,
                        nit
						from param.vproveedor provee
						where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'PM_PROVEEV_CONT'
 	#DESCRIPCION:	Conteo de registros de proveedores en la vista vproveedor
 	#AUTOR:		rac	
 	#FECHA:		09-12-2011 10:44:58
	***********************************/

	elsif(p_transaccion='PM_PROVEEV_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_proveedor)
					    from param.vproveedor provee
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 965 (class 1255 OID 207275)
-- Dependencies: 15 3246
-- Name: ft_alarma_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_alarma_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_alarma_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.talarma'
 AUTOR: 		 (fprudencio)
 FECHA:	        18-11-2011 11:59:10
 COMENTARIOS:	         
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_alarma	integer;  
    v_registros_config		record;
    v_registros_detalle		record;
    v_dif_dias				integer;
    v_id_funcionario		integer;
    v_id_subsistema			integer;
    v_consulta_config	    text;
    v_consulta_detalle		text;
    --Ids que se necesitan para  SAJ
    v_id_rpc				integer;
    v_id_sup    			integer;
    v_id_rep_legal			integer; 
    v_id_sup_boleta			integer;
			    
BEGIN            raise exception 'param.ft_alarma_ime';

    v_nombre_funcion = 'param.ft_alarma_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_ALARM_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	if(p_transaccion='PM_ALARM_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into param.talarma(
			acceso_directo,
			id_funcionario,
			fecha,
			estado_reg,
			descripcion,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.acceso_directo,
			v_parametros.id_funcionario,
			v_parametros.fecha,
			'activo',
			v_parametros.descripcion,
			p_id_usuario,
			now()::date,
			null,
			null
			)RETURNING id_alarma into v_id_alarma;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Alarmas almacenado(a) con exito (id_alarma'||v_id_alarma||')'); 
            v_resp = f_agrega_clave(v_resp,'id_alarma',v_id_alarma::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;
        
        	/*********************************    
 	#TRANSACCION:  'PM_ALARM_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	elsif(p_transaccion='PM_ALARM_MOD')then

		begin
			--Sentencia de la modificacion
			update param.talarma set
			acceso_directo = v_parametros.acceso_directo,
			id_funcionario = v_parametros.id_funcionario,
			fecha = v_parametros.fecha,
			descripcion = v_parametros.descripcion,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_alarma=v_parametros.id_alarma;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Alarmas modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_alarma',v_parametros.id_alarma::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;


	/*********************************    
 	#TRANSACCION:  'PM_DESCCOR_MOD'
 	#DESCRIPCION:	DEsactiva envio de correos
 	#AUTOR:		rarteaga	
 	#FECHA:		8-3-2012 11:59:10
	***********************************/

	elsif(p_transaccion='PM_DESCCOR_MOD')then

		begin
			--Sentencia de la modificacion
			 update param.talarma 
             set sw_correo = 1
             where sw_correo = 0;
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Desactiva envio de correo para alarmas'); 
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'PM_ALARM_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	elsif(p_transaccion='PM_ALARM_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from param.talarma
            where id_alarma=v_parametros.id_alarma;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Alarmas eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_alarma',v_parametros.id_alarma::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
        
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 966 (class 1255 OID 207276)
-- Dependencies: 15 3246
-- Name: ft_alarma_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_alarma_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_alarma_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'param.talarma'
 AUTOR: 		 (fprudencio)
 FECHA:	        18-11-2011 11:59:10
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_id_funcionario integer;
    v_filtro varchar;
			    
BEGIN
                                                    
	v_nombre_funcion = 'param.ft_alarma_sel';
    v_parametros = f_get_record(p_tabla);
    
   -- v_filtro = '';
   
   /*********************************    
 	#TRANSACCION:  'PM_ALARMCOR_SEL'
 	#DESCRIPCION:	Consulta de alarmas pendientes de envio de correo no se utiliza con pagiancion
 	#AUTOR:		rarteaga	
 	#FECHA:		7-03-2012 11:59:10
	***********************************/

	if(p_transaccion='PM_ALARMCOR_SEL')then
     				
    	begin
            
            --Sentencia de la consulta
			v_consulta:='
                        select
						alarm.id_alarma,
                        funcio.email_empresa,
						alarm.fecha,
						alarm.descripcion,
					    alarm.clase,
                        alarm.titulo,
                        alarm.obs,
                        alarm.tipo,
                        (alarm.fecha-now()::date)::integer as dias
						from param.talarma alarm
						inner join rhum.tfuncionario funcio on funcio.id_funcionario=alarm.id_funcionario
                        where alarm.sw_correo = 0';
                        
             --modificar correpondencia
           /*  update param.talarma 
             set sw_correo = 1
             where sw_correo = 0;*/
			
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'PM_ALARM_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	elseif(p_transaccion='PM_ALARM_SEL')then
     				
    	begin
        
         
         
    		--Sentencia de la consulta
			v_consulta:='select
						alarm.id_alarma,
						alarm.acceso_directo,
						alarm.id_funcionario,
						alarm.fecha,
						alarm.estado_reg,
						alarm.descripcion,
						alarm.id_usuario_reg,
						alarm.fecha_reg,
						alarm.id_usuario_mod,
						alarm.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        person.nombre_completo1,
                        alarm.clase,
                        alarm.titulo,
                        alarm.parametros,
                        alarm.obs,
                        alarm.tipo,
                        (alarm.fecha-now()::date)::integer as dias
						from param.talarma alarm
						inner join segu.tusuario usu1 on usu1.id_usuario = alarm.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = alarm.id_usuario_mod
                        inner join rhum.tfuncionario funcio on funcio.id_funcionario=alarm.id_funcionario   
                        inner join segu.vpersona person on person.id_persona=funcio.id_persona
				        where  ';
				       
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'PM_ALARM_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	elsif(p_transaccion='PM_ALARM_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_alarma)
					    from param.talarma alarm
					    inner join segu.tusuario usu1 on usu1.id_usuario = alarm.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = alarm.id_usuario_mod
                        inner join rhum.tfuncionario funcio on funcio.id_funcionario=alarm.id_funcionario   
                        inner join segu.vpersona person on person.id_persona=funcio.id_persona
				        where  ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
	/*********************************    
 	#TRANSACCION:  'PM_ALARM_PEND'
 	#DESCRIPCION:	Cuenta cuantas alarmas tiene pendientes el funcionario
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	elsif(p_transaccion='PM_ALARM_PEND')then

		begin
          
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_alarma) as total
					    from param.talarma alarm
					    inner join segu.tusuario usu1 on usu1.id_usuario = alarm.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = alarm.id_usuario_mod
                        inner join rhum.tfuncionario funcio on funcio.id_funcionario=alarm.id_funcionario   
                        inner join segu.vpersona person on person.id_persona=funcio.id_persona
				        where  alarm.estado_reg=''activo'' AND alarm.id_funcionario in(Select fun.id_funcionario
            																	      from rhum.tfuncionario fun
            																		  inner join segu.tusuario usu on usu.id_persona=fun.id_persona
                                                                                      where usu.id_usuario='||p_id_usuario||') AND ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;				
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 967 (class 1255 OID 207278)
-- Dependencies: 15 3246
-- Name: ft_config_alarma_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_config_alarma_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_config_alarma_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.tconfig_alarma'
 AUTOR: 		 (fprudencio)
 FECHA:	        18-11-2011 11:59:10
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_config_alarma	integer;  
   
			    
BEGIN       raise exception 'param.ft_config_alarma_ime';

    v_nombre_funcion = 'param.ft_config_alarma_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_CONALA_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	if(p_transaccion='PM_CONALA_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into param.tconfig_alarma(
			codigo,
			descripcion,
			dias,
            id_subsistema,
			estado_reg,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			v_parametros.codigo,
			v_parametros.descripcion,
			v_parametros.dias,
			v_parametros.id_subsistema,
			'activo',
			p_id_usuario,
			now()::date,
			null,
			null
			)RETURNING id_config_alarma into v_id_config_alarma;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Configuracion de Alarmas almacenado(a) con exito (id_config_alarma'||v_id_config_alarma||')'); 
            v_resp = f_agrega_clave(v_resp,'id_config_alarma',v_id_config_alarma::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'PM_CONALA_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	elsif(p_transaccion='PM_CONALA_MOD')then

		begin
			--Sentencia de la modificacion
			update param.tconfig_alarma set
			codigo = v_parametros.codigo,
			descripcion = v_parametros.descripcion,
			dias = v_parametros.dias,
			id_subsistema = v_parametros.id_subsistema,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_config_alarma=v_parametros.id_config_alarma;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Configuracion de Alarmas modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_config_alarma',v_parametros.id_config_alarma::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'PM_CONALA_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	elsif(p_transaccion='PM_CONALA_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from param.tconfig_alarma
            where id_config_alarma=v_parametros.id_config_alarma;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Configuracion de Alarmas eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_config_alarma',v_parametros.id_config_alarma::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;    
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 968 (class 1255 OID 207279)
-- Dependencies: 15 3246
-- Name: ft_config_alarma_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_config_alarma_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 moneda: 		param.ft_config_alarma_sel
 DESCRIPCIÓN:  listado de la configuracion de alarmas
 AUTOR: 		fprudencio
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		25-11-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='param.ft_config_alarma_sel';


     if(par_transaccion='PM_CONALA_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            CONALA.id_config_alarma,
                            CONALA.codigo,
                            CONALA.descripcion,
                            CONALA.dias,
                            CONALA.id_subsistema,
                            (SUBSIS.codigo ||'' - ''|| SUBSIS.nombre) as desc_subsis,
                            CONALA.id_usuario_reg,
                            CONALA.estado_reg ,
                            CONALA.fecha_reg ,                            
                            CONALA.fecha_mod,
                            CONALA.id_usuario_mod,
                            PERSON.nombre_completo1 AS desc_usuario_reg,
                            PERMOD.nombre_completo1 AS desc_usuario_mod
                            FROM PARAM.tconfig_alarma CONALA
                            INNER JOIN SEGU.tusuario USUARI
                            ON USUARI.id_usuario=CONALA.id_usuario_reg
                            INNER JOIN segu.vpersona PERSON ON PERSON.id_persona=USUARI.id_persona
                            INNER JOIN segu.tsubsistema SUBSIS ON SUBSIS.id_subsistema=CONALA.id_subsistema
                            LEFT JOIN SEGU.tusuario USUMOD
                            ON USUMOD.id_usuario=CONALA.id_usuario_mod
                            LEFT JOIN segu.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE  ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               --raise notice'(%)',v_consulta   ;
               return v_consulta;


         END;


     elsif(par_transaccion='PM_CONALA_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                            count(CONALA.id_config_alarma)
                            FROM PARAM.tconfig_alarma CONALA
                            INNER JOIN SEGU.tusuario USUARI
                            ON USUARI.id_usuario=CONALA.id_usuario_reg
                            INNER JOIN segu.vpersona PERSON ON PERSON.id_persona=USUARI.id_persona
                            INNER JOIN segu.tsubsistema SUBSIS ON SUBSIS.id_subsistema=CONALA.id_subsistema
                            LEFT JOIN SEGU.tusuario USUMOD
                            ON USUMOD.id_usuario=CONALA.id_usuario_mod
                            LEFT JOIN segu.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     elsif(par_transaccion='PM_ALATABLA_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT table_schema::varchar,
                                   table_name::varchar 
                            FROM information_schema.columns
                            WHERE column_name = ''id_alarma'' AND ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               raise notice '%',v_consulta;
               return v_consulta;


         END;
     elsif(par_transaccion='PM_ALATABLA_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(table_name)                                  
                            FROM information_schema.columns
                            WHERE column_name = ''id_alarma'' AND ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro; 
               
               return v_consulta;


         END;        
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 969 (class 1255 OID 207280)
-- Dependencies: 15 3246
-- Name: ft_depto_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_depto_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.ft_depto_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 		KPLIAN
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		06-06-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='param.ft_depto_ime';
     v_parametros:=f_get_record(par_tabla);


 /*******************************
 #TRANSACCION:   PM_DEPPTO_INS
 #DESCRIPCION:	Inserta deptos
 #AUTOR:		KPLIAN	
 #FECHA:		06-06-2011	
***********************************/
     if(par_transaccion='PM_DEPPTO_INS')then


          BEGIN

               --verificar unicidad de codigo
               if exists (select 1 from param.tdepto where upper(codigo)=upper(v_parametros.codigo) and estado_reg='activo' and id_subsistema=v_parametros.id_subsistema) then
                   raise exception 'Insercion no realizada. Codigo% en uso para subsistema%', upper(v_parametros.codigo),  (select nombre from segu.tsubsistema where id_subsistema=v_parametros.id_subsistema) ;
               end if;
               --insercion de nuevo depto
               INSERT INTO param.tdepto(codigo, id_subsistema, nombre, nombre_corto, estado_reg,fecha_reg, id_usuario_reg)
               values(v_parametros.codigo,v_parametros.id_subsistema, v_parametros.nombre, v_parametros.nombre_corto,'activo',now()::date, par_id_usuario);

               v_resp = f_agrega_clave(v_resp,'mensaje','depto insertado con exito '||v_parametros.nombre_corto || 'para Subsis.' || (select nombre from segu.tsubsistema where id_subsistema=v_parametros.id_subsistema));
               v_resp = f_agrega_clave(v_resp,'id_depto',v_id_funcion::varchar);


         END;
 /*******************************
 #TRANSACCION:  PM_DEPPTO_MOD
 #DESCRIPCION:	Modifica la depto seleccionada
 #AUTOR:		KPLIAN	
 #FECHA:		06-06-2011
***********************************/
     elsif(par_transaccion='PM_DEPPTO_MOD')then


          BEGIN
               --modificacion de depto
               update param.tdepto set
               codigo=v_parametros.codigo,
               nombre_corto=v_parametros.nombre_corto,
               nombre=v_parametros.nombre,
               id_subsistema=v_parametros.id_subsistema,
               id_usuario_mod=par_id_usuario,
               fecha_mod=now()
               where id_depto=v_parametros.id_depto;

               v_resp = f_agrega_clave(v_resp,'mensaje','depto modificado con exito '||v_parametros.codigo);
               v_resp = f_agrega_clave(v_resp,'id_depto',v_parametros.id_depto::varchar);


          END;

/*******************************
 #TRANSACCION:  PM_DEPPTO_ELI
 #DESCRIPCION:	Inactiva el depto selecionado
 #AUTOR:		KPLIAN	
 #FECHA:		06-06-2011
***********************************/

    elsif(par_transaccion='PM_DEPPTO_ELI')then
        BEGIN

         --inactivacion de la depto
               update param.tdepto set estado_reg='eliminado'
               where id_depto=v_parametros.id_depto;
               return 'depto eliminado con exito';

               v_resp = f_agrega_clave(v_resp,'mensaje','depto eliminado con exito '||v_parametros.id_depto);
               v_resp = f_agrega_clave(v_resp,'id_depto',v_parametros.id_depto::varchar);

        END;


    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;

 return v_resp;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 972 (class 1255 OID 207281)
-- Dependencies: 15 3246
-- Name: ft_depto_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_depto_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 documento: 	param.ft_depto_sel
 DESCRIPCIÓN:  listado de documento
 AUTOR: 	    KPLIAN	
 FECHA:	        06/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;
v_filadd varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='param.ft_depto_sel';
     
 /*******************************
 #TRANSACCION:  PM_DEPPTO_SEL
 #DESCRIPCION:	Listado de departamento
 #AUTOR:		MZM	
 #FECHA:		03-06-2011
 #AUTOR_MOD:     RAC
 #DESCRIPCION_MOD  se aumenta el filtro de id_subsistema cuando dea distinto de null	
 #FECHA:		15-10-2011
***********************************/


     if(par_transaccion='PM_DEPPTO_SEL')then

          --consulta:=';
          
          
          BEGIN
          v_filadd = '';
          IF (f_existe_parametro(par_tabla,'id_subsistema')) THEN
          v_filadd = ' (DEPPTO.id_subsistema = ' ||v_parametros.id_subsistema||') and ';
          
          END IF;
          
          IF (f_existe_parametro(par_tabla,'codigo_subsistema')) THEN
          v_filadd = ' (SUBSIS.codigo = ''' ||v_parametros.codigo_subsistema||''') and ';
          
          END IF;
          
          
          

               v_consulta:='SELECT 
                            DEPPTO.id_depto,
                            DEPPTO.codigo,
                            DEPPTO.nombre,
                            DEPPTO.nombre_corto,
                            DEPPTO.id_subsistema,
                            DEPPTO.estado_reg,
                            DEPPTO.fecha_reg,
                            DEPPTO.id_usuario_reg,
                            DEPPTO.fecha_mod,
                            DEPPTO.id_usuario_mod,
                            PERREG.nombre_completo1 as usureg,
                            PERMOD.nombre_completo1 as usumod,
                            SUBSIS.codigo||'' - ''||SUBSIS.nombre as desc_subsistema
                            FROM param.tdepto DEPPTO
                            INNER JOIN segu.tsubsistema SUBSIS on SUBSIS.id_subsistema=DEPPTO.id_subsistema
                            INNER JOIN segu.tusuario USUREG on USUREG.id_usuario=DEPPTO.id_usuario_reg
                            INNER JOIN segu.vpersona PERREG on PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN segu.tusuario USUMOD on USUMOD.id_usuario=DEPPTO.id_usuario_mod
                            LEFT JOIN segu.vpersona PERMOD on PERMOD.id_persona=USUMOD.id_persona
                            WHERE '||v_filadd;
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

 /*******************************
 #TRANSACCION:  PM_DEPPTO_CONT
 #DESCRIPCION:	cuenta la cantidad de departamentos
 #AUTOR:		MZM	
 #FECHA:		03-06-2011
 #AUTOR_MOD:     RAC
 #DESCRIPCION_MOD  se aumenta el filtro de id_subsistema cuando dea distinto de null	
 #FECHA:		15-10-2011
***********************************/

     elsif(par_transaccion='PM_DEPPTO_CONT')then
        BEGIN
          
          v_filadd = '';
          IF (f_existe_parametro(par_tabla,'id_subsistema')) THEN
             v_filadd = ' (DEPPTO.id_subsistema = ' ||v_parametros.id_subsistema||') and ';
          END IF;
          
          
               v_consulta:='SELECT
                                  count(DEPPTO.id_depto)
                            FROM param.tdepto DEPPTO
                            INNER JOIN segu.tsubsistema SUBSIS on SUBSIS.id_subsistema=DEPPTO.id_subsistema
                            INNER JOIN segu.tusuario USUREG on USUREG.id_usuario=DEPPTO.id_usuario_reg
                            INNER JOIN segu.vpersona PERREG on PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN segu.tusuario USUMOD on USUMOD.id_usuario=DEPPTO.id_usuario_mod
                            LEFT JOIN segu.vpersona PERMOD on PERMOD.id_persona=USUMOD.id_persona
                            WHERE '||v_filadd;
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 973 (class 1255 OID 207282)
-- Dependencies: 15 3246
-- Name: ft_dispara_alarma_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_dispara_alarma_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_dispara_alarma_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.talarma'
 AUTOR: 		 (fprudencio)
 FECHA:	        18-11-2011 11:59:10
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_alarma	integer;  
    v_registros_config		record;
    v_registros_detalle		record;
    v_dif_dias				integer;
    v_id_funcionario		integer;
    v_id_subsistema			integer;
    v_consulta_config	    text;
    v_consulta_detalle		text;
    --Ids que se necesitan para  SAJ
    v_mensaje varchar;
			    
BEGIN   

    v_nombre_funcion = 'param.ft_dispara_alarma_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_ALARMASAJ_INS'
 	#DESCRIPCION:	Revisa alaramas del sistema SAJ
 	#AUTOR:		rarteaga	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	if(p_transaccion='PM_GENALA_INS')then
					
        begin    
        	
            IF(v_parametros.tipo='TODOS' or v_parametros.tipo='SAJ')THEN 
               v_mensaje:= saj.f_verifica_alarma(v_parametros.id_usuario);
            END IF;
            
            --ir introducion if que diparen la funcion segun sistema X
            IF(v_parametros.tipo='TODOS' or v_parametros.tipo='X')THEN 
            --   v_mensaje:= x.f_verifica_alarma(v_parametros.id_usuario);
            END IF;
 
           --Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Alarmas almacenado(a) con exito'); 
            v_resp = f_agrega_clave(v_resp,'respuesta',v_mensaje);

            --Devuelve la respuesta
            return v_resp;

		end;

	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 974 (class 1255 OID 207283)
-- Dependencies: 15 3246
-- Name: ft_dispara_alarma_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_dispara_alarma_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_dispara_alarma_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'param.talarma'
 AUTOR: 		 (fprudencio)
 FECHA:	        18-11-2011 11:59:10
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_id_funcionario integer;
    v_filtro varchar;
			    
BEGIN
                                                    
	v_nombre_funcion = 'param.ft_dispara_alarma_sel';
    v_parametros = f_get_record(p_tabla);
    
   -- v_filtro = '';

	/*********************************    
 	#TRANSACCION:  'PM_ALARM_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	if(p_transaccion='PM_ALARM_SEL')then
     				
    	begin
        --Sentencia de la consulta
			v_consulta:='select
						alarm.id_alarma,
						alarm.acceso_directo,
						alarm.id_funcionario,
						alarm.fecha,
						alarm.estado_reg,
						alarm.descripcion,
						alarm.id_usuario_reg,
						alarm.fecha_reg,
						alarm.id_usuario_mod,
						alarm.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        person.nombre_completo1,
                        alarm.clase,
                        alarm.titulo,
                        alarm.parametros,
                        alarm.obs,
                        alarm.tipo,
                        (alarm.fecha-now()::date)::integer as dias
						from param.talarma alarm
						inner join segu.tusuario usu1 on usu1.id_usuario = alarm.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = alarm.id_usuario_mod
                        inner join rhum.tfuncionario funcio on funcio.id_funcionario=alarm.id_funcionario   
                        inner join segu.vpersona person on person.id_persona=funcio.id_persona
				        where  ';
				       
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'PM_ALARM_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		18-11-2011 11:59:10
	***********************************/

	elsif(p_transaccion='PM_ALARM_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_alarma)
					    from param.talarma alarm
					    inner join segu.tusuario usu1 on usu1.id_usuario = alarm.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = alarm.id_usuario_mod
                        inner join rhum.tfuncionario funcio on funcio.id_funcionario=alarm.id_funcionario   
                        inner join segu.vpersona person on person.id_persona=funcio.id_persona
				        where  ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 975 (class 1255 OID 207284)
-- Dependencies: 15 3246
-- Name: ft_documento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_documento_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.ft_documento_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 		KPLIAN
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		03-06-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

v_id_uo           integer;
v_id_depto        integer;
v_id_depto_uo     integer;
v_formato 		varchar;

BEGIN

     v_nombre_funcion:='param.ft_documento_ime';
     v_parametros:=f_get_record(par_tabla);


 /*******************************
 #TRANSACCION:   PM_DOCUME_INS
 #DESCRIPCION:	Inserta Documentos
 #AUTOR:		KPLIAN	
 #FECHA:		03-06-2011	
***********************************/
     if(par_transaccion='PM_DOCUME_INS')then


          BEGIN
               --verificar unicidad de codigo
               if exists (select 1 from param.tdocumento where upper(codigo)=upper(v_parametros.codigo) and estado_reg='activo' and id_subsistema=v_parametros.id_subsistema) then
                   raise exception 'Insercion no realizada. Codigo% en uso para subsistema%', upper(v_parametros.codigo),  (select nombre from segu.tsubsistema where id_subsistema=v_parametros.id_subsistema) ;
               end if;
               --insercion de nuevo documento
              
              --evita formato en blanco
              v_formato = NULL;
              IF(v_parametros.formato is not NULL and trim(v_parametros.formato) <>'' )THEN
                v_formato =  v_parametros.formato;
              END IF;
               
               INSERT INTO param.tdocumento(
               		codigo, 
               		descripcion, 
                    id_subsistema, 
                    estado_reg,
 					fecha_reg, 
                    id_usuario_reg, 
                    periodo_gestion, 
                    tipo, 
                    tipo_numeracion, 
                    formato)
               values (
               		v_parametros.codigo, 
                    v_parametros.descripcion,
                    v_parametros.id_subsistema, 
                    'activo', 
                    now() ::date,
                 	par_id_usuario, 
                    v_parametros.periodo_gestion, 
                    v_parametros.tipo, 
                    v_parametros.tipo_numeracion, 
                    v_formato);


               v_resp = f_agrega_clave(v_resp,'mensaje','Documento insertado con exito '||v_parametros.codigo || 'para Subsis.' || (select nombre from segu.tsubsistema where id_subsistema=v_parametros.id_subsistema));
               v_resp = f_agrega_clave(v_resp,'id_documento',v_id_funcion::varchar);


         END;
 /*******************************
 #TRANSACCION:  PM_DOCUME_MOD
 #DESCRIPCION:	Modifica la documento seleccionada
 #AUTOR:		KPLIAN	
 #FECHA:		03-06-2011
***********************************/
     elsif(par_transaccion='PM_DOCUME_MOD')then


          BEGIN
          
          
               /*validar que si ya se tienen correlativos generados para este tipo de doc==> no se pueda modificar ni el tipo_numeracion, ni tipo*/
               if exists (select 1 from param.tcorrelativo where id_documento=v_parametros.id_documento) then
                  if exists (select 1 from param.tdocumento where id_documento=v_parametros.id_documento and (tipo!=v_parametros.tipo or tipo_numeracion!=v_parametros.tipo_numeracion or formato!=v_parametros.formato)) then
                     raise exception 'No es posible modificar la forma en la que se numera este documento. Tiene numeracion generada';
                  end if;                                                                                                             
               end if;
               
              --evita formato en blanco
              v_formato = NULL;
              IF(v_parametros.formato is not NULL and trim(v_parametros.formato) <>'' )THEN
                v_formato =  v_parametros.formato;
              END IF;
                    
               --modificacion de documento
               update param.tdocumento set
               codigo=v_parametros.codigo,
               descripcion=v_parametros.descripcion,
               id_subsistema=v_parametros.id_subsistema,
               id_usuario_mod=par_id_usuario,
               fecha_mod=now(),
               estado_reg=v_parametros.estado_reg,
               periodo_gestion=v_parametros.periodo_gestion,
               tipo=v_parametros.tipo,
               tipo_numeracion=v_parametros.tipo_numeracion  ,
               formato=v_parametros.formato
               where id_documento=v_parametros.id_documento;

               v_resp = f_agrega_clave(v_resp,'mensaje','documento modificado con exito '||v_parametros.codigo);
               v_resp = f_agrega_clave(v_resp,'id_documento',v_parametros.id_documento::varchar);


          END;

/*******************************
 #TRANSACCION:  PM_DOCUME_ELI
 #DESCRIPCION:	Inactiva el documento selecionado
 #AUTOR:		KPLIAN	
 #FECHA:		03-06-2011
***********************************/

    elsif(par_transaccion='PM_DOCUME_ELI')then
        BEGIN

         --inactivacion de la documento
               update param.tdocumento set estado_reg='eliminado'
               where id_documento=v_parametros.id_documento;
               return 'documento eliminado con exito';

               v_resp = f_agrega_clave(v_resp,'mensaje','documento eliminado con exito '||v_parametros.id_documento);
               v_resp = f_agrega_clave(v_resp,'id_documento',v_parametros.id_documento::varchar);

        END;


    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;

 return v_resp;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 976 (class 1255 OID 207286)
-- Dependencies: 15 3246
-- Name: ft_documento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_documento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 documento: 	param.ft_documento_sel
 DESCRIPCIÓN:  listado de documento
 AUTOR: 	    KPLIAN	(m)
 FECHA:	        04/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;
v_filadd varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='param.ft_documento_sel';
/*******************************
 #TRANSACCION:  PM_DOCUME_SEL
 #DESCRIPCION:	Listado de documentos
 #AUTOR:		KPLIAN(mzm)	
 #FECHA:		08/01/11	
 ******************************
 #DESCRIPCION_MOD:	aumenta filtro para tipo de documentos por el subsistema
                    se usa desde la interface de correspondencia
 #AUTOR_MOD:		KPLIAN(rac)	
 #FECHA_MOD:		27/10/11
***********************************/

     if(par_transaccion='PM_DOCUME_SEL')then

          --consulta:=';
          BEGIN
          
           v_filadd = '';
            IF (f_existe_parametro(par_tabla,'tipo')) THEN
               v_filadd = ' ( DOCUME.tipo = '''||v_parametros.tipo||''' and  DOCUME.estado_reg=''activo'' ) and ';
            END IF;

               v_consulta:='SELECT 
                                   DOCUME.id_documento,
                                   DOCUME.codigo,
                                   DOCUME.descripcion,
                                   DOCUME.estado_reg,
                                   DOCUME.fecha_mod,
                                   DOCUME.fecha_reg,
                                   DOCUME.id_subsistema,
                                   DOCUME.id_usuario_mod,
                                   DOCUME.id_usuario_reg,
                                   SUBSIS.codigo  ||''-''||SUBSIS.nombre as desc_subsis,
                                   SUBSIS.nombre as nombre_subsis,
                                   PERREG.nombre_completo1 as usureg,
                                   PERMOD.nombre_completo1 as usumod,
                                   DOCUME.tipo_numeracion,
                                   DOCUME.periodo_gestion,
                                   DOCUME.tipo,
                                   DOCUME.formato

                            FROM param.tdocumento DOCUME
                            INNER JOIN segu.tsubsistema SUBSIS on SUBSIS.id_subsistema=DOCUME.id_subsistema
                            INNER JOIN segu.tusuario USUREG on USUREG.id_usuario=DOCUME.id_usuario_reg
                            INNER JOIN segu.vpersona PERREG on PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN segu.tusuario USUMOD on USUMOD.id_usuario=DOCUME.id_usuario_mod
                            LEFT JOIN segu.vpersona PERMOD on PERMOD.id_persona=USUMOD.id_persona
                            
                            WHERE '||v_filadd;
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='PM_DOCUME_CONT')then

          --consulta:=';
          BEGIN
          
              v_filadd = '';
              IF (f_existe_parametro(par_tabla,'tipo')) THEN
               v_filadd = ' ( DOCUME.tipo = '''||v_parametros.tipo||''' and  DOCUME.estado_reg=''activo'' ) and ';
              END IF;

               v_consulta:='SELECT
                            count(DOCUME.id_documento)
                            FROM param.tdocumento DOCUME
                            INNER JOIN segu.tsubsistema SUBSIS on SUBSIS.id_subsistema=DOCUME.id_subsistema
                            INNER JOIN segu.tusuario USUREG on USUREG.id_usuario=DOCUME.id_usuario_reg
                            INNER JOIN segu.vpersona PERREG on PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN segu.tusuario USUMOD on USUMOD.id_usuario=DOCUME.id_usuario_mod
                            LEFT JOIN segu.vpersona PERMOD on PERMOD.id_persona=USUMOD.id_persona
                            
                            WHERE  '||v_filadd;
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 981 (class 1255 OID 207287)
-- Dependencies: 15 3246
-- Name: ft_gestion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_gestion_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.ft_gestion_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 		KPLIAN
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		07-01-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;
i                 integer;
BEGIN

     v_nombre_funcion:='segu.ft_funcion_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   PM_GESTIO_INS
 #DESCRIPCION:	Inserta Funciones
 #AUTOR:		KPLIAN	
 #FECHA:		07-01-2011	
***********************************/
     if(par_transaccion='PM_GESTIO_INS')then

        
          BEGIN
          
          --insercion de nueva funcion
               if exists (select 1 from param.tgestion where gestion=v_parametros.gestion and estado_reg!='eliminado') then
                  raise exception 'Insercion no realizada. Gestion existente';
               end if;
               INSERT INTO param.tgestion(gestion, estado_reg,fecha_reg, id_usuario_reg)
               values(v_parametros.gestion,'activo',now()::date, par_id_usuario);
              
              
               for i in 1..12 loop
                 insert into param.tperiodo(periodo, id_gestion, id_usuario_reg, fecha_reg, estado_reg)
                 values (i, (select id_gestion from param.tgestion where gestion=v_parametros.gestion and estado_reg='activo'), par_id_usuario, now()::date,'activo');
               end loop;

               v_resp = f_agrega_clave(v_resp,'mensaje','Gestion insertada con exito '||v_parametros.gestion);
               v_resp = f_agrega_clave(v_resp,'id_gestion',v_id_funcion::varchar);


         END;
 /*******************************    
 #TRANSACCION:  PM_GESTIO_MOD
 #DESCRIPCION:	Modifica la gestion seleccionada
 #AUTOR:		KPLIAN	
 #FECHA:		07-01-2011
***********************************/
     elsif(par_transaccion='PM_GESTIO_MOD')then

          
          BEGIN

               if exists (select 1 from param.tgestion where gestion=v_parametros.gestion and id_gestion!=v_parametros.id_gestion and estado_reg!='eliminado') then
                  raise exception 'Modificacion no realizada. Gestion existente';
               end if;
               --modificacion de gestion
               update param.tgestion set

                     gestion=v_parametros.gestion,
                     estado_reg=v_parametros.estado_reg

               where id_gestion=v_parametros.id_gestion;

               v_resp = f_agrega_clave(v_resp,'mensaje','Gestion modificada con exito '||v_parametros.gestion);
               v_resp = f_agrega_clave(v_resp,'id_gestion',v_parametros.id_gestion::varchar);

             
          END;
          
/*******************************    
 #TRANSACCION:   PM_GESTIO_ELI
 #DESCRIPCION:	Inactiva la gestion selecionada
 #AUTOR:		KPLIAN	
 #FECHA:		07-01-2011
***********************************/

    elsif(par_transaccion='PM_GESTIO_ELI')then
        BEGIN
        
               -- verificar que la gestion no tenga dependencias
               -- en esquema param con tcorrelativo
               --inactivacion de la gestion
               update param.tgestion set estado_reg='eliminado'
               where id_gestion=v_parametros.id_gestion;
               return 'Gestion eliminada con exito';

               -- si existen periodos para la gestion que se esta eliminando, eliminar tb los periodos
               if exists (select 1 from param.tperiodo where id_gestion=v_parametros.id_gestion and estado_reg!='eliminado') then
                  update param.tperiodo set estado_reg='eliminado'
                  where id_gestion=v_parametros.id_gestion;
               end if;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Gestion eliminada con exito '||v_parametros.id_gestion);
               v_resp = f_agrega_clave(v_resp,'id_gestion',v_parametros.id_gestion::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 982 (class 1255 OID 207288)
-- Dependencies: 15 3246
-- Name: ft_gestion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_gestion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 gestion: 		param.ft_gestion_sel
 DESCRIPCIÓN:  listado de gestion
 AUTOR: 		KPLIAN
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		07-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='param.ft_gestion_sel';


     if(par_transaccion='PM_GESTIO_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            GESTIO.id_gestion,
                            GESTIO.gestion,
                            GESTIO.estado_reg,
                            GESTIO.fecha_reg,
                            GESTIO.fecha_mod,
                            GESTIO.id_usuario_reg,
                            GESTIO.id_usuario_mod,
                            PERREG.nombre_completo1 as desc_usureg,
                            PERMOD.nombre_completo1 as desc_usumod
                            FROM param.tgestion GESTIO
                            inner join segu.tusuario USUREG on USUREG.id_usuario=GESTIO.id_usuario_reg
                            inner join segu.vpersona PERREG on PERREG.id_persona=USUREG.id_persona
                            left join segu.tusuario USUMOD on USUMOD.id_usuario=GESTIO.id_usuario_mod
                            left join segu.vpersona PERMOD on PERMOD.id_persona=USUMOD.id_persona
                            WHERE GESTIO.estado_reg!=''eliminado'' and ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;     
               
               if(public.f_existe_parametro(par_tabla,'estado')) then
                  v_consulta:=v_consulta || ' and GESTIO.estado_reg='''||v_parametros.estado||'''';
               end if;
               
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='PM_GESTIO_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(GESTIO.id_gestion)
                            FROM param.tgestion GESTIO
                            WHERE GESTIO.estado_reg!=''eliminado'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;  
               if(public.f_existe_parametro(par_tabla,'estado')) then
                  v_consulta:=v_consulta || ' and GESTIO.estado_reg='''||v_parametros.estado||'''';
               end if;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 992 (class 1255 OID 207289)
-- Dependencies: 15 3246
-- Name: ft_institucion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_institucion_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_institucion_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.tinstitucion'
 AUTOR: 		 (gvelasquez)
 FECHA:	        21-09-2011 10:50:03
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_institucion	integer;
			    
BEGIN

    v_nombre_funcion = 'param.ft_institucion_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_INSTIT_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		21-09-2011 10:50:03
	***********************************/

	if(p_transaccion='PM_INSTIT_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into param.tinstitucion(
			fax,
			estado_reg,
			
			casilla,
			direccion,
			doc_id,
			telefono2,
			id_persona,
			email2,
			celular1,
			email1,
			
			nombre,
			observaciones,
			telefono1,
			celular2,
			codigo_banco,
			pag_web,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod,
            codigo,
            es_banco,
            cargo_representante
          	) values(
			v_parametros.fax,
			'activo',
			v_parametros.casilla,
			v_parametros.direccion,
			v_parametros.doc_id,
			v_parametros.telefono2,
			v_parametros.id_persona,
			v_parametros.email2,
			v_parametros.celular1,
			v_parametros.email1,
			v_parametros.nombre,
			v_parametros.observaciones,
			v_parametros.telefono1,
			v_parametros.celular2,
			v_parametros.codigo_banco,
			v_parametros.pag_web,
			p_id_usuario,
			now(),
			null,
			null,
            v_parametros.codigo,
            v_parametros.es_banco,
            v_parametros.cargo_representante
            
			)RETURNING id_institucion into v_id_institucion;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Institución almacenado(a) con exito (id_institucion'||v_id_institucion||')'); 
            v_resp = f_agrega_clave(v_resp,'id_institucion',v_id_institucion::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'PM_INSTIT_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		21-09-2011 10:50:03
	***********************************/

	elsif(p_transaccion='PM_INSTIT_MOD')then

		begin
        
      --  raise exception 'ss  %',v_parametros.id_institucion;
			--Sentencia de la modificacion
			update param.tinstitucion set
			fax = v_parametros.fax,
			
			casilla = v_parametros.casilla,
			direccion = v_parametros.direccion,
			doc_id = v_parametros.doc_id,
			telefono2 = v_parametros.telefono2,
			id_persona = v_parametros.id_persona,
			email2 = v_parametros.email2,
			celular1 = v_parametros.celular1,
			email1 = v_parametros.email1,
			
			nombre = v_parametros.nombre,
			observaciones = v_parametros.observaciones,
			telefono1 = v_parametros.telefono1,
			celular2 = v_parametros.celular2,
			codigo_banco = v_parametros.codigo_banco,
			pag_web = v_parametros.pag_web,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now(),
            codigo = v_parametros.codigo,
            es_banco = v_parametros.es_banco,
            cargo_representante = v_parametros.cargo_representante
			where id_institucion=v_parametros.id_institucion;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Institución modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_institucion',v_parametros.id_institucion::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'PM_INSTIT_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		21-09-2011 10:50:03
	***********************************/

	elsif(p_transaccion='PM_INSTIT_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from param.tinstitucion
            where id_institucion=v_parametros.id_institucion;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Institución eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_institucion',v_parametros.id_institucion::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 993 (class 1255 OID 207290)
-- Dependencies: 15 3246
-- Name: ft_institucion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_institucion_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_institucion_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'param.tinstitucion'
 AUTOR: 		 (gvelasquez)
 FECHA:	        21-09-2011 10:50:03
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_filadd			varchar;
			    
BEGIN

	v_nombre_funcion = 'param.ft_institucion_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_INSTIT_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		gvelasquez	
 	#FECHA:		21-09-2011 10:50:03
	***********************************/

	if(p_transaccion='PM_INSTIT_SEL')then
     				
    	begin
            v_filadd = ' 0=0 ';
            IF (f_existe_parametro(p_tabla,'es_banco')) THEN
               v_filadd = ' instit.es_banco = '''||v_parametros.es_banco||''' ';
            END IF;
        
        
    		--Sentencia de la consulta
			v_consulta:='select
						instit.id_institucion,
						instit.fax,
						instit.estado_reg,
                        instit.casilla,
						instit.direccion,
						instit.doc_id,
						instit.telefono2,
						instit.id_persona,
						instit.email2,
						instit.celular1,
						instit.email1,
					
						instit.nombre,
						instit.observaciones,
						instit.telefono1,
						instit.celular2,
						instit.codigo_banco,
						instit.pag_web,
						instit.id_usuario_reg,
						instit.fecha_reg,
						instit.id_usuario_mod,
						instit.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        instit.codigo,	
						instit.es_banco,
                        per.nombre_completo2 as desc_persona,
                        instit.cargo_representante
						from param.tinstitucion instit
						inner join segu.tusuario usu1 on usu1.id_usuario = instit.id_usuario_reg
                        LEFT JOIN segu.vpersona per on per.id_persona = instit.id_persona
						left join segu.tusuario usu2 on usu2.id_usuario = instit.id_usuario_mod
				        where  (instit.estado_reg=''activo'' and '||v_filadd||' ) and';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'PM_INSTIT_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		gvelasquez	
 	#FECHA:		21-09-2011 10:50:03
	***********************************/

	elsif(p_transaccion='PM_INSTIT_CONT')then

		begin
          v_filadd = ' 0=0 ';
            IF (f_existe_parametro(p_tabla,'es_banco')) THEN
               v_filadd = ' instit.es_banco = '''||v_parametros.es_banco||''' and  instit.estado_reg=''activo'' ';
            END IF;
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_institucion)
					    from param.tinstitucion instit
                        WHERE  '||v_filadd;
			
			--Definicion de la respuesta		    
			--v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 994 (class 1255 OID 207291)
-- Dependencies: 15 3246
-- Name: ft_lugar_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_lugar_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.f_tlugar_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.tlugar'
 AUTOR: 		 (rac)
 FECHA:	        29-08-2011 09:19:28
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_lugar	integer;
    v_codigo_largo varchar;
			    
BEGIN

    v_nombre_funcion = 'param.f_tlugar_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_lug_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		29-08-2011 09:19:28
	***********************************/

	if(p_transaccion='PM_LUG_INS')then
					
        begin
        
           --obtiene codigo recursivamente
            IF v_parametros.id_lugar_fk is null THEN
               v_codigo_largo = v_parametros.codigo;
            ELSE
            
             WITH RECURSIVE t(id,id_fk,cod,n) AS (
               SELECT l.id_lugar,l.id_lugar_fk, l.codigo,1 
               FROM param.tlugar l 
               WHERE l.id_lugar = v_parametros.id_lugar_fk
              UNION ALL
               SELECT l.id_lugar,l.id_lugar_fk, l.codigo , n+1
               FROM param.tlugar l, t
               WHERE l.id_lugar = t.id_fk
            )
            SELECT textcat_all(a.cod||'.')
             into  
             v_codigo_largo
            FROM (SELECT  cod
                  FROM t 
                 order by n desc)  a;
                 
                 
               v_codigo_largo = v_codigo_largo||v_parametros.codigo;
            END IF;
            
            
        	--Sentencia de la insercion
        	insert into param.tlugar(
			codigo,
			estado_reg,
			id_lugar_fk,
			nombre,
			sw_impuesto,
			sw_municipio,
			tipo,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod,
            codigo_largo
          	) values(
			v_parametros.codigo,
			'activo',
			v_parametros.id_lugar_fk,
			v_parametros.nombre,
			v_parametros.sw_impuesto,
			v_parametros.sw_municipio,
			v_parametros.tipo,
			now(),
			p_id_usuario,
			null,
			null,
            v_codigo_largo
			)RETURNING id_lugar into v_id_lugar;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Lugar almacenado(a) con exito (id_lugar'||v_id_lugar||')'); 
            v_resp = f_agrega_clave(v_resp,'id_lugar',v_id_lugar::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'PM_lug_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		29-08-2011 09:19:28
	***********************************/

	elsif(p_transaccion='PM_LUG_MOD')then

		begin
            --obtiene codigo recursivamente
            IF v_parametros.id_lugar_fk is null THEN
               v_codigo_largo = v_parametros.codigo;
            ELSE
            
             WITH RECURSIVE t(id,id_fk,cod,n) AS (
               SELECT l.id_lugar,l.id_lugar_fk, l.codigo,1 
               FROM param.tlugar l 
               WHERE l.id_lugar = v_parametros.id_lugar_fk
              UNION ALL
               SELECT l.id_lugar,l.id_lugar_fk, l.codigo , n+1
               FROM param.tlugar l, t
               WHERE l.id_lugar = t.id_fk
            )
            SELECT textcat_all(a.cod||'.')
             into  
             v_codigo_largo
            FROM (SELECT  cod
                  FROM t 
                 order by n desc)  a;
                 
                 
               v_codigo_largo = v_codigo_largo||v_parametros.codigo;
            END IF;
        
			--Sentencia de la modificacion
			update param.tlugar set
			codigo = v_parametros.codigo,
			id_lugar_fk = v_parametros.id_lugar_fk,
			nombre = v_parametros.nombre,
			sw_impuesto = v_parametros.sw_impuesto,
			sw_municipio = v_parametros.sw_municipio,
			tipo = v_parametros.tipo,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario,
            codigo_largo=v_codigo_largo
			where id_lugar=v_parametros.id_lugar;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Lugar modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_lugar',v_parametros.id_lugar::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'PM_lug_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		29-08-2011 09:19:28
	***********************************/

	elsif(p_transaccion='PM_LUG_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from param.tlugar
            where id_lugar=v_parametros.id_lugar;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Lugar eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_lugar',v_parametros.id_lugar::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 995 (class 1255 OID 207292)
-- Dependencies: 15 3246
-- Name: ft_lugar_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_lugar_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.f_tlugar_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'param.tlugar'
 AUTOR: 		 (rac)
 FECHA:	        29-08-2011 09:19:28
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_where varchar;
    v_join varchar;
			    
BEGIN

	v_nombre_funcion = 'param.f_tlugar_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_LUG_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		29-08-2011 09:19:28
	***********************************/

	if(p_transaccion='PM_LUG_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						lug.id_lugar,
						lug.codigo,
						lug.estado_reg,
						lug.id_lugar_fk,
						lug.nombre,
						lug.sw_impuesto,
						lug.sw_municipio,
						lug.tipo,
						lug.fecha_reg,
						lug.id_usuario_reg,
						lug.fecha_mod,
						lug.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from param.tlugar lug
						inner join segu.tusuario usu1 on usu1.id_usuario = lug.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = lug.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;
        
     /*********************************    
 	#TRANSACCION:  'PM_LUG_ARB_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		29-08-2011 09:19:28
	***********************************/

	elseif(p_transaccion='PM_LUG_ARB_SEL')then
     				
    	begin
        
              if(v_parametros.id_padre = '%') then
                v_where := ' lug.id_lugar_fk is NULL';
                 v_join:= 'LEFT';      
                      
              else
                v_where := ' lug.id_lugar_fk = '||v_parametros.id_padre;
                v_join := 'INNER';
              end if;
        
        
    		--Sentencia de la consulta
			v_consulta:='select
						lug.id_lugar,
						lug.codigo,
						lug.estado_reg,
						lug.id_lugar_fk,
						lug.nombre,
						lug.sw_impuesto,
						lug.sw_municipio,
						lug.tipo,
						lug.fecha_reg,
						lug.id_usuario_reg,
						lug.fecha_mod,
						lug.id_usuario_mod,
						usu1.cuenta as usr_reg,
                        case
                          when (lug.id_lugar_fk is null )then
                               ''raiz''::varchar
                          ELSE
                              ''hijo''::varchar
                          END as tipo_nodo,
                         codigo_largo
						from param.tlugar lug
						inner join segu.tusuario usu1 
                        on usu1.id_usuario = lug.id_usuario_reg
					    where  '||v_where|| '  
                        ORDER BY lug.id_lugar';
			
			
			--Devuelve la respuesta
			return v_consulta;
						
		end;   

	/*********************************    
 	#TRANSACCION:  'PM_LUG_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		29-08-2011 09:19:28
	***********************************/

	elsif(p_transaccion='PM_LUG_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_lugar)
					    from param.tlugar lug
					    inner join segu.tusuario usu1 on usu1.id_usuario = lug.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = lug.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 983 (class 1255 OID 207293)
-- Dependencies: 15 3246
-- Name: ft_moneda_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_moneda_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.ft_moneda_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 		KPLIAN
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		18-01-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='param.ft_moneda_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   PM_MONEDA_INS
 #DESCRIPCION:	Inserta Funciones
 #AUTOR:		KPLIAN	
 #FECHA:		18-01-2011	
***********************************/
     if(par_transaccion='PM_MONEDA_INS')then

        
          BEGIN
          
          --insercion de nueva funcion
               INSERT INTO param.tmoneda(codigo,moneda, estado_reg,fecha_reg, id_usuario_reg)
               values(v_parametros.codigo,v_parametros.moneda,'activo',now()::date, par_id_usuario);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','moneda insertada con exito '||v_parametros.moneda);
               v_resp = f_agrega_clave(v_resp,'id_moneda',v_id_funcion::varchar);


         END;
 /*******************************    
 #TRANSACCION:  PM_MONEDA_MOD
 #DESCRIPCION:	Modifica la moneda seleccionada
 #AUTOR:		KPLIAN	
 #FECHA:		18-01-2011
***********************************/
     elsif(par_transaccion='PM_MONEDA_MOD')then

          
          BEGIN

          
               if exists (select 1 from param.tmoneda where estado_reg='activo' and tipo_moneda='base' and id_moneda!=v_parametros.id_moneda and v_parametros.tipo_moneda='on') then
                  raise exception 'Modificacion no realizada. Ya existe una moneda base';
               end if;
               --modificacion de moneda
               update param.tmoneda set
               codigo=v_parametros.codigo,
               moneda=v_parametros.moneda,
               fecha_mod=now()::date,
               id_usuario_mod=par_id_usuario,
               tipo_moneda=f_iif(v_parametros.tipo_moneda='on','base', null)
               
               where id_moneda=v_parametros.id_moneda;

               v_resp = f_agrega_clave(v_resp,'mensaje','moneda modificada con exito '||v_parametros.id_moneda);
               v_resp = f_agrega_clave(v_resp,'id_moneda',v_parametros.id_moneda::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  PM_MONEDA_ELI
 #DESCRIPCION:	Inactiva la moneda selecionada
 #AUTOR:		KPLIAN	
 #FECHA:		18-01-2011
***********************************/

    elsif(par_transaccion='PM_MONEDA_ELI')then
        BEGIN
        
         --inactivacion de la moneda
               update param.tmoneda set estado_reg='eliminado'
               where id_moneda=v_parametros.id_moneda;
               return 'moneda eliminado con exito';
               
               v_resp = f_agrega_clave(v_resp,'mensaje','moneda eliminada con exito '||v_parametros.id_moneda);
               v_resp = f_agrega_clave(v_resp,'id_moneda',v_parametros.id_moneda::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 984 (class 1255 OID 207294)
-- Dependencies: 15 3246
-- Name: ft_moneda_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_moneda_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 moneda: 		param.ft_moneda_sel
 DESCRIPCIÓN:  listado de moneda
 AUTOR: 		KPLIAN
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		18-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='param.ft_moneda_sel';


     if(par_transaccion='PM_MONEDA_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            MONEDA.id_moneda,
                            MONEDA.codigo ,
                            MONEDA.moneda,
                            MONEDA.estado_reg ,
                            MONEDA.fecha_reg ,
                            MONEDA.id_usuario_reg,
                            MONEDA.fecha_mod,
                            MONEDA.id_usuario_mod,
                            PERSON.nombre_completo1 AS desc_usuario_reg,
                            PERMOD.nombre_completo1 AS desc_usuario_mod,
                            f_iif(MONEDA.tipo_moneda=''base'',''true'',''false'') as tipo_moneda
                            FROM PARAM.tmoneda MONEDA
                            INNER JOIN SEGU.tusuario USUARI
                            ON USUARI.id_usuario=MONEDA.id_usuario_reg
                            INNER JOIN segu.vpersona PERSON ON PERSON.id_persona=USUARI.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD
                            ON USUMOD.id_usuario=MONEDA.id_usuario_mod
                            LEFT JOIN segu.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE MONEDA.estado_reg!=''eliminado'' and ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='PM_MONEDA_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                            count(MONEDA.id_moneda)
                            FROM PARAM.tmoneda MONEDA
                            INNER JOIN SEGU.tusuario USUARI
                            ON USUARI.id_usuario=MONEDA.id_usuario_reg
                            LEFT JOIN SEGU.tusuario USUMOD
                            ON USUMOD.id_usuario=MONEDA.id_moneda
                            WHERE MONEDA.estado_reg!=''eliminado'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 998 (class 1255 OID 207295)
-- Dependencies: 15 3246
-- Name: ft_periodo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_periodo_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		param.ft_periodo_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 		KPLIAN
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		12-01-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='segu.ft_periodo_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   PM_PERIOD_INS
 #DESCRIPCION:	Inserta Funciones
 #AUTOR:		KPLIAN	
 #FECHA:		07-01-2011	
***********************************/
     if(par_transaccion='PM_PERIOD_INS')then

        
          BEGIN
          
          if exists (select 1 from param.tperiodo where periodo=v_parametros.periodo and estado_reg!='eliminado' and id_gestion=v_parametros.id_gestion) then
            raise exception 'Insercion no realizada. Periodo existente';
          end if;
          --insercion de nueva funcion
               INSERT INTO param.tperiodo(periodo, estado_reg,fecha_reg, id_gestion, id_usuario_reg)
               values(v_parametros.periodo,'activo',now()::date, v_parametros.id_gestion, par_id_usuario);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','periodo insertada con exito '||v_parametros.periodo);
               v_resp = f_agrega_clave(v_resp,'id_periodo',v_id_funcion::varchar);


         END;
 /*******************************    
 #TRANSACCION:  PM_PERIOD_MOD
 #DESCRIPCION:	Modifica la periodo seleccionada
 #AUTOR:		KPLIAN	
 #FECHA:		12-01-2011
***********************************/
     elsif(par_transaccion='PM_PERIOD_MOD')then

          
          BEGIN
          
               if exists (select 1 from param.tperiodo where periodo=v_parametros.periodo and id_periodo!=v_parametros.id_periodo and estado_reg!='eliminado' and id_gestion=v_parametros.id_gestion) then
                  raise exception 'Modificacion no realizada. Periodo existente';
               end if;
               --modificacion de periodo
               update param.tperiodo set
               periodo=v_parametros.periodo,
               estado_reg=v_parametros.estado_reg
               where id_periodo=v_parametros.id_periodo;

               v_resp = f_agrega_clave(v_resp,'mensaje','periodo modificada con exito '||v_parametros.id_periodo);
               v_resp = f_agrega_clave(v_resp,'id_periodo',v_parametros.id_periodo::varchar);

             
          END;
          
/*******************************    
 #TRANSACCION:  PM_PERIOD_ELI
 #DESCRIPCION:	Inactiva la periodo selecionada
 #AUTOR:		KPLIAN	
 #FECHA:		12-01-2011
***********************************/

    elsif(par_transaccion='PM_PERIOD_ELI')then
        BEGIN
        
         --inactivacion de la periodo
               update param.tperiodo set estado_reg='eliminado'
               where id_periodo=v_parametros.id_periodo;
               return 'periodo eliminado con exito';
               
               v_resp = f_agrega_clave(v_resp,'mensaje','periodo eliminada con exito '||v_parametros.id_periodo);
               v_resp = f_agrega_clave(v_resp,'id_periodo',v_parametros.id_periodo::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 999 (class 1255 OID 207296)
-- Dependencies: 3246 15
-- Name: ft_periodo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_periodo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 periodo: 		param.ft_periodo_sel
 DESCRIPCIÓN:  listado de periodo
 AUTOR: 		KPLIAN
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		12-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='param.ft_periodo_sel';


     if(par_transaccion='PM_PERIOD_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            PERIOD.id_periodo,
                            public.f_obtener_literal_periodo(PERIOD.periodo, 10),
                            PERIOD.estado_reg,
                            PERIOD.fecha_reg,
                            GESTIO.id_gestion,
                            GESTIO.gestion,
                            PERIOD.id_usuario_reg,
                            PERIOD.id_usuario_mod,
                            perreg.nombre_completo1 as usureg,
                            permod.nombre_completo1 as usumod,
                            PERIOD.fecha_mod
                            FROM param.tperiodo PERIOD
                            INNER JOIN param.tgestion GESTIO
                            ON GESTIO.id_gestion=PERIOD.id_gestion
                            inner join segu.tusuario usureg on usureg.id_usuario=PERIOD.id_usuario_reg
                            inner join segu.vpersona perreg on perreg.id_persona=usureg.id_persona
                            left join segu.tusuario usumod on usumod.id_usuario=PERIOD.id_usuario_mod
                            left join segu.vpersona permod on permod.id_persona=usumod.id_persona
                            WHERE PERIOD.estado_reg!=''eliminado'' and ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;

               --if (v_parametros.id_gestion!=null) then
               --raise exception 'id_gestion no null';
                 v_consulta:=v_consulta|| ' AND PERIOD.id_gestion='||coalesce(v_parametros.id_gestion,0);
             --  else
               --  raise exception 'entra aqui';
               --end if;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='PM_PERIOD_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(PERIOD.id_periodo)
                            FROM param.tperiodo PERIOD
                            INNER JOIN param.tgestion GESTIO
                            ON GESTIO.id_gestion=PERIOD.id_gestion
                            WHERE PERIOD.estado_reg!=''eliminado'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
                 if (v_parametros.id_gestion is not null) then
                 v_consulta:=v_consulta|| ' AND PERIOD.id_gestion='||v_parametros.id_gestion;
               end if;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1000 (class 1255 OID 207297)
-- Dependencies: 15 3246
-- Name: ft_usuario_uo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_usuario_uo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_usuario_uo_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'param.tusuario_uo'
 AUTOR: 		 (rac)
 FECHA:	        13-12-2011 11:14:34
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_usuario_uo	integer;
			    
BEGIN

    v_nombre_funcion = 'param.ft_usuario_uo_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_uuo_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		13-12-2011 11:14:34
	***********************************/

	if(p_transaccion='PM_uuo_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into param.tusuario_uo(
			estado_reg,
			id_uo,
			id_usuario,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			'activo',
			v_parametros.id_uo,
			v_parametros.id_usuario,
			now(),
			p_id_usuario,
			null,
			null
			)RETURNING id_usuario_uo into v_id_usuario_uo;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','usuario_uo almacenado(a) con exito (id_usuario_uo'||v_id_usuario_uo||')'); 
            v_resp = f_agrega_clave(v_resp,'id_usuario_uo',v_id_usuario_uo::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'PM_uuo_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		13-12-2011 11:14:34
	***********************************/

	elsif(p_transaccion='PM_uuo_MOD')then

		begin
			--Sentencia de la modificacion
			update param.tusuario_uo set
			id_uo = v_parametros.id_uo,
			id_usuario = v_parametros.id_usuario,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_usuario_uo=v_parametros.id_usuario_uo;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','usuario_uo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_usuario_uo',v_parametros.id_usuario_uo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'PM_uuo_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		13-12-2011 11:14:34
	***********************************/

	elsif(p_transaccion='PM_uuo_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from param.tusuario_uo
            where id_usuario_uo=v_parametros.id_usuario_uo;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','usuario_uo eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_usuario_uo',v_parametros.id_usuario_uo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 1001 (class 1255 OID 207298)
-- Dependencies: 3246 15
-- Name: ft_usuario_uo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: param; Owner: -
--

CREATE FUNCTION ft_usuario_uo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		param.ft_usuario_uo_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'param.tusuario_uo'
 AUTOR: 		 (rac)
 FECHA:	        13-12-2011 11:14:34
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'param.ft_usuario_uo_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'PM_UUO_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		13-12-2011 11:14:34
	***********************************/

	if(p_transaccion='PM_UUO_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						uuo.id_usuario_uo,
						uuo.estado_reg,
						uuo.id_uo,
						uuo.id_usuario,
						uuo.fecha_reg,
						uuo.id_usuario_reg,
						uuo.fecha_mod,
						uuo.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                        PERSON.nombre_completo2 as desc_usuario,
                        uo.nombre_unidad
                       
						from param.tusuario_uo uuo
                         INNER JOIN rhum.tuo uo on uo.id_uo = uuo.id_uo
                         INNER JOIN segu.tusuario usupri on usupri.id_usuario=uuo.id_usuario
                       INNER JOIN segu.vpersona PERSON on PERSON.id_persona = usupri.id_persona
						inner join segu.tusuario usu1 on usu1.id_usuario = uuo.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = uuo.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'PM_UUO_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		13-12-2011 11:14:34
	***********************************/

	elsif(p_transaccion='PM_UUO_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_usuario_uo)
					    from param.tusuario_uo uuo
                        INNER JOIN rhum.tuo uo on uo.id_uo = uuo.id_uo
                         INNER JOIN segu.tusuario usupri on usupri.id_usuario=uuo.id_usuario
                       INNER JOIN segu.vpersona PERSON on PERSON.id_persona = usupri.id_persona
						inner join segu.tusuario usu1 on usu1.id_usuario = uuo.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = uuo.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


SET search_path = public, pg_catalog;

--
-- TOC entry 1002 (class 1255 OID 207299)
-- Dependencies: 23
-- Name: _int_contained(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _int_contained(integer[], integer[]) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_int_contained';


--
-- TOC entry 7041 (class 0 OID 0)
-- Dependencies: 1002
-- Name: FUNCTION _int_contained(integer[], integer[]); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION _int_contained(integer[], integer[]) IS 'contained in';


--
-- TOC entry 1003 (class 1255 OID 207300)
-- Dependencies: 23
-- Name: _int_contains(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _int_contains(integer[], integer[]) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_int_contains';


--
-- TOC entry 7042 (class 0 OID 0)
-- Dependencies: 1003
-- Name: FUNCTION _int_contains(integer[], integer[]); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION _int_contains(integer[], integer[]) IS 'contains';


--
-- TOC entry 1004 (class 1255 OID 207301)
-- Dependencies: 23
-- Name: _int_different(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _int_different(integer[], integer[]) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_int_different';


--
-- TOC entry 7043 (class 0 OID 0)
-- Dependencies: 1004
-- Name: FUNCTION _int_different(integer[], integer[]); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION _int_different(integer[], integer[]) IS 'different';


--
-- TOC entry 1005 (class 1255 OID 207302)
-- Dependencies: 23
-- Name: _int_inter(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _int_inter(integer[], integer[]) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_int_inter';


--
-- TOC entry 1006 (class 1255 OID 207303)
-- Dependencies: 23
-- Name: _int_overlap(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _int_overlap(integer[], integer[]) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_int_overlap';


--
-- TOC entry 7044 (class 0 OID 0)
-- Dependencies: 1006
-- Name: FUNCTION _int_overlap(integer[], integer[]); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION _int_overlap(integer[], integer[]) IS 'overlaps';


--
-- TOC entry 1007 (class 1255 OID 207304)
-- Dependencies: 23
-- Name: _int_same(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _int_same(integer[], integer[]) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_int_same';


--
-- TOC entry 7045 (class 0 OID 0)
-- Dependencies: 1007
-- Name: FUNCTION _int_same(integer[], integer[]); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION _int_same(integer[], integer[]) IS 'same as';


--
-- TOC entry 1008 (class 1255 OID 207305)
-- Dependencies: 23
-- Name: _int_union(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _int_union(integer[], integer[]) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', '_int_union';


--
-- TOC entry 1009 (class 1255 OID 207306)
-- Dependencies: 23 2189
-- Name: _st_asgeojson(integer, geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_asgeojson(integer, geometry, integer, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asGeoJson';


--
-- TOC entry 996 (class 1255 OID 207307)
-- Dependencies: 23 2185
-- Name: _st_asgeojson(integer, geography, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_asgeojson(integer, geography, integer, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_as_geojson';


--
-- TOC entry 997 (class 1255 OID 207308)
-- Dependencies: 23 2189
-- Name: _st_asgml(integer, geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_asgml(integer, geometry, integer, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asGML';


--
-- TOC entry 669 (class 1255 OID 207309)
-- Dependencies: 23 2185
-- Name: _st_asgml(integer, geography, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_asgml(integer, geography, integer, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_as_gml';


--
-- TOC entry 670 (class 1255 OID 207310)
-- Dependencies: 23 2189
-- Name: _st_askml(integer, geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_askml(integer, geometry, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asKML';


--
-- TOC entry 681 (class 1255 OID 207311)
-- Dependencies: 23 2185
-- Name: _st_askml(integer, geography, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_askml(integer, geography, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_as_kml';


--
-- TOC entry 682 (class 1255 OID 207312)
-- Dependencies: 23 2185
-- Name: _st_bestsrid(geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_bestsrid(geography) RETURNS integer
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_BestSRID($1,$1)$_$;


--
-- TOC entry 683 (class 1255 OID 207313)
-- Dependencies: 2185 23 2185
-- Name: _st_bestsrid(geography, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_bestsrid(geography, geography) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_bestsrid';


--
-- TOC entry 697 (class 1255 OID 207314)
-- Dependencies: 2189 23 2189
-- Name: _st_buffer(geometry, double precision, cstring); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_buffer(geometry, double precision, cstring) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'buffer';


--
-- TOC entry 698 (class 1255 OID 207315)
-- Dependencies: 2189 23 2189
-- Name: _st_contains(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_contains(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'contains';


--
-- TOC entry 708 (class 1255 OID 207316)
-- Dependencies: 2189 23 2189
-- Name: _st_containsproperly(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_containsproperly(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'containsproperly';


--
-- TOC entry 709 (class 1255 OID 207317)
-- Dependencies: 23 2189 2189
-- Name: _st_coveredby(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_coveredby(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'coveredby';


--
-- TOC entry 710 (class 1255 OID 207318)
-- Dependencies: 2189 23 2189
-- Name: _st_covers(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_covers(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'covers';


--
-- TOC entry 711 (class 1255 OID 207319)
-- Dependencies: 2185 23 2185
-- Name: _st_covers(geography, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_covers(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'geography_covers';


--
-- TOC entry 712 (class 1255 OID 207320)
-- Dependencies: 2189 23 2189
-- Name: _st_crosses(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_crosses(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'crosses';


--
-- TOC entry 713 (class 1255 OID 207321)
-- Dependencies: 2189 23 2189
-- Name: _st_dfullywithin(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_dfullywithin(geometry, geometry, double precision) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dfullywithin';


--
-- TOC entry 714 (class 1255 OID 207322)
-- Dependencies: 2185 23 2185
-- Name: _st_distance(geography, geography, double precision, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_distance(geography, geography, double precision, boolean) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'geography_distance';


--
-- TOC entry 715 (class 1255 OID 207323)
-- Dependencies: 2193 23 3246 2189
-- Name: _st_dumppoints(geometry, integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_dumppoints(the_geom geometry, cur_path integer[]) RETURNS SETOF geometry_dump
    LANGUAGE plpgsql
    AS $$
DECLARE
  tmp geometry_dump;
  tmp2 geometry_dump;
  nb_points integer;
  nb_geom integer;
  i integer;
  j integer;
  g geometry;
  
BEGIN
  
  RAISE DEBUG '%,%', cur_path, ST_GeometryType(the_geom);

  -- Special case (MULTI* OR GEOMETRYCOLLECTION) : iterate and return the DumpPoints of the geometries
  SELECT ST_NumGeometries(the_geom) INTO nb_geom;

  IF (nb_geom IS NOT NULL) THEN
    
    i = 1;
    FOR tmp2 IN SELECT (ST_Dump(the_geom)).* LOOP

      FOR tmp IN SELECT * FROM _ST_DumpPoints(tmp2.geom, cur_path || tmp2.path) LOOP
	    RETURN NEXT tmp;
      END LOOP;
      i = i + 1;
      
    END LOOP;

    RETURN;
  END IF;
  

  -- Special case (POLYGON) : return the points of the rings of a polygon
  IF (ST_GeometryType(the_geom) = 'ST_Polygon') THEN

    FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_ExteriorRing(the_geom), cur_path || ARRAY[1]) LOOP
      RETURN NEXT tmp;
    END LOOP;
    
    j := ST_NumInteriorRings(the_geom);
    FOR i IN 1..j LOOP
        FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_InteriorRingN(the_geom, i), cur_path || ARRAY[i+1]) LOOP
          RETURN NEXT tmp;
        END LOOP;
    END LOOP;
    
    RETURN;
  END IF;

    
  -- Special case (POINT) : return the point
  IF (ST_GeometryType(the_geom) = 'ST_Point') THEN

    tmp.path = cur_path || ARRAY[1];
    tmp.geom = the_geom;

    RETURN NEXT tmp;
    RETURN;

  END IF;


  -- Use ST_NumPoints rather than ST_NPoints to have a NULL value if the_geom isn't
  -- a LINESTRING or CIRCULARSTRING.
  SELECT ST_NumPoints(the_geom) INTO nb_points;

  -- This should never happen
  IF (nb_points IS NULL) THEN
    RAISE EXCEPTION 'Unexpected error while dumping geometry %', ST_AsText(the_geom);
  END IF;

  FOR i IN 1..nb_points LOOP
    tmp.path = cur_path || ARRAY[i];
    tmp.geom := ST_PointN(the_geom, i);
    RETURN NEXT tmp;
  END LOOP;
   
END
$$;


--
-- TOC entry 716 (class 1255 OID 207324)
-- Dependencies: 2189 23 2189
-- Name: _st_dwithin(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_dwithin(geometry, geometry, double precision) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_dwithin';


--
-- TOC entry 717 (class 1255 OID 207325)
-- Dependencies: 2185 23 2185
-- Name: _st_dwithin(geography, geography, double precision, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_dwithin(geography, geography, double precision, boolean) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'geography_dwithin';


--
-- TOC entry 718 (class 1255 OID 207326)
-- Dependencies: 2189 23 2189
-- Name: _st_equals(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_equals(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'geomequals';


--
-- TOC entry 719 (class 1255 OID 207327)
-- Dependencies: 2185 23 2185
-- Name: _st_expand(geography, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_expand(geography, double precision) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_expand';


--
-- TOC entry 724 (class 1255 OID 207328)
-- Dependencies: 2189 23 2189
-- Name: _st_intersects(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_intersects(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'intersects';


--
-- TOC entry 725 (class 1255 OID 207329)
-- Dependencies: 2189 23 2189
-- Name: _st_linecrossingdirection(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_linecrossingdirection(geometry, geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'ST_LineCrossingDirection';


--
-- TOC entry 726 (class 1255 OID 207330)
-- Dependencies: 2189 23 2189 2189
-- Name: _st_longestline(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_longestline(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_longestline2d';


--
-- TOC entry 727 (class 1255 OID 207331)
-- Dependencies: 23 2189 2189
-- Name: _st_maxdistance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_maxdistance(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_maxdistance2d_linestring';


--
-- TOC entry 728 (class 1255 OID 207332)
-- Dependencies: 2189 23 2189
-- Name: _st_orderingequals(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_orderingequals(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_same';


--
-- TOC entry 729 (class 1255 OID 207333)
-- Dependencies: 2189 23 2189
-- Name: _st_overlaps(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_overlaps(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'overlaps';


--
-- TOC entry 730 (class 1255 OID 207334)
-- Dependencies: 2185 23 2185
-- Name: _st_pointoutside(geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_pointoutside(geography) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_point_outside';


--
-- TOC entry 731 (class 1255 OID 207335)
-- Dependencies: 2189 23 2189
-- Name: _st_touches(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_touches(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'touches';


--
-- TOC entry 732 (class 1255 OID 207336)
-- Dependencies: 2189 23 2189
-- Name: _st_within(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION _st_within(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'within';


--
-- TOC entry 733 (class 1255 OID 207337)
-- Dependencies: 23 3246
-- Name: addauth(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION addauth(text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$ 
DECLARE
	lockid alias for $1;
	okay boolean;
	myrec record;
BEGIN
	-- check to see if table exists
	--  if not, CREATE TEMP TABLE mylock (transid xid, lockcode text)
	okay := 'f';
	FOR myrec IN SELECT * FROM pg_class WHERE relname = 'temp_lock_have_table' LOOP
		okay := 't';
	END LOOP; 
	IF (okay <> 't') THEN 
		CREATE TEMP TABLE temp_lock_have_table (transid xid, lockcode text);
			-- this will only work from pgsql7.4 up
			-- ON COMMIT DELETE ROWS;
	END IF;

	--  INSERT INTO mylock VALUES ( $1)
--	EXECUTE 'INSERT INTO temp_lock_have_table VALUES ( '||
--		quote_literal(getTransactionID()) || ',' ||
--		quote_literal(lockid) ||')';

	INSERT INTO temp_lock_have_table VALUES (getTransactionID(), lockid);

	RETURN true::boolean;
END;
$_$;


--
-- TOC entry 734 (class 1255 OID 207338)
-- Dependencies: 2189 23 2189
-- Name: addbbox(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION addbbox(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_addBBOX';


--
-- TOC entry 735 (class 1255 OID 207339)
-- Dependencies: 23 3246
-- Name: addgeometrycolumn(character varying, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;


--
-- TOC entry 736 (class 1255 OID 207340)
-- Dependencies: 23 3246
-- Name: addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;


--
-- TOC entry 1010 (class 1255 OID 207341)
-- Dependencies: 23 3246
-- Name: addgeometrycolumn(character varying, character varying, character varying, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	catalog_name alias for $1;
	schema_name alias for $2;
	table_name alias for $3;
	column_name alias for $4;
	new_srid alias for $5;
	new_type alias for $6;
	new_dim alias for $7;
	rec RECORD;
	sr varchar;
	real_schema name;
	sql text;

BEGIN

	-- Verify geometry type
	IF ( NOT ( (new_type = 'GEOMETRY') OR
			   (new_type = 'GEOMETRYCOLLECTION') OR
			   (new_type = 'POINT') OR
			   (new_type = 'MULTIPOINT') OR
			   (new_type = 'POLYGON') OR
			   (new_type = 'MULTIPOLYGON') OR
			   (new_type = 'LINESTRING') OR
			   (new_type = 'MULTILINESTRING') OR
			   (new_type = 'GEOMETRYCOLLECTIONM') OR
			   (new_type = 'POINTM') OR
			   (new_type = 'MULTIPOINTM') OR
			   (new_type = 'POLYGONM') OR
			   (new_type = 'MULTIPOLYGONM') OR
			   (new_type = 'LINESTRINGM') OR
			   (new_type = 'MULTILINESTRINGM') OR
			   (new_type = 'CIRCULARSTRING') OR
			   (new_type = 'CIRCULARSTRINGM') OR
			   (new_type = 'COMPOUNDCURVE') OR
			   (new_type = 'COMPOUNDCURVEM') OR
			   (new_type = 'CURVEPOLYGON') OR
			   (new_type = 'CURVEPOLYGONM') OR
			   (new_type = 'MULTICURVE') OR
			   (new_type = 'MULTICURVEM') OR
			   (new_type = 'MULTISURFACE') OR
			   (new_type = 'MULTISURFACEM')) )
	THEN
		RAISE EXCEPTION 'Invalid type name - valid ones are:
	POINT, MULTIPOINT,
	LINESTRING, MULTILINESTRING,
	POLYGON, MULTIPOLYGON,
	CIRCULARSTRING, COMPOUNDCURVE, MULTICURVE,
	CURVEPOLYGON, MULTISURFACE,
	GEOMETRY, GEOMETRYCOLLECTION,
	POINTM, MULTIPOINTM,
	LINESTRINGM, MULTILINESTRINGM,
	POLYGONM, MULTIPOLYGONM,
	CIRCULARSTRINGM, COMPOUNDCURVEM, MULTICURVEM
	CURVEPOLYGONM, MULTISURFACEM,
	or GEOMETRYCOLLECTIONM';
		RETURN 'fail';
	END IF;


	-- Verify dimension
	IF ( (new_dim >4) OR (new_dim <0) ) THEN
		RAISE EXCEPTION 'invalid dimension';
		RETURN 'fail';
	END IF;

	IF ( (new_type LIKE '%M') AND (new_dim!=3) ) THEN
		RAISE EXCEPTION 'TypeM needs 3 dimensions';
		RETURN 'fail';
	END IF;


	-- Verify SRID
	IF ( new_srid != -1 ) THEN
		SELECT SRID INTO sr FROM spatial_ref_sys WHERE SRID = new_srid;
		IF NOT FOUND THEN
			RAISE EXCEPTION 'AddGeometryColumns() - invalid SRID';
			RETURN 'fail';
		END IF;
	END IF;


	-- Verify schema
	IF ( schema_name IS NOT NULL AND schema_name != '' ) THEN
		sql := 'SELECT nspname FROM pg_namespace ' ||
			'WHERE text(nspname) = ' || quote_literal(schema_name) ||
			'LIMIT 1';
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Schema % is not a valid schemaname', quote_literal(schema_name);
			RETURN 'fail';
		END IF;
	END IF;

	IF ( real_schema IS NULL ) THEN
		RAISE DEBUG 'Detecting schema';
		sql := 'SELECT n.nspname AS schemaname ' ||
			'FROM pg_catalog.pg_class c ' ||
			  'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace ' ||
			'WHERE c.relkind = ' || quote_literal('r') ||
			' AND n.nspname NOT IN (' || quote_literal('pg_catalog') || ', ' || quote_literal('pg_toast') || ')' ||
			' AND pg_catalog.pg_table_is_visible(c.oid)' ||
			' AND c.relname = ' || quote_literal(table_name);
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Table % does not occur in the search_path', quote_literal(table_name);
			RETURN 'fail';
		END IF;
	END IF;


	-- Add geometry column to table
	sql := 'ALTER TABLE ' ||
		quote_ident(real_schema) || '.' || quote_ident(table_name)
		|| ' ADD COLUMN ' || quote_ident(column_name) ||
		' geometry ';
	RAISE DEBUG '%', sql;
	EXECUTE sql;


	-- Delete stale record in geometry_columns (if any)
	sql := 'DELETE FROM geometry_columns WHERE
		f_table_catalog = ' || quote_literal('') ||
		' AND f_table_schema = ' ||
		quote_literal(real_schema) ||
		' AND f_table_name = ' || quote_literal(table_name) ||
		' AND f_geometry_column = ' || quote_literal(column_name);
	RAISE DEBUG '%', sql;
	EXECUTE sql;


	-- Add record in geometry_columns
	sql := 'INSERT INTO geometry_columns (f_table_catalog,f_table_schema,f_table_name,' ||
										  'f_geometry_column,coord_dimension,srid,type)' ||
		' VALUES (' ||
		quote_literal('') || ',' ||
		quote_literal(real_schema) || ',' ||
		quote_literal(table_name) || ',' ||
		quote_literal(column_name) || ',' ||
		new_dim::text || ',' ||
		new_srid::text || ',' ||
		quote_literal(new_type) || ')';
	RAISE DEBUG '%', sql;
	EXECUTE sql;


	-- Add table CHECKs
	sql := 'ALTER TABLE ' ||
		quote_ident(real_schema) || '.' || quote_ident(table_name)
		|| ' ADD CONSTRAINT '
		|| quote_ident('enforce_srid_' || column_name)
		|| ' CHECK (ST_SRID(' || quote_ident(column_name) ||
		') = ' || new_srid::text || ')' ;
	RAISE DEBUG '%', sql;
	EXECUTE sql;

	sql := 'ALTER TABLE ' ||
		quote_ident(real_schema) || '.' || quote_ident(table_name)
		|| ' ADD CONSTRAINT '
		|| quote_ident('enforce_dims_' || column_name)
		|| ' CHECK (ST_NDims(' || quote_ident(column_name) ||
		') = ' || new_dim::text || ')' ;
	RAISE DEBUG '%', sql;
	EXECUTE sql;

	IF ( NOT (new_type = 'GEOMETRY')) THEN
		sql := 'ALTER TABLE ' ||
			quote_ident(real_schema) || '.' || quote_ident(table_name) || ' ADD CONSTRAINT ' ||
			quote_ident('enforce_geotype_' || column_name) ||
			' CHECK (GeometryType(' ||
			quote_ident(column_name) || ')=' ||
			quote_literal(new_type) || ' OR (' ||
			quote_ident(column_name) || ') is null)';
		RAISE DEBUG '%', sql;
		EXECUTE sql;
	END IF;

	RETURN
		real_schema || '.' ||
		table_name || '.' || column_name ||
		' SRID:' || new_srid::text ||
		' TYPE:' || new_type ||
		' DIMS:' || new_dim::text || ' ';
END;
$_$;


--
-- TOC entry 1011 (class 1255 OID 207342)
-- Dependencies: 2189 23 2189 2189
-- Name: addpoint(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION addpoint(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_addpoint';


--
-- TOC entry 1012 (class 1255 OID 207343)
-- Dependencies: 2189 23 2189 2189
-- Name: addpoint(geometry, geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION addpoint(geometry, geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_addpoint';


--
-- TOC entry 1013 (class 1255 OID 207344)
-- Dependencies: 23 2189 2189
-- Name: affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  $2, $3, 0,  $4, $5, 0,  0, 0, 1,  $6, $7, 0)$_$;


--
-- TOC entry 1014 (class 1255 OID 207345)
-- Dependencies: 2189 2189 23
-- Name: affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_affine';


--
-- TOC entry 1015 (class 1255 OID 207346)
-- Dependencies: 23
-- Name: aggregate_array(anyarray, anyelement); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION aggregate_array(anyarray, anyelement) RETURNS anyarray
    LANGUAGE sql
    AS $_$
SELECT
CASE
WHEN $1 IS NULL
THEN ARRAY[$2]
WHEN $2 IS NULL
THEN $1
ELSE array_append($1,$2)
END;
$_$;


--
-- TOC entry 1016 (class 1255 OID 207347)
-- Dependencies: 23 2189
-- Name: area(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION area(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_area_polygon';


--
-- TOC entry 1017 (class 1255 OID 207348)
-- Dependencies: 2189 23
-- Name: area2d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION area2d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_area_polygon';


--
-- TOC entry 1018 (class 1255 OID 207349)
-- Dependencies: 2189 23
-- Name: asbinary(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION asbinary(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asBinary';


--
-- TOC entry 1019 (class 1255 OID 207350)
-- Dependencies: 23 2189
-- Name: asbinary(geometry, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION asbinary(geometry, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asBinary';


--
-- TOC entry 1020 (class 1255 OID 207351)
-- Dependencies: 2189 23
-- Name: asewkb(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION asewkb(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'WKBFromLWGEOM';


--
-- TOC entry 1021 (class 1255 OID 207352)
-- Dependencies: 23 2189
-- Name: asewkb(geometry, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION asewkb(geometry, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'WKBFromLWGEOM';


--
-- TOC entry 1022 (class 1255 OID 207353)
-- Dependencies: 2189 23
-- Name: asewkt(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION asewkt(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asEWKT';


--
-- TOC entry 1023 (class 1255 OID 207354)
-- Dependencies: 23 2189
-- Name: asgml(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION asgml(geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, 15, 0)$_$;


--
-- TOC entry 1024 (class 1255 OID 207355)
-- Dependencies: 2189 23
-- Name: asgml(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION asgml(geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, $2, 0)$_$;


--
-- TOC entry 1025 (class 1255 OID 207356)
-- Dependencies: 23 2189
-- Name: ashexewkb(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION ashexewkb(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asHEXEWKB';


--
-- TOC entry 1026 (class 1255 OID 207357)
-- Dependencies: 2189 23
-- Name: ashexewkb(geometry, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION ashexewkb(geometry, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asHEXEWKB';


--
-- TOC entry 1027 (class 1255 OID 207358)
-- Dependencies: 23 2189
-- Name: askml(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION askml(geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML(2, transform($1,4326), 15)$_$;


--
-- TOC entry 1028 (class 1255 OID 207359)
-- Dependencies: 2189 23
-- Name: askml(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION askml(geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML(2, transform($1,4326), $2)$_$;


--
-- TOC entry 1029 (class 1255 OID 207360)
-- Dependencies: 23 2189
-- Name: askml(integer, geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION askml(integer, geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML($1, transform($2,4326), $3)$_$;


--
-- TOC entry 1030 (class 1255 OID 207361)
-- Dependencies: 23 2189
-- Name: assvg(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION assvg(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'assvg_geometry';


--
-- TOC entry 1031 (class 1255 OID 207362)
-- Dependencies: 23 2189
-- Name: assvg(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION assvg(geometry, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'assvg_geometry';


--
-- TOC entry 1032 (class 1255 OID 207363)
-- Dependencies: 23 2189
-- Name: assvg(geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION assvg(geometry, integer, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'assvg_geometry';


--
-- TOC entry 1033 (class 1255 OID 207364)
-- Dependencies: 2189 23
-- Name: astext(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION astext(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asText';


--
-- TOC entry 1034 (class 1255 OID 207365)
-- Dependencies: 23 2189 2189
-- Name: azimuth(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION azimuth(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_azimuth';


--
-- TOC entry 1035 (class 1255 OID 207366)
-- Dependencies: 2189 23 3246
-- Name: bdmpolyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(BuildArea(mline));

	RETURN geom;
END;
$_$;


--
-- TOC entry 739 (class 1255 OID 207367)
-- Dependencies: 2189 23 3246
-- Name: bdpolyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;


--
-- TOC entry 740 (class 1255 OID 207368)
-- Dependencies: 2208 23
-- Name: boolop(integer[], query_int); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION boolop(integer[], query_int) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'boolop';


--
-- TOC entry 7046 (class 0 OID 0)
-- Dependencies: 740
-- Name: FUNCTION boolop(integer[], query_int); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION boolop(integer[], query_int) IS 'boolean operation with array';


--
-- TOC entry 741 (class 1255 OID 207369)
-- Dependencies: 23 2189 2189
-- Name: boundary(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION boundary(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'boundary';


--
-- TOC entry 742 (class 1255 OID 207370)
-- Dependencies: 23 2189
-- Name: box(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION box(geometry) RETURNS box
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_BOX';


--
-- TOC entry 743 (class 1255 OID 207371)
-- Dependencies: 23 2164
-- Name: box(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION box(box3d) RETURNS box
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_BOX';


--
-- TOC entry 744 (class 1255 OID 207372)
-- Dependencies: 2160 23 2168
-- Name: box2d(box3d_extent); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION box2d(box3d_extent) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_BOX2DFLOAT4';


--
-- TOC entry 745 (class 1255 OID 207373)
-- Dependencies: 2189 2160 23
-- Name: box2d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION box2d(geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_BOX2DFLOAT4';


--
-- TOC entry 746 (class 1255 OID 207374)
-- Dependencies: 2164 23 2160
-- Name: box2d(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION box2d(box3d) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_BOX2DFLOAT4';


--
-- TOC entry 747 (class 1255 OID 207375)
-- Dependencies: 2189 23 2164
-- Name: box3d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION box3d(geometry) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_BOX3D';


--
-- TOC entry 748 (class 1255 OID 207376)
-- Dependencies: 2160 2164 23
-- Name: box3d(box2d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION box3d(box2d) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_to_BOX3D';


--
-- TOC entry 749 (class 1255 OID 207377)
-- Dependencies: 2168 2164 23
-- Name: box3d_extent(box3d_extent); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION box3d_extent(box3d_extent) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_extent_to_BOX3D';


--
-- TOC entry 750 (class 1255 OID 207378)
-- Dependencies: 2164 23
-- Name: box3dtobox(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION box3dtobox(box3d) RETURNS box
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT box($1)$_$;


--
-- TOC entry 751 (class 1255 OID 207379)
-- Dependencies: 2189 2189 23
-- Name: buffer(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION buffer(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'buffer';


--
-- TOC entry 752 (class 1255 OID 207380)
-- Dependencies: 23 2189 2189
-- Name: buffer(geometry, double precision, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION buffer(geometry, double precision, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_Buffer($1, $2, $3)$_$;


--
-- TOC entry 753 (class 1255 OID 207381)
-- Dependencies: 2189 2189 23
-- Name: buildarea(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION buildarea(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_buildarea';


--
-- TOC entry 754 (class 1255 OID 207382)
-- Dependencies: 23 2189
-- Name: bytea(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION bytea(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_bytea';


--
-- TOC entry 755 (class 1255 OID 207383)
-- Dependencies: 23 3246
-- Name: cast_bytea_oid(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION cast_bytea_oid(archivo bytea) RETURNS oid
    LANGUAGE plpgsql
    AS $$
   declare
      loid oid;
      lfd integer;
      lsize integer;
begin

   if(archivo is null) then
      return null;
   end if;
   loid := lo_create(0);
   lfd := lo_open(loid,131072);
   lsize := lowrite(lfd,archivo);
   perform lo_close(lfd);
   return loid;
end;
$$;


--
-- TOC entry 756 (class 1255 OID 207384)
-- Dependencies: 2189 2189 23
-- Name: centroid(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION centroid(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'centroid';


--
-- TOC entry 757 (class 1255 OID 207385)
-- Dependencies: 23
-- Name: checkauth(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION checkauth(text, text) RETURNS integer
    LANGUAGE sql
    AS $_$ SELECT CheckAuth('', $1, $2) $_$;


--
-- TOC entry 762 (class 1255 OID 207386)
-- Dependencies: 3246 23
-- Name: checkauth(text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION checkauth(text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
DECLARE
	schema text;
BEGIN
	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	if ( $1 != '' ) THEN
		schema = $1;
	ELSE
		SELECT current_schema() into schema;
	END IF;

	-- TODO: check for an already existing trigger ?

	EXECUTE 'CREATE TRIGGER check_auth BEFORE UPDATE OR DELETE ON ' 
		|| quote_ident(schema) || '.' || quote_ident($2)
		||' FOR EACH ROW EXECUTE PROCEDURE CheckAuthTrigger('
		|| quote_literal($3) || ')';

	RETURN 0;
END;
$_$;


--
-- TOC entry 763 (class 1255 OID 207387)
-- Dependencies: 23
-- Name: checkauthtrigger(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION checkauthtrigger() RETURNS trigger
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'check_authorization';


--
-- TOC entry 764 (class 1255 OID 207388)
-- Dependencies: 2189 23 2189 2189
-- Name: collect(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION collect(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'LWGEOM_collect';


--
-- TOC entry 765 (class 1255 OID 207389)
-- Dependencies: 23 2189 2160 2160
-- Name: combine_bbox(box2d, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION combine_bbox(box2d, geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_combine';


--
-- TOC entry 766 (class 1255 OID 207390)
-- Dependencies: 2168 23 2189 2168
-- Name: combine_bbox(box3d_extent, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION combine_bbox(box3d_extent, geometry) RETURNS box3d_extent
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'BOX3D_combine';


--
-- TOC entry 767 (class 1255 OID 207391)
-- Dependencies: 2189 2164 2164 23
-- Name: combine_bbox(box3d, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION combine_bbox(box3d, geometry) RETURNS box3d
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'BOX3D_combine';


--
-- TOC entry 768 (class 1255 OID 207392)
-- Dependencies: 23
-- Name: comma_cat(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION comma_cat(text, text) RETURNS text
    LANGUAGE sql
    AS $_$
select case
 WHEN $2 is null or $2 = '' THEN $1
 WHEN $1 is null or $1 = '' THEN $2
 ELSE $1 || ',' || $2
 END
$_$;


--
-- TOC entry 774 (class 1255 OID 207393)
-- Dependencies: 23 2172
-- Name: compression(chip); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION compression(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getCompression';


--
-- TOC entry 775 (class 1255 OID 207394)
-- Dependencies: 23 3246
-- Name: concat(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION concat(text, text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
begin
  if $1 is null then
    return $2;
  end if;
  if $2 is null then
    return $1;
  end if;
  return $1 || ',' || $2;
end
$_$;


--
-- TOC entry 776 (class 1255 OID 207395)
-- Dependencies: 2189 2189 23
-- Name: contains(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION contains(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'contains';


--
-- TOC entry 777 (class 1255 OID 207396)
-- Dependencies: 2189 23 2189
-- Name: convexhull(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION convexhull(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'convexhull';


--
-- TOC entry 778 (class 1255 OID 207397)
-- Dependencies: 2189 2189 23
-- Name: crosses(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION crosses(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'crosses';


--
-- TOC entry 779 (class 1255 OID 207398)
-- Dependencies: 2172 23
-- Name: datatype(chip); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION datatype(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getDatatype';


--
-- TOC entry 780 (class 1255 OID 207399)
-- Dependencies: 23
-- Name: dblink(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink(text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


--
-- TOC entry 781 (class 1255 OID 207400)
-- Dependencies: 23
-- Name: dblink(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink(text, text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


--
-- TOC entry 782 (class 1255 OID 207401)
-- Dependencies: 23
-- Name: dblink(text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink(text, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


--
-- TOC entry 783 (class 1255 OID 207402)
-- Dependencies: 23
-- Name: dblink(text, text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink(text, text, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


--
-- TOC entry 786 (class 1255 OID 207403)
-- Dependencies: 23
-- Name: dblink_build_sql_delete(text, int2vector, integer, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_build_sql_delete(text, int2vector, integer, text[]) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_build_sql_delete';


--
-- TOC entry 787 (class 1255 OID 207404)
-- Dependencies: 23
-- Name: dblink_build_sql_insert(text, int2vector, integer, text[], text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_build_sql_insert(text, int2vector, integer, text[], text[]) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_build_sql_insert';


--
-- TOC entry 788 (class 1255 OID 207405)
-- Dependencies: 23
-- Name: dblink_build_sql_update(text, int2vector, integer, text[], text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_build_sql_update(text, int2vector, integer, text[], text[]) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_build_sql_update';


--
-- TOC entry 789 (class 1255 OID 207406)
-- Dependencies: 23
-- Name: dblink_cancel_query(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_cancel_query(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_cancel_query';


--
-- TOC entry 790 (class 1255 OID 207407)
-- Dependencies: 23
-- Name: dblink_close(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_close(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


--
-- TOC entry 791 (class 1255 OID 207408)
-- Dependencies: 23
-- Name: dblink_close(text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_close(text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


--
-- TOC entry 792 (class 1255 OID 207409)
-- Dependencies: 23
-- Name: dblink_close(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_close(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


--
-- TOC entry 793 (class 1255 OID 207410)
-- Dependencies: 23
-- Name: dblink_close(text, text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_close(text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


--
-- TOC entry 794 (class 1255 OID 207411)
-- Dependencies: 23
-- Name: dblink_connect(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_connect(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_connect';


--
-- TOC entry 795 (class 1255 OID 207412)
-- Dependencies: 23
-- Name: dblink_connect(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_connect(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_connect';


--
-- TOC entry 1844 (class 1255 OID 207413)
-- Dependencies: 23
-- Name: dblink_connect_u(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_connect_u(text) RETURNS text
    LANGUAGE c STRICT SECURITY DEFINER
    AS '$libdir/dblink', 'dblink_connect';


--
-- TOC entry 796 (class 1255 OID 207414)
-- Dependencies: 23
-- Name: dblink_connect_u(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_connect_u(text, text) RETURNS text
    LANGUAGE c STRICT SECURITY DEFINER
    AS '$libdir/dblink', 'dblink_connect';


--
-- TOC entry 797 (class 1255 OID 207415)
-- Dependencies: 23
-- Name: dblink_current_query(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_current_query() RETURNS text
    LANGUAGE c
    AS '$libdir/dblink', 'dblink_current_query';


--
-- TOC entry 798 (class 1255 OID 207416)
-- Dependencies: 23
-- Name: dblink_disconnect(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_disconnect() RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_disconnect';


--
-- TOC entry 799 (class 1255 OID 207417)
-- Dependencies: 23
-- Name: dblink_disconnect(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_disconnect(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_disconnect';


--
-- TOC entry 800 (class 1255 OID 207418)
-- Dependencies: 23
-- Name: dblink_error_message(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_error_message(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_error_message';


--
-- TOC entry 801 (class 1255 OID 207419)
-- Dependencies: 23
-- Name: dblink_exec(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_exec(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


--
-- TOC entry 802 (class 1255 OID 207420)
-- Dependencies: 23
-- Name: dblink_exec(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_exec(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


--
-- TOC entry 803 (class 1255 OID 207421)
-- Dependencies: 23
-- Name: dblink_exec(text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_exec(text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


--
-- TOC entry 804 (class 1255 OID 207422)
-- Dependencies: 23
-- Name: dblink_exec(text, text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_exec(text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


--
-- TOC entry 809 (class 1255 OID 207423)
-- Dependencies: 23
-- Name: dblink_fetch(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_fetch(text, integer) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


--
-- TOC entry 810 (class 1255 OID 207424)
-- Dependencies: 23
-- Name: dblink_fetch(text, integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_fetch(text, integer, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


--
-- TOC entry 811 (class 1255 OID 207425)
-- Dependencies: 23
-- Name: dblink_fetch(text, text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_fetch(text, text, integer) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


--
-- TOC entry 812 (class 1255 OID 207426)
-- Dependencies: 23
-- Name: dblink_fetch(text, text, integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_fetch(text, text, integer, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


--
-- TOC entry 813 (class 1255 OID 207427)
-- Dependencies: 23
-- Name: dblink_get_connections(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_get_connections() RETURNS text[]
    LANGUAGE c
    AS '$libdir/dblink', 'dblink_get_connections';


--
-- TOC entry 814 (class 1255 OID 207428)
-- Dependencies: 23
-- Name: dblink_get_notify(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_get_notify(OUT notify_name text, OUT be_pid integer, OUT extra text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_notify';


--
-- TOC entry 822 (class 1255 OID 207429)
-- Dependencies: 23
-- Name: dblink_get_notify(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_get_notify(conname text, OUT notify_name text, OUT be_pid integer, OUT extra text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_notify';


--
-- TOC entry 823 (class 1255 OID 207430)
-- Dependencies: 23 2176
-- Name: dblink_get_pkey(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_get_pkey(text) RETURNS SETOF dblink_pkey_results
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_pkey';


--
-- TOC entry 824 (class 1255 OID 207431)
-- Dependencies: 23
-- Name: dblink_get_result(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_get_result(text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_result';


--
-- TOC entry 825 (class 1255 OID 207432)
-- Dependencies: 23
-- Name: dblink_get_result(text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_get_result(text, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_result';


--
-- TOC entry 826 (class 1255 OID 207433)
-- Dependencies: 23
-- Name: dblink_is_busy(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_is_busy(text) RETURNS integer
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_is_busy';


--
-- TOC entry 827 (class 1255 OID 207434)
-- Dependencies: 23
-- Name: dblink_open(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_open(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


--
-- TOC entry 828 (class 1255 OID 207435)
-- Dependencies: 23
-- Name: dblink_open(text, text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_open(text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


--
-- TOC entry 829 (class 1255 OID 207436)
-- Dependencies: 23
-- Name: dblink_open(text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_open(text, text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


--
-- TOC entry 830 (class 1255 OID 207437)
-- Dependencies: 23
-- Name: dblink_open(text, text, text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_open(text, text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


--
-- TOC entry 831 (class 1255 OID 207438)
-- Dependencies: 23
-- Name: dblink_send_query(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dblink_send_query(text, text) RETURNS integer
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_send_query';


--
-- TOC entry 832 (class 1255 OID 207439)
-- Dependencies: 2189 23 2189 2189
-- Name: difference(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION difference(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'difference';


--
-- TOC entry 833 (class 1255 OID 207440)
-- Dependencies: 23 2189
-- Name: dimension(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dimension(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dimension';


--
-- TOC entry 834 (class 1255 OID 207441)
-- Dependencies: 23 3246
-- Name: disablelongtransactions(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION disablelongtransactions() RETURNS text
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;

BEGIN

	--
	-- Drop all triggers applied by CheckAuth()
	--
	FOR rec IN
		SELECT c.relname, t.tgname, t.tgargs FROM pg_trigger t, pg_class c, pg_proc p
		WHERE p.proname = 'checkauthtrigger' and t.tgfoid = p.oid and t.tgrelid = c.oid
	LOOP
		EXECUTE 'DROP TRIGGER ' || quote_ident(rec.tgname) ||
			' ON ' || quote_ident(rec.relname);
	END LOOP;

	--
	-- Drop the authorization_table table
	--
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table' LOOP
		DROP TABLE authorization_table;
	END LOOP;

	--
	-- Drop the authorized_tables view
	--
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables' LOOP
		DROP VIEW authorized_tables;
	END LOOP;

	RETURN 'Long transactions support disabled';
END;
$$;


--
-- TOC entry 837 (class 1255 OID 207442)
-- Dependencies: 2189 23 2189
-- Name: disjoint(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION disjoint(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'disjoint';


--
-- TOC entry 838 (class 1255 OID 207443)
-- Dependencies: 23 2189 2189
-- Name: distance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION distance(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_mindistance2d';


--
-- TOC entry 839 (class 1255 OID 207444)
-- Dependencies: 2189 2189 23
-- Name: distance_sphere(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION distance_sphere(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_distance_sphere';


--
-- TOC entry 840 (class 1255 OID 207445)
-- Dependencies: 2189 2189 23 2212
-- Name: distance_spheroid(geometry, geometry, spheroid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION distance_spheroid(geometry, geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_distance_ellipsoid';


--
-- TOC entry 841 (class 1255 OID 207446)
-- Dependencies: 2189 23 2189
-- Name: dropbbox(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dropbbox(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dropBBOX';


--
-- TOC entry 842 (class 1255 OID 207447)
-- Dependencies: 3246 23
-- Name: dropgeometrycolumn(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dropgeometrycolumn(character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$;


--
-- TOC entry 843 (class 1255 OID 207448)
-- Dependencies: 23 3246
-- Name: dropgeometrycolumn(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dropgeometrycolumn(character varying, character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;


--
-- TOC entry 844 (class 1255 OID 207449)
-- Dependencies: 3246 23
-- Name: dropgeometrycolumn(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dropgeometrycolumn(character varying, character varying, character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	catalog_name alias for $1;
	schema_name alias for $2;
	table_name alias for $3;
	column_name alias for $4;
	myrec RECORD;
	okay boolean;
	real_schema name;

BEGIN


	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = 'f';

		FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := 't';
		END LOOP;

		IF ( okay <> 't' ) THEN
			RAISE NOTICE 'Invalid schema name - using current_schema()';
			SELECT current_schema() into real_schema;
		ELSE
			real_schema = schema_name;
		END IF;
	ELSE
		SELECT current_schema() into real_schema;
	END IF;

	-- Find out if the column is in the geometry_columns table
	okay = 'f';
	FOR myrec IN SELECT * from geometry_columns where f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := 't';
	END LOOP;
	IF (okay <> 't') THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
		RETURN 'f';
	END IF;

	-- Remove ref from geometry_columns table
	EXECUTE 'delete from geometry_columns where f_table_schema = ' ||
		quote_literal(real_schema) || ' and f_table_name = ' ||
		quote_literal(table_name)  || ' and f_geometry_column = ' ||
		quote_literal(column_name);

	-- Remove table column
	EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) || '.' ||
		quote_ident(table_name) || ' DROP COLUMN ' ||
		quote_ident(column_name);

	RETURN real_schema || '.' || table_name || '.' || column_name ||' effectively removed.';

END;
$_$;


--
-- TOC entry 845 (class 1255 OID 207450)
-- Dependencies: 23
-- Name: dropgeometrytable(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dropgeometrytable(character varying) RETURNS text
    LANGUAGE sql STRICT
    AS $_$ SELECT DropGeometryTable('','',$1) $_$;


--
-- TOC entry 846 (class 1255 OID 207451)
-- Dependencies: 23
-- Name: dropgeometrytable(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dropgeometrytable(character varying, character varying) RETURNS text
    LANGUAGE sql STRICT
    AS $_$ SELECT DropGeometryTable('',$1,$2) $_$;


--
-- TOC entry 847 (class 1255 OID 207452)
-- Dependencies: 23 3246
-- Name: dropgeometrytable(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dropgeometrytable(character varying, character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	catalog_name alias for $1;
	schema_name alias for $2;
	table_name alias for $3;
	real_schema name;

BEGIN

	IF ( schema_name = '' ) THEN
		SELECT current_schema() into real_schema;
	ELSE
		real_schema = schema_name;
	END IF;

	-- Remove refs from geometry_columns table
	EXECUTE 'DELETE FROM geometry_columns WHERE ' ||
		'f_table_schema = ' || quote_literal(real_schema) ||
		' AND ' ||
		' f_table_name = ' || quote_literal(table_name);

	-- Remove table
	EXECUTE 'DROP TABLE '
		|| quote_ident(real_schema) || '.' ||
		quote_ident(table_name);

	RETURN
		real_schema || '.' ||
		table_name ||' dropped.';

END;
$_$;


--
-- TOC entry 848 (class 1255 OID 207453)
-- Dependencies: 2193 2189 23
-- Name: dump(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dump(geometry) RETURNS SETOF geometry_dump
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dump';


--
-- TOC entry 851 (class 1255 OID 207454)
-- Dependencies: 2193 23 2189
-- Name: dumprings(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION dumprings(geometry) RETURNS SETOF geometry_dump
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dump_rings';


--
-- TOC entry 852 (class 1255 OID 207455)
-- Dependencies: 3246 23
-- Name: enablelongtransactions(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION enablelongtransactions() RETURNS text
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	"query" text;
	exists bool;
	rec RECORD;

BEGIN

	exists = 'f';
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table'
	LOOP
		exists = 't';
	END LOOP;

	IF NOT exists
	THEN
		"query" = 'CREATE TABLE authorization_table (
			toid oid, -- table oid
			rid text, -- row id
			expires timestamp,
			authid text
		)';
		EXECUTE "query";
	END IF;

	exists = 'f';
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		exists = 't';
	END LOOP;

	IF NOT exists THEN
		"query" = 'CREATE VIEW authorized_tables AS ' ||
			'SELECT ' ||
			'n.nspname as schema, ' ||
			'c.relname as table, trim(' ||
			quote_literal(chr(92) || '000') ||
			' from t.tgargs) as id_column ' ||
			'FROM pg_trigger t, pg_class c, pg_proc p ' ||
			', pg_namespace n ' ||
			'WHERE p.proname = ' || quote_literal('checkauthtrigger') ||
			' AND c.relnamespace = n.oid' ||
			' AND t.tgfoid = p.oid and t.tgrelid = c.oid';
		EXECUTE "query";
	END IF;

	RETURN 'Long transactions support enabled';
END;
$$;


--
-- TOC entry 853 (class 1255 OID 207456)
-- Dependencies: 2189 2189 23
-- Name: endpoint(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION endpoint(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_endpoint_linestring';


--
-- TOC entry 854 (class 1255 OID 207457)
-- Dependencies: 23 2189 2189
-- Name: envelope(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION envelope(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_envelope';


--
-- TOC entry 855 (class 1255 OID 207458)
-- Dependencies: 2189 23 2189
-- Name: equals(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION equals(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geomequals';


--
-- TOC entry 856 (class 1255 OID 207459)
-- Dependencies: 2160 23
-- Name: estimated_extent(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION estimated_extent(text, text) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT SECURITY DEFINER
    AS '$libdir/postgis-1.5', 'LWGEOM_estimated_extent';


--
-- TOC entry 857 (class 1255 OID 207460)
-- Dependencies: 2160 23
-- Name: estimated_extent(text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION estimated_extent(text, text, text) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT SECURITY DEFINER
    AS '$libdir/postgis-1.5', 'LWGEOM_estimated_extent';


--
-- TOC entry 858 (class 1255 OID 207461)
-- Dependencies: 3247 23
-- Name: existe_archivo(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION existe_archivo(archivo text) RETURNS boolean
    LANGUAGE plpythonu
    AS $$
    import os
    return os.path.exists(archivo)
$$;


--
-- TOC entry 859 (class 1255 OID 207462)
-- Dependencies: 2164 2164 23
-- Name: expand(box3d, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION expand(box3d, double precision) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_expand';


--
-- TOC entry 860 (class 1255 OID 207463)
-- Dependencies: 23 2160 2160
-- Name: expand(box2d, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION expand(box2d, double precision) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_expand';


--
-- TOC entry 861 (class 1255 OID 207464)
-- Dependencies: 2189 2189 23
-- Name: expand(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION expand(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_expand';


--
-- TOC entry 862 (class 1255 OID 207465)
-- Dependencies: 2189 23 2189
-- Name: exteriorring(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION exteriorring(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_exteriorring_polygon';


--
-- TOC entry 885 (class 1255 OID 207466)
-- Dependencies: 3246 23
-- Name: f1(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f1() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
a integer;
v_mensaje_error text;
v_resp varchar[];
v_nombre_funcion varchar;
v_msg varchar;
BEGIN
v_nombre_funcion='public.f1';
raise exception 'error forzado';
  a= 5/0;
  return a::varchar;
EXCEPTION
WHEN OTHERS THEN
	v_msg = f_agrega_clave(v_msg,'mensaje',SQLERRM);	
  	v_msg = f_agrega_clave(v_msg,'codigo_error',SQLSTATE);
  	v_msg = f_agrega_clave(v_msg,'procedimientos',v_nombre_funcion);
  	raise exception '%',v_msg; 
END;
$$;


--
-- TOC entry 1038 (class 1255 OID 207467)
-- Dependencies: 23 3246
-- Name: f_agrega_clave(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_agrega_clave(p_cad character varying, p_clave character varying, p_valor character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_agrega_clave
 DESCRIPCION:   Anade un parametro de respuesta a la cadena que se va a devolver al servidor
                Web
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE
v_cad_ini varchar;
    v_cad_fin varchar;
    v_cad_ini_fin varchar;
    v_cad_fin_fin varchar;
    v_resp varchar;
    v_cadena varchar;
    v_aux varchar;
    v_clave varchar;
    v_valor varchar;
BEGIN

--RCM: 22/03/2011 Verifica los parámetros para prevenir que vengan nulos. Si es así se hace un coalesce para evitar problemas en concatenación
    v_clave = COALESCE(p_clave,'indefinido');
    v_valor = COALESCE(p_valor,'');
    
    --Para hacer el trim se verifica que no sea cadena vacía porque hay un bug que al aplicar trim sobre la cadena vacía aparentemente lo vuelve null
    if v_valor != '' then
        v_valor = trim(p_valor);
    end if;


--Inicialización de constantes
v_cad_ini = '<';
    v_cad_fin = '>';
    v_cad_ini_fin = '</'||v_clave;
    v_cad_fin_fin = '>';
    
    /*v_cad_ini = '';
    v_cad_fin = ':';
    v_cad_ini_fin = '';
    v_cad_fin_fin = ',';*/
    
    --Se vacía la cadena en variables locales
    v_cadena=COALESCE(p_cad,'');

    --Verifica si la clave es mensaje y si ya fue serializada para no volver a serializar
    if v_clave = 'mensaje' then
    --raise notice 'substr: %     v_cad_ini: %  v_valor: %',substr(ltrim(v_cadena),1,1),v_cad_ini,v_valor;
     if substr(ltrim(v_valor),1,1) = v_cad_ini then
         return v_valor;
        end if;
    end if;
    
    --Verifica si ya esta registrado el 'codigo_error'
    if v_clave = 'codigo_error' then
     if f_obtiene_clave_valor(v_cadena,v_clave,'','','valor') <> '' then
         return p_cad;
        end if;
    end if;
    
    --Verifica si ya se registro el codigo procedimiento
    if v_clave = 'procedimientos' then
     if f_obtiene_clave_valor(v_cadena,v_clave,'','','valor') <> '' then
         v_aux =f_obtiene_clave_valor(v_cadena,v_clave,v_valor,'unir','');
         return v_aux;
        end if;
    end if;
    
    --Arma la rama
    v_aux = v_cad_ini || v_clave ||v_cad_fin || replace(v_valor,'"','') || v_cad_ini_fin || v_cad_fin_fin;
    
    --Agregar la rama
    v_cadena = v_cadena || v_aux;
    --Devolver respuesta    
    return v_cadena;
  
END;
$$;


--
-- TOC entry 1039 (class 1255 OID 207468)
-- Dependencies: 23 3246
-- Name: f_agrega_clave_multiple(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_agrega_clave_multiple(p_cad character varying, p_claves character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_agrega_clave_multiple
 DESCRIPCION:   Anade varios parametros de respuesta a la cadena que se va a devolver al servidor
                Web
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE
	v_cad_ini varchar;
    v_cad_fin varchar;
    v_cad_ini_fin varchar;
    v_cad_fin_fin varchar;
    v_resp varchar;
    v_cadena varchar;
    v_aux varchar;
    v_claves varchar;
    v_sw boolean;
    v_pos_ini integer;
    v_pos_fin integer;
    v_clave varchar;
    v_pos_aux integer;
BEGIN
	--Inicializa variables
	v_cad_ini = '<';
	v_cad_fin = '>';
	v_cad_ini_fin = '</';
	v_cad_fin_fin = '>';
	v_sw=true;

	--Inicializa la cadena
	v_cadena = p_cad;
	v_claves = p_claves;
	--raise exception 'HOLA: %',v_claves;

	--Recorre todas las claves 
	LOOP
		if substr(ltrim(v_claves),1,1) = v_cad_ini then
			v_pos_ini=1;
			--Ubica el primer v_cad_fin
			v_pos_fin=position(v_cad_fin in v_claves);
			--Obtiene la cadena entre v_cad_ini y v_cad_fin
			v_clave = substr(v_claves,v_pos_ini+1,v_pos_fin-v_pos_ini-1);
			--raise exception 'FFF:%',v_clave;
			--Obtiene el valor de la clave
			v_cadena = f_agrega_clave(v_cadena,v_clave,f_obtiene_clave_valor(p_claves,v_clave,'','','valor'));
			--Corta la cadena de claves
			v_aux=v_cad_ini_fin||v_clave||v_cad_fin_fin;
			v_pos_aux = position(v_aux in v_claves);
			--raise exception '%',v_pos_aux;
			
			v_claves = substr(v_claves,v_pos_aux+length(v_aux),length(v_claves));
			--raise exception '%',v_claves;
		else
			exit;
		end if;

	END LOOP;
    --Devolver respuesta    
    return v_cadena;
  
END;
$$;


--
-- TOC entry 1040 (class 1255 OID 207469)
-- Dependencies: 23 3246
-- Name: f_array_p(character varying[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_array_p(p_array character varying[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

	i integer;
    j integer;

BEGIN
--j=array_length(p_array);
 for i in 1..array_upper(p_array,1) loop
 	raise notice '%', p_array[i];
 end loop;
return 'bien';
END;
$$;


--
-- TOC entry 907 (class 1255 OID 207470)
-- Dependencies: 3246 23
-- Name: f_array_ubicar_clave(character varying[], character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_array_ubicar_clave(p_array character varying[], p_clave character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_ubicar_clave
 DESCRIPCION:   
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE
	i integer;
  	v_valor varchar;
  	v_array varchar[];
    v_tam integer;
BEGIN
	v_valor='_false';
    v_array=p_array;
    v_tam=COALESCE(array_upper(p_array,1),0);
    
	for i in 1..v_tam loop
       	if p_array[i][1]=p_clave then
        	v_valor=p_array[i][2];
            return v_valor;
        end if;
    end loop;
	return v_valor;
/*EXCEPTION
WHEN OTHERS THEN
  return '_false';*/
END;
$$;


--
-- TOC entry 919 (class 1255 OID 207471)
-- Dependencies: 23 3246
-- Name: f_array_ubicar_clave_posicion(character varying[], character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_array_ubicar_clave_posicion(p_array character varying[], p_clave character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_ubicar_clave_posicion
 DESCRIPCION:
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE
	i integer;
  	v_valor integer;
  	v_array varchar[];
    v_tam integer;
BEGIN
	v_valor=-1;
    v_array=p_array;
    v_tam=COALESCE(array_upper(p_array,1),0);
    
	for i in 1..v_tam loop
       	if p_array[i][1]=p_clave then
        	v_valor=i;
            return v_valor;
        end if;
    end loop;
	return v_valor;
/*EXCEPTION
WHEN OTHERS THEN
  return '_false';*/
END;
$$;


--
-- TOC entry 945 (class 1255 OID 207472)
-- Dependencies: 3246 23
-- Name: f_campo_constraint(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_campo_constraint(descripcion text, tipo integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
  inicio	integer;
  fin 		integer;
  cadena	text;
BEGIN
  if(tipo=1)then	
  inicio=strpos(descripcion,'REFERENCES');
  cadena=SUBSTRING(descripcion,inicio);
  inicio=strpos(cadena,'(');
  fin=strpos(cadena,')');
  cadena=SUBSTRING(cadena,inicio+1,fin-inicio-1);
  return cadena;
  elsif(tipo=0)then
  inicio=strpos(descripcion,'REFERENCES');
  cadena=SUBSTRING(descripcion,inicio);
  inicio=strpos(cadena,'.');
  fin=strpos(cadena,'(');
  cadena=SUBSTRING(cadena,inicio+1,fin-inicio-1);
  return cadena;
  else
  inicio=strpos(descripcion,'(');
  fin=strpos(descripcion,')');
  cadena=SUBSTRING(descripcion,inicio+1,fin-inicio-1);
  --raise notice '%',descripcion;
  return cadena;
  end if;
END;
$$;


--
-- TOC entry 1062 (class 1255 OID 207473)
-- Dependencies: 23 3246
-- Name: f_convertir_num_a_letra(numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_convertir_num_a_letra(par_numero numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 documento: 	public.f_convertir_num_a_letra
 DESCRIPCION:   Funcion que convierte un numero a letra
 AUTOR: 	    KPLIAN	
 FECHA:	        06/06/2011
 COMENTARIOS:	
***************************************************************************/

declare

       ptotal  numeric;

       total numeric;
       total1 numeric;
       cent2  numeric;
       cent   numeric;
       cent1  char(2);
       mil    numeric;
       millon numeric;
       millones numeric;
       sav    numeric;
       unit   numeric;
       deci   numeric;
       centi  numeric;
       factor numeric;
       sav1   numeric;
       depesos numeric;
       lletra  varchar;
       letras varchar;

       begin
            ptotal:=par_numero;
            total := ptotal;

            total1:= total;
            total := trunc(total);
            cent2 := total1 - total;
            cent  := cent2*100;
            cent1 := '0';

                  if (total=0) then
                     lletra := 'CERO';
                     cent1:=cast(cent as char(2));
                     return 'CERO  ,'||cent1||'/100 ';
                  end if;

                  mil:=0;
                  millon:=0;
                  millones:=0;
                  depesos:=0;
                  sav:=1;
                  unit:=1;
                  deci:=1;
                  centi:=1;
                  factor:=1;
                  sav1:=1;
                  letras:='';

                            while (total > 0) loop
                                if (total > 1999999) then
                                   depesos  := 1;
                                   factor   := 1000000;
                                   millones := 1;
                                   millon   := 0;
                                else
                                   if (total > 999999) then
                                      depesos := 1;
                                      factor  := 1000000;
                                      millon  := 1;
                                   else
                                       if (total > 999) then
                                          factor := 1000;
                                          mil    := 1;
                                       else
                                          factor := 1;
                                          mil := 0;
                                       end if;
                                   end if;
                                end if;

                                sav := total;

                                total := trunc(total/factor);
                                sav  := sav-(total*factor);
                                if (sav=0) then
                                   depesos := 0;
                                end if;

                                centi:=TRUNC(total/100);

                                if centi = 0 then
                                   letras := rtrim(letras)||'';
                                end if;
                                if centi = 1 then
                                   if total = 100 then
                                      letras := rtrim(letras)|| ' CIEN';
                                   else
                                       letras := rtrim(letras)||' CIENTO';
                                   end if;
                                end if;
                                if centi = 2 then
                                   letras := rtrim(letras)||' DOSCIENTOS';
                                end if;
                                if centi = 3 then
                                   letras := rtrim(letras)||' TRESCIENTOS';
                                end if;
                                if centi = 4 then
                                   letras := rtrim(letras)||' CUATROCIENTOS';
                                end if;
                                if centi = 5 then
                                   letras := rtrim(letras)||' QUINIENTOS';
                                end if;
                                if centi = 6 then
                                   letras := rtrim(letras)||' SEISCIENTOS';
                                end if;
                                if centi = 7 then
                                   letras := rtrim(letras)||' SETECIENTOS';
                                end if;
                                if centi = 8 then
                                   letras := rtrim(letras)||' OCHOCIENTOS';
                                end if;
                                if centi = 9 then
                                   letras := rtrim(letras)||' NOVECIENTOS';
                                end if;

                                total:=total - (centi*100);
                                deci :=trunc(total/10);
                                unit :=total-(deci*10);

                                if total >= 30 then
                                   if deci = 3 then
                                      letras := rtrim(letras)||' TREINTA';
                                   end if;
                                   if deci = 4 then
                                      letras := rtrim(letras)||' CUARENTA';
                                   end if;
                                   if deci = 5 then
                                      letras := rtrim(letras)||' CINCUENTA';
                                   end if;
                                   if deci = 6 then
                                      letras := rtrim(letras)||' SESENTA';
                                   end if;
                                   if deci = 7 then
                                      letras := rtrim(letras)||' SETENTA';
                                   end if;
                                   if deci = 8 then
                                      letras := rtrim(letras)||' OCHENTA';
                                   end if;
                                   if deci = 9 then
                                      letras := rtrim(letras)||' NOVENTA';
                                   end if;
                                   if unit > 0 then
                                      letras := rtrim(letras)||' Y';
                                   end if;
                                else
                                    unit := total;
                                end if;

                                if unit = 0 then
                                   letras := rtrim(letras)||'';
                                end if;
                                if unit = 1 then
                                   letras := rtrim(letras)||' UN';
                                end if;
                                if unit = 2 then
                                   letras := rtrim(letras)||' DOS';
                                end if;
                                if unit = 3 then
                                   letras := rtrim(letras)||' TRES';
                                end if;
                                if unit = 4 then
                                   letras := rtrim(letras)||' CUATRO';
                                end if;
                                if unit = 5 then
                                   letras := rtrim(letras)||' CINCO';
                                end if;
                                if unit = 6 then
                                   letras := rtrim(letras)||' SEIS';
                                end if;
                                if unit = 7 then
                                   letras := rtrim(letras)||' SIETE';
                                end if;
                                if unit = 8 then
                                   letras := rtrim(letras)||' OCHO';
                                end if;
                                if unit = 9 then
                                   letras := rtrim(letras)||' NUEVE';
                                end if;
                                if unit = 10 then
                                   letras := rtrim(letras)||' DIEZ';
                                end if;
                                if unit = 11 then
                                   letras := rtrim(letras)||' ONCE';
                                end if;
                                if unit = 12 then
                                   letras := rtrim(letras)||' DOCE';
                                end if;
                                if unit = 13 then
                                   letras := rtrim(letras)||' TRECE';
                                end if;
                                if unit = 14 then
                                   letras := rtrim(letras)||' CATORCE';
                                end if;
                                if unit = 15 then
                                   letras := rtrim(letras)||' QUINCE';
                                end if;
                                if unit = 16 then
                                   letras := rtrim(letras)||' DIECISEIS';
                                end if;
                                if unit = 17 then
                                   letras := rtrim(letras)||' DIECISIETE';
                                end if;
                                if unit = 18 then
                                   letras := rtrim(letras)||' DIECIOCHO';
                                end if;
                                if unit = 19 then
                                   letras := rtrim(letras)||' DIECINUEVE';
                                end if;
                                if unit = 20 then
                                   letras := rtrim(letras)||' VEINTE';
                                end if;
                                if unit = 21 then
                                   letras := rtrim(letras)||' VEINTIUNO';
                                end if;
                                if unit = 22 then
                                   letras := rtrim(letras)||' VEINTIDOS';
                                end if;
                                if unit = 23 then
                                   letras := rtrim(letras)||' VEINTITRES';
                                end if;
                                if unit = 24 then
                                   letras := rtrim(letras)||' VEINTICUATRO';
                                end if;
                                if unit = 25 then
                                   letras := rtrim(letras)||' VEINTICINCO';
                                end if;
                                if unit = 26 then
                                   letras := rtrim(letras)||' VEINTISEIS';
                                end if;
                                if unit = 27 then
                                   letras := rtrim(letras)||' VEINTISIETE';
                                end if;
                                if unit = 28 then
                                   letras := rtrim(letras)||' VEINTIOCHO';
                                end if;
                                if unit = 29 then
                                   letras := rtrim(letras)||' VEINTINUEVE';
                                end if;
                                if millones=1 then
                                   letras := rtrim(letras)||' MILLONES';
                                   millones := 0;
                                else
                                    if millon=1 then
                                       letras := rtrim(letras)||' MILLON';
                                       millon := 0;
                                    else
                                        if mil=1 then
                                           letras := rtrim(letras)||' MIL';
                                           mil := 0;
                                        end if;
                                    end if;
                                end if;
                                total:=sav;
  end loop;

  if cent=0 then
     cent1:='00';
  else
     if cent <10
     THEN
     raise notice '%',cent;
     cent1:= '0'||cast(cent as char(1));
	ELSE
     cent1:=cast(cent as char(2));
     END IF;
  end if;
  if depesos=1 then
     letras := rtrim(letras)||' ,'||cent1||'/100 ';
  else
     letras := rtrim(letras)||' ,'||cent1||'/100 ';
  end if;

--  lletra := '('||ltrim(letras)||')';
    lletra := ltrim(letras);

return lletra;
end
$$;


--
-- TOC entry 1063 (class 1255 OID 207474)
-- Dependencies: 3246 23
-- Name: f_copy(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_copy(pm_nombre_tabla character varying, pm_ruta_archivo character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  g_respuesta	varchar;
BEGIN
     EXECUTE ('COPY '||pm_nombre_tabla||' FROM '''||pm_ruta_archivo||''' DELIMITER '','';'); 
     g_respuesta='si';
     RETURN g_respuesta;
END;
$$;


--
-- TOC entry 1064 (class 1255 OID 207475)
-- Dependencies: 23 3246
-- Name: f_dblink(character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_dblink(p_host character varying, p_puerto character varying, p_dbname character varying, p_user character varying, p_password character varying, p_sql character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA ENDESIS 
***************************************************************************
 SCRIPT: 		f_dblink
 DESCRIPCIÓN: 	Permite ejecutar una instrucción sql en otro servidor de base de datos con dblink
 AUTOR: 		RCM
 FECHA:			23/03/2012
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/
--------------------------
-- CUERPO DE LA FUNCIÓN --
--------------------------


--**** DECLARACION DE VARIABLES DE LA FUNCIÓN (LOCALES) ****---
DECLARE

	v_respuesta varchar;
    v_cadena_cnx varchar;

BEGIN

	--Verifica que los parámetros enviados ninguno sea nulo
    if coalesce(p_host,'')='' or coalesce(p_puerto,'')='' or coalesce(p_dbname,'')='' or coalesce(p_password,'')='' or coalesce(p_sql,'')='' then
    	raise exception 'No se puede realizar la conexión con el host destino: parámetros inválidos, ningún parámetro debe ser nulo o vacío';
    end if;
    
	--Forma la cadena de conexión
    v_cadena_cnx = 'hostaddr='||p_host||' port='||p_puerto||' dbname='||p_dbname||' user='||p_user||' password='||p_password;
      -- raise exception 'cadena%',p_sql;
    --Ejecuta el dblink
    v_respuesta = dblink_exec(v_cadena_cnx,p_sql);
     
	--Devuelve la respuesta
    return v_respuesta;    

END;
$$;


--
-- TOC entry 1065 (class 1255 OID 207476)
-- Dependencies: 23 3246
-- Name: f_ejecutar_dblink(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_ejecutar_dblink(p_cadena character varying, p_opcion character varying) RETURNS record
    LANGUAGE plpgsql STRICT SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: public.f_ejecutar_dblink
 DESCRIPCIÓN: Guarda la sesion o el log mediante un dblink, la cadena
                indica los parametros que se van a guardar
 AUTOR:         KPLIAN(jrr)
 FECHA:
 COMENTARIOS:


***************************************************************************
 HISTORIA DE MODIFICACIONES:
 DESCRIPCION: se vuelve dinámico el usuario de base de datos con el que se conecta el dblink (linea 31 a la 34)
 AUTOR: KPLIAN(rcm)
 FECHA: 24-03-2011
***************************************************************************
*/

DECLARE
    v_resp      record;
    v_res_cone  varchar;
    v_database  varchar;
    v_respuesta varchar;
    v_nombre_funcion   text;
    v_mensaje_error    text;
    v_usr_bd 		varchar;
BEGIN
    v_nombre_funcion='f_ejecutar_dblink';
    v_database=current_database();
    v_usr_bd=v_database||'_conexion';
    --RCM 24-03-2011: modificación a usuario de bd dinámico
    --v_res_cone=(select dblink_connect('user=bdweb_conexion dbname='||v_database));
    v_res_cone=(select dblink_connect('user=' || v_usr_bd ||' dbname='||v_database));
    --FIN RCM

    if(p_opcion='log')then
        SELECT * FROM
            dblink(
                'select * from f_registrar_log'||p_cadena,true)
            AS t1(id_log integer)
            into v_resp;
         
        v_res_cone=(select dblink_disconnect());
    elsif(p_opcion='sesion')then
        SELECT * FROM
            dblink(
                'select * from segu.f_actualizar_sesion'||p_cadena,true)
            AS t1(res varchar)
            into v_resp;
        
        v_res_cone=(select dblink_disconnect());
    end if;
    return v_resp;
EXCEPTION

      WHEN OTHERS THEN
      
    	v_respuesta = '';
		v_respuesta = f_agrega_clave(v_respuesta,'mensaje',SQLERRM);
    	v_respuesta = f_agrega_clave(v_respuesta,'codigo_error',SQLSTATE);
  		v_respuesta = f_agrega_clave(v_respuesta,'tipo_respuesta','ERROR'::varchar);
        v_respuesta = f_agrega_clave(v_respuesta,'procedimientos',v_nombre_funcion);

        --raise exception '%',v_respuesta;
        
        --RCM 31/01/2012: Cuando la llamada a esta funcion devuelve error, el manejador de excepciones de esa función da el resultado,
        --por lo que se modifica para que devuelva un json direcamente
		raise exception '%',f_resp_to_json(v_respuesta);
      
END;
$$;


--
-- TOC entry 1077 (class 1255 OID 207477)
-- Dependencies: 23 3246
-- Name: f_excel(bytea, character varying, character varying[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_excel(archivo bytea, tabla character varying, titulo character varying[]) RETURNS SETOF text[]
    LANGUAGE plpgsql
    AS $$
DECLARE
  cant_filas	integer; 	--la cantidad de filas del Excel original
  cant_cols		integer; 	--la cantidad de columnas del Excel original
  filas_titulo	integer;
  cols_titulo	integer;
  vector		text[]; 	--contiene las filas del excel
  registros		text[]; 	--contiene una fila de excel separada por comas
  fila			text[];
  i				numeric;	--indice del for para las filas
  j				numeric;	--indice del for para las columnas
  k				numeric;
  aux			text;		-- bytea sin codificacion
  v_consulta	varchar;	--consulta insert
  
BEGIN
 	
    aux := (select decode(archivo::text,'base64')); --se obtiene el bytea y se quita la codificación
        
    vector := string_to_array(aux,'\\015\\012'); --descomponer el bytea en un vector que contenga una fila del CSV cada uno
    											 --\\015\\012 --> ENTER o salto de linea/retorno de carro en el bytea	
	
    fila := string_to_array(vector[1],';');
    select array_upper(fila,1) into cols_titulo;
    
    for k in 1..cols_titulo loop
    	if(titulo[k] <> fila[k]) then
        	raise exception 'El orden de las columnas en el archivo CSV es incorrecto, utilice la Plantilla por favor';
        end if;
    end loop;
    
    select array_upper(vector,1) into cant_filas; --cantidad de registros del CSV
    
    for i in 2..(cant_filas-1) loop
      	
        v_consulta := 'insert into '||tabla||' values ('; --inicio de la consulta del insert

        registros := string_to_array(vector[i],';'); --descomponer cada fila para obtener las columnas del CSV
        select array_upper(registros,1) into cant_cols; --cantidad de columnas del CSV
        
        for j in 1..(cant_cols-1) loop
                        
            registros[j] := (select replace(registros[j]::text,',','.')); --reemplazar las comas por puntos
            v_consulta := v_consulta ||''''|| registros[j] || ''','; --continuar con la insercion hasta la columna N-1
                 	
        end loop;  
        
        v_consulta := v_consulta ||''''||  registros[cant_cols] || ''');'; --insertar la ultima columna 
        execute v_consulta; --ejecutar el insert
        
    end loop;
    
    return;
        
END;
$$;


--
-- TOC entry 1078 (class 1255 OID 207478)
-- Dependencies: 23 3246
-- Name: f_existe_parametro(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_existe_parametro(p_tabla character varying, p_parametro character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_existe_parametro
 DESCRIPCION:   devuelve true si existe el parametro en la tabla indicada y false si no existe
                Web
 AUTOR: 	    KPLIAN (jrr)	
 FECHA:	        09/08/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
 
 
 DECLARE
    v_nombre_funcion   	text;
    v_resp              varchar;
    v_respuesta         boolean;
 BEGIN
    v_nombre_funcion:='public.f_existe_parametro';
    v_respuesta=false;
    
    if(exists ( select 1
                from pg_class c
                inner join pg_catalog.pg_attribute a
                    on c.oid = a.attrelid
                where c.relname=p_tabla and a.attname ilike p_parametro))then
                
        v_respuesta=true;
    end if;
    
    return v_respuesta;
    
 EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1079 (class 1255 OID 207479)
-- Dependencies: 23 3246
-- Name: f_get_mensaje_err(character varying, text, text, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_get_mensaje_err(par_codigo_sql character varying, par_mensaje text, par_funcion text, par_transaccion character varying, par_linea character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_get_mensaje_err
 DESCRIPCION:
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
declare
       v_separador_error     varchar;
       v_separador_inicial   varchar;
       v_separador_funcion   varchar;
       v_mensaje_nuevo       text;

begin

     select valor into v_separador_inicial from public.variable_global vg where vg.variable='separador_inicial';
     select valor into v_separador_error from public.variable_global vg where vg.variable='separador_error';
     
     select valor into v_separador_funcion from public.variable_global vg where vg.variable='separador_funcion';

     if(split_part(par_mensaje,v_separador_error,3) ='')then

         v_mensaje_nuevo:=(v_separador_inicial||'f'||v_separador_error||par_codigo_sql||v_separador_error||coalesce(par_mensaje,' ')||v_separador_error||par_funcion)::text;
         --raise exception 'entra%',par_funcion;
         if(par_transaccion is not null)then
            v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_transaccion)::text;
         end if;
         if(par_linea is not null)then
            v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_linea)::text;
         end if;
     
     else
         v_mensaje_nuevo:=(coalesce(par_mensaje,'')||v_separador_funcion||par_funcion)::text;
         if(par_transaccion is not null)then
            v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_transaccion)::text;
         end if;
         if(par_linea is not null)then
            v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_linea)::text;
         end if;
     end if;

     return v_mensaje_nuevo;



end;
$$;


--
-- TOC entry 1080 (class 1255 OID 207480)
-- Dependencies: 23 3246
-- Name: f_get_mensaje_err2(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_get_mensaje_err2(p_procedimientos character varying, p_codigo_error character varying, p_mensaje_error character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_get_mensaje_err2
 DESCRIPCION:
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
declare
       v_separador_error     varchar;
       v_separador_inicial   varchar;
       v_separador_funcion   varchar;
       v_mensaje_nuevo       text;

begin

     select valor into v_separador_inicial from public.variable_global vg where vg.variable='separador_inicial';
     select valor into v_separador_error from public.variable_global vg where vg.variable='separador_error';
     
     select valor into v_separador_funcion from public.variable_global vg where vg.variable='separador_funcion';

     /*if(split_part(par_mensaje,v_separador_error,3) ='')then

         v_mensaje_nuevo:=(v_separador_inicial||'f'||v_separador_error||par_codigo_sql||v_separador_error||coalesce(par_mensaje,' ')||v_separador_error||par_funcion)::text;
         --raise exception 'entra%',par_funcion;
         if(par_transaccion is not null)then
            v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_transaccion)::text;
         end if;
         if(par_linea is not null)then
            v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_linea)::text;
         end if;
     
     else
         v_mensaje_nuevo:=(coalesce(par_mensaje,'')||v_separador_funcion||par_funcion)::text;
         if(par_transaccion is not null)then
            v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_transaccion)::text;
         end if;
         if(par_linea is not null)then
            v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_linea)::text;
         end if;
     end if;*/
     
     
     v_mensaje_nuevo = p_procedimientos || v_separador_error || p_codigo_error || v_separador_error || p_mensaje_error;

     return v_mensaje_nuevo;



end;
$$;


--
-- TOC entry 1090 (class 1255 OID 207481)
-- Dependencies: 23 3246
-- Name: f_get_mensaje_exi(text, text, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_get_mensaje_exi(par_mensaje text, par_funcion text, par_transaccion character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_get_mensaje_exi
 DESCRIPCION:
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
declare
       v_separador_error     varchar;
       v_separador_inicial   varchar;
       v_separador_funcion   varchar;
       v_mensaje_nuevo       text;

begin
     select valor into v_separador_inicial from public.variable_global vg where vg.variable='separador_inicial';
     select valor into v_separador_error from public.variable_global vg where vg.variable='separador_error';

     select valor into v_separador_funcion from public.variable_global vg where vg.variable='separador_funcion';

     v_mensaje_nuevo:=(v_separador_inicial||'t'||v_separador_error||'0'||v_separador_error||coalesce(par_mensaje,'')||v_separador_error||par_funcion)::text;
     if(par_transaccion is not null)then
         v_mensaje_nuevo:=(v_mensaje_nuevo||v_separador_error||par_transaccion)::text;
     end if;
     
    return v_mensaje_nuevo;



end;
$$;


--
-- TOC entry 1091 (class 1255 OID 207482)
-- Dependencies: 23 3246
-- Name: f_get_parametro(character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_get_parametro(p_tabla character varying, p_parametro character varying) RETURNS character varying
    LANGUAGE plpgsql COST 16
    AS $$
/**************************************************************************
 FUNCION: 		public.f_get_parametro
 DESCRIPCION:   devuelve el en varchar del parametros si existe
 				
                Web
 AUTOR: 	    KPLIAN (rac)	
 FECHA:	        09/08/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
 
 
 DECLARE
    v_nombre_funcion   	text;
    v_resp              varchar;
    v_respuesta         varchar;
    v_record record;
    v_consulta varchar;
 BEGIN
    v_nombre_funcion:='public.f_get_parametro';
    v_respuesta='NULL';
    
  v_consulta='select ('||p_parametro||')::varchar as resp  from '||p_tabla||' limit 1';
  
  raise notice 'get_parametro %',v_consulta;
                
      FOR  v_record in execute(v_consulta) LOOP
        
        v_respuesta = (v_record.resp);
        
      END LOOP;

   
    
    return coalesce(v_respuesta,'NULL');
    
    
 EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1092 (class 1255 OID 207483)
-- Dependencies: 23 3246
-- Name: f_get_parametro_by_id(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_get_parametro_by_id(p_tabla character varying, p_parametro character varying, p_id character varying) RETURNS character varying
    LANGUAGE plpgsql COST 16
    AS $$
/**************************************************************************
 FUNCION: 		public.f_get_parametro_by_id
 DESCRIPCION:   devuelve el en varchar del parametros si existe
 				
                Web
 AUTOR: 	    KPLIAN (rac)	
 FECHA:	        09/08/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
 
 
 DECLARE
    v_nombre_funcion   	text;
    v_resp              varchar;
    v_respuesta         varchar;
    v_record record;
    v_consulta varchar;
 BEGIN
    v_nombre_funcion:='public.f_get_parametro_by_id';
    v_respuesta='NULL';
    
  v_consulta='select ('||p_parametro||')::varchar as resp  from '||p_tabla||' WHERE '||p_id;
  
  raise notice 'get_parametro %',v_consulta;
                
      FOR  v_record in execute(v_consulta) LOOP
        
        v_respuesta = (v_record.resp);
        
      END LOOP;

   
    
    return coalesce(v_respuesta,'NULL');
    
    
 EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1093 (class 1255 OID 207484)
-- Dependencies: 23 3246
-- Name: f_get_record(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_get_record(tabla character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_get_record
 DESCRIPCION:   Obtiene el record de la tabla temporal insertada en la funcion
                DBIntermediario
 AUTOR: 	    KPLIAN (jrr)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE

v_parametros                record;
v_consulta                  varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

BEGIN
     v_nombre_funcion:='public.f_get_record';

    v_consulta:= 'select * from '||tabla||' limit 1';
    
    execute v_consulta into v_parametros;
    return v_parametros;
    
EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;

END;
$$;


--
-- TOC entry 1103 (class 1255 OID 207485)
-- Dependencies: 23 3246
-- Name: f_get_variable_global(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_get_variable_global(p_parametro character varying) RETURNS character varying
    LANGUAGE plpgsql COST 16
    AS $$
/**************************************************************************
 FUNCION: 		public.f_get_variable_global
 DESCRIPCION:   devuelve el en varchar de la variable señalada 
 				en la tabla de varialbes globales
 				
                Web
 AUTOR: 	    KPLIAN (rac)	
 FECHA:	        09/08/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
 
 
 DECLARE
    v_nombre_funcion   	text;
    v_resp              varchar;
    v_respuesta         varchar;
    v_record record;
    v_consulta varchar;
 BEGIN
    v_nombre_funcion:='public.f_get_variable_global';
    v_respuesta='NULL';
    
  v_consulta='select valor as resp from public.variable_global v where v.variable='''||p_parametro||''' limit 1';
  
   raise notice 'get_parametro %',v_consulta;
                
      FOR  v_record in execute(v_consulta) LOOP
        
        v_respuesta = (v_record.resp);
        
      END LOOP;
      
     IF  v_respuesta is NULL THEN
      
      raise exception  'NO EXISTE UN VALOR PARA LA VARIABLE GLOBAL %',p_parametro;
     
     END IF;

   
    
    return coalesce(v_respuesta,'NULL');
    
    
 EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1104 (class 1255 OID 207486)
-- Dependencies: 3246 23
-- Name: f_iif(boolean, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_iif(condicion boolean, op1 character varying, op2 character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_iif
 DESCRIPCION:   Si la condicion es verdadera devuelve laop1 sino devuelve op2
 AUTOR: 	    KPLIAN (jrr)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
BEGIN
if(condicion) then
return op1;
else
return op2;
end if;
END;
$$;


--
-- TOC entry 1105 (class 1255 OID 207487)
-- Dependencies: 23 3246
-- Name: f_intermediario_ime(integer, character varying, integer, character varying, macaddr, character varying, character varying, integer, character varying, character varying[], character varying[], character varying[], character varying[], character varying, bytea, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_intermediario_ime(par_id_usuario integer, par_sid_web character varying, par_pid_web integer, par_ip character varying, par_mac macaddr, par_procedimiento character varying, par_transaccion character varying, par_id_categoria integer, es_matriz character varying, ip_admin character varying[], variables character varying[], valores character varying[], tipos character varying[], par_consulta character varying, par_files bytea, variable_files character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_intermediario_ime
 DESCRIPCIÃ“N: 	Recibe las peticiones del servidor web y las encamina 
  				hacia el procedimiento almacenado correspondiente
 AUTOR: 		KPLIAN(jrr)
 FECHA:			26/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:
 DESCRIPCION:	Revison y documentacion
 AUTOR:			 KPLIAN(rac)
 FECHA:			 26-11-10
***************************************************************************
 DESCRIPCION:	Valida si el usuario tiene permiso para ejecutar la transaccion
 AUTOR:			 KPLIAN(rac)
 FECHA:			 29-11-10
***************************************************************************
 DESCRIPCION:	Agregar array de direcciones IP para uso administrativo
 AUTOR:			 KPLIAN(rac)
 FECHA:			 25-12-10
**************************************************************************
DESCRIPCION:	Cuando campo tipo date viene vacio lo convierte en null
 AUTOR:			 KPLIAN(rac)
 FECHA:			 12/09/2011
***************************************************************************
DESCRIPCION:	Se introduce funcion  f_get_id_usuario  para aginarle persmisos de ejecucion
				del dueño de la funciona para no asginar permisos directos sobre la tabal
                tusuario por motivos de seguridad
 AUTOR:			 KPLIAN(rac)
 FECHA:			 29/02/2012
***************************************************************************
 */


DECLARE
 
    v_consulta          varchar;
    v_secuencia         integer;
    v_tamano            integer;
    v_retorno           varchar;
    v_mensaje           text;
    v_nombre_funcion    text;
    v_id_log       		integer;
    v_administrador     integer;
    v_valores_array     varchar[];
    v_tamano_matriz     integer;
    v_linea             varchar;
    v_resp				varchar;
    v_tiene_permisos    boolean;
    v_habilitar_log     integer;
    v_administrador_bool boolean;
    v_hora_ini          timestamp;
    v_hora_fin          timestamp;
    v_nivel_error        integer;
    v_tipo_error        varchar;
    v_id_usuario        integer;
    v_id_subsistema     integer;
    v_resp_error        record;
    v_upload_file        boolean;
    v_uf_count integer;
    
    --1 tipo: ERROR|EXITO
    --2 codigo_error: P0001
    --3 procedimientos: funciones
    --4 id_log
    --5 mensaje
    --6 ...
    --7 ..
    
    
    --TODO: falta concatenar procedimientos y eliminar los codigos de procedimientos

BEGIN

 --raise exception 'aaa  ';
    
    v_nombre_funcion:='public.f_intermediario_ime';
    v_nivel_error=2;
    v_hora_ini = clock_timestamp();
    
    v_linea=null;
    v_secuencia:=(nextval('parametro'));
    v_resp=f_runtime_config('LOG_STATEMENT','LOCAL','none');
    
    v_resp_error=f_ejecutar_dblink('('||pg_backend_pid()::varchar||',
            '''||par_sid_web||''','||par_pid_web||','''||par_transaccion||''','''||par_procedimiento||''')'
            ,'sesion');
       
    if(par_transaccion='SEG_VALUSU_SEG')then
       
        v_id_usuario:= segu.f_get_id_usuario(valores[6]);

    else
           
        v_id_usuario=par_id_usuario;
    
    end if;
    
    
   
    
    --1) verifica si es administrador, si tiene permisos y si habilita el log
       v_administrador = 0;
       
       v_nivel_error=0;
       v_resp=f_validar_bloqueos(v_id_usuario,par_ip);
       v_nivel_error=1;
      SELECT po_administrador,po_habilitar_log,po_tiene_permisos,po_id_subsistema
           into v_administrador_bool,v_habilitar_log,v_tiene_permisos,v_id_subsistema
       FROM f_verifica_permisos(par_id_usuario, par_transaccion, ''::varchar,ip_admin,par_ip::varchar);
       v_nivel_error=2;
      if(v_administrador_bool) THEN
        v_administrador = 1;
      END IF;
          
    -- 2) crea una tabla temportal con los parametros, valores y tipo de datos 
    -- 	  que seran direcciionado al procedimiento almacenado 
    --    concatena con el numero de secuencia para generar nombre de tabla unicos

    v_consulta:='create temporary table tt_parametros_'||v_secuencia||'(';
    v_tamano:=array_upper(tipos,1);
             --   raise exception 'aa%',variable_files;          

    for i in 1..(v_tamano-1) loop
        v_consulta:=v_consulta || variables[i] || ' ' || tipos[i] || ',';
    end loop;  
    --verifica si recibe archivos tipo bytea
    if( variable_files !='') THEN
      v_upload_file=true;
      v_consulta:=v_consulta || variables[v_tamano] || ' ' || tipos[v_tamano] || ','||variable_files||' bytea) on commit drop';
    ELSE
    v_upload_file=false;
      v_consulta:=v_consulta || variables[v_tamano] || ' ' || tipos[v_tamano] || ') on commit drop';
    END IF;
   -- raise exception 'aa%',v_consulta;
   
       RAISE NOTICE 'LLEGAAAAAAAA  2222';
    execute(v_consulta);
    
        RAISE NOTICE 'LLEGAAAAAAAA 333333333';
         
    
	-- 3) IF verifica si los resultados a ser enviados deben estar en formato de matriz o no
    --    Si no es formato de matriz es una llamada sencilla con un unico regisotr en la tabla temporal
    if(es_matriz='no') then
         
         -- 3.1)  prepara una cadena con un insert para la tabla temporal con los valores recibidos
        v_consulta:='insert into tt_parametros_'||v_secuencia||' values(';

        -- 3.2) FOR  recorre el array de  valores armando la cadena de insercion 
        
        for i in 1..(v_tamano-1) loop
            -- 3.2.1)IF si los valores son del tipo numeric o integer los espacios se insertan con valores nulos
            IF(tipos[i]='numeric' or tipos[i]='integer' or tipos[i]='int4')then
                if(valores[i]='')THEN
                    v_consulta:=v_consulta || 'null' || ',';
                else
                    v_consulta:=v_consulta || valores[i] || ',';
                end if;
            ELSE
                --RAC 12/09/2011 validacion para campo date vacio 
                if((tipos[i]='date' or tipos[i]='timestamp' or tipos[i]='time') and  valores[i]='')THEN
                     v_consulta:=v_consulta || 'null' || ',';
                else
                    v_consulta:=v_consulta ||''''|| valores[i] || ''',';
                end if;
            

            END IF;

        end loop; -- END FOOR 3.2)
        
        --   raise exception 'cons%',v_consulta;
         -- 3.3) introduce el final de la cadena de insercion
         
 --        raise exception '11111  %',par_files;
        
         --encode(par_files,'escape')
        if(tipos[v_tamano]='numeric' or tipos[v_tamano]='integer' or tipos[v_tamano]='int4')then
            
             if(v_upload_file)THEN
                 if(valores[v_tamano]='')THEN
               -- raise exception '222';
--                    v_consulta:=v_consulta || 'null' || ','''||par_files::text||''')';
--                    v_consulta:=v_consulta || 'null' || ','||decode('{'||par_files||'}','hex')||')';
--                    v_consulta:=v_consulta || 'null' || ','''||encode('{'||par_files||'}','hex')||''')';
--                      v_consulta:=v_consulta || 'null' || ',encode('''||par_files||'''::bytea,''hex''))';
                    --  v_consulta:=v_consulta || 'null' || ','''||encode(par_files,'escape')||''')';
                     v_consulta:=v_consulta || 'null' || ','''||par_files||'''::bytea)';
                      
                      
--                      v_consulta:=v_consulta || 'null' || ','''||par_files||'''::bytea)';
                else
                    v_consulta:=v_consulta || valores[v_tamano]|| ','''||par_files||'''::bytea)';
                end if;
             
             ELSE
                  
                if(valores[v_tamano]='')THEN
                    v_consulta:=v_consulta || 'null' || ')';
                else
                    v_consulta:=v_consulta || valores[v_tamano] || ')';
                end if;
            END IF;
          
        else
           --RAC 12/09/2011 validacion para campo date vacio 
           if(v_upload_file)THEN
              if((tipos[v_tamano]='date' or tipos[v_tamano]='timestamp' or tipos[v_tamano]='time') and  valores[v_tamano]='')THEN
                  v_consulta:=v_consulta || 'null' || ','''||par_files||'''::bytea)';
              else
                 v_consulta:=v_consulta ||''''|| valores[v_tamano] || ''','''||par_files||'''::bytea)';
              end if;
           
           ELSE
              if((tipos[v_tamano]='date' or tipos[v_tamano]='timestamp' or tipos[v_tamano]='time') and  valores[v_tamano]='')THEN
                  v_consulta:=v_consulta || 'null' || ')';
              else
                  v_consulta:=v_consulta ||''''|| valores[v_tamano] || ''')';
              end if;
            
           END IF;
        
        end if;
      -- 3.4  Ejecuta la cadena de insercion  en la tabla temporal con los datos recibidos del servidor
      -- raise exception 'aa%', v_consulta;
         raise notice '%', v_consulta;       
        execute v_consulta;
        
       --3.5) Arma en una cadena  la llamada al  procedimiento almacenado destino, le envia
       --     como parametro el nombre de la tabla temporal, el id_usuario,si es administrador 
       --     y la transaccion que se quiere ejecutar   

        v_consulta:='select ' || par_procedimiento || '('||v_administrador||','||coalesce(par_id_usuario,0)||',''tt_parametros_'||v_secuencia||''','''||par_transaccion||''')';
        raise notice '%',v_consulta;
   
        -- 3.6)ejecuta la cadena de llamada al procedimiento almacenado el valor de respuesta lo introduce
        --     en la variable tipo varchar v_retorno en formato JSON (o XML)
        execute v_consulta into v_retorno;
        
    
    -- 4) ELSE Si  es formato de matriz,   un for recorre la misma haciendo por cada vuelta
      --  un llamada al procedimiento almacenado con esto logramamos,  por ejemplo varias inserciones en una misma tabla
      -- y dentro de una misma transaccion, si tenemos algun error se corre un rollback para todo 
    else
    
    
          
    
     
        --4.1) calcula el tamano de la matriz
        v_tamano_matriz:=array_upper(valores,1);
        
        --4.2) recorre las filas de la matriz 
       for j in 1..(v_tamano_matriz) loop
            -- 4.2.1) prepara una cadena de insercion para la tabla temporal
            
            v_consulta='insert into tt_parametros_'||v_secuencia||' values(';
            
            --4.2.2)  FOR  recorre el array  de  valores (para la fila [j] de la matriz) armando la cadena de insercion con 
                  --  los valores  correpondientes a la fila [j]
        
          for i in 1..(v_tamano-1) loop
            
                --4.2.2.1) botiene el numero de fila por si acaso ocurriera un error tenerla identificada
                if(variables[i]='_fila')then
                    v_linea='Ocurrido en la linea # '||valores[j][i];
                end if;
                
               -- 4.2.2.2)IF si los valores son del tipo numeric o integer los espacios se insertan con valores nulos
                 
                if(tipos[i]='numeric' or tipos[i]='integer' or tipos[i]='int4')then
                    if(valores[j][i]='')THEN
                        v_consulta:=v_consulta || 'null' || ',';
                    else
                        v_consulta:=v_consulta || valores[j][i] || ',';
                    end if;
                ELSE
                
                --RAC 12/09/2011 validacion para campo date vacio 
                  if((tipos[i]='date' or tipos[i]='timestamp' or tipos[i]='time') and  valores[j][i]='')THEN
                       v_consulta:=v_consulta || 'null' || ',';
                  else
                    v_consulta:=v_consulta ||''''|| valores[j][i] || ''',';
                  end if;
                
                
                    
                end if;

            end loop;
            
            --4.2.3) inserta el ultimo valor en la cadena de insercion para la tabla temporal

            if(tipos[v_tamano]='numeric' or tipos[v_tamano]='integer' or tipos[v_tamano]='int4')then
                if(valores[j][v_tamano]='')THEN
                    v_consulta:=v_consulta || 'null' || ')';
                else
                    v_consulta:=v_consulta || valores[j][v_tamano] || ')';
                end if;

            ELSE
            
                --RAC 12/09/2011 validacion para campo date vacio 
                  if((tipos[v_tamano]='date' or tipos[v_tamano]='timestamp' or tipos[v_tamano]='time') and  valores[j][v_tamano]='')THEN
                      v_consulta:=v_consulta || 'null' || ')';
                  else
                    v_consulta:=v_consulta ||''''|| valores[j][v_tamano] || ''')';
                  end if;
                
            end if;
            --raise exception '%',v_consulta;
            
          -- 4.2.4  Ejecuta la cadena de insercion  en la tabla temporal con los datos recibidos del servidor

      
            execute v_consulta;
        
           --4.2.5) Arma en una cadena  la llamada al  procedimiento almacenado destino, le envia
           --     como parametro el nombre de la tabla temporal, el id_usuario,si es administrador 
           --     y la transaccion que se quiere ejecutar   
      
            v_consulta:='select ' || par_procedimiento || '('||v_administrador||','||coalesce(par_id_usuario,0)||',''tt_parametros_'||v_secuencia||''','''||par_transaccion||''')';

     
          -- 4.2.6) ejecuta la cadena de llamada al procedimiento almacenado el valor de respuesta lo introduce
          --     en la variable tipo varchar v_retorno en formato JSON (o XML)
            
              v_consulta:='select ' || par_procedimiento || '('||v_administrador||','||coalesce(par_id_usuario,0)||',''tt_parametros_'||v_secuencia||''','''||par_transaccion||''')';

            execute v_consulta into v_retorno;
          -- 4.2.7) vacia la tabla temporal para prepararla para la proxima fila de la matriz  
            execute('truncate table tt_parametros_'||v_secuencia);
            
            
        end loop; -- END FOR 4.2.2)
        
        
    end if;
    
    
    --Procesamiento de la respuesta de la funciÃ³n ejecutada
    --rcm
    --raise exception '%',v_retorno[1];
    
    --5) REgistra en LOG las trasacciones ejecutadas como exitosas
    
    v_id_log=0;
 -- v_habilitar_log = TRUE;
    
  RAISE NOTICE 'LLEGAAAAAAAA 444444444';
          
        
      v_hora_fin=clock_timestamp();
      v_id_log:=f_registrar_log(par_id_usuario,
    							par_ip,
                                par_mac::varchar,
                                'LOG_TRANSACCION',
                                f_obtiene_clave_valor(v_retorno,'mensaje','','','valor')::text,
                                par_procedimiento,
                                par_transaccion,
                                par_consulta,
                                to_char((v_hora_fin-v_hora_ini),'MS')::integer,
                                getpgusername()::varchar,
                                NULL,
                                pg_backend_pid(),
                                par_sid_web,
                                par_pid_web,
                                v_id_subsistema,
                                v_habilitar_log);
    
    v_resp='';
    v_resp = f_agrega_clave(v_resp,'tipo_respuesta','EXITO');
    v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
    v_resp = f_agrega_clave(v_resp,'id_log',v_id_log::varchar);
    
    v_resp = f_agrega_clave_multiple(v_resp,v_retorno);
    
    return f_resp_to_json(v_resp);

EXCEPTION
	WHEN OTHERS THEN
    
		v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'tipo_respuesta','ERROR'::varchar);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
  		--raise exception '%',v_resp;
        v_tipo_error='ERROR_TRANSACCION_BD';
        
         if(v_nivel_error=0)then
            v_tipo_error='ERROR_BLOQUEO';
         elsif(v_nivel_error=1)then
            v_tipo_error='ERROR_PERMISOS';
         elsif(par_transaccion='SEG_VALUSU_SEG')then
            v_tipo_error='ERROR_ACCESO';
         elsif (SQLSTATE='P0001')THEN
            v_tipo_error='ERROR_CONTROLADO_BD';
         end if;
        --Registro en el log
        v_id_log:=f_registrar_log(v_id_usuario,
        						par_ip,
                                par_mac::varchar,
                                v_tipo_error,
                                f_obtiene_clave_valor(v_resp,'mensaje','','','valor'),
                                f_obtiene_clave_valor(v_resp,'procedimientos','','','valor'),
                                par_transaccion,
                                par_consulta,
                                NULL,
                                getpgusername()::varchar,
                                SQLSTATE::varchar,
                                pg_backend_pid(),
                                par_sid_web,
                                par_pid_web,
                                v_id_subsistema,
                                1);
                                
        v_resp = f_agrega_clave(v_resp,'id_log',v_id_log::varchar);
        
  		return f_resp_to_json(v_resp);
END;
$$;


--
-- TOC entry 1106 (class 1255 OID 207490)
-- Dependencies: 23 3246
-- Name: f_intermediario_ime_orig(integer, character varying, macaddr, character varying, character varying, integer, character varying, character varying[], character varying[], character varying[], character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_intermediario_ime_orig(par_id_usuario integer, par_ip character varying, par_mac macaddr, par_procedimiento character varying, par_transaccion character varying, par_id_categoria integer, es_matriz character varying, variables character varying[], valores character varying[], tipos character varying[], par_consulta character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 
v_consulta          varchar;
v_secuencia         integer;
v_tamano            integer;
v_retorno           varchar;
v_mensaje           text;
v_nombre_funcion    text;
v_mensaje_log       varchar;
v_administrador     integer;
v_valores_array     varchar[];
v_tamano_matriz     integer;
v_linea             varchar;

BEGIN

    v_nombre_funcion:='public.f_intermediario_ime';
    v_linea=null;
    v_secuencia:=(nextval('parametro'));
    v_administrador:=0;
    if exists(select 1 from segu.usuario_rol ur where id_usuario=par_id_usuario and id_rol=1 and estado_reg='activo')then
       v_administrador:=1;
    end if;
    
    v_consulta:='create temporary table tt_parametros_'||v_secuencia||'(';
    v_tamano:=array_upper(tipos,1);
    for i in 1..(v_tamano-1) loop
        v_consulta:=v_consulta || variables[i] || ' ' || tipos[i] || ',';
    end loop;

    v_consulta:=v_consulta || variables[v_tamano] || ' ' || tipos[v_tamano] || ') on commit drop';

    execute(v_consulta);

    if(es_matriz='no')then

        v_consulta:='insert into tt_parametros_'||v_secuencia||' values(';

        for i in 1..(v_tamano-1) loop
            if(tipos[i]='numeric' or tipos[i]='integer')then
                if(valores[i]='')THEN
                    v_consulta:=v_consulta || 'null' || ',';
                else
                    v_consulta:=v_consulta || valores[i] || ',';
                end if;
            ELSE
                v_consulta:=v_consulta ||''''|| valores[i] || ''',';
            end if;

        end loop;

        if(tipos[v_tamano]='numeric' or tipos[v_tamano]='integer')then
            if(valores[v_tamano]='')THEN
                v_consulta:=v_consulta || 'null' || ')';
            else
                v_consulta:=v_consulta || valores[v_tamano] || ')';
            end if;
          
        ELSE
            v_consulta:=v_consulta ||''''|| valores[v_tamano] || ''')';
        end if;
        
        execute v_consulta;
   
        v_consulta:='select ' || par_procedimiento || '('||v_administrador||','||coalesce(par_id_usuario,0)||',''tt_parametros_'||v_secuencia||''','''||par_transaccion||''')';
        
        execute v_consulta into v_retorno;
    else
        
        v_tamano_matriz:=array_upper(valores,1);
        
        for j in 1..(v_tamano_matriz) loop
            v_consulta='insert into tt_parametros_'||v_secuencia||' values(';
            for i in 1..(v_tamano-1) loop
                if(variables[i]='_fila')then
                    v_linea='Ocurrido en la linea # '||valores[j][i];
                end if;
                if(tipos[i]='numeric' or tipos[i]='integer')then
                    if(valores[j][i]='')THEN
                        v_consulta:=v_consulta || 'null' || ',';
                    else
                        v_consulta:=v_consulta || valores[j][i] || ',';
                    end if;
                ELSE
                    v_consulta:=v_consulta ||''''|| valores[j][i] || ''',';
                end if;

            end loop;

            if(tipos[v_tamano]='numeric' or tipos[v_tamano]='integer')then
                if(valores[j][v_tamano]='')THEN
                    v_consulta:=v_consulta || 'null' || ')';
                else
                    v_consulta:=v_consulta || valores[j][v_tamano] || ')';
                end if;

            ELSE
                v_consulta:=v_consulta ||''''|| valores[j][v_tamano] || ''')';
            end if;
            --raise exception '%',v_consulta;
            execute v_consulta;

            v_consulta:='select ' || par_procedimiento || '('||v_administrador||','||coalesce(par_id_usuario,0)||',''tt_parametros_'||v_secuencia||''','''||par_transaccion||''')';

            execute v_consulta into v_retorno;
            execute('truncate table tt_parametros_'||v_secuencia);
        end loop;
        
        
    end if;
    v_mensaje:=f_get_mensaje_exi(v_retorno,v_nombre_funcion,par_transaccion);
    v_mensaje_log:=f_registrar_log(par_id_usuario,par_ip,par_mac::varchar,v_mensaje,par_consulta);
    return v_mensaje;
    
    EXCEPTION

       WHEN OTHERS THEN
--raise exception '%',par_consulta;
         v_mensaje:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM,v_nombre_funcion,par_transaccion,v_linea);
         
         v_mensaje_log:=f_registrar_log(par_id_usuario,par_ip,par_mac::varchar,v_mensaje,par_consulta);
         return v_mensaje::varchar;


END;
$$;


--
-- TOC entry 1845 (class 1255 OID 207491)
-- Dependencies: 3246 23
-- Name: f_intermediario_sel(integer, character varying, integer, character varying, macaddr, character varying, character varying, integer, character varying[], character varying[], character varying[], character varying[], character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_intermediario_sel(par_id_usuario integer, par_sid_web character varying, par_pid_web integer, par_ip character varying, par_mac macaddr, par_procedimiento character varying, par_transaccion character varying, par_id_categoria integer, ip_admin character varying[], variables character varying[], valores character varying[], tipos character varying[], tipo_retorno character varying DEFAULT 'varchar'::character varying, datos_retorno character varying DEFAULT NULL::character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_intermediario_sel
 DESCRIPCIÓN: 	Recibe las peticiones del servidor web y las encamina 
  				hacia el procedimiento almacenado correspondiente
 AUTOR: 		KPLIAN (jrr)
 FECHA:			26/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	Revison y documentacion
 AUTOR:			 KPLIAN (rac)
 FECHA:			 26-11-10
***************************************************************************
 DESCRIPCION:	Valida si el usuario tiene permiso para ejecutar la transaccion
 AUTOR:			 KPLIAN (rac)
 FECHA:			 29-11-10
****************************************************************************
 DESCRIPCION:	Agregar array de direcciones IP para uso administrativo
 AUTOR:			 KPLIAN (rac)
 FECHA:			 25-12-10
 ****************************************************************************
 DESCRIPCION:	Aumenta variable tipo retorno para definir se 
 				la funcion regresa su resultado como consulta o como record
                los record se utilizan cuando tenemos tablas temporales
 AUTOR:			 KPLIAN (rac)
 FECHA:			 19-03-12
***************************************************************************/

DECLARE
 
v_consulta    varchar;
v_secuencia   integer;
v_tamano      integer;
v_retorno     varchar;
v_mensaje    text;
v_mensaje_log   varchar;
v_nombre_funcion    text;
v_administrador     integer;

v_id_log integer;
v_resp_error record;
v_administrador_bool boolean;
v_tiene_permisos    boolean;
v_habilitar_log     integer;
v_database          varchar;
v_resp				varchar;
v_hora_ini          timestamp;
v_hora_fin          timestamp;
v_nivel_error    integer;
v_tipo_error        varchar;
v_id_subsistema     integer;
v_id_subsistema_cade varchar;
v_cadena_log        varchar;
v_retorno_record record;



BEGIN
    v_nombre_funcion:='public.f_intermediario_sel';
    v_resp=f_runtime_config('LOG_STATEMENT','LOCAL','none');
    v_nivel_error=2;
    v_hora_ini = clock_timestamp();
    v_retorno='';
    v_resp_error=f_ejecutar_dblink('('||pg_backend_pid()::varchar||',
            '''||par_sid_web||''','||par_pid_web||','''||par_transaccion||''','''||par_procedimiento||''')'
            ,'sesion');
    
    
    --1) verifica si es administrador, si tiene permisos y si habilita el log
       
       
       v_administrador = 0;
       v_nivel_error=0;
       v_resp=f_validar_bloqueos(par_id_usuario,par_ip);
       v_nivel_error=1;
       SELECT po_administrador,po_habilitar_log,po_tiene_permisos,po_id_subsistema
           into v_administrador_bool,v_habilitar_log,v_tiene_permisos,v_id_subsistema
       FROM f_verifica_permisos( par_id_usuario, par_transaccion, ''::varchar,ip_admin,par_ip::varchar);
       v_nivel_error=2;
       --raise exception 'permisos ->  %,%,%',v_tiene_permisos,v_habilitar_log,v_administrador_bool;
    
     
      if(v_administrador_bool) THEN
        v_administrador = 1;
      END IF;
       
       
      
    
       
    v_secuencia:=(nextval('parametro'));
    
    v_consulta:='create temporary table tt_parametros_'||v_secuencia||'(';
    v_tamano:=array_upper(variables,1);
    for i in 1..(v_tamano-1) loop
        v_consulta:=v_consulta || variables[i] || ' ' || tipos[i] || ',';

    end loop;
     
    v_consulta:=v_consulta || variables[v_tamano] || ' ' || tipos[v_tamano] || ') on commit drop';
    
    execute(v_consulta);
    
    v_consulta:='insert into tt_parametros_'||v_secuencia||' values(';
    
    for i in 1..(v_tamano-1) loop
        if(tipos[i]='numeric' or tipos[i]='integer')then
            if(valores[i]='')then
                v_consulta:=v_consulta || 'null' || ',';
            else
                v_consulta:=v_consulta || valores[i] || ',';
            end if;
        ELSE
            v_consulta:=v_consulta ||''''|| replace(valores[i],'''','''''') || ''',';
        end if;

    end loop;

    if(tipos[v_tamano]='numeric' or tipos[v_tamano]='integer')then
        if(valores[v_tamano]='')then
            v_consulta:=v_consulta || 'null'|| ')';
        else
            v_consulta:=v_consulta || valores[v_tamano] || ')';
        end if;
    ELSE
          v_consulta:=v_consulta ||''''|| replace(valores[v_tamano],'''','''''') || ''')';
    end if;
    --raise exception 'prueba:%',v_consulta;
    execute v_consulta;
    
  
    -- raise notice 'pasa';
    
   
    --raise exception '%',v_retorno;
    
    --raise exception 'aaaaaa: %',v_consulta;
   
    -- raise exception 'ES  SEL ';
     
     v_id_log=0;
     
  	 v_mensaje:=f_get_mensaje_exi('Exito en la consulta',v_nombre_funcion,par_transaccion);
    
   /*
   RAC 19032012
   aumentamos el tipo de dato de retorno
   para poder ejecutar consultar que retornan un tipo record
   */ 
    
   
   if(tipo_retorno='varchar')THEN
   
     v_consulta:='select ' || par_procedimiento || '('||v_administrador||','||coalesce(par_id_usuario,0)||',''tt_parametros_'||v_secuencia||''','''||par_transaccion||''')';
    
   
    execute v_consulta into v_retorno;
    
    return query execute (v_retorno);
    
    --RAC  >>>> OJO me parece que este registro de LOG nunca se EJECUTA
    v_hora_fin=clock_timestamp();
    --raise exception 'gfdsgfsd: %',v_habilitar_log;
        v_id_log:=f_registrar_log(par_id_usuario,
    							par_ip,
                                par_mac::varchar,
                                'LOG_TRANSACCION',
                                v_mensaje,
                                par_procedimiento,
                                par_transaccion,
                                v_retorno,
                                to_char((v_hora_fin-v_hora_ini),'MS')::integer,
                                getpgusername()::varchar,
                                NULL,
                                pg_backend_pid(),
                                par_sid_web,
                                par_pid_web,
                                v_id_subsistema,
                                v_habilitar_log);
                                
                                
     ELSE
     
     --en caso que el tipo de retorno sea un record
     
   -- execute v_consulta into v_retorno_record;
   
     v_consulta:='select * from ' || par_procedimiento || '('||v_administrador||','||coalesce(par_id_usuario,0)||',''tt_parametros_'||v_secuencia||''','''||par_transaccion||''') '||datos_retorno;
    
    raise notice 'CONSULTA %  ',v_consulta;
     
      for v_retorno_record in execute (v_consulta) LOOP
          RETURN NEXT v_retorno_record;
      END LOOP;
     
    
     END IF;


    EXCEPTION

       WHEN OTHERS THEN
       
        v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'tipo_respuesta','ERROR'::varchar);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);

        
         v_retorno:=replace(v_retorno,'''','''''');
         
         v_tipo_error='ERROR_TRANSACCION_BD';
         if(v_nivel_error=0)then
            v_tipo_error='ERROR_BLOQUEO';
         elsif(v_nivel_error=1)then
            v_tipo_error='ERROR_PERMISOS';
         elsif (SQLSTATE='P0001')THEN
            v_tipo_error='ERROR_CONTROLADO_BD';
         end if;
         
         if(v_id_subsistema is null)then
            v_id_subsistema_cade='null';
         else
            v_id_subsistema_cade=v_id_subsistema::varchar;
         end if;

         v_cadena_log='('||
         		coalesce(par_id_usuario,0)||',''' ||
                par_ip::varchar||''','''||
             	par_mac::varchar||''','''||
             	v_tipo_error ||''','''||
                f_obtiene_clave_valor(v_resp,'mensaje','','','valor')||''','''||
             	f_obtiene_clave_valor(v_resp,'procedimientos','','','valor')||''','''||
                par_transaccion||''','''||
                coalesce (v_retorno,' ')||''',NULL,''' ||
                getpgusername()||''','''||
                SQLSTATE||''','||
                pg_backend_pid()||','''||
                par_sid_web||''','||
                par_pid_web||','||
                v_id_subsistema_cade||
                ',1)';

		--RCM 31/01/2012: Cuando la llamada a esta funcion devuelve error, el manejador de excepciones de esa función da el resultado,
        --por lo que se modifica para que devuelva un json direcamente
         v_resp_error=f_ejecutar_dblink(v_cadena_log,'log');
                
         v_resp = f_agrega_clave(v_resp,'id_log',v_resp_error.id_log::varchar);
         


         raise exception '%',f_resp_to_json(v_resp);


END;
$$;


--
-- TOC entry 970 (class 1255 OID 207494)
-- Dependencies: 23 3246
-- Name: f_llenar_ceros(numeric, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_llenar_ceros(numero numeric, digitos integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	largo_cad 		integer;
	cadena			text;
BEGIN
    cadena:=text(numero);
    largo_cad:=char_length(cadena);
    while (largo_cad<digitos) loop
        cadena:='0'||cadena;
        largo_cad:=char_length(cadena);
    end loop;
    return cadena;
END;
$$;


--
-- TOC entry 1107 (class 1255 OID 207495)
-- Dependencies: 23 3246
-- Name: f_obtener_literal_periodo(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_obtener_literal_periodo(par_mes integer, par_nro integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 documento: 	public.f_obtener_literal_periodo
 DESCRIPCION:   Funcion que obtiene el literal de un periodo (mes)
 AUTOR: 	    KPLIAN	
 FECHA:	        06/06/2011
 COMENTARIOS:	
***************************************************************************/
DECLARE
  g_mes_lite varchar;
BEGIN
    IF par_mes = 1 THEN
        g_mes_lite := 'Enero';
    ELSIF par_mes = 2 THEN
    	g_mes_lite := 'Febrero';
    ELSIF par_mes = 3 THEN
    	g_mes_lite := 'Marzo';
    ELSIF par_mes = 4 THEN
    	g_mes_lite := 'Abril';
    ELSIF par_mes = 5 THEN
    	g_mes_lite := 'Mayo';
    ELSIF par_mes = 6 THEN
    	g_mes_lite := 'Junio';
	ELSIF par_mes = 7 THEN
    	g_mes_lite := 'Julio';
	ELSIF par_mes = 8 THEN
    	g_mes_lite := 'Agosto';
    ELSIF par_mes = 9 THEN
    	g_mes_lite := 'Septiembre';
    ELSIF par_mes = 10 THEN
    	g_mes_lite := 'Octubre';
    ELSIF par_mes = 11 THEN
    	g_mes_lite := 'Noviembre';
   ELSIF par_mes = 12 THEN
    	g_mes_lite := 'Diciembre';
   END IF;

   IF par_nro > 0 THEN
        g_mes_lite := substr(g_mes_lite, 1, par_nro);
   END IF;

   return g_mes_lite;
END;
$$;


--
-- TOC entry 1108 (class 1255 OID 207496)
-- Dependencies: 23 3246
-- Name: f_obtener_primer_dia_mes(numeric, numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_obtener_primer_dia_mes(par_mes numeric, par_anio numeric) RETURNS date
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 documento: 	public.f_obtener_primer_dia_mes
 DESCRIPCION:   Funcion que obtiene el primer dia de un mes y anio especifico
 AUTOR: 	    KPLIAN	
 FECHA:	        06/06/2011
 COMENTARIOS:	
***************************************************************************/
DECLARE

g_mes      numeric;
g_fecha    date;

BEGIN
    g_mes:=par_mes;
    if (g_mes<10)then
        g_fecha:=(select cast(par_anio || '-0' || g_mes || '-01' as date));

    ELSE
        g_fecha:=(select cast(par_anio || '-' || g_mes || '-01' as date));
    end if;
    raise notice '%',g_fecha;
    return g_fecha;

END;
$$;


--
-- TOC entry 1109 (class 1255 OID 207497)
-- Dependencies: 23 3246
-- Name: f_obtener_ultimo_dia_mes(numeric, numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_obtener_ultimo_dia_mes(par_mes numeric, par_anio numeric) RETURNS date
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 documento: 	public.f_obtener_ultimo_dia_mes
 DESCRIPCION:   Funcion que obtiene el ultimo dia de un mes y anio especifico
 AUTOR: 	    KPLIAN	
 FECHA:	        06/06/2011
 COMENTARIOS:	
***************************************************************************/

DECLARE

g_mes      integer;
g_fecha    date;

BEGIN
    g_mes:=par_mes+1;
    if (g_mes<10)then
        g_fecha:=(select cast(par_anio || '-0' || g_mes || '-01' as date)-1);
    elsif(g_mes=13)THEN
        g_fecha:=(select cast(par_anio || '-12-31' as date));
    ELSE
        g_fecha:=(select cast(par_anio || '-' || g_mes || '-01' as date)-1);
    end if;
    return g_fecha;

END;
$$;


--
-- TOC entry 1110 (class 1255 OID 207498)
-- Dependencies: 23 3246
-- Name: f_obtiene_clave_valor(character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_obtiene_clave_valor(p_cad character varying, p_clave character varying, p_valor character varying, p_accion character varying, p_respuesta character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_obtiene_clave_valor
 DESCRIPCION:
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE

	v_cad_ini varchar; --SEPARADOR INICIAL DE LA CLAVE
    v_cad_fin varchar; --SEPARADOR FINAL DE LA CLAVE
    v_cad_ini_fin varchar; --SEPARADOR INICIAL DEL CIERRE DE LA CLAVE
    v_cad_fin_fin varchar; --SEPARADOR FINAL DEL CIERRE DE LA CLAVE

	v_ini integer; --POSICION INICIAL DE LA CLAVE INICIAL
    v_fin integer; --POSICION INICIAL DE LA CLAVE FINAL
    
    v_clave_ini varchar; --CLAVE INICIAL CON LOS SEPARADORES INCLUIDOS
    v_clave_fin varchar; --CLAVE FINAL CON LOS SEPARADORES INCLUIDOS
    v_tam integer; --TAMAÑO DE LA CLAVE BUSCADA
    v_valor varchar; --VALOR ACTUAL DE LA CLAVE UBICADA
    
    v_valor_nuevo varchar;
    v_cad_ant varchar;
    v_cad_post varchar;
    v_cadena_accion varchar;
    
BEGIN
	--Inicialización de constantes
	v_cad_ini = '<';
    v_cad_fin = '>';
    v_cad_ini_fin = '</'||p_clave;
    v_cad_fin_fin = '>';
    
    /*v_cad_ini = '[';
    v_cad_fin = ':';
    v_cad_ini_fin = '';
    v_cad_fin_fin = '],';*/
    
	--Forma claves de busqueda
    v_clave_ini = v_cad_ini || p_clave || v_cad_fin;
    v_clave_fin = v_cad_ini_fin || v_cad_fin_fin;
    
	--Ubica la posicion inicial de la clave
	v_ini = strpos(p_cad,v_clave_ini);
    --raise notice 'clave_ini %  v_clave_fin %  ini %',v_clave_ini,v_clave_fin,v_ini;
    
    --Si no se ubica la clave
    if v_ini=0 then
    	return '';
    end if;
    
    --Obtiene el tamaño de la clave
    v_tam = length(v_clave_ini);
    
    --Suma al inicio el tamaño de la clave
    v_ini = v_tam + v_ini;
    
    --Ubica la posicion del cierre de clave
    v_fin = strpos(p_cad,v_clave_fin); --25=B
    --raise notice 'tam %  ini %  fin %',v_tam,v_ini,v_fin;
    
    if v_fin = 0 then
    	return '';
    end if;
    
    --Se obtiene el valor de la clave ubicada
    v_valor = substr(p_cad,v_ini,v_fin-v_ini);
    v_cadena_accion = p_cad;
    
    --Obtiene toda la cadena anterior
    v_cad_ant=substr(p_cad,1,v_ini-1);
    
    --Obtiene toda la cadena posterior
	v_cad_post=substr(p_cad,v_fin,length(p_cad)-v_fin+1);
    
    -- Verfica si la accion es cambiar, unir o nada
    if p_accion = 'cambiar' then
    	v_valor = p_valor;
    	v_cadena_accion = v_cad_ant || p_valor ||v_cad_post;	
    elsif p_accion = 'unir' then
    	v_valor = p_valor || ' - ' || v_valor;
    	v_cadena_accion = v_cad_ant || v_valor ||v_cad_post;	
    end if;

	if p_respuesta = 'valor' then
    	return v_valor;
    elsif p_respuesta = 'cadena' then
    	return v_cadena_accion;
    else
    	return v_cadena_accion;
    end if;

END;
$$;


--
-- TOC entry 1111 (class 1255 OID 207499)
-- Dependencies: 23 3246
-- Name: f_registrar_log(integer, character varying, character varying, character varying, text, text, character varying, character varying, integer, character varying, character varying, integer, character varying, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_registrar_log(par_id_usuario integer, par_ip character varying, par_mac character varying, par_tipo_log character varying, par_descripcion text, par_procedimientos text, par_transaccion character varying, par_consulta character varying, par_tiempo_ejecucion integer, par_usuario_base character varying, par_codigo_error character varying, par_pid_db integer, par_sid_web character varying, par_pid_web integer, par_id_subsistema integer, par_log integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: 		public.f_intermediario_ime
 DESCRIPCIÓN: 	Inserta registro de bitacora
 AUTOR: 		KPLIAN(jrr)
 FECHA:			26/07/2010

***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	 returning id_log
 AUTOR:			 KPLIAN(rac)
 FECHA:			 29-11-10
***************************************************************************
HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	 se anade el parametro par_log si es 1 se muestra en el
                log sino(0) solo en el monitor
 AUTOR:			 KPLIAN(jrr)
 FECHA:			 03-03-2011
***************************************************************************/

declare
       g_separador_error     varchar;
       g_separador_inicial   varchar;
       g_separador_funcion   varchar;
       g_mensaje_nuevo       text;
       g_descripcion         text;
       g_procedimientos      text;
       g_transaccion         varchar;
       g_tipo_log            varchar;
       v_id_log				 integer;
       v_resp                varchar;
       v_pid_db             integer;
       v_cuenta             varchar;
       v_subsistema         varchar;
       v_desc_transaccion   varchar;
       v_registro           record;
       v_interval           interval;

begin
    v_resp=f_runtime_config('LOG_STATEMENT','LOCAL','none');
    
     select valor into g_separador_inicial from public.variable_global vg where vg.variable='separador_inicial';
     select valor into g_separador_error from public.variable_global vg where vg.variable='separador_error';
    if(par_pid_db is null)then
        v_pid_db=pg_backend_pid();
    else
        v_pid_db=par_pid_db;
    end if;
    if(par_id_subsistema is not null)then
        select codigo
        into v_subsistema
        from segu.tsubsistema
        where id_subsistema=par_id_subsistema;
    end if;
    if(par_id_usuario is not null) then
        select cuenta
        into v_cuenta
        from segu.tusuario
        where id_usuario=par_id_usuario;
    end if;
    
    if(par_transaccion is not null)then
        select descripcion
        into v_desc_transaccion
        from segu.tprocedimiento
        where codigo=par_transaccion;
    end if;
    
    
    v_id_log=(select nextval('segu.log_id_log_seq'));
     --RAC, RCM: cambios para qe devuelva el id_log
     insert into segu.tlog(
     id_log,
     id_usuario,mac_maquina,ip_maquina,tipo_log,descripcion,fecha_reg,
     estado_reg,procedimientos,transaccion,consulta,tiempo_ejecucion,
     usuario_base,codigo_error,dia_semana,pid_db,pid_web,sid_web,cuenta_usuario,
     descripcion_transaccion,codigo_subsistema,id_subsistema,si_log
     ) values(
     v_id_log,
     par_id_usuario,par_mac,par_ip,par_tipo_log,par_descripcion,now(),'activo',
     par_procedimientos,par_transaccion,par_consulta,par_tiempo_ejecucion,
     par_usuario_base,par_codigo_error,to_char(now(),'D')::integer,
     v_pid_db,par_pid_web,par_sid_web,v_cuenta,
     v_desc_transaccion,v_subsistema,par_id_subsistema,par_log
     ) ;
     
    IF(par_tipo_log in('ERROR_WEB','ERROR_CONTROLADO_PHP','INYECCION','SESION',
                        'ERROR_TRANSACCION_BD','ERROR_CONTROLADO_BD',
                        'ERROR_PERMISOS','ERROR_BLOQUEO','ERROR_ACCESO'))THEN
                        
        for v_registro in
            (   select * from segu.tpatron_evento
                where estado_reg='activo' and tipo_evento=par_tipo_log)loop
            
            if((select count(*)
                from segu.vlog
                where tipo_log=par_tipo_log and
                    fecha_reg>(now() - (v_registro.periodo_intentos||' minutes')::interval) AND
                    ((v_registro.aplicacion='ip' and ip_maquina=par_ip) or (v_registro.aplicacion='usuario' and id_usuario=par_id_usuario)))
                    >=v_registro.cantidad_intentos)then
                

                if(not exists ( select 1
                                from segu.tbloqueo_notificacion
                                where id_patron_evento=v_registro.id_patron_evento and
                                        estado_reg='activo' and
                                        fecha_hora_fin > now() and
                                   ((aplicacion='ip' and ip=par_ip) or
                                   (aplicacion='usuario' and id_usuario=par_id_usuario))))THEN
                                   
                       insert into segu.tbloqueo_notificacion
                       (id_patron_evento,           nombre_patron,              fecha_hora_ini,
                       fecha_hora_fin,              estado_reg,                 id_usuario,
                       usuario,                     ip,                         tipo,
                       aplicacion,                  tipo_evento)
                       values(
                       v_registro.id_patron_evento, v_registro.nombre_patron,   now(),
                       (now()+ (v_registro.tiempo_bloqueo||' minutes')::interval),'activo',par_id_usuario,
                       v_cuenta,                    par_ip,                     v_registro.operacion,
                       v_registro.aplicacion,       v_registro.tipo_evento
                       );
                       
                end if;
                    
            end if;
        end loop;

    END IF;

     return v_id_log;
     
     

end;
$$;


--
-- TOC entry 1081 (class 1255 OID 207502)
-- Dependencies: 23 3246
-- Name: f_resp_array(character varying[], character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_resp_array(p_array character varying[], p_clave character varying, p_valor character varying, p_accion character varying) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$
/*
Autor: KPLIAN(rcm)
Fecha: 19/08/2010
Propósito: FOrmar la respuesta en forma de array en formato clave-valor
Dominio: p_accion: 'unico','unir',otros
*/
DECLARE

	v_ini varchar;
    v_fin varchar;
    v_cad varchar;
    v_array varchar[];
    v_valor varchar;
    v_procede boolean;
    v_fila integer;

BEGIN

	--Definición de constantes para el formato del arrray
	v_ini='{';
    v_fin='}';
    v_procede=false;
        
    --Verifica la acción a realizar con el array
    --return '{claveZZ,'||p_clave||'}';
    v_valor = f_array_ubicar_clave(p_array,p_clave);
    if p_accion = 'unico' then
    	--Verifica si en el array enviado ya existe registrada la clave enviada. Si no existe la crea. Si existe no hace nada
        if v_valor = '_false' then
        	--No Existe, entonces crea la clave valor
            v_valor = p_valor;
            v_procede=true;
        end if;
    elsif p_accion = 'unir' then
    	--Verifica si ya existe la clave enviada. Si hay concatena por delante el valor. Si no existe lo crea.
        if v_valor = '_false' then
        	--Crea
            v_valor = p_valor;
            v_procede=true;
        else
        	--Concatena el valor con lo obtenido
            v_valor = p_valor||'|'||v_valor;
            v_fila = f_array_ubicar_clave_posicion(p_array);
            v_array = p_array;
            v_array[v_fila][2]=v_valor;
        end if;
    else
    	--Cualquier caso. Siempre crea la clave
        v_valor = p_valor;
        v_procede=true;
    end if;
    
    --Preparación de la cadena para agregar al array
    v_cad = v_ini||p_clave||','||v_valor||v_fin;
    
    --Append de la cadena procesada si la bandera esta encendida
    if v_procede then
    	v_array=array_append(p_array,v_cad);
    end if;
    
    --Envío de respuesta
	RETURN v_array;

END;
$$;


--
-- TOC entry 1124 (class 1255 OID 207503)
-- Dependencies: 23 3246
-- Name: f_resp_to_json(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_resp_to_json(p_xml character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_resp_to_json
 DESCRIPCION:   Convierte la cadena de respuesta a una cadena json
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE

	v_cad varchar;
    i integer;
    v_tam integer;
    v_array_claves varchar[];
    v_sub_cad varchar;
    v_pos_ini integer;
    v_pos_fin integer;
    v_clave varchar;
    v_cad_ini varchar;
    v_cad_fin varchar;
    v_cad_ini_fin varchar;
    v_cad_fin_fin varchar;
    v_nom_clave_ini varchar;
    v_nom_clave_fin varchar;
    v_aux varchar;
    v_resp varchar;

BEGIN
	--Inicialización de constantes
	v_cad_ini = '<';
    v_cad_fin = '>';
    v_cad_ini_fin = '</';
    v_cad_fin_fin = '>';

	v_cad=p_xml;
    v_tam=length(v_cad);
    
    loop
    	v_sub_cad='';
    	--Obtener la posicion del primer <
        v_pos_ini=strpos(v_cad,'<');
        --Obtener la posicion del primer >
        v_pos_fin=strpos(v_cad,'>');
        --Obtener la cadena siguiente del < hasta el >
        v_clave=substr(v_cad,v_pos_ini+1,v_pos_fin-2);
        --raise notice 'clave: %',v_clave;
        --Obtiene los nombres de las claves serializadas
        v_nom_clave_ini=v_cad_ini||v_clave||v_cad_fin;
        v_nom_clave_fin=v_cad_ini_fin||v_clave||v_cad_fin_fin;                
        --Obtiene el valor a partir de la clave
        v_sub_cad=f_obtiene_clave_valor(v_cad,v_clave,'','','valor');
        --Borrar de la cadena grande la cadena encontrada
        v_pos_fin=strpos(v_cad,v_nom_clave_fin);
        
        v_cad=substr(v_cad,v_pos_fin+length(v_nom_clave_fin),length(v_cad));
        --Guarda la subcadena en un array
        v_aux='"'||v_clave||'"'||':'||'"'||v_sub_cad||'"';
        v_array_claves=array_append(v_array_claves,v_aux);
        --raise exception '%',v_aux;
        exit when length(v_cad)=0;
    end loop;
    
    for i in 1..array_upper(v_array_claves,1) loop
    	--raise notice '%',v_array_claves[i];
        if i=1 then
        	v_resp = '{'||v_array_claves[i]||',';
        elsif i=array_upper(v_array_claves,1) then
        	v_resp = v_resp || v_array_claves[i] ||'}';
        else
        	v_resp = v_resp || v_array_claves[i]||',';
        end if;
    end loop;
    
    return v_resp;
    

END;
$$;


--
-- TOC entry 1125 (class 1255 OID 207504)
-- Dependencies: 23 3246
-- Name: f_runtime_config(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_runtime_config(p_variable character varying, p_ambito character varying, p_valor character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: 		public.f_runtime_config
 DESCRIPCION:   Cambia el valor de una variable de configuracion de postgresql.conf
                en tiempo de ejecucion
 AUTOR: 	    KPLIAN (jrr)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE
    v_nombre_funcion    varchar;
    v_resp              varchar;
BEGIN
    v_nombre_funcion='public.f_runtime_config';
    if(p_variable is null or p_ambito is null or p_valor is null)then
        raise exception 'Error al realizar configuracion en tiempo de ejecucion uno de los parametros esta vacio';
    end if;
    execute('SET '||p_ambito||' '||p_variable||' = '||p_valor);
    return 'exito';

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1151 (class 1255 OID 207505)
-- Dependencies: 23 3246
-- Name: f_validar_bloqueos(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_validar_bloqueos(p_id_usuario integer, p_ip character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: 		public.f_validar_bloqueos
 DESCRIPCION:   Verifica si un usuario tiene un bloqueo activo al momento de ejecutar
                una transaccion
 AUTOR: 	    KPLIAN (jrr)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE

BEGIN
    if(exists(  select 1
                from segu.tbloqueo_notificacion
                where id_usuario=p_id_usuario
                and aplicacion='usuario'
                and tipo='bloqueo'
                and estado_reg='activo' and fecha_hora_fin>now()))then
        raise exception 'Su cuenta ha sido bloqueada. Comuniquese con el administrador';
    end if;
    if(exists(  select 1
                from segu.tbloqueo_notificacion
                where ip=p_ip
                and aplicacion='ip'
                and tipo='bloqueo'
                and estado_reg='activo' and fecha_hora_fin>now()))then

        raise exception 'Su equipo ha sido bloqueado. Comuniquese con el administrador';

    end if;
    
    return 'exito';
END;
$$;


--
-- TOC entry 1848 (class 1255 OID 207506)
-- Dependencies: 3246 23
-- Name: f_verifica_permisos(integer, character varying, character varying, character varying[], character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION f_verifica_permisos(par_id_usuario integer, par_transaccion character varying, par_cod_gui character varying, par_ip_admin character varying[], par_ip character varying, OUT po_administrador boolean, OUT po_habilitar_log integer, OUT po_tiene_permisos boolean, OUT po_id_subsistema integer) RETURNS SETOF record
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/***************************************************************************
 DESCRIPCION:	Valida si el usuario tiene permiso para ejecutar la transaccion
 AUTOR:			 KPLIAN(jrr)
 FECHA:			 29-11-10
***************************************************************************/
declare
    v_descripcion   varchar;
begin


  -- 1) iniciamos los parametro
    
     po_administrador =FALSE; -- no es usuario administrador
     po_tiene_permisos = FALSE;  --los habilitado por defecto
     
  --2) verifica si es un usuario administrador, el administrador
  --   tiene permiso para ejecutar todas las transacciones 
  
   if exists(select 1 from segu.tusuario_rol ur where id_usuario=par_id_usuario and id_rol=1 and estado_reg='activo')then
       po_administrador:=true;
       po_tiene_permisos=true;
       
       --2.1) verificamos si la direccion IP del usuario administrador esta en la lista de los que pueden loguearse
       --si la lista de IP es nula no se plica esta verificacion 
       IF par_ip_admin is not null THEN
          IF  not ( ARRAY[par_ip] <@ par_ip_admin ) THEN        
               raise exception 'El usuario no tiene autorizacion para conectarse  desde %',par_ip;
          END IF;
       END IF;
    end if;
    
   -- 3) verifica si la transaccion se almacena en log
   
    select CASE  
           WHEN p.habilita_log = 'no'THEN
              0
           ELSE
              1
           END,
           p.descripcion,
           f.id_subsistema
    into po_habilitar_log,v_descripcion,po_id_subsistema
    from segu.tprocedimiento p
    inner join segu.tfuncion f
        on(f.id_funcion=p.id_funcion)
    where p.codigo = par_transaccion;
    
    if(po_habilitar_log is null)then
        po_habilitar_log=1;
    end if;
   
     -- po_habilitar_log  = true;
  
    
    
    --  4) si no es administrador verificamos si no es una trasaccion basica
         -- (todos tienen permisos para ejecutar las basicas)
         IF ((not po_tiene_permisos) and  (par_transaccion in  ('SEG_SESION_INS','SEG_SESION_SEL','SEG_SESION_CONT','SEG_VALUSU_SEG','SEG_OBTEPRI_SEL','SEG_OBTEPRI_CONT','SEG_MENU_SEL','PM_GENALA_INS'))) THEN
         
            po_tiene_permisos = true;
         
         END IF; 
         
 
    
    --5)  verifica si el usuario tiene permiso para ejecutar la transaccion
   
    if (not po_tiene_permisos) THEN
     
     
     --5.1) si el usuario no es administrador verificamos 
     --     si tiene permisos para ejecutar la transaccion 
    
           IF(    
            		SELECT 1 
                    FROM segu.tusuario_rol ur
                    INNER JOIN  segu.trol_procedimiento_gui  rpg
                      ON rpg.id_rol = ur.id_rol  and rpg.estado_reg = 'activo'
                    INNER JOIN segu.tprocedimiento_gui pg
                     ON  rpg.id_procedimiento_gui = pg.id_procedimiento_gui and pg.estado_reg = 'activo'
                    INNER JOIN segu.tprocedimiento p 
                     ON    p.id_procedimiento  = pg.id_procedimiento   and p.estado_reg = 'activo'
                    WHERE ur.id_usuario=par_id_usuario 
                       and  ur.estado_reg='activo' and
                       p.codigo = par_transaccion
                       limit 1) THEN
                    
              
              po_tiene_permisos = true;
              
           ELSE   
           --en caso contrario arojamos el error de permiso denegado
           
              raise exception 'Permiso denegado para la transaccion :  %',par_transaccion;
              
           END IF;
           
   END IF;
   
   RETURN NEXT;
   --RETURN;

   
   
end;
$$;


--
-- TOC entry 1152 (class 1255 OID 207507)
-- Dependencies: 2172 23
-- Name: factor(chip); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION factor(chip) RETURNS real
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getFactor';


--
-- TOC entry 1153 (class 1255 OID 207508)
-- Dependencies: 23 3246
-- Name: fbytea(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION fbytea(b character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		public.f_agrega_clave_multiple
 DESCRIPCION:   Anade varios parametros de respuesta a la cadena que se va a devolver al servidor
                Web
 AUTOR: 	    KPLIAN (rcm)	
 FECHA:	        02/06/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		
 ***************************************************************************/
DECLARE
	v_cad_ini varchar;

BEGIN
	

  
    
    EXECUTE ('insert into tbytea(bb) values('''||b||''')');

    return 'exito';
  
END;
$$;


--
-- TOC entry 1154 (class 1255 OID 207509)
-- Dependencies: 3246 23 2160
-- Name: find_extent(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent("' || columnname || '") FROM "' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;


--
-- TOC entry 1155 (class 1255 OID 207510)
-- Dependencies: 2160 23 3246
-- Name: find_extent(text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent("' || columnname || '") FROM "' || schemaname || '"."' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;


--
-- TOC entry 1156 (class 1255 OID 207511)
-- Dependencies: 3246 23
-- Name: find_srid(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schem text;
	tabl text;
	sr int4;
BEGIN
	IF $1 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - schema is NULL!';
	END IF;
	IF $2 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - table name is NULL!';
	END IF;
	IF $3 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - column name is NULL!';
	END IF;
	schem = $1;
	tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and tabl LIKE '%.%' ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	ELSE
	 schem = schem || '%';
	END IF;

	select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
	END IF;
	return sr;
END;
$_$;


--
-- TOC entry 1164 (class 1255 OID 207512)
-- Dependencies: 3246 23
-- Name: fix_geometry_columns(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION fix_geometry_columns() RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	mislinked record;
	result text;
	linked integer;
	deleted integer;
	foundschema integer;
BEGIN

	-- Since 7.3 schema support has been added.
	-- Previous postgis versions used to put the database name in
	-- the schema column. This needs to be fixed, so we try to
	-- set the correct schema for each geometry_colums record
	-- looking at table, column, type and srid.
	UPDATE geometry_columns SET f_table_schema = n.nspname
		FROM pg_namespace n, pg_class c, pg_attribute a,
			pg_constraint sridcheck, pg_constraint typecheck
			WHERE ( f_table_schema is NULL
		OR f_table_schema = ''
			OR f_table_schema NOT IN (
					SELECT nspname::varchar
					FROM pg_namespace nn, pg_class cc, pg_attribute aa
					WHERE cc.relnamespace = nn.oid
					AND cc.relname = f_table_name::name
					AND aa.attrelid = cc.oid
					AND aa.attname = f_geometry_column::name))
			AND f_table_name::name = c.relname
			AND c.oid = a.attrelid
			AND c.relnamespace = n.oid
			AND f_geometry_column::name = a.attname

			AND sridcheck.conrelid = c.oid
		AND sridcheck.consrc LIKE '(srid(% = %)'
			AND sridcheck.consrc ~ textcat(' = ', srid::text)

			AND typecheck.conrelid = c.oid
		AND typecheck.consrc LIKE
		'((geometrytype(%) = ''%''::text) OR (% IS NULL))'
			AND typecheck.consrc ~ textcat(' = ''', type::text)

			AND NOT EXISTS (
					SELECT oid FROM geometry_columns gc
					WHERE c.relname::varchar = gc.f_table_name
					AND n.nspname::varchar = gc.f_table_schema
					AND a.attname::varchar = gc.f_geometry_column
			);

	GET DIAGNOSTICS foundschema = ROW_COUNT;

	-- no linkage to system table needed
	return 'fixed:'||foundschema::text;

END;
$$;


--
-- TOC entry 1165 (class 1255 OID 207513)
-- Dependencies: 2189 23 2189
-- Name: force_2d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION force_2d(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_2d';


--
-- TOC entry 1166 (class 1255 OID 207514)
-- Dependencies: 2189 23 2189
-- Name: force_3d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION force_3d(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_3dz';


--
-- TOC entry 1167 (class 1255 OID 207515)
-- Dependencies: 23 2189 2189
-- Name: force_3dm(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION force_3dm(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_3dm';


--
-- TOC entry 1168 (class 1255 OID 207516)
-- Dependencies: 2189 2189 23
-- Name: force_3dz(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION force_3dz(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_3dz';


--
-- TOC entry 1169 (class 1255 OID 207517)
-- Dependencies: 2189 23 2189
-- Name: force_4d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION force_4d(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_4d';


--
-- TOC entry 1170 (class 1255 OID 207518)
-- Dependencies: 2189 23 2189
-- Name: force_collection(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION force_collection(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_collection';


--
-- TOC entry 1171 (class 1255 OID 207519)
-- Dependencies: 2189 23 2189
-- Name: forcerhr(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION forcerhr(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_forceRHR_poly';


--
-- TOC entry 1172 (class 1255 OID 207520)
-- Dependencies: 23
-- Name: g_int_compress(internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION g_int_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_int_compress';


--
-- TOC entry 1173 (class 1255 OID 207521)
-- Dependencies: 23
-- Name: g_int_consistent(internal, integer[], integer, oid, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION g_int_consistent(internal, integer[], integer, oid, internal) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_int_consistent';


--
-- TOC entry 1174 (class 1255 OID 207522)
-- Dependencies: 23
-- Name: g_int_decompress(internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION g_int_decompress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_int_decompress';


--
-- TOC entry 1175 (class 1255 OID 207523)
-- Dependencies: 23
-- Name: g_int_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION g_int_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_int_penalty';


--
-- TOC entry 1176 (class 1255 OID 207524)
-- Dependencies: 23
-- Name: g_int_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION g_int_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_int_picksplit';


--
-- TOC entry 1177 (class 1255 OID 207525)
-- Dependencies: 23
-- Name: g_int_same(integer[], integer[], internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION g_int_same(integer[], integer[], internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_int_same';


--
-- TOC entry 1178 (class 1255 OID 207526)
-- Dependencies: 23
-- Name: g_int_union(internal, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION g_int_union(internal, internal) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_int_union';


--
-- TOC entry 1179 (class 1255 OID 207527)
-- Dependencies: 23
-- Name: g_intbig_compress(internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION g_intbig_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_intbig_compress';


--
-- TOC entry 1180 (class 1255 OID 207528)
-- Dependencies: 23
-- Name: g_intbig_consistent(internal, internal, integer, oid, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION g_intbig_consistent(internal, internal, integer, oid, internal) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_intbig_consistent';


--
-- TOC entry 1181 (class 1255 OID 207529)
-- Dependencies: 23
-- Name: g_intbig_decompress(internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION g_intbig_decompress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_intbig_decompress';


--
-- TOC entry 1182 (class 1255 OID 207530)
-- Dependencies: 23
-- Name: g_intbig_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION g_intbig_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_intbig_penalty';


--
-- TOC entry 1183 (class 1255 OID 207531)
-- Dependencies: 23
-- Name: g_intbig_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION g_intbig_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_intbig_picksplit';


--
-- TOC entry 1184 (class 1255 OID 207532)
-- Dependencies: 23
-- Name: g_intbig_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION g_intbig_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_intbig_same';


--
-- TOC entry 1185 (class 1255 OID 207533)
-- Dependencies: 23
-- Name: g_intbig_union(internal, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION g_intbig_union(internal, internal) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'g_intbig_union';


--
-- TOC entry 1186 (class 1255 OID 207534)
-- Dependencies: 2185 2189 23
-- Name: geography(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography(geometry) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_from_geometry';


--
-- TOC entry 1187 (class 1255 OID 207535)
-- Dependencies: 2185 2185 23
-- Name: geography(geography, integer, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography(geography, integer, boolean) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_enforce_typmod';


--
-- TOC entry 1188 (class 1255 OID 207536)
-- Dependencies: 2185 2185 23
-- Name: geography_cmp(geography, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_cmp(geography, geography) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_cmp';


--
-- TOC entry 1189 (class 1255 OID 207537)
-- Dependencies: 23 2185 2185
-- Name: geography_eq(geography, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_eq(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_eq';


--
-- TOC entry 1190 (class 1255 OID 207538)
-- Dependencies: 2185 23 2185
-- Name: geography_ge(geography, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_ge(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_ge';


--
-- TOC entry 1191 (class 1255 OID 207539)
-- Dependencies: 23
-- Name: geography_gist_compress(internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_gist_compress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_compress';


--
-- TOC entry 1192 (class 1255 OID 207540)
-- Dependencies: 23 2189
-- Name: geography_gist_consistent(internal, geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_gist_consistent(internal, geometry, integer) RETURNS boolean
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_consistent';


--
-- TOC entry 1193 (class 1255 OID 207541)
-- Dependencies: 23
-- Name: geography_gist_decompress(internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_gist_decompress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_decompress';


--
-- TOC entry 1194 (class 1255 OID 207542)
-- Dependencies: 23
-- Name: geography_gist_join_selectivity(internal, oid, internal, smallint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_gist_join_selectivity(internal, oid, internal, smallint) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_join_selectivity';


--
-- TOC entry 1094 (class 1255 OID 207543)
-- Dependencies: 23
-- Name: geography_gist_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_gist_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_penalty';


--
-- TOC entry 1095 (class 1255 OID 207544)
-- Dependencies: 23
-- Name: geography_gist_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_gist_picksplit(internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_picksplit';


--
-- TOC entry 1096 (class 1255 OID 207545)
-- Dependencies: 2160 2160 23
-- Name: geography_gist_same(box2d, box2d, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_gist_same(box2d, box2d, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_same';


--
-- TOC entry 1097 (class 1255 OID 207546)
-- Dependencies: 23
-- Name: geography_gist_selectivity(internal, oid, internal, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_gist_selectivity(internal, oid, internal, integer) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_selectivity';


--
-- TOC entry 1098 (class 1255 OID 207547)
-- Dependencies: 23
-- Name: geography_gist_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_gist_union(bytea, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'geography_gist_union';


--
-- TOC entry 1099 (class 1255 OID 207548)
-- Dependencies: 2185 2185 23
-- Name: geography_gt(geography, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_gt(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_gt';


--
-- TOC entry 1100 (class 1255 OID 207549)
-- Dependencies: 2185 2185 23
-- Name: geography_le(geography, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_le(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_le';


--
-- TOC entry 1101 (class 1255 OID 207550)
-- Dependencies: 2185 2185 23
-- Name: geography_lt(geography, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_lt(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_lt';


--
-- TOC entry 1102 (class 1255 OID 207551)
-- Dependencies: 2185 2185 23
-- Name: geography_overlaps(geography, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_overlaps(geography, geography) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_overlaps';


--
-- TOC entry 1112 (class 1255 OID 207552)
-- Dependencies: 23
-- Name: geography_typmod_dims(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_typmod_dims(integer) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_typmod_dims';


--
-- TOC entry 1113 (class 1255 OID 207553)
-- Dependencies: 23
-- Name: geography_typmod_srid(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_typmod_srid(integer) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_typmod_srid';


--
-- TOC entry 1114 (class 1255 OID 207554)
-- Dependencies: 23
-- Name: geography_typmod_type(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geography_typmod_type(integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_typmod_type';


--
-- TOC entry 1115 (class 1255 OID 207555)
-- Dependencies: 23 2189
-- Name: geomcollfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geomcollfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(GeomFromText($1)) = 'GEOMETRYCOLLECTION'
	THEN GeomFromText($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1116 (class 1255 OID 207556)
-- Dependencies: 23 2189
-- Name: geomcollfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geomcollfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(GeomFromText($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1117 (class 1255 OID 207557)
-- Dependencies: 2189 23
-- Name: geomcollfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geomcollfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(GeomFromWKB($1)) = 'GEOMETRYCOLLECTION'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1118 (class 1255 OID 207558)
-- Dependencies: 2189 23
-- Name: geomcollfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geomcollfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(GeomFromWKB($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1119 (class 1255 OID 207559)
-- Dependencies: 2189 2168 23
-- Name: geometry(box3d_extent); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry(box3d_extent) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_LWGEOM';


--
-- TOC entry 1120 (class 1255 OID 207560)
-- Dependencies: 2189 2160 23
-- Name: geometry(box2d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry(box2d) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_to_LWGEOM';


--
-- TOC entry 1121 (class 1255 OID 207561)
-- Dependencies: 2189 2164 23
-- Name: geometry(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry(box3d) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_LWGEOM';


--
-- TOC entry 1122 (class 1255 OID 207562)
-- Dependencies: 2189 23
-- Name: geometry(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'parse_WKT_lwgeom';


--
-- TOC entry 1123 (class 1255 OID 207563)
-- Dependencies: 2189 2172 23
-- Name: geometry(chip); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry(chip) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_to_LWGEOM';


--
-- TOC entry 1126 (class 1255 OID 207564)
-- Dependencies: 2189 23
-- Name: geometry(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_bytea';


--
-- TOC entry 1127 (class 1255 OID 207565)
-- Dependencies: 2189 2185 23
-- Name: geometry(geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry(geography) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geometry_from_geography';


--
-- TOC entry 1128 (class 1255 OID 207566)
-- Dependencies: 23 2189 2189
-- Name: geometry_above(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_above(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_above';


--
-- TOC entry 1129 (class 1255 OID 207567)
-- Dependencies: 2189 23 2189
-- Name: geometry_below(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_below(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_below';


--
-- TOC entry 1130 (class 1255 OID 207568)
-- Dependencies: 23 2189 2189
-- Name: geometry_cmp(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_cmp(geometry, geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_cmp';


--
-- TOC entry 1131 (class 1255 OID 207569)
-- Dependencies: 2189 2189 23
-- Name: geometry_contain(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_contain(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_contain';


--
-- TOC entry 1132 (class 1255 OID 207570)
-- Dependencies: 2189 2189 23
-- Name: geometry_contained(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_contained(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_contained';


--
-- TOC entry 1133 (class 1255 OID 207571)
-- Dependencies: 2189 2189 23
-- Name: geometry_eq(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_eq(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_eq';


--
-- TOC entry 1134 (class 1255 OID 207572)
-- Dependencies: 2189 2189 23
-- Name: geometry_ge(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_ge(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_ge';


--
-- TOC entry 1135 (class 1255 OID 207573)
-- Dependencies: 23
-- Name: geometry_gist_joinsel(internal, oid, internal, smallint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_gist_joinsel(internal, oid, internal, smallint) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_joinsel';


--
-- TOC entry 1136 (class 1255 OID 207574)
-- Dependencies: 23
-- Name: geometry_gist_sel(internal, oid, internal, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_gist_sel(internal, oid, internal, integer) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_sel';


--
-- TOC entry 1137 (class 1255 OID 207575)
-- Dependencies: 2189 23 2189
-- Name: geometry_gt(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_gt(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_gt';


--
-- TOC entry 1138 (class 1255 OID 207576)
-- Dependencies: 2189 23 2189
-- Name: geometry_le(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_le(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_le';


--
-- TOC entry 1139 (class 1255 OID 207577)
-- Dependencies: 2189 23 2189
-- Name: geometry_left(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_left(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_left';


--
-- TOC entry 1140 (class 1255 OID 207578)
-- Dependencies: 2189 23 2189
-- Name: geometry_lt(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_lt(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_lt';


--
-- TOC entry 1141 (class 1255 OID 207579)
-- Dependencies: 23 2189 2189
-- Name: geometry_overabove(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_overabove(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overabove';


--
-- TOC entry 1142 (class 1255 OID 207580)
-- Dependencies: 2189 23 2189
-- Name: geometry_overbelow(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_overbelow(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overbelow';


--
-- TOC entry 1143 (class 1255 OID 207581)
-- Dependencies: 2189 23 2189
-- Name: geometry_overlap(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_overlap(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overlap';


--
-- TOC entry 1144 (class 1255 OID 207582)
-- Dependencies: 2189 23 2189
-- Name: geometry_overleft(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_overleft(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overleft';


--
-- TOC entry 1145 (class 1255 OID 207583)
-- Dependencies: 2189 23 2189
-- Name: geometry_overright(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_overright(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overright';


--
-- TOC entry 1146 (class 1255 OID 207584)
-- Dependencies: 2189 23 2189
-- Name: geometry_right(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_right(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_right';


--
-- TOC entry 1147 (class 1255 OID 207585)
-- Dependencies: 2189 23 2189
-- Name: geometry_same(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_same(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_samebox';


--
-- TOC entry 1148 (class 1255 OID 207586)
-- Dependencies: 2189 23 2189
-- Name: geometry_samebox(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometry_samebox(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_samebox';


--
-- TOC entry 1149 (class 1255 OID 207587)
-- Dependencies: 23 2189
-- Name: geometryfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometryfromtext(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_text';


--
-- TOC entry 1150 (class 1255 OID 207588)
-- Dependencies: 23 2189
-- Name: geometryfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometryfromtext(text, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_text';


--
-- TOC entry 1157 (class 1255 OID 207589)
-- Dependencies: 23 2189 2189
-- Name: geometryn(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometryn(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_geometryn_collection';


--
-- TOC entry 1158 (class 1255 OID 207590)
-- Dependencies: 23 2189
-- Name: geometrytype(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geometrytype(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_getTYPE';


--
-- TOC entry 1159 (class 1255 OID 207591)
-- Dependencies: 23 2189
-- Name: geomfromewkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geomfromewkb(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOMFromWKB';


--
-- TOC entry 1160 (class 1255 OID 207592)
-- Dependencies: 2189 23
-- Name: geomfromewkt(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geomfromewkt(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'parse_WKT_lwgeom';


--
-- TOC entry 1161 (class 1255 OID 207593)
-- Dependencies: 23 2189
-- Name: geomfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geomfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT geometryfromtext($1)$_$;


--
-- TOC entry 1162 (class 1255 OID 207594)
-- Dependencies: 23 2189
-- Name: geomfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geomfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT geometryfromtext($1, $2)$_$;


--
-- TOC entry 1163 (class 1255 OID 207595)
-- Dependencies: 23 2189
-- Name: geomfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geomfromwkb(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_WKB';


--
-- TOC entry 863 (class 1255 OID 207596)
-- Dependencies: 23 2189
-- Name: geomfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geomfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT setSRID(GeomFromWKB($1), $2)$_$;


--
-- TOC entry 864 (class 1255 OID 207597)
-- Dependencies: 2189 23 2189 2189
-- Name: geomunion(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION geomunion(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geomunion';


--
-- TOC entry 865 (class 1255 OID 207598)
-- Dependencies: 23 3246
-- Name: get_proj4_from_srid(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;


--
-- TOC entry 866 (class 1255 OID 207599)
-- Dependencies: 2160 23 2189
-- Name: getbbox(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION getbbox(geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_BOX2DFLOAT4';


--
-- TOC entry 867 (class 1255 OID 207600)
-- Dependencies: 2189 23
-- Name: getsrid(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION getsrid(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_getSRID';


--
-- TOC entry 872 (class 1255 OID 207601)
-- Dependencies: 23
-- Name: gettransactionid(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION gettransactionid() RETURNS xid
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'getTransactionID';


--
-- TOC entry 873 (class 1255 OID 207602)
-- Dependencies: 23
-- Name: ginint4_consistent(internal, smallint, internal, integer, internal, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION ginint4_consistent(internal, smallint, internal, integer, internal, internal) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'ginint4_consistent';


--
-- TOC entry 874 (class 1255 OID 207603)
-- Dependencies: 23
-- Name: ginint4_queryextract(internal, internal, smallint, internal, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION ginint4_queryextract(internal, internal, smallint, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'ginint4_queryextract';


--
-- TOC entry 875 (class 1255 OID 207604)
-- Dependencies: 23 2189
-- Name: hasbbox(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION hasbbox(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_hasBBOX';


--
-- TOC entry 876 (class 1255 OID 207605)
-- Dependencies: 2172 23
-- Name: height(chip); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION height(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getHeight';


--
-- TOC entry 877 (class 1255 OID 207606)
-- Dependencies: 23
-- Name: icount(integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION icount(integer[]) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'icount';


--
-- TOC entry 878 (class 1255 OID 207607)
-- Dependencies: 23
-- Name: idx(integer[], integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION idx(integer[], integer) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'idx';


--
-- TOC entry 879 (class 1255 OID 207608)
-- Dependencies: 23
-- Name: intarray_del_elem(integer[], integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION intarray_del_elem(integer[], integer) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'intarray_del_elem';


--
-- TOC entry 880 (class 1255 OID 207609)
-- Dependencies: 23
-- Name: intarray_push_array(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION intarray_push_array(integer[], integer[]) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'intarray_push_array';


--
-- TOC entry 886 (class 1255 OID 207610)
-- Dependencies: 23
-- Name: intarray_push_elem(integer[], integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION intarray_push_elem(integer[], integer) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'intarray_push_elem';


--
-- TOC entry 887 (class 1255 OID 207611)
-- Dependencies: 23 3246
-- Name: intconcat(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION intconcat(integer, integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
begin
  if $1 is null then
    return $2;
  end if;
  if $2 is null then
    return $1;
  end if;
  return $1 || ',' || $2;
end
$_$;


--
-- TOC entry 888 (class 1255 OID 207612)
-- Dependencies: 23 2189 2189
-- Name: interiorringn(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION interiorringn(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_interiorringn_polygon';


--
-- TOC entry 889 (class 1255 OID 207613)
-- Dependencies: 23 2189 2189 2189
-- Name: intersection(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION intersection(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'intersection';


--
-- TOC entry 890 (class 1255 OID 207614)
-- Dependencies: 2189 23 2189
-- Name: intersects(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION intersects(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'intersects';


--
-- TOC entry 891 (class 1255 OID 207615)
-- Dependencies: 23
-- Name: intset(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION intset(integer) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'intset';


--
-- TOC entry 892 (class 1255 OID 207616)
-- Dependencies: 23
-- Name: intset_subtract(integer[], integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION intset_subtract(integer[], integer[]) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'intset_subtract';


--
-- TOC entry 893 (class 1255 OID 207617)
-- Dependencies: 23
-- Name: intset_union_elem(integer[], integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION intset_union_elem(integer[], integer) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'intset_union_elem';


--
-- TOC entry 894 (class 1255 OID 207618)
-- Dependencies: 23 2189
-- Name: isclosed(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION isclosed(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_isclosed_linestring';


--
-- TOC entry 900 (class 1255 OID 207619)
-- Dependencies: 23 2189
-- Name: isempty(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION isempty(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_isempty';


--
-- TOC entry 901 (class 1255 OID 207620)
-- Dependencies: 23 2189
-- Name: isring(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION isring(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'isring';


--
-- TOC entry 902 (class 1255 OID 207621)
-- Dependencies: 23 2189
-- Name: issimple(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION issimple(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'issimple';


--
-- TOC entry 903 (class 1255 OID 207622)
-- Dependencies: 23 2189
-- Name: isvalid(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION isvalid(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'isvalid';


--
-- TOC entry 920 (class 1255 OID 207623)
-- Dependencies: 23 2189
-- Name: length(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION length(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_length_linestring';


--
-- TOC entry 925 (class 1255 OID 207624)
-- Dependencies: 23 2189
-- Name: length2d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION length2d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_length2d_linestring';


--
-- TOC entry 926 (class 1255 OID 207625)
-- Dependencies: 23 2189 2212
-- Name: length2d_spheroid(geometry, spheroid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION length2d_spheroid(geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_length2d_ellipsoid';


--
-- TOC entry 927 (class 1255 OID 207626)
-- Dependencies: 2189 23
-- Name: length3d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION length3d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_length_linestring';


--
-- TOC entry 928 (class 1255 OID 207627)
-- Dependencies: 2189 23 2212
-- Name: length3d_spheroid(geometry, spheroid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION length3d_spheroid(geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_length_ellipsoid_linestring';


--
-- TOC entry 929 (class 1255 OID 207628)
-- Dependencies: 2189 23 2212
-- Name: length_spheroid(geometry, spheroid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION length_spheroid(geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_length_ellipsoid_linestring';


--
-- TOC entry 930 (class 1255 OID 207629)
-- Dependencies: 23 2189 2189
-- Name: line_interpolate_point(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION line_interpolate_point(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_interpolate_point';


--
-- TOC entry 936 (class 1255 OID 207630)
-- Dependencies: 2189 23 2189
-- Name: line_locate_point(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION line_locate_point(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_locate_point';


--
-- TOC entry 937 (class 1255 OID 207631)
-- Dependencies: 2189 23 2189
-- Name: line_substring(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION line_substring(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_substring';


--
-- TOC entry 938 (class 1255 OID 207632)
-- Dependencies: 23 2189 2189
-- Name: linefrommultipoint(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION linefrommultipoint(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_from_mpoint';


--
-- TOC entry 946 (class 1255 OID 207633)
-- Dependencies: 23 2189
-- Name: linefromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION linefromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'LINESTRING'
	THEN GeomFromText($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 964 (class 1255 OID 207634)
-- Dependencies: 23 2189
-- Name: linefromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION linefromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'LINESTRING'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


--
-- TOC entry 971 (class 1255 OID 207635)
-- Dependencies: 23 2189
-- Name: linefromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION linefromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'LINESTRING'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 977 (class 1255 OID 207636)
-- Dependencies: 23 2189
-- Name: linefromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION linefromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 978 (class 1255 OID 207637)
-- Dependencies: 23 2189 2189
-- Name: linemerge(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION linemerge(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'linemerge';


--
-- TOC entry 979 (class 1255 OID 207638)
-- Dependencies: 2189 23
-- Name: linestringfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION linestringfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT LineFromText($1)$_$;


--
-- TOC entry 980 (class 1255 OID 207639)
-- Dependencies: 23 2189
-- Name: linestringfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION linestringfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT LineFromText($1, $2)$_$;


--
-- TOC entry 985 (class 1255 OID 207640)
-- Dependencies: 2189 23
-- Name: linestringfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION linestringfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'LINESTRING'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 986 (class 1255 OID 207641)
-- Dependencies: 23 2189
-- Name: linestringfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION linestringfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 987 (class 1255 OID 207642)
-- Dependencies: 23 2189 2189
-- Name: locate_along_measure(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION locate_along_measure(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT locate_between_measures($1, $2, $2) $_$;


--
-- TOC entry 988 (class 1255 OID 207643)
-- Dependencies: 23 2189 2189
-- Name: locate_between_measures(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION locate_between_measures(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_locate_between_m';


--
-- TOC entry 989 (class 1255 OID 207644)
-- Dependencies: 23
-- Name: lockrow(text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION lockrow(text, text, text) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT LockRow(current_schema(), $1, $2, $3, now()::timestamp+'1:00'); $_$;


--
-- TOC entry 990 (class 1255 OID 207645)
-- Dependencies: 23
-- Name: lockrow(text, text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION lockrow(text, text, text, text) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT LockRow($1, $2, $3, $4, now()::timestamp+'1:00'); $_$;


--
-- TOC entry 991 (class 1255 OID 207646)
-- Dependencies: 23
-- Name: lockrow(text, text, text, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION lockrow(text, text, text, timestamp without time zone) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT LockRow(current_schema(), $1, $2, $3, $4); $_$;


--
-- TOC entry 1195 (class 1255 OID 207647)
-- Dependencies: 3246 23
-- Name: lockrow(text, text, text, text, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION lockrow(text, text, text, text, timestamp without time zone) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $_$ 
DECLARE
	myschema alias for $1;
	mytable alias for $2;
	myrid   alias for $3;
	authid alias for $4;
	expires alias for $5;
	ret int;
	mytoid oid;
	myrec RECORD;
	
BEGIN

	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	EXECUTE 'DELETE FROM authorization_table WHERE expires < now()'; 

	SELECT c.oid INTO mytoid FROM pg_class c, pg_namespace n
		WHERE c.relname = mytable
		AND c.relnamespace = n.oid
		AND n.nspname = myschema;

	-- RAISE NOTICE 'toid: %', mytoid;

	FOR myrec IN SELECT * FROM authorization_table WHERE 
		toid = mytoid AND rid = myrid
	LOOP
		IF myrec.authid != authid THEN
			RETURN 0;
		ELSE
			RETURN 1;
		END IF;
	END LOOP;

	EXECUTE 'INSERT INTO authorization_table VALUES ('||
		quote_literal(mytoid::text)||','||quote_literal(myrid)||
		','||quote_literal(expires::text)||
		','||quote_literal(authid) ||')';

	GET DIAGNOSTICS ret = ROW_COUNT;

	RETURN ret;
END;
$_$;


--
-- TOC entry 1196 (class 1255 OID 207648)
-- Dependencies: 23 3246
-- Name: longtransactionsenabled(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$;


--
-- TOC entry 1197 (class 1255 OID 207649)
-- Dependencies: 23
-- Name: lwgeom_gist_compress(internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION lwgeom_gist_compress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_compress';


--
-- TOC entry 1198 (class 1255 OID 207650)
-- Dependencies: 23 2189
-- Name: lwgeom_gist_consistent(internal, geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION lwgeom_gist_consistent(internal, geometry, integer) RETURNS boolean
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_consistent';


--
-- TOC entry 1199 (class 1255 OID 207651)
-- Dependencies: 23
-- Name: lwgeom_gist_decompress(internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION lwgeom_gist_decompress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_decompress';


--
-- TOC entry 1200 (class 1255 OID 207652)
-- Dependencies: 23
-- Name: lwgeom_gist_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION lwgeom_gist_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_penalty';


--
-- TOC entry 1201 (class 1255 OID 207653)
-- Dependencies: 23
-- Name: lwgeom_gist_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION lwgeom_gist_picksplit(internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_picksplit';


--
-- TOC entry 1202 (class 1255 OID 207654)
-- Dependencies: 23 2160 2160
-- Name: lwgeom_gist_same(box2d, box2d, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION lwgeom_gist_same(box2d, box2d, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_same';


--
-- TOC entry 1203 (class 1255 OID 207655)
-- Dependencies: 23
-- Name: lwgeom_gist_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION lwgeom_gist_union(bytea, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_union';


--
-- TOC entry 1204 (class 1255 OID 207656)
-- Dependencies: 2189 23
-- Name: m(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION m(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_m_point';


--
-- TOC entry 1205 (class 1255 OID 207657)
-- Dependencies: 23 2160 2189 2189
-- Name: makebox2d(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION makebox2d(geometry, geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_construct';


--
-- TOC entry 1206 (class 1255 OID 207658)
-- Dependencies: 2164 2189 2189 23
-- Name: makebox3d(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION makebox3d(geometry, geometry) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_construct';


--
-- TOC entry 1207 (class 1255 OID 207659)
-- Dependencies: 2189 2189 23 2189
-- Name: makeline(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION makeline(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makeline';


--
-- TOC entry 1208 (class 1255 OID 207660)
-- Dependencies: 2191 23 2189
-- Name: makeline_garray(geometry[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION makeline_garray(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makeline_garray';


--
-- TOC entry 1209 (class 1255 OID 207661)
-- Dependencies: 2189 23
-- Name: makepoint(double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION makepoint(double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint';


--
-- TOC entry 1210 (class 1255 OID 207662)
-- Dependencies: 2189 23
-- Name: makepoint(double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION makepoint(double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint';


--
-- TOC entry 1211 (class 1255 OID 207663)
-- Dependencies: 23 2189
-- Name: makepoint(double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION makepoint(double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint';


--
-- TOC entry 1212 (class 1255 OID 207664)
-- Dependencies: 2189 23
-- Name: makepointm(double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION makepointm(double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint3dm';


--
-- TOC entry 1213 (class 1255 OID 207665)
-- Dependencies: 23 2189 2189
-- Name: makepolygon(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION makepolygon(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoly';


--
-- TOC entry 1214 (class 1255 OID 207666)
-- Dependencies: 2189 2189 23 2191
-- Name: makepolygon(geometry, geometry[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION makepolygon(geometry, geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoly';


--
-- TOC entry 1215 (class 1255 OID 207667)
-- Dependencies: 2189 2189 23
-- Name: max_distance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION max_distance(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_maxdistance2d_linestring';


--
-- TOC entry 1216 (class 1255 OID 207668)
-- Dependencies: 23 2189
-- Name: mem_size(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION mem_size(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_mem_size';


--
-- TOC entry 1217 (class 1255 OID 207669)
-- Dependencies: 23 2189
-- Name: mlinefromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION mlinefromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'MULTILINESTRING'
	THEN GeomFromText($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1218 (class 1255 OID 207670)
-- Dependencies: 23 2189
-- Name: mlinefromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION mlinefromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(GeomFromText($1, $2)) = 'MULTILINESTRING'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1219 (class 1255 OID 207671)
-- Dependencies: 23 2189
-- Name: mlinefromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION mlinefromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1220 (class 1255 OID 207672)
-- Dependencies: 23 2189
-- Name: mlinefromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION mlinefromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'MULTILINESTRING'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1221 (class 1255 OID 207673)
-- Dependencies: 23
-- Name: monitor_phx(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION monitor_phx(integer) RETURNS integer
    LANGUAGE c STRICT
    AS '/usr/local/lib/phx.so', 'monitor_phx';


--
-- TOC entry 1222 (class 1255 OID 207674)
-- Dependencies: 23 2189
-- Name: mpointfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION mpointfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'MULTIPOINT'
	THEN GeomFromText($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1223 (class 1255 OID 207675)
-- Dependencies: 23 2189
-- Name: mpointfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION mpointfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1,$2)) = 'MULTIPOINT'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1224 (class 1255 OID 207676)
-- Dependencies: 23 2189
-- Name: mpointfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION mpointfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTIPOINT'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1036 (class 1255 OID 207677)
-- Dependencies: 23 2189
-- Name: mpointfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION mpointfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1,$2)) = 'MULTIPOINT'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1037 (class 1255 OID 207678)
-- Dependencies: 23 2189
-- Name: mpolyfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION mpolyfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'MULTIPOLYGON'
	THEN GeomFromText($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1041 (class 1255 OID 207679)
-- Dependencies: 2189 23
-- Name: mpolyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION mpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'MULTIPOLYGON'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1042 (class 1255 OID 207680)
-- Dependencies: 23 2189
-- Name: mpolyfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION mpolyfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTIPOLYGON'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1043 (class 1255 OID 207681)
-- Dependencies: 23 2189
-- Name: mpolyfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION mpolyfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1044 (class 1255 OID 207682)
-- Dependencies: 2189 23 2189
-- Name: multi(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION multi(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_multi';


--
-- TOC entry 1045 (class 1255 OID 207683)
-- Dependencies: 23 2189
-- Name: multilinefromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION multilinefromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1046 (class 1255 OID 207684)
-- Dependencies: 23 2189
-- Name: multilinefromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION multilinefromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'MULTILINESTRING'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1047 (class 1255 OID 207685)
-- Dependencies: 2189 23
-- Name: multilinestringfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION multilinestringfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_MLineFromText($1)$_$;


--
-- TOC entry 1048 (class 1255 OID 207686)
-- Dependencies: 23 2189
-- Name: multilinestringfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION multilinestringfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MLineFromText($1, $2)$_$;


--
-- TOC entry 1049 (class 1255 OID 207687)
-- Dependencies: 23 2189
-- Name: multipointfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION multipointfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MPointFromText($1)$_$;


--
-- TOC entry 1050 (class 1255 OID 207688)
-- Dependencies: 23 2189
-- Name: multipointfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION multipointfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MPointFromText($1, $2)$_$;


--
-- TOC entry 1051 (class 1255 OID 207689)
-- Dependencies: 23 2189
-- Name: multipointfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION multipointfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTIPOINT'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1052 (class 1255 OID 207690)
-- Dependencies: 23 2189
-- Name: multipointfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION multipointfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1,$2)) = 'MULTIPOINT'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1053 (class 1255 OID 207691)
-- Dependencies: 23 2189
-- Name: multipolyfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION multipolyfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'MULTIPOLYGON'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1054 (class 1255 OID 207692)
-- Dependencies: 23 2189
-- Name: multipolyfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION multipolyfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1055 (class 1255 OID 207693)
-- Dependencies: 23 2189
-- Name: multipolygonfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION multipolygonfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MPolyFromText($1)$_$;


--
-- TOC entry 1056 (class 1255 OID 207694)
-- Dependencies: 23 2189
-- Name: multipolygonfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION multipolygonfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MPolyFromText($1, $2)$_$;


--
-- TOC entry 1057 (class 1255 OID 207695)
-- Dependencies: 23 2189
-- Name: ndims(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION ndims(geometry) RETURNS smallint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_ndims';


--
-- TOC entry 1058 (class 1255 OID 207696)
-- Dependencies: 23 2189 2189
-- Name: noop(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION noop(geometry) RETURNS geometry
    LANGUAGE c STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_noop';


--
-- TOC entry 1059 (class 1255 OID 207697)
-- Dependencies: 23 2189
-- Name: npoints(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION npoints(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_npoints';


--
-- TOC entry 1060 (class 1255 OID 207698)
-- Dependencies: 23 2189
-- Name: nrings(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION nrings(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_nrings';


--
-- TOC entry 1061 (class 1255 OID 207699)
-- Dependencies: 23 2189
-- Name: numgeometries(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION numgeometries(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_numgeometries_collection';


--
-- TOC entry 1066 (class 1255 OID 207700)
-- Dependencies: 23 2189
-- Name: numinteriorring(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION numinteriorring(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_numinteriorrings_polygon';


--
-- TOC entry 1067 (class 1255 OID 207701)
-- Dependencies: 23 2189
-- Name: numinteriorrings(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION numinteriorrings(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_numinteriorrings_polygon';


--
-- TOC entry 1068 (class 1255 OID 207702)
-- Dependencies: 23 2189
-- Name: numpoints(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION numpoints(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_numpoints_linestring';


--
-- TOC entry 1069 (class 1255 OID 207703)
-- Dependencies: 23 2189 2189
-- Name: overlaps(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION "overlaps"(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'overlaps';


--
-- TOC entry 1070 (class 1255 OID 207704)
-- Dependencies: 23 2189
-- Name: perimeter(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION perimeter(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_perimeter_poly';


--
-- TOC entry 1071 (class 1255 OID 207705)
-- Dependencies: 23 2189
-- Name: perimeter2d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION perimeter2d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_perimeter2d_poly';


--
-- TOC entry 1072 (class 1255 OID 207706)
-- Dependencies: 23 2189
-- Name: perimeter3d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION perimeter3d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_perimeter_poly';


--
-- TOC entry 1073 (class 1255 OID 207707)
-- Dependencies: 23 2191 2204
-- Name: pgis_geometry_accum_finalfn(pgis_abs); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pgis_geometry_accum_finalfn(pgis_abs) RETURNS geometry[]
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'pgis_geometry_accum_finalfn';


--
-- TOC entry 1074 (class 1255 OID 207708)
-- Dependencies: 23 2204 2204 2189
-- Name: pgis_geometry_accum_transfn(pgis_abs, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pgis_geometry_accum_transfn(pgis_abs, geometry) RETURNS pgis_abs
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'pgis_geometry_accum_transfn';


--
-- TOC entry 1075 (class 1255 OID 207709)
-- Dependencies: 23 2189 2204
-- Name: pgis_geometry_collect_finalfn(pgis_abs); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pgis_geometry_collect_finalfn(pgis_abs) RETURNS geometry
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'pgis_geometry_collect_finalfn';


--
-- TOC entry 1076 (class 1255 OID 207710)
-- Dependencies: 23 2189 2204
-- Name: pgis_geometry_makeline_finalfn(pgis_abs); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pgis_geometry_makeline_finalfn(pgis_abs) RETURNS geometry
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'pgis_geometry_makeline_finalfn';


--
-- TOC entry 1082 (class 1255 OID 207711)
-- Dependencies: 23 2189 2204
-- Name: pgis_geometry_polygonize_finalfn(pgis_abs); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pgis_geometry_polygonize_finalfn(pgis_abs) RETURNS geometry
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'pgis_geometry_polygonize_finalfn';


--
-- TOC entry 1083 (class 1255 OID 207712)
-- Dependencies: 23 2189 2204
-- Name: pgis_geometry_union_finalfn(pgis_abs); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pgis_geometry_union_finalfn(pgis_abs) RETURNS geometry
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'pgis_geometry_union_finalfn';


--
-- TOC entry 1084 (class 1255 OID 207713)
-- Dependencies: 23 2189
-- Name: point_inside_circle(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION point_inside_circle(geometry, double precision, double precision, double precision) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_inside_circle_point';


--
-- TOC entry 1085 (class 1255 OID 207714)
-- Dependencies: 23 2189
-- Name: pointfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pointfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'POINT'
	THEN GeomFromText($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1086 (class 1255 OID 207715)
-- Dependencies: 23 2189
-- Name: pointfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pointfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'POINT'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1087 (class 1255 OID 207716)
-- Dependencies: 23 2189
-- Name: pointfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pointfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'POINT'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1088 (class 1255 OID 207717)
-- Dependencies: 23 2189
-- Name: pointfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pointfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'POINT'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1089 (class 1255 OID 207718)
-- Dependencies: 23 2189 2189
-- Name: pointn(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pointn(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_pointn_linestring';


--
-- TOC entry 1225 (class 1255 OID 207719)
-- Dependencies: 23 2189 2189
-- Name: pointonsurface(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION pointonsurface(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'pointonsurface';


--
-- TOC entry 1226 (class 1255 OID 207720)
-- Dependencies: 23 2189
-- Name: polyfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION polyfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1)) = 'POLYGON'
	THEN GeomFromText($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1227 (class 1255 OID 207721)
-- Dependencies: 23 2189
-- Name: polyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION polyfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'POLYGON'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1228 (class 1255 OID 207722)
-- Dependencies: 23 2189
-- Name: polyfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION polyfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'POLYGON'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1229 (class 1255 OID 207723)
-- Dependencies: 23 2189
-- Name: polyfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION polyfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'POLYGON'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1230 (class 1255 OID 207724)
-- Dependencies: 23 2189
-- Name: polygonfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION polygonfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT PolyFromText($1)$_$;


--
-- TOC entry 1231 (class 1255 OID 207725)
-- Dependencies: 23 2189
-- Name: polygonfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION polygonfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT PolyFromText($1, $2)$_$;


--
-- TOC entry 1232 (class 1255 OID 207726)
-- Dependencies: 23 2189
-- Name: polygonfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION polygonfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'POLYGON'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1233 (class 1255 OID 207727)
-- Dependencies: 23 2189
-- Name: polygonfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION polygonfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1,$2)) = 'POLYGON'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1234 (class 1255 OID 207728)
-- Dependencies: 23 2189 2191
-- Name: polygonize_garray(geometry[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION polygonize_garray(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'polygonize_garray';


--
-- TOC entry 1235 (class 1255 OID 207729)
-- Dependencies: 23 3246
-- Name: populate_geometry_columns(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION populate_geometry_columns() RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	inserted    integer;
	oldcount    integer;
	probed      integer;
	stale       integer;
	gcs         RECORD;
	gc          RECORD;
	gsrid       integer;
	gndims      integer;
	gtype       text;
	query       text;
	gc_is_valid boolean;

BEGIN
	SELECT count(*) INTO oldcount FROM geometry_columns;
	inserted := 0;

	EXECUTE 'TRUNCATE geometry_columns';

	-- Count the number of geometry columns in all tables and views
	SELECT count(DISTINCT c.oid) INTO probed
	FROM pg_class c,
		 pg_attribute a,
		 pg_type t,
		 pg_namespace n
	WHERE (c.relkind = 'r' OR c.relkind = 'v')
	AND t.typname = 'geometry'
	AND a.attisdropped = false
	AND a.atttypid = t.oid
	AND a.attrelid = c.oid
	AND c.relnamespace = n.oid
	AND n.nspname NOT ILIKE 'pg_temp%';

	-- Iterate through all non-dropped geometry columns
	RAISE DEBUG 'Processing Tables.....';

	FOR gcs IN
	SELECT DISTINCT ON (c.oid) c.oid, n.nspname, c.relname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'r'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%'
	LOOP

	inserted := inserted + populate_geometry_columns(gcs.oid);
	END LOOP;

	-- Add views to geometry columns table
	RAISE DEBUG 'Processing Views.....';
	FOR gcs IN
	SELECT DISTINCT ON (c.oid) c.oid, n.nspname, c.relname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'v'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
	LOOP

	inserted := inserted + populate_geometry_columns(gcs.oid);
	END LOOP;

	IF oldcount > inserted THEN
	stale = oldcount-inserted;
	ELSE
	stale = 0;
	END IF;

	RETURN 'probed:' ||probed|| ' inserted:'||inserted|| ' conflicts:'||probed-inserted|| ' deleted:'||stale;
END

$$;


--
-- TOC entry 1236 (class 1255 OID 207730)
-- Dependencies: 23 3246
-- Name: populate_geometry_columns(oid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION populate_geometry_columns(tbl_oid oid) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	gcs         RECORD;
	gc          RECORD;
	gsrid       integer;
	gndims      integer;
	gtype       text;
	query       text;
	gc_is_valid boolean;
	inserted    integer;

BEGIN
	inserted := 0;

	-- Iterate through all geometry columns in this table
	FOR gcs IN
	SELECT n.nspname, c.relname, a.attname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'r'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%'
		AND c.oid = tbl_oid
	LOOP

	RAISE DEBUG 'Processing table %.%.%', gcs.nspname, gcs.relname, gcs.attname;

	DELETE FROM geometry_columns
	  WHERE f_table_schema = gcs.nspname
	  AND f_table_name = gcs.relname
	  AND f_geometry_column = gcs.attname;

	gc_is_valid := true;

	-- Try to find srid check from system tables (pg_constraint)
	gsrid :=
		(SELECT replace(replace(split_part(s.consrc, ' = ', 2), ')', ''), '(', '')
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = gcs.nspname
		 AND c.relname = gcs.relname
		 AND a.attname = gcs.attname
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%srid(% = %');
	IF (gsrid IS NULL) THEN
		-- Try to find srid from the geometry itself
		EXECUTE 'SELECT srid(' || quote_ident(gcs.attname) || ')
				 FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gsrid := gc.srid;

		-- Try to apply srid check to column
		IF (gsrid IS NOT NULL) THEN
			BEGIN
				EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
						 ADD CONSTRAINT ' || quote_ident('enforce_srid_' || gcs.attname) || '
						 CHECK (srid(' || quote_ident(gcs.attname) || ') = ' || gsrid || ')';
			EXCEPTION
				WHEN check_violation THEN
					RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (srid(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gsrid;
					gc_is_valid := false;
			END;
		END IF;
	END IF;

	-- Try to find ndims check from system tables (pg_constraint)
	gndims :=
		(SELECT replace(split_part(s.consrc, ' = ', 2), ')', '')
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = gcs.nspname
		 AND c.relname = gcs.relname
		 AND a.attname = gcs.attname
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%ndims(% = %');
	IF (gndims IS NULL) THEN
		-- Try to find ndims from the geometry itself
		EXECUTE 'SELECT ndims(' || quote_ident(gcs.attname) || ')
				 FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gndims := gc.ndims;

		-- Try to apply ndims check to column
		IF (gndims IS NOT NULL) THEN
			BEGIN
				EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
						 ADD CONSTRAINT ' || quote_ident('enforce_dims_' || gcs.attname) || '
						 CHECK (ndims(' || quote_ident(gcs.attname) || ') = '||gndims||')';
			EXCEPTION
				WHEN check_violation THEN
					RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (ndims(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gndims;
					gc_is_valid := false;
			END;
		END IF;
	END IF;

	-- Try to find geotype check from system tables (pg_constraint)
	gtype :=
		(SELECT replace(split_part(s.consrc, '''', 2), ')', '')
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = gcs.nspname
		 AND c.relname = gcs.relname
		 AND a.attname = gcs.attname
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%geometrytype(% = %');
	IF (gtype IS NULL) THEN
		-- Try to find geotype from the geometry itself
		EXECUTE 'SELECT geometrytype(' || quote_ident(gcs.attname) || ')
				 FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gtype := gc.geometrytype;
		--IF (gtype IS NULL) THEN
		--    gtype := 'GEOMETRY';
		--END IF;

		-- Try to apply geometrytype check to column
		IF (gtype IS NOT NULL) THEN
			BEGIN
				EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				ADD CONSTRAINT ' || quote_ident('enforce_geotype_' || gcs.attname) || '
				CHECK ((geometrytype(' || quote_ident(gcs.attname) || ') = ' || quote_literal(gtype) || ') OR (' || quote_ident(gcs.attname) || ' IS NULL))';
			EXCEPTION
				WHEN check_violation THEN
					-- No geometry check can be applied. This column contains a number of geometry types.
					RAISE WARNING 'Could not add geometry type check (%) to table column: %.%.%', gtype, quote_ident(gcs.nspname),quote_ident(gcs.relname),quote_ident(gcs.attname);
			END;
		END IF;
	END IF;

	IF (gsrid IS NULL) THEN
		RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine the srid', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
	ELSIF (gndims IS NULL) THEN
		RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine the number of dimensions', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
	ELSIF (gtype IS NULL) THEN
		RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine the geometry type', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
	ELSE
		-- Only insert into geometry_columns if table constraints could be applied.
		IF (gc_is_valid) THEN
			INSERT INTO geometry_columns (f_table_catalog,f_table_schema, f_table_name, f_geometry_column, coord_dimension, srid, type)
			VALUES ('', gcs.nspname, gcs.relname, gcs.attname, gndims, gsrid, gtype);
			inserted := inserted + 1;
		END IF;
	END IF;
	END LOOP;

	-- Add views to geometry columns table
	FOR gcs IN
	SELECT n.nspname, c.relname, a.attname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'v'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%'
		AND c.oid = tbl_oid
	LOOP
		RAISE DEBUG 'Processing view %.%.%', gcs.nspname, gcs.relname, gcs.attname;

	DELETE FROM geometry_columns
	  WHERE f_table_schema = gcs.nspname
	  AND f_table_name = gcs.relname
	  AND f_geometry_column = gcs.attname;
	  
		EXECUTE 'SELECT ndims(' || quote_ident(gcs.attname) || ')
				 FROM ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gndims := gc.ndims;

		EXECUTE 'SELECT srid(' || quote_ident(gcs.attname) || ')
				 FROM ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gsrid := gc.srid;

		EXECUTE 'SELECT geometrytype(' || quote_ident(gcs.attname) || ')
				 FROM ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gtype := gc.geometrytype;

		IF (gndims IS NULL) THEN
			RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine ndims', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
		ELSIF (gsrid IS NULL) THEN
			RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine srid', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
		ELSIF (gtype IS NULL) THEN
			RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine gtype', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
		ELSE
			query := 'INSERT INTO geometry_columns (f_table_catalog,f_table_schema, f_table_name, f_geometry_column, coord_dimension, srid, type) ' ||
					 'VALUES ('''', ' || quote_literal(gcs.nspname) || ',' || quote_literal(gcs.relname) || ',' || quote_literal(gcs.attname) || ',' || gndims || ',' || gsrid || ',' || quote_literal(gtype) || ')';
			EXECUTE query;
			inserted := inserted + 1;
		END IF;
	END LOOP;

	RETURN inserted;
END

$$;


--
-- TOC entry 1237 (class 1255 OID 207732)
-- Dependencies: 23 2189 2189
-- Name: postgis_addbbox(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_addbbox(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_addBBOX';


--
-- TOC entry 1238 (class 1255 OID 207733)
-- Dependencies: 23
-- Name: postgis_cache_bbox(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_cache_bbox() RETURNS trigger
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'cache_bbox';


--
-- TOC entry 1239 (class 1255 OID 207734)
-- Dependencies: 23 2189 2189
-- Name: postgis_dropbbox(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_dropbbox(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dropBBOX';


--
-- TOC entry 1240 (class 1255 OID 207735)
-- Dependencies: 23 3246
-- Name: postgis_full_version(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	projver text;
	geosver text;
	libxmlver text;
	usestats bool;
	dbproc text;
	relproc text;
	fullver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_libxml_version() INTO libxmlver;
	SELECT postgis_uses_stats() INTO usestats;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;

	fullver = 'POSTGIS="' || libver || '"';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS="' || geosver || '"';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ="' || projver || '"';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML="' || libxmlver || '"';
	END IF;

	IF usestats THEN
		fullver = fullver || ' USE_STATS';
	END IF;

	-- fullver = fullver || ' DBPROC="' || dbproc || '"';
	-- fullver = fullver || ' RELPROC="' || relproc || '"';

	IF dbproc != relproc THEN
		fullver = fullver || ' (procs from ' || dbproc || ' need upgrade)';
	END IF;

	RETURN fullver;
END
$$;


--
-- TOC entry 1241 (class 1255 OID 207736)
-- Dependencies: 23
-- Name: postgis_geos_version(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_geos_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'postgis_geos_version';


--
-- TOC entry 1242 (class 1255 OID 207737)
-- Dependencies: 23 2160 2189
-- Name: postgis_getbbox(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_getbbox(geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_BOX2DFLOAT4';


--
-- TOC entry 1243 (class 1255 OID 207738)
-- Dependencies: 23
-- Name: postgis_gist_joinsel(internal, oid, internal, smallint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_gist_joinsel(internal, oid, internal, smallint) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_joinsel';


--
-- TOC entry 1244 (class 1255 OID 207739)
-- Dependencies: 23
-- Name: postgis_gist_sel(internal, oid, internal, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_gist_sel(internal, oid, internal, integer) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_sel';


--
-- TOC entry 1245 (class 1255 OID 207740)
-- Dependencies: 23 2189
-- Name: postgis_hasbbox(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_hasbbox(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_hasBBOX';


--
-- TOC entry 1246 (class 1255 OID 207741)
-- Dependencies: 23
-- Name: postgis_lib_build_date(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_lib_build_date() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'postgis_lib_build_date';


--
-- TOC entry 1247 (class 1255 OID 207742)
-- Dependencies: 23
-- Name: postgis_lib_version(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_lib_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'postgis_lib_version';


--
-- TOC entry 1248 (class 1255 OID 207743)
-- Dependencies: 23
-- Name: postgis_libxml_version(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_libxml_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'postgis_libxml_version';


--
-- TOC entry 1249 (class 1255 OID 207744)
-- Dependencies: 23 2189 2189
-- Name: postgis_noop(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_noop(geometry) RETURNS geometry
    LANGUAGE c STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_noop';


--
-- TOC entry 1250 (class 1255 OID 207745)
-- Dependencies: 23
-- Name: postgis_proj_version(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_proj_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'postgis_proj_version';


--
-- TOC entry 1251 (class 1255 OID 207746)
-- Dependencies: 23
-- Name: postgis_scripts_build_date(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_scripts_build_date() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$SELECT '2011-09-12 18:37:35'::text AS version$$;


--
-- TOC entry 1252 (class 1255 OID 207747)
-- Dependencies: 23
-- Name: postgis_scripts_installed(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_scripts_installed() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$SELECT '1.5 r7360'::text AS version$$;


--
-- TOC entry 1253 (class 1255 OID 207748)
-- Dependencies: 23
-- Name: postgis_scripts_released(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_scripts_released() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'postgis_scripts_released';


--
-- TOC entry 939 (class 1255 OID 207749)
-- Dependencies: 23 2189 2189
-- Name: postgis_transform_geometry(geometry, text, text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_transform_geometry(geometry, text, text, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'transform_geom';


--
-- TOC entry 958 (class 1255 OID 207750)
-- Dependencies: 23
-- Name: postgis_uses_stats(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_uses_stats() RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'postgis_uses_stats';


--
-- TOC entry 1254 (class 1255 OID 207751)
-- Dependencies: 23
-- Name: postgis_version(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION postgis_version() RETURNS text
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'postgis_version';


--
-- TOC entry 1255 (class 1255 OID 207752)
-- Dependencies: 23 3246
-- Name: probe_geometry_columns(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION probe_geometry_columns() RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	inserted integer;
	oldcount integer;
	probed integer;
	stale integer;
BEGIN

	SELECT count(*) INTO oldcount FROM geometry_columns;

	SELECT count(*) INTO probed
		FROM pg_class c, pg_attribute a, pg_type t,
			pg_namespace n,
			pg_constraint sridcheck, pg_constraint typecheck

		WHERE t.typname = 'geometry'
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND sridcheck.connamespace = n.oid
		AND typecheck.connamespace = n.oid
		AND sridcheck.conrelid = c.oid
		AND sridcheck.consrc LIKE '(srid('||a.attname||') = %)'
		AND typecheck.conrelid = c.oid
		AND typecheck.consrc LIKE
		'((geometrytype('||a.attname||') = ''%''::text) OR (% IS NULL))'
		;

	INSERT INTO geometry_columns SELECT
		''::varchar as f_table_catalogue,
		n.nspname::varchar as f_table_schema,
		c.relname::varchar as f_table_name,
		a.attname::varchar as f_geometry_column,
		2 as coord_dimension,
		trim(both  ' =)' from
			replace(replace(split_part(
				sridcheck.consrc, ' = ', 2), ')', ''), '(', ''))::integer AS srid,
		trim(both ' =)''' from substr(typecheck.consrc,
			strpos(typecheck.consrc, '='),
			strpos(typecheck.consrc, '::')-
			strpos(typecheck.consrc, '=')
			))::varchar as type
		FROM pg_class c, pg_attribute a, pg_type t,
			pg_namespace n,
			pg_constraint sridcheck, pg_constraint typecheck
		WHERE t.typname = 'geometry'
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND sridcheck.connamespace = n.oid
		AND typecheck.connamespace = n.oid
		AND sridcheck.conrelid = c.oid
		AND sridcheck.consrc LIKE '(st_srid('||a.attname||') = %)'
		AND typecheck.conrelid = c.oid
		AND typecheck.consrc LIKE
		'((geometrytype('||a.attname||') = ''%''::text) OR (% IS NULL))'

			AND NOT EXISTS (
					SELECT oid FROM geometry_columns gc
					WHERE c.relname::varchar = gc.f_table_name
					AND n.nspname::varchar = gc.f_table_schema
					AND a.attname::varchar = gc.f_geometry_column
			);

	GET DIAGNOSTICS inserted = ROW_COUNT;

	IF oldcount > probed THEN
		stale = oldcount-probed;
	ELSE
		stale = 0;
	END IF;

	RETURN 'probed:'||probed::text||
		' inserted:'||inserted::text||
		' conflicts:'||(probed-inserted)::text||
		' stale:'||stale::text;
END

$$;


--
-- TOC entry 1256 (class 1255 OID 207753)
-- Dependencies: 23 2208
-- Name: querytree(query_int); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION querytree(query_int) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'querytree';


--
-- TOC entry 1257 (class 1255 OID 207754)
-- Dependencies: 23 2208
-- Name: rboolop(query_int, integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rboolop(query_int, integer[]) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'rboolop';


--
-- TOC entry 7047 (class 0 OID 0)
-- Dependencies: 1257
-- Name: FUNCTION rboolop(query_int, integer[]); Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON FUNCTION rboolop(query_int, integer[]) IS 'boolean operation with array';


--
-- TOC entry 1258 (class 1255 OID 207755)
-- Dependencies: 23 2189 2189
-- Name: relate(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION relate(geometry, geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'relate_full';


--
-- TOC entry 1259 (class 1255 OID 207756)
-- Dependencies: 23 2189 2189
-- Name: relate(geometry, geometry, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION relate(geometry, geometry, text) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'relate_pattern';


--
-- TOC entry 1260 (class 1255 OID 207757)
-- Dependencies: 23 2189 2189
-- Name: removepoint(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION removepoint(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_removepoint';


--
-- TOC entry 1261 (class 1255 OID 207758)
-- Dependencies: 23
-- Name: rename_geometry_table_constraints(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rename_geometry_table_constraints() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$
SELECT 'rename_geometry_table_constraint() is obsoleted'::text
$$;


--
-- TOC entry 1262 (class 1255 OID 207759)
-- Dependencies: 23 2189 2189
-- Name: reverse(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION reverse(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_reverse';


--
-- TOC entry 1263 (class 1255 OID 207760)
-- Dependencies: 23 2189 2189
-- Name: rotate(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rotate(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT rotateZ($1, $2)$_$;


--
-- TOC entry 1264 (class 1255 OID 207761)
-- Dependencies: 23 2189 2189
-- Name: rotatex(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rotatex(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1, 1, 0, 0, 0, cos($2), -sin($2), 0, sin($2), cos($2), 0, 0, 0)$_$;


--
-- TOC entry 1265 (class 1255 OID 207762)
-- Dependencies: 23 2189 2189
-- Name: rotatey(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rotatey(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  cos($2), 0, sin($2),  0, 1, 0,  -sin($2), 0, cos($2), 0,  0, 0)$_$;


--
-- TOC entry 1266 (class 1255 OID 207763)
-- Dependencies: 23 2189 2189
-- Name: rotatez(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rotatez(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  cos($2), -sin($2), 0,  sin($2), cos($2), 0,  0, 0, 1,  0, 0, 0)$_$;


--
-- TOC entry 1267 (class 1255 OID 207764)
-- Dependencies: 23 2189 2189
-- Name: scale(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION scale(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT scale($1, $2, $3, 1)$_$;


--
-- TOC entry 1268 (class 1255 OID 207765)
-- Dependencies: 23 2189 2189
-- Name: scale(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION scale(geometry, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  $2, 0, 0,  0, $3, 0,  0, 0, $4,  0, 0, 0)$_$;


--
-- TOC entry 1269 (class 1255 OID 207766)
-- Dependencies: 23 2189 2189
-- Name: se_envelopesintersect(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION se_envelopesintersect(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ 
	SELECT $1 && $2
	$_$;


--
-- TOC entry 1270 (class 1255 OID 207767)
-- Dependencies: 23 2189
-- Name: se_is3d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION se_is3d(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_hasz';


--
-- TOC entry 1271 (class 1255 OID 207768)
-- Dependencies: 23 2189
-- Name: se_ismeasured(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION se_ismeasured(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_hasm';


--
-- TOC entry 1272 (class 1255 OID 207769)
-- Dependencies: 23 2189 2189
-- Name: se_locatealong(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION se_locatealong(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT locate_between_measures($1, $2, $2) $_$;


--
-- TOC entry 1273 (class 1255 OID 207770)
-- Dependencies: 23 2189 2189
-- Name: se_locatebetween(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION se_locatebetween(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_locate_between_m';


--
-- TOC entry 1274 (class 1255 OID 207771)
-- Dependencies: 23 2189
-- Name: se_m(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION se_m(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_m_point';


--
-- TOC entry 1275 (class 1255 OID 207772)
-- Dependencies: 23 2189
-- Name: se_z(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION se_z(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_z_point';


--
-- TOC entry 1276 (class 1255 OID 207773)
-- Dependencies: 23 2189 2189
-- Name: segmentize(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION segmentize(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_segmentize2d';


--
-- TOC entry 1277 (class 1255 OID 207774)
-- Dependencies: 23 2172 2172
-- Name: setfactor(chip, real); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION setfactor(chip, real) RETURNS chip
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_setFactor';


--
-- TOC entry 1278 (class 1255 OID 207775)
-- Dependencies: 23 2189 2189 2189
-- Name: setpoint(geometry, integer, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION setpoint(geometry, integer, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_setpoint_linestring';


--
-- TOC entry 1279 (class 1255 OID 207776)
-- Dependencies: 23 2172 2172
-- Name: setsrid(chip, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION setsrid(chip, integer) RETURNS chip
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_setSRID';


--
-- TOC entry 1280 (class 1255 OID 207777)
-- Dependencies: 23 2189 2189
-- Name: setsrid(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION setsrid(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_setSRID';


--
-- TOC entry 1281 (class 1255 OID 207778)
-- Dependencies: 23 2189 2189
-- Name: shift_longitude(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION shift_longitude(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_longitude_shift';


--
-- TOC entry 1282 (class 1255 OID 207779)
-- Dependencies: 23 2189 2189
-- Name: simplify(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION simplify(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_simplify2d';


--
-- TOC entry 1283 (class 1255 OID 207780)
-- Dependencies: 23 2189 2189
-- Name: snaptogrid(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION snaptogrid(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT SnapToGrid($1, 0, 0, $2, $2)$_$;


--
-- TOC entry 1284 (class 1255 OID 207781)
-- Dependencies: 23 2189 2189
-- Name: snaptogrid(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION snaptogrid(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT SnapToGrid($1, 0, 0, $2, $3)$_$;


--
-- TOC entry 1285 (class 1255 OID 207782)
-- Dependencies: 23 2189 2189
-- Name: snaptogrid(geometry, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION snaptogrid(geometry, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_snaptogrid';


--
-- TOC entry 1286 (class 1255 OID 207783)
-- Dependencies: 23 2189 2189 2189
-- Name: snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_snaptogrid_pointoff';


--
-- TOC entry 1287 (class 1255 OID 207784)
-- Dependencies: 23
-- Name: sort(integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION sort(integer[]) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'sort';


--
-- TOC entry 720 (class 1255 OID 207785)
-- Dependencies: 23
-- Name: sort(integer[], text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION sort(integer[], text) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'sort';


--
-- TOC entry 758 (class 1255 OID 207786)
-- Dependencies: 23
-- Name: sort_asc(integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION sort_asc(integer[]) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'sort_asc';


--
-- TOC entry 1288 (class 1255 OID 207787)
-- Dependencies: 23
-- Name: sort_desc(integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION sort_desc(integer[]) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'sort_desc';


--
-- TOC entry 1289 (class 1255 OID 207788)
-- Dependencies: 23 2172
-- Name: srid(chip); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION srid(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getSRID';


--
-- TOC entry 1290 (class 1255 OID 207789)
-- Dependencies: 23 2189
-- Name: srid(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION srid(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_getSRID';


--
-- TOC entry 1291 (class 1255 OID 207790)
-- Dependencies: 23 2189 2189
-- Name: st_addmeasure(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_addmeasure(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ST_AddMeasure';


--
-- TOC entry 1292 (class 1255 OID 207791)
-- Dependencies: 23 2189 2189 2189
-- Name: st_addpoint(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_addpoint(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_addpoint';


--
-- TOC entry 1293 (class 1255 OID 207792)
-- Dependencies: 23 2189 2189 2189
-- Name: st_addpoint(geometry, geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_addpoint(geometry, geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_addpoint';


--
-- TOC entry 1294 (class 1255 OID 207793)
-- Dependencies: 23 2189 2189
-- Name: st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  $2, $3, 0,  $4, $5, 0,  0, 0, 1,  $6, $7, 0)$_$;


--
-- TOC entry 1295 (class 1255 OID 207794)
-- Dependencies: 23 2189 2189
-- Name: st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_affine';


--
-- TOC entry 1296 (class 1255 OID 207795)
-- Dependencies: 23 2189
-- Name: st_area(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_area(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_area_polygon';


--
-- TOC entry 1297 (class 1255 OID 207796)
-- Dependencies: 23 2185
-- Name: st_area(geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_area(geography) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_Area($1, true)$_$;


--
-- TOC entry 1298 (class 1255 OID 207797)
-- Dependencies: 23
-- Name: st_area(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_area(text) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Area($1::geometry);  $_$;


--
-- TOC entry 1299 (class 1255 OID 207798)
-- Dependencies: 23 2185
-- Name: st_area(geography, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_area(geography, boolean) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'geography_area';


--
-- TOC entry 1300 (class 1255 OID 207799)
-- Dependencies: 23 2189
-- Name: st_area2d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_area2d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_area_polygon';


--
-- TOC entry 1301 (class 1255 OID 207800)
-- Dependencies: 23 2189
-- Name: st_asbinary(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asbinary(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asBinary';


--
-- TOC entry 1302 (class 1255 OID 207801)
-- Dependencies: 23 2185
-- Name: st_asbinary(geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asbinary(geography) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_as_binary';


--
-- TOC entry 1303 (class 1255 OID 207802)
-- Dependencies: 23
-- Name: st_asbinary(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asbinary(text) RETURNS bytea
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsBinary($1::geometry);  $_$;


--
-- TOC entry 1304 (class 1255 OID 207803)
-- Dependencies: 23 2189
-- Name: st_asbinary(geometry, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asbinary(geometry, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asBinary';


--
-- TOC entry 1305 (class 1255 OID 207804)
-- Dependencies: 23 2189
-- Name: st_asewkb(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asewkb(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'WKBFromLWGEOM';


--
-- TOC entry 1306 (class 1255 OID 207805)
-- Dependencies: 23 2189
-- Name: st_asewkb(geometry, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asewkb(geometry, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'WKBFromLWGEOM';


--
-- TOC entry 1307 (class 1255 OID 207806)
-- Dependencies: 23 2189
-- Name: st_asewkt(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asewkt(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asEWKT';


--
-- TOC entry 1308 (class 1255 OID 207807)
-- Dependencies: 23 2189
-- Name: st_asgeojson(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgeojson(geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson(1, $1, 15, 0)$_$;


--
-- TOC entry 1309 (class 1255 OID 207808)
-- Dependencies: 23 2185
-- Name: st_asgeojson(geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgeojson(geography) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson(1, $1, 15, 0)$_$;


--
-- TOC entry 1310 (class 1255 OID 207809)
-- Dependencies: 23
-- Name: st_asgeojson(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgeojson(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsGeoJson($1::geometry);  $_$;


--
-- TOC entry 1311 (class 1255 OID 207810)
-- Dependencies: 23 2189
-- Name: st_asgeojson(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgeojson(geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson(1, $1, $2, 0)$_$;


--
-- TOC entry 1312 (class 1255 OID 207811)
-- Dependencies: 23 2189
-- Name: st_asgeojson(integer, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgeojson(integer, geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson($1, $2, 15, 0)$_$;


--
-- TOC entry 1313 (class 1255 OID 207812)
-- Dependencies: 23 2185
-- Name: st_asgeojson(geography, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgeojson(geography, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson(1, $1, $2, 0)$_$;


--
-- TOC entry 1314 (class 1255 OID 207813)
-- Dependencies: 23 2185
-- Name: st_asgeojson(integer, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgeojson(integer, geography) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson($1, $2, 15, 0)$_$;


--
-- TOC entry 1315 (class 1255 OID 207814)
-- Dependencies: 23 2189
-- Name: st_asgeojson(integer, geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgeojson(integer, geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson($1, $2, $3, 0)$_$;


--
-- TOC entry 1316 (class 1255 OID 207815)
-- Dependencies: 23 2189
-- Name: st_asgeojson(geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgeojson(geometry, integer, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson(1, $1, $2, $3)$_$;


--
-- TOC entry 1317 (class 1255 OID 207816)
-- Dependencies: 23 2185
-- Name: st_asgeojson(integer, geography, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgeojson(integer, geography, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson($1, $2, $3, 0)$_$;


--
-- TOC entry 1318 (class 1255 OID 207817)
-- Dependencies: 23 2185
-- Name: st_asgeojson(geography, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgeojson(geography, integer, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson(1, $1, $2, $3)$_$;


--
-- TOC entry 1319 (class 1255 OID 207818)
-- Dependencies: 23 2189
-- Name: st_asgeojson(integer, geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgeojson(integer, geometry, integer, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson($1, $2, $3, $4)$_$;


--
-- TOC entry 1320 (class 1255 OID 207819)
-- Dependencies: 23 2185
-- Name: st_asgeojson(integer, geography, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgeojson(integer, geography, integer, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGeoJson($1, $2, $3, $4)$_$;


--
-- TOC entry 1321 (class 1255 OID 207820)
-- Dependencies: 23 2189
-- Name: st_asgml(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgml(geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, 15, 0)$_$;


--
-- TOC entry 1322 (class 1255 OID 207821)
-- Dependencies: 23 2185
-- Name: st_asgml(geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgml(geography) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, 15, 0)$_$;


--
-- TOC entry 1323 (class 1255 OID 207822)
-- Dependencies: 23
-- Name: st_asgml(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgml(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsGML($1::geometry);  $_$;


--
-- TOC entry 1324 (class 1255 OID 207823)
-- Dependencies: 23 2189
-- Name: st_asgml(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgml(geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, $2, 0)$_$;


--
-- TOC entry 1325 (class 1255 OID 207824)
-- Dependencies: 23 2189
-- Name: st_asgml(integer, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgml(integer, geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML($1, $2, 15, 0)$_$;


--
-- TOC entry 1326 (class 1255 OID 207825)
-- Dependencies: 23 2185
-- Name: st_asgml(geography, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgml(geography, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, $2, 0)$_$;


--
-- TOC entry 1327 (class 1255 OID 207826)
-- Dependencies: 23 2185
-- Name: st_asgml(integer, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgml(integer, geography) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML($1, $2, 15, 0)$_$;


--
-- TOC entry 1328 (class 1255 OID 207827)
-- Dependencies: 23 2189
-- Name: st_asgml(integer, geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgml(integer, geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML($1, $2, $3, 0)$_$;


--
-- TOC entry 1329 (class 1255 OID 207828)
-- Dependencies: 23 2189
-- Name: st_asgml(geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgml(geometry, integer, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, $2, $3)$_$;


--
-- TOC entry 1330 (class 1255 OID 207829)
-- Dependencies: 23 2185
-- Name: st_asgml(integer, geography, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgml(integer, geography, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML($1, $2, $3, 0)$_$;


--
-- TOC entry 1331 (class 1255 OID 207830)
-- Dependencies: 23 2185
-- Name: st_asgml(geography, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgml(geography, integer, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML(2, $1, $2, $3)$_$;


--
-- TOC entry 1332 (class 1255 OID 207831)
-- Dependencies: 23 2189
-- Name: st_asgml(integer, geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgml(integer, geometry, integer, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML($1, $2, $3, $4)$_$;


--
-- TOC entry 1333 (class 1255 OID 207832)
-- Dependencies: 23 2185
-- Name: st_asgml(integer, geography, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_asgml(integer, geography, integer, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsGML($1, $2, $3, $4)$_$;


--
-- TOC entry 1334 (class 1255 OID 207833)
-- Dependencies: 23 2189
-- Name: st_ashexewkb(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_ashexewkb(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asHEXEWKB';


--
-- TOC entry 1335 (class 1255 OID 207834)
-- Dependencies: 23 2189
-- Name: st_ashexewkb(geometry, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_ashexewkb(geometry, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asHEXEWKB';


--
-- TOC entry 1336 (class 1255 OID 207835)
-- Dependencies: 23 2189
-- Name: st_askml(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_askml(geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML(2, ST_Transform($1,4326), 15)$_$;


--
-- TOC entry 1337 (class 1255 OID 207836)
-- Dependencies: 23 2185
-- Name: st_askml(geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_askml(geography) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML(2, $1, 15)$_$;


--
-- TOC entry 1338 (class 1255 OID 207837)
-- Dependencies: 23
-- Name: st_askml(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_askml(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsKML($1::geometry);  $_$;


--
-- TOC entry 1339 (class 1255 OID 207838)
-- Dependencies: 23 2189
-- Name: st_askml(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_askml(geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML(2, ST_Transform($1,4326), $2)$_$;


--
-- TOC entry 1340 (class 1255 OID 207839)
-- Dependencies: 23 2189
-- Name: st_askml(integer, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_askml(integer, geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML($1, ST_Transform($2,4326), 15)$_$;


--
-- TOC entry 1341 (class 1255 OID 207840)
-- Dependencies: 23 2185
-- Name: st_askml(geography, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_askml(geography, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML(2, $1, $2)$_$;


--
-- TOC entry 1342 (class 1255 OID 207841)
-- Dependencies: 23 2185
-- Name: st_askml(integer, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_askml(integer, geography) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML($1, $2, 15)$_$;


--
-- TOC entry 1343 (class 1255 OID 207842)
-- Dependencies: 23 2189
-- Name: st_askml(integer, geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_askml(integer, geometry, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML($1, ST_Transform($2,4326), $3)$_$;


--
-- TOC entry 1344 (class 1255 OID 207843)
-- Dependencies: 23 2185
-- Name: st_askml(integer, geography, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_askml(integer, geography, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_AsKML($1, $2, $3)$_$;


--
-- TOC entry 1345 (class 1255 OID 207844)
-- Dependencies: 23 2189
-- Name: st_assvg(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_assvg(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'assvg_geometry';


--
-- TOC entry 1346 (class 1255 OID 207845)
-- Dependencies: 23 2185
-- Name: st_assvg(geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_assvg(geography) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_as_svg';


--
-- TOC entry 1347 (class 1255 OID 207846)
-- Dependencies: 23
-- Name: st_assvg(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_assvg(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsSVG($1::geometry);  $_$;


--
-- TOC entry 1348 (class 1255 OID 207847)
-- Dependencies: 23 2189
-- Name: st_assvg(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_assvg(geometry, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'assvg_geometry';


--
-- TOC entry 1349 (class 1255 OID 207848)
-- Dependencies: 23 2185
-- Name: st_assvg(geography, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_assvg(geography, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_as_svg';


--
-- TOC entry 1350 (class 1255 OID 207849)
-- Dependencies: 23 2189
-- Name: st_assvg(geometry, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_assvg(geometry, integer, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'assvg_geometry';


--
-- TOC entry 1351 (class 1255 OID 207850)
-- Dependencies: 23 2185
-- Name: st_assvg(geography, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_assvg(geography, integer, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_as_svg';


--
-- TOC entry 1352 (class 1255 OID 207851)
-- Dependencies: 23 2189
-- Name: st_astext(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_astext(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_asText';


--
-- TOC entry 1353 (class 1255 OID 207852)
-- Dependencies: 23 2185
-- Name: st_astext(geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_astext(geography) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_as_text';


--
-- TOC entry 1354 (class 1255 OID 207853)
-- Dependencies: 23
-- Name: st_astext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_astext(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsText($1::geometry);  $_$;


--
-- TOC entry 1355 (class 1255 OID 207854)
-- Dependencies: 23 2189 2189
-- Name: st_azimuth(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_azimuth(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_azimuth';


--
-- TOC entry 1356 (class 1255 OID 207855)
-- Dependencies: 23 3246 2189
-- Name: st_bdmpolyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(ST_BuildArea(mline));

	RETURN geom;
END;
$_$;


--
-- TOC entry 1357 (class 1255 OID 207856)
-- Dependencies: 23 3246 2189
-- Name: st_bdpolyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := ST_BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;


--
-- TOC entry 1358 (class 1255 OID 207857)
-- Dependencies: 23 2189 2189
-- Name: st_boundary(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_boundary(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'boundary';


--
-- TOC entry 1359 (class 1255 OID 207858)
-- Dependencies: 23 2189
-- Name: st_box(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_box(geometry) RETURNS box
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_BOX';


--
-- TOC entry 1360 (class 1255 OID 207859)
-- Dependencies: 23 2164
-- Name: st_box(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_box(box3d) RETURNS box
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_BOX';


--
-- TOC entry 1361 (class 1255 OID 207860)
-- Dependencies: 23 2160 2189
-- Name: st_box2d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_box2d(geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_BOX2DFLOAT4';


--
-- TOC entry 1363 (class 1255 OID 207861)
-- Dependencies: 23 2160 2164
-- Name: st_box2d(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_box2d(box3d) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_BOX2DFLOAT4';


--
-- TOC entry 1364 (class 1255 OID 207862)
-- Dependencies: 23 2160 2168
-- Name: st_box2d(box3d_extent); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_box2d(box3d_extent) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_BOX2DFLOAT4';


--
-- TOC entry 1365 (class 1255 OID 207863)
-- Dependencies: 23 2160
-- Name: st_box2d_in(cstring); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_box2d_in(cstring) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_in';


--
-- TOC entry 1366 (class 1255 OID 207864)
-- Dependencies: 23 2160
-- Name: st_box2d_out(box2d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_box2d_out(box2d) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_out';


--
-- TOC entry 1367 (class 1255 OID 207865)
-- Dependencies: 23 2164 2189
-- Name: st_box3d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_box3d(geometry) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_BOX3D';


--
-- TOC entry 1368 (class 1255 OID 207866)
-- Dependencies: 23 2164 2160
-- Name: st_box3d(box2d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_box3d(box2d) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_to_BOX3D';


--
-- TOC entry 1369 (class 1255 OID 207867)
-- Dependencies: 23 2164 2168
-- Name: st_box3d_extent(box3d_extent); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_box3d_extent(box3d_extent) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_extent_to_BOX3D';


--
-- TOC entry 1370 (class 1255 OID 207868)
-- Dependencies: 23 2164
-- Name: st_box3d_in(cstring); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_box3d_in(cstring) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_in';


--
-- TOC entry 1371 (class 1255 OID 207869)
-- Dependencies: 23 2164
-- Name: st_box3d_out(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_box3d_out(box3d) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_out';


--
-- TOC entry 1372 (class 1255 OID 207870)
-- Dependencies: 23 2189 2189
-- Name: st_buffer(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_buffer(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'buffer';


--
-- TOC entry 1373 (class 1255 OID 207871)
-- Dependencies: 23 2185 2185
-- Name: st_buffer(geography, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_buffer(geography, double precision) RETURNS geography
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT geography(ST_Transform(ST_Buffer(ST_Transform(geometry($1), _ST_BestSRID($1)), $2), 4326))$_$;


--
-- TOC entry 1374 (class 1255 OID 207872)
-- Dependencies: 23 2189
-- Name: st_buffer(text, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_buffer(text, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Buffer($1::geometry, $2);  $_$;


--
-- TOC entry 1375 (class 1255 OID 207873)
-- Dependencies: 23 2189 2189
-- Name: st_buffer(geometry, double precision, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_buffer(geometry, double precision, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_Buffer($1, $2,
		CAST('quad_segs='||CAST($3 AS text) as cstring))
	   $_$;


--
-- TOC entry 1376 (class 1255 OID 207874)
-- Dependencies: 23 2189 2189
-- Name: st_buffer(geometry, double precision, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_buffer(geometry, double precision, text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_Buffer($1, $2,
		CAST( regexp_replace($3, '^[0123456789]+$',
			'quad_segs='||$3) AS cstring)
		)
	   $_$;


--
-- TOC entry 1377 (class 1255 OID 207875)
-- Dependencies: 23 2189 2189
-- Name: st_buildarea(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_buildarea(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_buildarea';


--
-- TOC entry 1378 (class 1255 OID 207876)
-- Dependencies: 23 2189
-- Name: st_bytea(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_bytea(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_bytea';


--
-- TOC entry 1379 (class 1255 OID 207877)
-- Dependencies: 23 2189 2189
-- Name: st_centroid(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_centroid(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'centroid';


--
-- TOC entry 1380 (class 1255 OID 207878)
-- Dependencies: 23 2172
-- Name: st_chip_in(cstring); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_chip_in(cstring) RETURNS chip
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_in';


--
-- TOC entry 1381 (class 1255 OID 207879)
-- Dependencies: 23 2172
-- Name: st_chip_out(chip); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_chip_out(chip) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_out';


--
-- TOC entry 1382 (class 1255 OID 207880)
-- Dependencies: 23 2189 2189 2189
-- Name: st_closestpoint(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_closestpoint(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_closestpoint';


--
-- TOC entry 1383 (class 1255 OID 207881)
-- Dependencies: 23 2189 2191
-- Name: st_collect(geometry[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_collect(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_collect_garray';


--
-- TOC entry 1384 (class 1255 OID 207882)
-- Dependencies: 23 2189 2189 2189
-- Name: st_collect(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_collect(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'LWGEOM_collect';


--
-- TOC entry 1385 (class 1255 OID 207883)
-- Dependencies: 23 2189 2189
-- Name: st_collectionextract(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_collectionextract(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ST_CollectionExtract';


--
-- TOC entry 1386 (class 1255 OID 207884)
-- Dependencies: 23 2160 2160 2189
-- Name: st_combine_bbox(box2d, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_combine_bbox(box2d, geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_combine';


--
-- TOC entry 1387 (class 1255 OID 207885)
-- Dependencies: 23 2168 2168 2189
-- Name: st_combine_bbox(box3d_extent, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_combine_bbox(box3d_extent, geometry) RETURNS box3d_extent
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'BOX3D_combine';


--
-- TOC entry 1388 (class 1255 OID 207886)
-- Dependencies: 23 2164 2164 2189
-- Name: st_combine_bbox(box3d, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_combine_bbox(box3d, geometry) RETURNS box3d
    LANGUAGE c IMMUTABLE
    AS '$libdir/postgis-1.5', 'BOX3D_combine';


--
-- TOC entry 1389 (class 1255 OID 207887)
-- Dependencies: 23 2172
-- Name: st_compression(chip); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_compression(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getCompression';


--
-- TOC entry 1390 (class 1255 OID 207888)
-- Dependencies: 23 2189 2189
-- Name: st_contains(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_contains(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Contains($1,$2)$_$;


--
-- TOC entry 1391 (class 1255 OID 207889)
-- Dependencies: 23 2189 2189
-- Name: st_containsproperly(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_containsproperly(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_ContainsProperly($1,$2)$_$;


--
-- TOC entry 1392 (class 1255 OID 207890)
-- Dependencies: 23 2189 2189
-- Name: st_convexhull(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_convexhull(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'convexhull';


--
-- TOC entry 1393 (class 1255 OID 207891)
-- Dependencies: 23 2189
-- Name: st_coorddim(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_coorddim(geometry) RETURNS smallint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_ndims';


--
-- TOC entry 1394 (class 1255 OID 207892)
-- Dependencies: 23 2189 2189
-- Name: st_coveredby(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_coveredby(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_CoveredBy($1,$2)$_$;


--
-- TOC entry 1395 (class 1255 OID 207893)
-- Dependencies: 23 2185 2185
-- Name: st_coveredby(geography, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_coveredby(geography, geography) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Covers($2, $1)$_$;


--
-- TOC entry 1396 (class 1255 OID 207894)
-- Dependencies: 23
-- Name: st_coveredby(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_coveredby(text, text) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_CoveredBy($1::geometry, $2::geometry);  $_$;


--
-- TOC entry 1397 (class 1255 OID 207895)
-- Dependencies: 23 2189 2189
-- Name: st_covers(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_covers(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Covers($1,$2)$_$;


--
-- TOC entry 1398 (class 1255 OID 207896)
-- Dependencies: 23 2185 2185
-- Name: st_covers(geography, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_covers(geography, geography) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT $1 && $2 AND _ST_Covers($1, $2)$_$;


--
-- TOC entry 1399 (class 1255 OID 207897)
-- Dependencies: 23
-- Name: st_covers(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_covers(text, text) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_Covers($1::geometry, $2::geometry);  $_$;


--
-- TOC entry 1400 (class 1255 OID 207898)
-- Dependencies: 23 2189 2189
-- Name: st_crosses(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_crosses(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Crosses($1,$2)$_$;


--
-- TOC entry 1401 (class 1255 OID 207899)
-- Dependencies: 23 2189 2189
-- Name: st_curvetoline(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_curvetoline(geometry) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_CurveToLine($1, 32)$_$;


--
-- TOC entry 1402 (class 1255 OID 207900)
-- Dependencies: 23 2189 2189
-- Name: st_curvetoline(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_curvetoline(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_curve_segmentize';


--
-- TOC entry 1403 (class 1255 OID 207901)
-- Dependencies: 23 2172
-- Name: st_datatype(chip); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_datatype(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getDatatype';


--
-- TOC entry 1404 (class 1255 OID 207902)
-- Dependencies: 23 2189 2189
-- Name: st_dfullywithin(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_dfullywithin(geometry, geometry, double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && ST_Expand($2,$3) AND $2 && ST_Expand($1,$3) AND _ST_DFullyWithin(ST_ConvexHull($1), ST_ConvexHull($2), $3)$_$;


--
-- TOC entry 1405 (class 1255 OID 207903)
-- Dependencies: 23 2189 2189 2189
-- Name: st_difference(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_difference(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'difference';


--
-- TOC entry 1406 (class 1255 OID 207904)
-- Dependencies: 23 2189
-- Name: st_dimension(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_dimension(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dimension';


--
-- TOC entry 1407 (class 1255 OID 207905)
-- Dependencies: 23 2189 2189
-- Name: st_disjoint(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_disjoint(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'disjoint';


--
-- TOC entry 1408 (class 1255 OID 207906)
-- Dependencies: 23 2189 2189
-- Name: st_distance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_distance(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_mindistance2d';


--
-- TOC entry 1409 (class 1255 OID 207907)
-- Dependencies: 23 2185 2185
-- Name: st_distance(geography, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_distance(geography, geography) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_Distance($1, $2, 0.0, true)$_$;


--
-- TOC entry 1410 (class 1255 OID 207908)
-- Dependencies: 23
-- Name: st_distance(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_distance(text, text) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Distance($1::geometry, $2::geometry);  $_$;


--
-- TOC entry 1411 (class 1255 OID 207909)
-- Dependencies: 23 2185 2185
-- Name: st_distance(geography, geography, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_distance(geography, geography, boolean) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_Distance($1, $2, 0.0, $3)$_$;


--
-- TOC entry 1412 (class 1255 OID 207910)
-- Dependencies: 23 2189 2189
-- Name: st_distance_sphere(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_distance_sphere(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_distance_sphere';


--
-- TOC entry 1413 (class 1255 OID 207911)
-- Dependencies: 23 2189 2189 2212
-- Name: st_distance_spheroid(geometry, geometry, spheroid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_distance_spheroid(geometry, geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_distance_ellipsoid';


--
-- TOC entry 1414 (class 1255 OID 207912)
-- Dependencies: 23 2193 2189
-- Name: st_dump(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_dump(geometry) RETURNS SETOF geometry_dump
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dump';


--
-- TOC entry 1415 (class 1255 OID 207913)
-- Dependencies: 23 2193 2189
-- Name: st_dumppoints(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_dumppoints(geometry) RETURNS SETOF geometry_dump
    LANGUAGE sql STRICT
    AS $_$
  SELECT * FROM _ST_DumpPoints($1, NULL);
$_$;


--
-- TOC entry 1416 (class 1255 OID 207914)
-- Dependencies: 23 2193 2189
-- Name: st_dumprings(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_dumprings(geometry) RETURNS SETOF geometry_dump
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_dump_rings';


--
-- TOC entry 1417 (class 1255 OID 207915)
-- Dependencies: 23 2189 2189
-- Name: st_dwithin(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_dwithin(geometry, geometry, double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && ST_Expand($2,$3) AND $2 && ST_Expand($1,$3) AND _ST_DWithin($1, $2, $3)$_$;


--
-- TOC entry 1418 (class 1255 OID 207916)
-- Dependencies: 23 2185 2185
-- Name: st_dwithin(geography, geography, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_dwithin(geography, geography, double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && _ST_Expand($2,$3) AND $2 && _ST_Expand($1,$3) AND _ST_DWithin($1, $2, $3, true)$_$;


--
-- TOC entry 1419 (class 1255 OID 207917)
-- Dependencies: 23
-- Name: st_dwithin(text, text, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_dwithin(text, text, double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_DWithin($1::geometry, $2::geometry, $3);  $_$;


--
-- TOC entry 1420 (class 1255 OID 207918)
-- Dependencies: 23 2185 2185
-- Name: st_dwithin(geography, geography, double precision, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_dwithin(geography, geography, double precision, boolean) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && _ST_Expand($2,$3) AND $2 && _ST_Expand($1,$3) AND _ST_DWithin($1, $2, $3, $4)$_$;


--
-- TOC entry 1421 (class 1255 OID 207919)
-- Dependencies: 23 2189 2189
-- Name: st_endpoint(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_endpoint(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_endpoint_linestring';


--
-- TOC entry 1422 (class 1255 OID 207920)
-- Dependencies: 23 2189 2189
-- Name: st_envelope(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_envelope(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_envelope';


--
-- TOC entry 1423 (class 1255 OID 207921)
-- Dependencies: 23 2189 2189
-- Name: st_equals(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_equals(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Equals($1,$2)$_$;


--
-- TOC entry 1424 (class 1255 OID 207922)
-- Dependencies: 23 2160
-- Name: st_estimated_extent(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_estimated_extent(text, text) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT SECURITY DEFINER
    AS '$libdir/postgis-1.5', 'LWGEOM_estimated_extent';


--
-- TOC entry 1425 (class 1255 OID 207923)
-- Dependencies: 23 2160
-- Name: st_estimated_extent(text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_estimated_extent(text, text, text) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT SECURITY DEFINER
    AS '$libdir/postgis-1.5', 'LWGEOM_estimated_extent';


--
-- TOC entry 1426 (class 1255 OID 207924)
-- Dependencies: 23 2164 2164
-- Name: st_expand(box3d, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_expand(box3d, double precision) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_expand';


--
-- TOC entry 1427 (class 1255 OID 207925)
-- Dependencies: 23 2160 2160
-- Name: st_expand(box2d, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_expand(box2d, double precision) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_expand';


--
-- TOC entry 1428 (class 1255 OID 207926)
-- Dependencies: 23 2189 2189
-- Name: st_expand(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_expand(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_expand';


--
-- TOC entry 1429 (class 1255 OID 207927)
-- Dependencies: 23 2189 2189
-- Name: st_exteriorring(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_exteriorring(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_exteriorring_polygon';


--
-- TOC entry 1430 (class 1255 OID 207928)
-- Dependencies: 23 2172
-- Name: st_factor(chip); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_factor(chip) RETURNS real
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getFactor';


--
-- TOC entry 1431 (class 1255 OID 207929)
-- Dependencies: 23 3246 2160
-- Name: st_find_extent(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent("' || columnname || '") FROM "' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;


--
-- TOC entry 1432 (class 1255 OID 207930)
-- Dependencies: 23 3246 2160
-- Name: st_find_extent(text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent("' || columnname || '") FROM "' || schemaname || '"."' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;


--
-- TOC entry 1433 (class 1255 OID 207931)
-- Dependencies: 23 2189 2189
-- Name: st_force_2d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_force_2d(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_2d';


--
-- TOC entry 1434 (class 1255 OID 207932)
-- Dependencies: 23 2189 2189
-- Name: st_force_3d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_force_3d(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_3dz';


--
-- TOC entry 1435 (class 1255 OID 207933)
-- Dependencies: 23 2189 2189
-- Name: st_force_3dm(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_force_3dm(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_3dm';


--
-- TOC entry 1436 (class 1255 OID 207934)
-- Dependencies: 23 2189 2189
-- Name: st_force_3dz(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_force_3dz(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_3dz';


--
-- TOC entry 1437 (class 1255 OID 207935)
-- Dependencies: 23 2189 2189
-- Name: st_force_4d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_force_4d(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_4d';


--
-- TOC entry 1438 (class 1255 OID 207936)
-- Dependencies: 23 2189 2189
-- Name: st_force_collection(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_force_collection(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_collection';


--
-- TOC entry 1439 (class 1255 OID 207937)
-- Dependencies: 23 2189 2189
-- Name: st_forcerhr(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_forcerhr(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_forceRHR_poly';


--
-- TOC entry 1440 (class 1255 OID 207938)
-- Dependencies: 23 2185
-- Name: st_geogfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geogfromtext(text) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_from_text';


--
-- TOC entry 1441 (class 1255 OID 207939)
-- Dependencies: 23 2185
-- Name: st_geogfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geogfromwkb(bytea) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_from_binary';


--
-- TOC entry 1442 (class 1255 OID 207940)
-- Dependencies: 23 2185
-- Name: st_geographyfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geographyfromtext(text) RETURNS geography
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geography_from_text';


--
-- TOC entry 1443 (class 1255 OID 207941)
-- Dependencies: 23 2189
-- Name: st_geohash(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geohash(geometry) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_GeoHash($1, 0)$_$;


--
-- TOC entry 1444 (class 1255 OID 207942)
-- Dependencies: 23 2189
-- Name: st_geohash(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geohash(geometry, integer) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ST_GeoHash';


--
-- TOC entry 1445 (class 1255 OID 207943)
-- Dependencies: 23 2189
-- Name: st_geomcollfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geomcollfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(ST_GeomFromText($1)) = 'GEOMETRYCOLLECTION'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1446 (class 1255 OID 207944)
-- Dependencies: 23 2189
-- Name: st_geomcollfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geomcollfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(ST_GeomFromText($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN ST_GeomFromText($1,$2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1447 (class 1255 OID 207945)
-- Dependencies: 23 2189
-- Name: st_geomcollfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geomcollfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(ST_GeomFromWKB($1)) = 'GEOMETRYCOLLECTION'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1448 (class 1255 OID 207946)
-- Dependencies: 23 2189
-- Name: st_geomcollfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geomcollfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(GeomFromWKB($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1449 (class 1255 OID 207947)
-- Dependencies: 23 2189 2160
-- Name: st_geometry(box2d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry(box2d) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_to_LWGEOM';


--
-- TOC entry 1450 (class 1255 OID 207948)
-- Dependencies: 23 2189 2164
-- Name: st_geometry(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry(box3d) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_LWGEOM';


--
-- TOC entry 1451 (class 1255 OID 207949)
-- Dependencies: 23 2189
-- Name: st_geometry(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'parse_WKT_lwgeom';


--
-- TOC entry 1452 (class 1255 OID 207950)
-- Dependencies: 23 2189 2172
-- Name: st_geometry(chip); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry(chip) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_to_LWGEOM';


--
-- TOC entry 1453 (class 1255 OID 207951)
-- Dependencies: 23 2189
-- Name: st_geometry(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_bytea';


--
-- TOC entry 1454 (class 1255 OID 207952)
-- Dependencies: 23 2189 2168
-- Name: st_geometry(box3d_extent); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry(box3d_extent) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_to_LWGEOM';


--
-- TOC entry 1455 (class 1255 OID 207953)
-- Dependencies: 23 2189 2189
-- Name: st_geometry_above(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_above(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_above';


--
-- TOC entry 1456 (class 1255 OID 207954)
-- Dependencies: 23
-- Name: st_geometry_analyze(internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_analyze(internal) RETURNS boolean
    LANGUAGE c STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_analyze';


--
-- TOC entry 1457 (class 1255 OID 207955)
-- Dependencies: 23 2189 2189
-- Name: st_geometry_below(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_below(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_below';


--
-- TOC entry 1458 (class 1255 OID 207956)
-- Dependencies: 23 2189 2189
-- Name: st_geometry_cmp(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_cmp(geometry, geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_cmp';


--
-- TOC entry 1459 (class 1255 OID 207957)
-- Dependencies: 23 2189 2189
-- Name: st_geometry_contain(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_contain(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_contain';


--
-- TOC entry 1460 (class 1255 OID 207958)
-- Dependencies: 23 2189 2189
-- Name: st_geometry_contained(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_contained(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_contained';


--
-- TOC entry 1461 (class 1255 OID 207959)
-- Dependencies: 23 2189 2189
-- Name: st_geometry_eq(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_eq(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_eq';


--
-- TOC entry 1462 (class 1255 OID 207960)
-- Dependencies: 23 2189 2189
-- Name: st_geometry_ge(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_ge(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_ge';


--
-- TOC entry 1463 (class 1255 OID 207961)
-- Dependencies: 23 2189 2189
-- Name: st_geometry_gt(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_gt(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_gt';


--
-- TOC entry 1464 (class 1255 OID 207962)
-- Dependencies: 23 2189
-- Name: st_geometry_in(cstring); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_in(cstring) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_in';


--
-- TOC entry 1465 (class 1255 OID 207963)
-- Dependencies: 23 2189 2189
-- Name: st_geometry_le(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_le(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_le';


--
-- TOC entry 1466 (class 1255 OID 207964)
-- Dependencies: 23 2189 2189
-- Name: st_geometry_left(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_left(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_left';


--
-- TOC entry 1467 (class 1255 OID 207965)
-- Dependencies: 2189 23 2189
-- Name: st_geometry_lt(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_lt(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'lwgeom_lt';


--
-- TOC entry 1468 (class 1255 OID 207966)
-- Dependencies: 23 2189
-- Name: st_geometry_out(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_out(geometry) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_out';


--
-- TOC entry 1469 (class 1255 OID 207967)
-- Dependencies: 2189 23 2189
-- Name: st_geometry_overabove(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_overabove(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overabove';


--
-- TOC entry 1470 (class 1255 OID 207968)
-- Dependencies: 2189 23 2189
-- Name: st_geometry_overbelow(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_overbelow(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overbelow';


--
-- TOC entry 1471 (class 1255 OID 207969)
-- Dependencies: 2189 23 2189
-- Name: st_geometry_overlap(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_overlap(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overlap';


--
-- TOC entry 1472 (class 1255 OID 207970)
-- Dependencies: 2189 23 2189
-- Name: st_geometry_overleft(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_overleft(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overleft';


--
-- TOC entry 1473 (class 1255 OID 207971)
-- Dependencies: 23 2189 2189
-- Name: st_geometry_overright(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_overright(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_overright';


--
-- TOC entry 1474 (class 1255 OID 207972)
-- Dependencies: 23 2189
-- Name: st_geometry_recv(internal); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_recv(internal) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_recv';


--
-- TOC entry 1475 (class 1255 OID 207973)
-- Dependencies: 2189 23 2189
-- Name: st_geometry_right(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_right(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_right';


--
-- TOC entry 1476 (class 1255 OID 207974)
-- Dependencies: 2189 23 2189
-- Name: st_geometry_same(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_same(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_samebox';


--
-- TOC entry 1477 (class 1255 OID 207975)
-- Dependencies: 23 2189
-- Name: st_geometry_send(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometry_send(geometry) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_send';


--
-- TOC entry 1478 (class 1255 OID 207976)
-- Dependencies: 23 2189
-- Name: st_geometryfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometryfromtext(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_text';


--
-- TOC entry 1479 (class 1255 OID 207977)
-- Dependencies: 23 2189
-- Name: st_geometryfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometryfromtext(text, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_text';


--
-- TOC entry 1480 (class 1255 OID 207978)
-- Dependencies: 2189 23 2189
-- Name: st_geometryn(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometryn(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_geometryn_collection';


--
-- TOC entry 1481 (class 1255 OID 207979)
-- Dependencies: 2189 23
-- Name: st_geometrytype(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geometrytype(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geometry_geometrytype';


--
-- TOC entry 1482 (class 1255 OID 207980)
-- Dependencies: 23 2189
-- Name: st_geomfromewkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geomfromewkb(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOMFromWKB';


--
-- TOC entry 1483 (class 1255 OID 207981)
-- Dependencies: 23 2189
-- Name: st_geomfromewkt(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geomfromewkt(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'parse_WKT_lwgeom';


--
-- TOC entry 1484 (class 1255 OID 207982)
-- Dependencies: 23 2189
-- Name: st_geomfromgml(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geomfromgml(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geom_from_gml';


--
-- TOC entry 1485 (class 1255 OID 207983)
-- Dependencies: 2189 23
-- Name: st_geomfromkml(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geomfromkml(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geom_from_kml';


--
-- TOC entry 1486 (class 1255 OID 207984)
-- Dependencies: 23 2189
-- Name: st_geomfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geomfromtext(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_text';


--
-- TOC entry 1487 (class 1255 OID 207985)
-- Dependencies: 23 2189
-- Name: st_geomfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geomfromtext(text, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_text';


--
-- TOC entry 1488 (class 1255 OID 207986)
-- Dependencies: 23 2189
-- Name: st_geomfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geomfromwkb(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_WKB';


--
-- TOC entry 1489 (class 1255 OID 207987)
-- Dependencies: 23 2189
-- Name: st_geomfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_geomfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_SetSRID(ST_GeomFromWKB($1), $2)$_$;


--
-- TOC entry 1490 (class 1255 OID 207988)
-- Dependencies: 23 2189
-- Name: st_gmltosql(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_gmltosql(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geom_from_gml';


--
-- TOC entry 1491 (class 1255 OID 207989)
-- Dependencies: 23 2189
-- Name: st_hasarc(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_hasarc(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_has_arc';


--
-- TOC entry 1492 (class 1255 OID 207990)
-- Dependencies: 23 2189 2189
-- Name: st_hausdorffdistance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_hausdorffdistance(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'hausdorffdistance';


--
-- TOC entry 1493 (class 1255 OID 207991)
-- Dependencies: 23 2189 2189
-- Name: st_hausdorffdistance(geometry, geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_hausdorffdistance(geometry, geometry, double precision) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'hausdorffdistancedensify';


--
-- TOC entry 1494 (class 1255 OID 207992)
-- Dependencies: 23 2172
-- Name: st_height(chip); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_height(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getHeight';


--
-- TOC entry 1495 (class 1255 OID 207993)
-- Dependencies: 23 2189 2189
-- Name: st_interiorringn(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_interiorringn(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_interiorringn_polygon';


--
-- TOC entry 1496 (class 1255 OID 207994)
-- Dependencies: 23 2189 2189 2189
-- Name: st_intersection(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_intersection(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'intersection';


--
-- TOC entry 1497 (class 1255 OID 207995)
-- Dependencies: 23 2185 2185 2185
-- Name: st_intersection(geography, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_intersection(geography, geography) RETURNS geography
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT geography(ST_Transform(ST_Intersection(ST_Transform(geometry($1), _ST_BestSRID($1, $2)), ST_Transform(geometry($2), _ST_BestSRID($1, $2))), 4326))$_$;


--
-- TOC entry 1498 (class 1255 OID 207996)
-- Dependencies: 23 2189
-- Name: st_intersection(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_intersection(text, text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Intersection($1::geometry, $2::geometry);  $_$;


--
-- TOC entry 1499 (class 1255 OID 207997)
-- Dependencies: 23 2189 2189
-- Name: st_intersects(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_intersects(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Intersects($1,$2)$_$;


--
-- TOC entry 1500 (class 1255 OID 207998)
-- Dependencies: 2185 2185 23
-- Name: st_intersects(geography, geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_intersects(geography, geography) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Distance($1, $2, 0.0, false) < 0.00001$_$;


--
-- TOC entry 1501 (class 1255 OID 207999)
-- Dependencies: 23
-- Name: st_intersects(text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_intersects(text, text) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_Intersects($1::geometry, $2::geometry);  $_$;


--
-- TOC entry 1502 (class 1255 OID 208000)
-- Dependencies: 2189 23
-- Name: st_isclosed(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_isclosed(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_isclosed_linestring';


--
-- TOC entry 1503 (class 1255 OID 208001)
-- Dependencies: 23 2189
-- Name: st_isempty(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_isempty(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_isempty';


--
-- TOC entry 1504 (class 1255 OID 208002)
-- Dependencies: 2189 23
-- Name: st_isring(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_isring(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'isring';


--
-- TOC entry 1505 (class 1255 OID 208003)
-- Dependencies: 2189 23
-- Name: st_issimple(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_issimple(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'issimple';


--
-- TOC entry 1506 (class 1255 OID 208004)
-- Dependencies: 23 2189
-- Name: st_isvalid(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_isvalid(geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'isvalid';


--
-- TOC entry 1507 (class 1255 OID 208005)
-- Dependencies: 23 2189
-- Name: st_isvalidreason(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_isvalidreason(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'isvalidreason';


--
-- TOC entry 1508 (class 1255 OID 208006)
-- Dependencies: 2189 23
-- Name: st_length(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_length(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_length2d_linestring';


--
-- TOC entry 1509 (class 1255 OID 208007)
-- Dependencies: 23 2185
-- Name: st_length(geography); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_length(geography) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT ST_Length($1, true)$_$;


--
-- TOC entry 1510 (class 1255 OID 208008)
-- Dependencies: 23
-- Name: st_length(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_length(text) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Length($1::geometry);  $_$;


--
-- TOC entry 1511 (class 1255 OID 208009)
-- Dependencies: 2185 23
-- Name: st_length(geography, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_length(geography, boolean) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'geography_length';


--
-- TOC entry 1512 (class 1255 OID 208010)
-- Dependencies: 23 2189
-- Name: st_length2d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_length2d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_length2d_linestring';


--
-- TOC entry 1513 (class 1255 OID 208011)
-- Dependencies: 23 2189 2212
-- Name: st_length2d_spheroid(geometry, spheroid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_length2d_spheroid(geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_length2d_ellipsoid';


--
-- TOC entry 1514 (class 1255 OID 208012)
-- Dependencies: 23 2189
-- Name: st_length3d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_length3d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_length_linestring';


--
-- TOC entry 1515 (class 1255 OID 208013)
-- Dependencies: 23 2189 2212
-- Name: st_length3d_spheroid(geometry, spheroid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_length3d_spheroid(geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_length_ellipsoid_linestring';


--
-- TOC entry 1516 (class 1255 OID 208014)
-- Dependencies: 2189 2212 23
-- Name: st_length_spheroid(geometry, spheroid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_length_spheroid(geometry, spheroid) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'LWGEOM_length_ellipsoid_linestring';


--
-- TOC entry 1517 (class 1255 OID 208015)
-- Dependencies: 2189 2189 23
-- Name: st_line_interpolate_point(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_line_interpolate_point(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_interpolate_point';


--
-- TOC entry 1518 (class 1255 OID 208016)
-- Dependencies: 23 2189 2189
-- Name: st_line_locate_point(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_line_locate_point(geometry, geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_locate_point';


--
-- TOC entry 1519 (class 1255 OID 208017)
-- Dependencies: 23 2189 2189
-- Name: st_line_substring(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_line_substring(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_substring';


--
-- TOC entry 1520 (class 1255 OID 208018)
-- Dependencies: 23 2189 2189
-- Name: st_linecrossingdirection(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_linecrossingdirection(geometry, geometry) RETURNS integer
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT CASE WHEN NOT $1 && $2 THEN 0 ELSE _ST_LineCrossingDirection($1,$2) END $_$;


--
-- TOC entry 1521 (class 1255 OID 208019)
-- Dependencies: 2189 2189 23
-- Name: st_linefrommultipoint(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_linefrommultipoint(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_from_mpoint';


--
-- TOC entry 1522 (class 1255 OID 208020)
-- Dependencies: 23 2189
-- Name: st_linefromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_linefromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'LINESTRING'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1523 (class 1255 OID 208021)
-- Dependencies: 23 2189
-- Name: st_linefromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_linefromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'LINESTRING'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1524 (class 1255 OID 208022)
-- Dependencies: 23 2189
-- Name: st_linefromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_linefromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'LINESTRING'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1525 (class 1255 OID 208023)
-- Dependencies: 23 2189
-- Name: st_linefromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_linefromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1526 (class 1255 OID 208024)
-- Dependencies: 2189 23 2189
-- Name: st_linemerge(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_linemerge(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'linemerge';


--
-- TOC entry 1527 (class 1255 OID 208025)
-- Dependencies: 23 2189
-- Name: st_linestringfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_linestringfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'LINESTRING'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1528 (class 1255 OID 208026)
-- Dependencies: 2189 23
-- Name: st_linestringfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_linestringfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1529 (class 1255 OID 208027)
-- Dependencies: 2189 2189 23
-- Name: st_linetocurve(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_linetocurve(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_line_desegmentize';


--
-- TOC entry 1530 (class 1255 OID 208028)
-- Dependencies: 2189 2189 23
-- Name: st_locate_along_measure(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_locate_along_measure(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT locate_between_measures($1, $2, $2) $_$;


--
-- TOC entry 1531 (class 1255 OID 208029)
-- Dependencies: 2189 2189 23
-- Name: st_locate_between_measures(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_locate_between_measures(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_locate_between_m';


--
-- TOC entry 1532 (class 1255 OID 208030)
-- Dependencies: 2189 2189 23
-- Name: st_locatebetweenelevations(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_locatebetweenelevations(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ST_LocateBetweenElevations';


--
-- TOC entry 1533 (class 1255 OID 208031)
-- Dependencies: 23 2189 2189 2189
-- Name: st_longestline(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_longestline(geometry, geometry) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_LongestLine(ST_ConvexHull($1), ST_ConvexHull($2))$_$;


--
-- TOC entry 1534 (class 1255 OID 208032)
-- Dependencies: 2189 23
-- Name: st_m(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_m(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_m_point';


--
-- TOC entry 1535 (class 1255 OID 208033)
-- Dependencies: 23 2189 2189 2160
-- Name: st_makebox2d(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_makebox2d(geometry, geometry) RETURNS box2d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX2DFLOAT4_construct';


--
-- TOC entry 1536 (class 1255 OID 208034)
-- Dependencies: 23 2164 2189 2189
-- Name: st_makebox3d(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_makebox3d(geometry, geometry) RETURNS box3d
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_construct';


--
-- TOC entry 1537 (class 1255 OID 208035)
-- Dependencies: 23 2189
-- Name: st_makeenvelope(double precision, double precision, double precision, double precision, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_makeenvelope(double precision, double precision, double precision, double precision, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ST_MakeEnvelope';


--
-- TOC entry 1538 (class 1255 OID 208036)
-- Dependencies: 23 2191 2189
-- Name: st_makeline(geometry[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_makeline(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makeline_garray';


--
-- TOC entry 1539 (class 1255 OID 208037)
-- Dependencies: 2189 2189 2189 23
-- Name: st_makeline(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_makeline(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makeline';


--
-- TOC entry 1540 (class 1255 OID 208038)
-- Dependencies: 2191 2189 23
-- Name: st_makeline_garray(geometry[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_makeline_garray(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makeline_garray';


--
-- TOC entry 1541 (class 1255 OID 208039)
-- Dependencies: 23 2189
-- Name: st_makepoint(double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_makepoint(double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint';


--
-- TOC entry 1542 (class 1255 OID 208040)
-- Dependencies: 2189 23
-- Name: st_makepoint(double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_makepoint(double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint';


--
-- TOC entry 1543 (class 1255 OID 208041)
-- Dependencies: 23 2189
-- Name: st_makepoint(double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_makepoint(double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint';


--
-- TOC entry 1544 (class 1255 OID 208042)
-- Dependencies: 23 2189
-- Name: st_makepointm(double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_makepointm(double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint3dm';


--
-- TOC entry 1545 (class 1255 OID 208043)
-- Dependencies: 2189 23 2189
-- Name: st_makepolygon(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_makepolygon(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoly';


--
-- TOC entry 1546 (class 1255 OID 208044)
-- Dependencies: 2191 23 2189 2189
-- Name: st_makepolygon(geometry, geometry[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_makepolygon(geometry, geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoly';


--
-- TOC entry 1547 (class 1255 OID 208045)
-- Dependencies: 2189 23 2189
-- Name: st_maxdistance(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_maxdistance(geometry, geometry) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT _ST_MaxDistance(ST_ConvexHull($1), ST_ConvexHull($2))$_$;


--
-- TOC entry 1548 (class 1255 OID 208046)
-- Dependencies: 23 2189
-- Name: st_mem_size(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_mem_size(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_mem_size';


--
-- TOC entry 1549 (class 1255 OID 208047)
-- Dependencies: 23 2189 2189
-- Name: st_minimumboundingcircle(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_minimumboundingcircle(geometry) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_MinimumBoundingCircle($1, 48)$_$;


--
-- TOC entry 1550 (class 1255 OID 208048)
-- Dependencies: 2189 23 3246 2189
-- Name: st_minimumboundingcircle(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_minimumboundingcircle(inputgeom geometry, segs_per_quarter integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
	DECLARE
	hull GEOMETRY;
	ring GEOMETRY;
	center GEOMETRY;
	radius DOUBLE PRECISION;
	dist DOUBLE PRECISION;
	d DOUBLE PRECISION;
	idx1 integer;
	idx2 integer;
	l1 GEOMETRY;
	l2 GEOMETRY;
	p1 GEOMETRY;
	p2 GEOMETRY;
	a1 DOUBLE PRECISION;
	a2 DOUBLE PRECISION;


	BEGIN

	-- First compute the ConvexHull of the geometry
	hull = ST_ConvexHull(inputgeom);
	--A point really has no MBC
	IF ST_GeometryType(hull) = 'ST_Point' THEN
		RETURN hull;
	END IF;
	-- convert the hull perimeter to a linestring so we can manipulate individual points
	--If its already a linestring force it to a closed linestring
	ring = CASE WHEN ST_GeometryType(hull) = 'ST_LineString' THEN ST_AddPoint(hull, ST_StartPoint(hull)) ELSE ST_ExteriorRing(hull) END;

	dist = 0;
	-- Brute Force - check every pair
	FOR i in 1 .. (ST_NumPoints(ring)-2)
		LOOP
			FOR j in i .. (ST_NumPoints(ring)-1)
				LOOP
				d = ST_Distance(ST_PointN(ring,i),ST_PointN(ring,j));
				-- Check the distance and update if larger
				IF (d > dist) THEN
					dist = d;
					idx1 = i;
					idx2 = j;
				END IF;
			END LOOP;
		END LOOP;

	-- We now have the diameter of the convex hull.  The following line returns it if desired.
	-- RETURN MakeLine(PointN(ring,idx1),PointN(ring,idx2));

	-- Now for the Minimum Bounding Circle.  Since we know the two points furthest from each
	-- other, the MBC must go through those two points. Start with those points as a diameter of a circle.

	-- The radius is half the distance between them and the center is midway between them
	radius = ST_Distance(ST_PointN(ring,idx1),ST_PointN(ring,idx2)) / 2.0;
	center = ST_Line_interpolate_point(ST_MakeLine(ST_PointN(ring,idx1),ST_PointN(ring,idx2)),0.5);

	-- Loop through each vertex and check if the distance from the center to the point
	-- is greater than the current radius.
	FOR k in 1 .. (ST_NumPoints(ring)-1)
		LOOP
		IF(k <> idx1 and k <> idx2) THEN
			dist = ST_Distance(center,ST_PointN(ring,k));
			IF (dist > radius) THEN
				-- We have to expand the circle.  The new circle must pass trhough
				-- three points - the two original diameters and this point.

				-- Draw a line from the first diameter to this point
				l1 = ST_Makeline(ST_PointN(ring,idx1),ST_PointN(ring,k));
				-- Compute the midpoint
				p1 = ST_line_interpolate_point(l1,0.5);
				-- Rotate the line 90 degrees around the midpoint (perpendicular bisector)
				l1 = ST_Translate(ST_Rotate(ST_Translate(l1,-X(p1),-Y(p1)),pi()/2),X(p1),Y(p1));
				--  Compute the azimuth of the bisector
				a1 = ST_Azimuth(ST_PointN(l1,1),ST_PointN(l1,2));
				--  Extend the line in each direction the new computed distance to insure they will intersect
				l1 = ST_AddPoint(l1,ST_Makepoint(X(ST_PointN(l1,2))+sin(a1)*dist,Y(ST_PointN(l1,2))+cos(a1)*dist),-1);
				l1 = ST_AddPoint(l1,ST_Makepoint(X(ST_PointN(l1,1))-sin(a1)*dist,Y(ST_PointN(l1,1))-cos(a1)*dist),0);

				-- Repeat for the line from the point to the other diameter point
				l2 = ST_Makeline(ST_PointN(ring,idx2),ST_PointN(ring,k));
				p2 = ST_Line_interpolate_point(l2,0.5);
				l2 = ST_Translate(ST_Rotate(ST_Translate(l2,-X(p2),-Y(p2)),pi()/2),X(p2),Y(p2));
				a2 = ST_Azimuth(ST_PointN(l2,1),ST_PointN(l2,2));
				l2 = ST_AddPoint(l2,ST_Makepoint(X(ST_PointN(l2,2))+sin(a2)*dist,Y(ST_PointN(l2,2))+cos(a2)*dist),-1);
				l2 = ST_AddPoint(l2,ST_Makepoint(X(ST_PointN(l2,1))-sin(a2)*dist,Y(ST_PointN(l2,1))-cos(a2)*dist),0);

				-- The new center is the intersection of the two bisectors
				center = ST_Intersection(l1,l2);
				-- The new radius is the distance to any of the three points
				radius = ST_Distance(center,ST_PointN(ring,idx1));
			END IF;
		END IF;
		END LOOP;
	--DONE!!  Return the MBC via the buffer command
	RETURN ST_Buffer(center,radius,segs_per_quarter);

	END;
$$;


--
-- TOC entry 1551 (class 1255 OID 208050)
-- Dependencies: 23 2189
-- Name: st_mlinefromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_mlinefromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'MULTILINESTRING'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1552 (class 1255 OID 208051)
-- Dependencies: 23 2189
-- Name: st_mlinefromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_mlinefromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE
	WHEN geometrytype(GeomFromText($1, $2)) = 'MULTILINESTRING'
	THEN GeomFromText($1,$2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1553 (class 1255 OID 208052)
-- Dependencies: 23 2189
-- Name: st_mlinefromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_mlinefromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1554 (class 1255 OID 208053)
-- Dependencies: 23 2189
-- Name: st_mlinefromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_mlinefromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'MULTILINESTRING'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1555 (class 1255 OID 208054)
-- Dependencies: 23 2189
-- Name: st_mpointfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_mpointfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'MULTIPOINT'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1556 (class 1255 OID 208055)
-- Dependencies: 23 2189
-- Name: st_mpointfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_mpointfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromText($1, $2)) = 'MULTIPOINT'
	THEN GeomFromText($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1557 (class 1255 OID 208056)
-- Dependencies: 23 2189
-- Name: st_mpointfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_mpointfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTIPOINT'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1558 (class 1255 OID 208057)
-- Dependencies: 2189 23
-- Name: st_mpointfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_mpointfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1, $2)) = 'MULTIPOINT'
	THEN GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1559 (class 1255 OID 208058)
-- Dependencies: 2189 23
-- Name: st_mpolyfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_mpolyfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'MULTIPOLYGON'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1560 (class 1255 OID 208059)
-- Dependencies: 2189 23
-- Name: st_mpolyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_mpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1, $2)) = 'MULTIPOLYGON'
	THEN ST_GeomFromText($1,$2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1561 (class 1255 OID 208060)
-- Dependencies: 23 2189
-- Name: st_mpolyfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_mpolyfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTIPOLYGON'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1562 (class 1255 OID 208061)
-- Dependencies: 2189 23
-- Name: st_mpolyfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_mpolyfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1563 (class 1255 OID 208062)
-- Dependencies: 2189 23 2189
-- Name: st_multi(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_multi(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_force_multi';


--
-- TOC entry 1564 (class 1255 OID 208063)
-- Dependencies: 23 2189
-- Name: st_multilinefromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_multilinefromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1565 (class 1255 OID 208064)
-- Dependencies: 23 2189
-- Name: st_multilinestringfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_multilinestringfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_MLineFromText($1)$_$;


--
-- TOC entry 1566 (class 1255 OID 208065)
-- Dependencies: 23 2189
-- Name: st_multilinestringfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_multilinestringfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MLineFromText($1, $2)$_$;


--
-- TOC entry 1567 (class 1255 OID 208066)
-- Dependencies: 23 2189
-- Name: st_multipointfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_multipointfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MPointFromText($1)$_$;


--
-- TOC entry 1568 (class 1255 OID 208067)
-- Dependencies: 23 2189
-- Name: st_multipointfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_multipointfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTIPOINT'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1569 (class 1255 OID 208068)
-- Dependencies: 23 2189
-- Name: st_multipointfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_multipointfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1,$2)) = 'MULTIPOINT'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1570 (class 1255 OID 208069)
-- Dependencies: 23 2189
-- Name: st_multipolyfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_multipolyfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'MULTIPOLYGON'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1571 (class 1255 OID 208070)
-- Dependencies: 23 2189
-- Name: st_multipolyfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_multipolyfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1572 (class 1255 OID 208071)
-- Dependencies: 23 2189
-- Name: st_multipolygonfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_multipolygonfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MPolyFromText($1)$_$;


--
-- TOC entry 1573 (class 1255 OID 208072)
-- Dependencies: 23 2189
-- Name: st_multipolygonfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_multipolygonfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT MPolyFromText($1, $2)$_$;


--
-- TOC entry 1574 (class 1255 OID 208073)
-- Dependencies: 23 2189
-- Name: st_ndims(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_ndims(geometry) RETURNS smallint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_ndims';


--
-- TOC entry 1575 (class 1255 OID 208074)
-- Dependencies: 2189 23
-- Name: st_npoints(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_npoints(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_npoints';


--
-- TOC entry 1576 (class 1255 OID 208075)
-- Dependencies: 23 2189
-- Name: st_nrings(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_nrings(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_nrings';


--
-- TOC entry 1577 (class 1255 OID 208076)
-- Dependencies: 23 2189
-- Name: st_numgeometries(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_numgeometries(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_numgeometries_collection';


--
-- TOC entry 1578 (class 1255 OID 208077)
-- Dependencies: 23 2189
-- Name: st_numinteriorring(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_numinteriorring(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_numinteriorrings_polygon';


--
-- TOC entry 1579 (class 1255 OID 208078)
-- Dependencies: 23 2189
-- Name: st_numinteriorrings(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_numinteriorrings(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_numinteriorrings_polygon';


--
-- TOC entry 1580 (class 1255 OID 208079)
-- Dependencies: 23 2189
-- Name: st_numpoints(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_numpoints(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_numpoints_linestring';


--
-- TOC entry 1581 (class 1255 OID 208080)
-- Dependencies: 2189 23 2189
-- Name: st_orderingequals(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_orderingequals(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ 
	SELECT $1 ~= $2 AND _ST_OrderingEquals($1, $2)
	$_$;


--
-- TOC entry 1582 (class 1255 OID 208081)
-- Dependencies: 2189 23 2189
-- Name: st_overlaps(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_overlaps(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Overlaps($1,$2)$_$;


--
-- TOC entry 1583 (class 1255 OID 208082)
-- Dependencies: 23 2189
-- Name: st_perimeter(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_perimeter(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_perimeter2d_poly';


--
-- TOC entry 1584 (class 1255 OID 208083)
-- Dependencies: 2189 23
-- Name: st_perimeter2d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_perimeter2d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_perimeter2d_poly';


--
-- TOC entry 1585 (class 1255 OID 208084)
-- Dependencies: 23 2189
-- Name: st_perimeter3d(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_perimeter3d(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_perimeter_poly';


--
-- TOC entry 1586 (class 1255 OID 208085)
-- Dependencies: 23 2189
-- Name: st_point(double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_point(double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_makepoint';


--
-- TOC entry 1587 (class 1255 OID 208086)
-- Dependencies: 23 2189
-- Name: st_point_inside_circle(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_point_inside_circle(geometry, double precision, double precision, double precision) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_inside_circle_point';


--
-- TOC entry 1588 (class 1255 OID 208087)
-- Dependencies: 23 2189
-- Name: st_pointfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_pointfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'POINT'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1589 (class 1255 OID 208088)
-- Dependencies: 23 2189
-- Name: st_pointfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_pointfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1, $2)) = 'POINT'
	THEN ST_GeomFromText($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1590 (class 1255 OID 208089)
-- Dependencies: 23 2189
-- Name: st_pointfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_pointfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'POINT'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1591 (class 1255 OID 208090)
-- Dependencies: 23 2189
-- Name: st_pointfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_pointfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'POINT'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1592 (class 1255 OID 208091)
-- Dependencies: 23 2189 2189
-- Name: st_pointn(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_pointn(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_pointn_linestring';


--
-- TOC entry 1593 (class 1255 OID 208092)
-- Dependencies: 23 2189 2189
-- Name: st_pointonsurface(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_pointonsurface(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'pointonsurface';


--
-- TOC entry 1594 (class 1255 OID 208093)
-- Dependencies: 23 2189
-- Name: st_polyfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_polyfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1)) = 'POLYGON'
	THEN ST_GeomFromText($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1595 (class 1255 OID 208094)
-- Dependencies: 23 2189
-- Name: st_polyfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_polyfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromText($1, $2)) = 'POLYGON'
	THEN ST_GeomFromText($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1596 (class 1255 OID 208095)
-- Dependencies: 23 2189
-- Name: st_polyfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_polyfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1)) = 'POLYGON'
	THEN ST_GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1597 (class 1255 OID 208096)
-- Dependencies: 23 2189
-- Name: st_polyfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_polyfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1, $2)) = 'POLYGON'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1598 (class 1255 OID 208097)
-- Dependencies: 2189 23 2189
-- Name: st_polygon(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_polygon(geometry, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ 
	SELECT setSRID(makepolygon($1), $2)
	$_$;


--
-- TOC entry 1599 (class 1255 OID 208098)
-- Dependencies: 23 2189
-- Name: st_polygonfromtext(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_polygonfromtext(text) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_PolyFromText($1)$_$;


--
-- TOC entry 1600 (class 1255 OID 208099)
-- Dependencies: 23 2189
-- Name: st_polygonfromtext(text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_polygonfromtext(text, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT PolyFromText($1, $2)$_$;


--
-- TOC entry 1601 (class 1255 OID 208100)
-- Dependencies: 23 2189
-- Name: st_polygonfromwkb(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_polygonfromwkb(bytea) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(GeomFromWKB($1)) = 'POLYGON'
	THEN GeomFromWKB($1)
	ELSE NULL END
	$_$;


--
-- TOC entry 1602 (class 1255 OID 208101)
-- Dependencies: 23 2189
-- Name: st_polygonfromwkb(bytea, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_polygonfromwkb(bytea, integer) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT CASE WHEN geometrytype(ST_GeomFromWKB($1,$2)) = 'POLYGON'
	THEN ST_GeomFromWKB($1, $2)
	ELSE NULL END
	$_$;


--
-- TOC entry 1603 (class 1255 OID 208102)
-- Dependencies: 23 2189 2191
-- Name: st_polygonize(geometry[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_polygonize(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'polygonize_garray';


--
-- TOC entry 1604 (class 1255 OID 208103)
-- Dependencies: 23 2189 2191
-- Name: st_polygonize_garray(geometry[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_polygonize_garray(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'polygonize_garray';


--
-- TOC entry 1605 (class 1255 OID 208104)
-- Dependencies: 23
-- Name: st_postgis_gist_joinsel(internal, oid, internal, smallint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_postgis_gist_joinsel(internal, oid, internal, smallint) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_joinsel';


--
-- TOC entry 1606 (class 1255 OID 208105)
-- Dependencies: 23
-- Name: st_postgis_gist_sel(internal, oid, internal, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_postgis_gist_sel(internal, oid, internal, integer) RETURNS double precision
    LANGUAGE c
    AS '$libdir/postgis-1.5', 'LWGEOM_gist_sel';


--
-- TOC entry 1607 (class 1255 OID 208106)
-- Dependencies: 23 2189 2189
-- Name: st_relate(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_relate(geometry, geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'relate_full';


--
-- TOC entry 1608 (class 1255 OID 208107)
-- Dependencies: 23 2189 2189
-- Name: st_relate(geometry, geometry, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_relate(geometry, geometry, text) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'relate_pattern';


--
-- TOC entry 1609 (class 1255 OID 208108)
-- Dependencies: 23 2189 2189
-- Name: st_removepoint(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_removepoint(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_removepoint';


--
-- TOC entry 1610 (class 1255 OID 208109)
-- Dependencies: 2189 23 2189
-- Name: st_reverse(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_reverse(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_reverse';


--
-- TOC entry 1611 (class 1255 OID 208110)
-- Dependencies: 23 2189 2189
-- Name: st_rotate(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_rotate(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT rotateZ($1, $2)$_$;


--
-- TOC entry 1612 (class 1255 OID 208111)
-- Dependencies: 23 2189 2189
-- Name: st_rotatex(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_rotatex(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1, 1, 0, 0, 0, cos($2), -sin($2), 0, sin($2), cos($2), 0, 0, 0)$_$;


--
-- TOC entry 1613 (class 1255 OID 208112)
-- Dependencies: 23 2189 2189
-- Name: st_rotatey(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_rotatey(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  cos($2), 0, sin($2),  0, 1, 0,  -sin($2), 0, cos($2), 0,  0, 0)$_$;


--
-- TOC entry 1614 (class 1255 OID 208113)
-- Dependencies: 23 2189 2189
-- Name: st_rotatez(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_rotatez(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  cos($2), -sin($2), 0,  sin($2), cos($2), 0,  0, 0, 1,  0, 0, 0)$_$;


--
-- TOC entry 1615 (class 1255 OID 208114)
-- Dependencies: 23 2189 2189
-- Name: st_scale(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_scale(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT scale($1, $2, $3, 1)$_$;


--
-- TOC entry 1616 (class 1255 OID 208115)
-- Dependencies: 23 2189 2189
-- Name: st_scale(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_scale(geometry, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  $2, 0, 0,  0, $3, 0,  0, 0, $4,  0, 0, 0)$_$;


--
-- TOC entry 1617 (class 1255 OID 208116)
-- Dependencies: 23 2189 2189
-- Name: st_segmentize(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_segmentize(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_segmentize2d';


--
-- TOC entry 1618 (class 1255 OID 208117)
-- Dependencies: 23 2172 2172
-- Name: st_setfactor(chip, real); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_setfactor(chip, real) RETURNS chip
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_setFactor';


--
-- TOC entry 1619 (class 1255 OID 208118)
-- Dependencies: 23 2189 2189 2189
-- Name: st_setpoint(geometry, integer, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_setpoint(geometry, integer, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_setpoint_linestring';


--
-- TOC entry 1620 (class 1255 OID 208119)
-- Dependencies: 23 2189 2189
-- Name: st_setsrid(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_setsrid(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_setSRID';


--
-- TOC entry 1621 (class 1255 OID 208120)
-- Dependencies: 23 2189 2189
-- Name: st_shift_longitude(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_shift_longitude(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_longitude_shift';


--
-- TOC entry 1622 (class 1255 OID 208121)
-- Dependencies: 23 2189 2189 2189
-- Name: st_shortestline(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_shortestline(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_shortestline2d';


--
-- TOC entry 1623 (class 1255 OID 208122)
-- Dependencies: 23 2189 2189
-- Name: st_simplify(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_simplify(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_simplify2d';


--
-- TOC entry 1624 (class 1255 OID 208123)
-- Dependencies: 23 2189 2189
-- Name: st_simplifypreservetopology(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_simplifypreservetopology(geometry, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT COST 100
    AS '$libdir/postgis-1.5', 'topologypreservesimplify';


--
-- TOC entry 1625 (class 1255 OID 208124)
-- Dependencies: 23 2189 2189
-- Name: st_snaptogrid(geometry, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_snaptogrid(geometry, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_SnapToGrid($1, 0, 0, $2, $2)$_$;


--
-- TOC entry 1626 (class 1255 OID 208125)
-- Dependencies: 23 2189 2189
-- Name: st_snaptogrid(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_snaptogrid(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT ST_SnapToGrid($1, 0, 0, $2, $3)$_$;


--
-- TOC entry 1627 (class 1255 OID 208126)
-- Dependencies: 23 2189 2189
-- Name: st_snaptogrid(geometry, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_snaptogrid(geometry, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_snaptogrid';


--
-- TOC entry 1628 (class 1255 OID 208127)
-- Dependencies: 23 2189 2189 2189
-- Name: st_snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_snaptogrid_pointoff';


--
-- TOC entry 1629 (class 1255 OID 208128)
-- Dependencies: 23 2212
-- Name: st_spheroid_in(cstring); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_spheroid_in(cstring) RETURNS spheroid
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ellipsoid_in';


--
-- TOC entry 1630 (class 1255 OID 208129)
-- Dependencies: 23 2212
-- Name: st_spheroid_out(spheroid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_spheroid_out(spheroid) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'ellipsoid_out';


--
-- TOC entry 1631 (class 1255 OID 208130)
-- Dependencies: 23 2172
-- Name: st_srid(chip); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_srid(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getSRID';


--
-- TOC entry 1632 (class 1255 OID 208131)
-- Dependencies: 23 2189
-- Name: st_srid(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_srid(geometry) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_getSRID';


--
-- TOC entry 1633 (class 1255 OID 208132)
-- Dependencies: 23 2189 2189
-- Name: st_startpoint(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_startpoint(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_startpoint_linestring';


--
-- TOC entry 1634 (class 1255 OID 208133)
-- Dependencies: 23 2189
-- Name: st_summary(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_summary(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_summary';


--
-- TOC entry 1635 (class 1255 OID 208134)
-- Dependencies: 23 2189 2189 2189
-- Name: st_symdifference(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_symdifference(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'symdifference';


--
-- TOC entry 1636 (class 1255 OID 208135)
-- Dependencies: 23 2189 2189 2189
-- Name: st_symmetricdifference(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_symmetricdifference(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'symdifference';


--
-- TOC entry 1637 (class 1255 OID 208136)
-- Dependencies: 23 2189
-- Name: st_text(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_text(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_text';


--
-- TOC entry 1638 (class 1255 OID 208137)
-- Dependencies: 23 2189 2189
-- Name: st_touches(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_touches(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Touches($1,$2)$_$;


--
-- TOC entry 1639 (class 1255 OID 208138)
-- Dependencies: 23 2189 2189
-- Name: st_transform(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_transform(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'transform';


--
-- TOC entry 1640 (class 1255 OID 208139)
-- Dependencies: 23 2189 2189
-- Name: st_translate(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_translate(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT translate($1, $2, $3, 0)$_$;


--
-- TOC entry 1641 (class 1255 OID 208140)
-- Dependencies: 23 2189 2189
-- Name: st_translate(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_translate(geometry, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1, 1, 0, 0, 0, 1, 0, 0, 0, 1, $2, $3, $4)$_$;


--
-- TOC entry 1642 (class 1255 OID 208141)
-- Dependencies: 23 2189 2189
-- Name: st_transscale(geometry, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_transscale(geometry, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  $4, 0, 0,  0, $5, 0,
		0, 0, 1,  $2 * $4, $3 * $5, 0)$_$;


--
-- TOC entry 1643 (class 1255 OID 208142)
-- Dependencies: 23 2189 2191
-- Name: st_union(geometry[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_union(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'pgis_union_geometry_array';


--
-- TOC entry 1644 (class 1255 OID 208143)
-- Dependencies: 23 2189 2189 2189
-- Name: st_union(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_union(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'geomunion';


--
-- TOC entry 1645 (class 1255 OID 208144)
-- Dependencies: 23 2189 2191
-- Name: st_unite_garray(geometry[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_unite_garray(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'pgis_union_geometry_array';


--
-- TOC entry 1646 (class 1255 OID 208145)
-- Dependencies: 23 2172
-- Name: st_width(chip); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_width(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getWidth';


--
-- TOC entry 1647 (class 1255 OID 208146)
-- Dependencies: 23 2189 2189
-- Name: st_within(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_within(geometry, geometry) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT $1 && $2 AND _ST_Within($1,$2)$_$;


--
-- TOC entry 1648 (class 1255 OID 208147)
-- Dependencies: 23 2189
-- Name: st_wkbtosql(bytea); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_wkbtosql(bytea) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_WKB';


--
-- TOC entry 1649 (class 1255 OID 208148)
-- Dependencies: 23 2189
-- Name: st_wkttosql(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_wkttosql(text) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_from_text';


--
-- TOC entry 1650 (class 1255 OID 208149)
-- Dependencies: 23 2189
-- Name: st_x(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_x(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_x_point';


--
-- TOC entry 1651 (class 1255 OID 208150)
-- Dependencies: 23 2164
-- Name: st_xmax(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_xmax(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_xmax';


--
-- TOC entry 1652 (class 1255 OID 208151)
-- Dependencies: 23 2164
-- Name: st_xmin(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_xmin(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_xmin';


--
-- TOC entry 1653 (class 1255 OID 208152)
-- Dependencies: 23 2189
-- Name: st_y(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_y(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_y_point';


--
-- TOC entry 1654 (class 1255 OID 208153)
-- Dependencies: 23 2164
-- Name: st_ymax(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_ymax(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_ymax';


--
-- TOC entry 1655 (class 1255 OID 208154)
-- Dependencies: 23 2164
-- Name: st_ymin(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_ymin(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_ymin';


--
-- TOC entry 1656 (class 1255 OID 208155)
-- Dependencies: 23 2189
-- Name: st_z(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_z(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_z_point';


--
-- TOC entry 1657 (class 1255 OID 208156)
-- Dependencies: 23 2164
-- Name: st_zmax(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_zmax(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_zmax';


--
-- TOC entry 1658 (class 1255 OID 208157)
-- Dependencies: 23 2189
-- Name: st_zmflag(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_zmflag(geometry) RETURNS smallint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_zmflag';


--
-- TOC entry 1659 (class 1255 OID 208158)
-- Dependencies: 23 2164
-- Name: st_zmin(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION st_zmin(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_zmin';


--
-- TOC entry 1660 (class 1255 OID 208159)
-- Dependencies: 23 2189 2189
-- Name: startpoint(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION startpoint(geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_startpoint_linestring';


--
-- TOC entry 1661 (class 1255 OID 208160)
-- Dependencies: 23
-- Name: subarray(integer[], integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION subarray(integer[], integer) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'subarray';


--
-- TOC entry 1662 (class 1255 OID 208161)
-- Dependencies: 23
-- Name: subarray(integer[], integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION subarray(integer[], integer, integer) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'subarray';


--
-- TOC entry 1663 (class 1255 OID 208162)
-- Dependencies: 23 2189
-- Name: summary(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION summary(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_summary';


--
-- TOC entry 1664 (class 1255 OID 208163)
-- Dependencies: 23 2189 2189 2189
-- Name: symdifference(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION symdifference(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'symdifference';


--
-- TOC entry 1665 (class 1255 OID 208164)
-- Dependencies: 23 2189 2189 2189
-- Name: symmetricdifference(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION symmetricdifference(geometry, geometry) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'symdifference';


--
-- TOC entry 1666 (class 1255 OID 208165)
-- Dependencies: 23 2189
-- Name: text(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION text(geometry) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_to_text';


--
-- TOC entry 1667 (class 1255 OID 208166)
-- Dependencies: 23 2189 2189
-- Name: touches(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION touches(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'touches';


--
-- TOC entry 1668 (class 1255 OID 208167)
-- Dependencies: 23 2189 2189
-- Name: transform(geometry, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION transform(geometry, integer) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'transform';


--
-- TOC entry 1669 (class 1255 OID 208168)
-- Dependencies: 23 2189 2189
-- Name: translate(geometry, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION translate(geometry, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT translate($1, $2, $3, 0)$_$;


--
-- TOC entry 1670 (class 1255 OID 208169)
-- Dependencies: 23 2189 2189
-- Name: translate(geometry, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION translate(geometry, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1, 1, 0, 0, 0, 1, 0, 0, 0, 1, $2, $3, $4)$_$;


--
-- TOC entry 1671 (class 1255 OID 208170)
-- Dependencies: 23 2189 2189
-- Name: transscale(geometry, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION transscale(geometry, double precision, double precision, double precision, double precision) RETURNS geometry
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT affine($1,  $4, 0, 0,  0, $5, 0,
		0, 0, 1,  $2 * $4, $3 * $5, 0)$_$;


--
-- TOC entry 1672 (class 1255 OID 208171)
-- Dependencies: 23 3246
-- Name: trigger_usuario(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION trigger_usuario() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
/**************************************************************************
 SISTEMA ENDESIS - SISTEMA DE SEGURIDAD (SSS)
***************************************************************************
 SCRIPT: 		trisg_usuario
 DESCRIPCIÓN: 	Permite insertar, modificar y eliminar usuarios de la base
                de datos
 AUTOR: 		KPLIAN(rac)
 FECHA:			11-09-2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:
 
 DESCRIPCION:	cambio que permite crear nombre de usuario con .
 AUTOR:			KPLIAN (rac)
 FECHA:			26/11/2011

***************************************************************************/
--------------------------
-- CUERPO DE LA FUNCIÓN --
--------------------------

--**** DECLARACION DE VARIABLES DE LA FUNCIÓN (LOCALES) ****---


DECLARE

    --PARÁMETROS FIJOS

    g_consulta         text;    -- VARIABLE QUE CONTENDRÁ LA CONSULTA DINÁMICA PARA EL FILTRO
    g_new_login            text;
    g_old_login            text;
    y varchar;
    
    _SEMILLA varchar;
BEGIN

      --*** EJECUCIÓN DEL PROCEDIMIENTO ESPECÍFICO

  --procedimiento de creación de base de datos

_SEMILLA = '+_)(*&^%$#@!@TERPODO';


    IF TG_OP = 'INSERT' THEN

                BEGIN
                select (current_database()::text)||'_'||NEW.cuenta into g_new_login;
                     -- Creación Usuario
                     g_consulta := 'CREATE USER'||' "'||g_new_login||'"';
                     g_consulta := g_consulta||' '||'WITH ENCRYPTED PASSWORD '''||md5(_SEMILLA||NEW.contrasena)||'''';
                     g_consulta := g_consulta||' '||'VALID UNTIL '''||NEW.fecha_caducidad||'''';

                     EXECUTE(g_consulta);

                  
                     --ASGINACION DE ROLES
                     
                     y:='ALTER GROUP rol_usuario_'||current_database()::text||'
                     ADD USER  "'||g_new_login||'"';
                     EXECUTE (y); 
                     
         
                END;

          --procedimiento de modificacion de usuario

     
   ELSIF TG_OP = 'UPDATE' THEN

        BEGIN
        
            --raise exception  'llega';
            --Modificación de login
               select (current_database()::text)||'_'||NEW.cuenta into g_new_login;
               select (current_database()::text)||'_'||OLD.cuenta into g_old_login;
                 
                
           
                
             IF (OLD.cuenta != NEW.cuenta) THEN
               		 g_consulta := 'ALTER USER "'||g_old_login||'" RENAME TO "'||g_new_login||'"';
          
           		     EXECUTE(g_consulta);
                   
             END IF; 

             -- Modificación de la contraseña

            IF (OLD.contrasena != NEW.contrasena) THEN

                    g_consulta := NULL;
                    g_consulta := 'ALTER USER "'||g_new_login||'" ';
                    g_consulta := g_consulta||' '||'WITH ENCRYPTED PASSWORD '''||md5(_SEMILLA||NEW.contrasena)||'''';

                    EXECUTE(g_consulta);
                    
                   
                    
            END IF;

                 -- Modificación de la Fecha de Validez del usuario

            IF (OLD.fecha_caducidad != NEW.fecha_caducidad) THEN

                    g_consulta := NULL;
                    g_consulta := 'ALTER USER "'||g_new_login||'" ';
                    g_consulta := g_consulta||' '||'VALID UNTIL '''||NEW.fecha_caducidad||'''';

                    EXECUTE(g_consulta);

            END IF;
            
            
                   -- Modificación de la Fecha de Validez del usuario

           IF (NEW.estado_reg != OLD.estado_reg) THEN

                  IF (NEW.estado_reg = 'inactivo') THEN

                          g_consulta := NULL;
                          g_consulta := 'ALTER USER "'||g_new_login||'" ';
                          g_consulta := g_consulta||' '||'VALID UNTIL '''||now()||'''';
                          
                          EXECUTE(g_consulta);
                   ELSE      
                   
                          g_consulta := NULL;
                          g_consulta := 'ALTER USER "'||g_new_login||'"';
                          g_consulta := g_consulta||' '||'VALID UNTIL '''||NEW.fecha_caducidad||'''';

                          EXECUTE(g_consulta);
                   END IF;
            END IF;


        END;

  --procedimiento de eliminación de usuario

   ELSIF TG_OP = 'DELETE' THEN

        BEGIN
        select (current_database()::text)||'_'||OLD.cuenta into g_old_login;
             g_consulta := 'DROP USER "'||g_old_login||'"';
            
             EXECUTE(g_consulta);

        END;
        --*/

   END IF;

   RETURN NULL;

END;
$_$;


--
-- TOC entry 1362 (class 1255 OID 208172)
-- Dependencies: 23
-- Name: uniq(integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION uniq(integer[]) RETURNS integer[]
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/_int', 'uniq';


--
-- TOC entry 1673 (class 1255 OID 208173)
-- Dependencies: 23 2189 2191
-- Name: unite_garray(geometry[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION unite_garray(geometry[]) RETURNS geometry
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'pgis_union_geometry_array';


--
-- TOC entry 1674 (class 1255 OID 208174)
-- Dependencies: 23 3246
-- Name: unlockrows(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION unlockrows(text) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $_$ 
DECLARE
	ret int;
BEGIN

	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	EXECUTE 'DELETE FROM authorization_table where authid = ' ||
		quote_literal($1);

	GET DIAGNOSTICS ret = ROW_COUNT;

	RETURN ret;
END;
$_$;


--
-- TOC entry 1675 (class 1255 OID 208175)
-- Dependencies: 23 3246
-- Name: updategeometrysrid(character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION updategeometrysrid(character varying, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT UpdateGeometrySRID('','',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;


--
-- TOC entry 1676 (class 1255 OID 208176)
-- Dependencies: 23 3246
-- Name: updategeometrysrid(character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION updategeometrysrid(character varying, character varying, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT UpdateGeometrySRID('',$1,$2,$3,$4) into ret;
	RETURN ret;
END;
$_$;


--
-- TOC entry 1677 (class 1255 OID 208177)
-- Dependencies: 23 3246
-- Name: updategeometrysrid(character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION updategeometrysrid(character varying, character varying, character varying, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	catalog_name alias for $1;
	schema_name alias for $2;
	table_name alias for $3;
	column_name alias for $4;
	new_srid alias for $5;
	myrec RECORD;
	okay boolean;
	cname varchar;
	real_schema name;

BEGIN


	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = 'f';

		FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := 't';
		END LOOP;

		IF ( okay <> 't' ) THEN
			RAISE EXCEPTION 'Invalid schema name';
		ELSE
			real_schema = schema_name;
		END IF;
	ELSE
		SELECT INTO real_schema current_schema()::text;
	END IF;

	-- Find out if the column is in the geometry_columns table
	okay = 'f';
	FOR myrec IN SELECT * from geometry_columns where f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := 't';
	END LOOP;
	IF (okay <> 't') THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
		RETURN 'f';
	END IF;

	-- Update ref from geometry_columns table
	EXECUTE 'UPDATE geometry_columns SET SRID = ' || new_srid::text ||
		' where f_table_schema = ' ||
		quote_literal(real_schema) || ' and f_table_name = ' ||
		quote_literal(table_name)  || ' and f_geometry_column = ' ||
		quote_literal(column_name);

	-- Make up constraint name
	cname = 'enforce_srid_'  || column_name;

	-- Drop enforce_srid constraint
	EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||
		'.' || quote_ident(table_name) ||
		' DROP constraint ' || quote_ident(cname);

	-- Update geometries SRID
	EXECUTE 'UPDATE ' || quote_ident(real_schema) ||
		'.' || quote_ident(table_name) ||
		' SET ' || quote_ident(column_name) ||
		' = setSRID(' || quote_ident(column_name) ||
		', ' || new_srid::text || ')';

	-- Reset enforce_srid constraint
	EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||
		'.' || quote_ident(table_name) ||
		' ADD constraint ' || quote_ident(cname) ||
		' CHECK (srid(' || quote_ident(column_name) ||
		') = ' || new_srid::text || ')';

	RETURN real_schema || '.' || table_name || '.' || column_name ||' SRID changed to ' || new_srid::text;

END;
$_$;


--
-- TOC entry 1678 (class 1255 OID 208178)
-- Dependencies: 23 2172
-- Name: width(chip); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION width(chip) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'CHIP_getWidth';


--
-- TOC entry 1679 (class 1255 OID 208179)
-- Dependencies: 23 2189 2189
-- Name: within(geometry, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION within(geometry, geometry) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'within';


--
-- TOC entry 1680 (class 1255 OID 208180)
-- Dependencies: 23 2189
-- Name: x(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION x(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_x_point';


--
-- TOC entry 1681 (class 1255 OID 208181)
-- Dependencies: 23 2164
-- Name: xmax(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION xmax(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_xmax';


--
-- TOC entry 1682 (class 1255 OID 208182)
-- Dependencies: 23 2164
-- Name: xmin(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION xmin(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_xmin';


--
-- TOC entry 1683 (class 1255 OID 208183)
-- Dependencies: 23 2189
-- Name: y(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION y(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_y_point';


--
-- TOC entry 1684 (class 1255 OID 208184)
-- Dependencies: 23 2164
-- Name: ymax(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION ymax(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_ymax';


--
-- TOC entry 1685 (class 1255 OID 208185)
-- Dependencies: 23 2164
-- Name: ymin(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION ymin(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_ymin';


--
-- TOC entry 1686 (class 1255 OID 208186)
-- Dependencies: 23 2189
-- Name: z(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION z(geometry) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_z_point';


--
-- TOC entry 1687 (class 1255 OID 208187)
-- Dependencies: 23 2164
-- Name: zmax(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION zmax(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_zmax';


--
-- TOC entry 1688 (class 1255 OID 208188)
-- Dependencies: 23 2189
-- Name: zmflag(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION zmflag(geometry) RETURNS smallint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'LWGEOM_zmflag';


--
-- TOC entry 1689 (class 1255 OID 208189)
-- Dependencies: 23 2164
-- Name: zmin(box3d); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION zmin(box3d) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/postgis-1.5', 'BOX3D_zmin';


SET search_path = rhum, pg_catalog;

--
-- TOC entry 1690 (class 1255 OID 208190)
-- Dependencies: 16 3246
-- Name: __24nov11_ft_estructura_uo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION __24nov11_ft_estructura_uo_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		rhum.ft_estructura_uo_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 	    KPLIAN (mzm)
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		23-05-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_uo  				integer;

BEGIN

     v_nombre_funcion:='rhum.ft_estructura_uo_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:  RH_ESTRUO_INS
 #DESCRIPCION:	Inserta estructura de uos
 #AUTOR:			
 #FECHA:		23-05-2011	
***********************************/
     if(par_transaccion='RH_ESTRUO_INS')then

        
          BEGIN
               -- validacion de un solo nodo_base
               if exists (select distinct 1 from rhum.tuo where nodo_base='si' and estado_reg='activo' and v_parametros.nodo_base='si') then
                  raise exception 'Insercion no realizada. Ya se definio alguna unidad como nodo base';
               end if;
               
               -- verificar duplicidad de codigo de uo
               if exists (select distinct 1 from rhum.tuo where lower(codigo)=lower(v_parametros.codigo) and estado_reg='activo') then
               end if;
               -- insercion de uo nueva
               select nextval('rhum.tuo_id_uo_seq')::regclass into v_id_uo;
               insert into rhum.tuo(id_uo,          codigo,      nombre_unidad,nombre_cargo,   descripcion, cargo_individual,presupuesta,    estado_reg,  fecha_reg,id_usuario_reg, nodo_base)
               values(v_id_uo, upper(v_parametros.codigo), upper(v_parametros.nombre_unidad), upper(v_parametros.nombre_cargo), v_parametros.descripcion, v_parametros.cargo_individual, v_parametros.presupuesta, 'activo', now()::date, par_id_usuario, v_parametros.nodo_base);

               -- relacion de uo_hijo a o_padre
               INSERT INTO rhum.testructura_uo(id_uo_hijo, id_uo_padre,estado_reg, id_usuario_reg, fecha_reg)
               values(v_id_uo, v_parametros.id_uo_padre,'activo',    par_id_usuario, now()::date);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','estructura uo '||v_parametros.nombre_unidad ||' insertado con exito a ' || v_parametros.id_uo_padre);
               v_resp = f_agrega_clave(v_resp,'id_uo',v_id_uo::varchar);
         END;
 /*******************************    
 #TRANSACCION:  RH_ESTRUO_MOD
 #DESCRIPCION:	Modifica la parametrizacion seleccionada
 #AUTOR:			
 #FECHA:		23-05-2011
***********************************/
     elsif(par_transaccion='RH_ESTRUO_MOD')then

          
          BEGIN
               -- validacion de un solo nodo_base
               if exists (select distinct 1 from rhum.tuo where nodo_base='si' and estado_reg='activo' and id_uo!=v_parametros.id_uo and v_parametros.nodo_base='si') then
                  raise exception 'Insercion no realizada. Ya se definio alguna unidad como nodo base';
               end if;
               
               update rhum.tuo
               set codigo=upper(v_parametros.codigo),
                   nombre_unidad= upper(v_parametros.nombre_unidad),
                   nombre_cargo=upper(v_parametros.nombre_cargo),
                   descripcion=v_parametros.descripcion,
                   cargo_individual=v_parametros.cargo_individual,
                   presupuesta=v_parametros.presupuesta,
                   nodo_base=v_parametros.nodo_base
                where id_uo=v_parametros.id_uo;
               
                v_resp = f_agrega_clave(v_resp,'mensaje','estructura uo modificado con exito '||v_parametros.id_uo);
                v_resp = f_agrega_clave(v_resp,'id_uo',v_parametros.id_uo::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  RH_ESTRUO_ELI
 #DESCRIPCION:	Inactiva la parametrizacion selecionada. Verifica dependencias hacia abajo
 #AUTOR:			
 #FECHA:		23-05-2011
***********************************/

    elsif(par_transaccion='RH_ESTRUO_ELI')then
        BEGIN
        
         --inactivacion de la estructura uo
              if exists (select distinct 1 from rhum.testructura_uo
                         where id_uo_hijo in (select id_uo_padre from rhum.testructura_uo where estado_reg='activo')) then
                         raise exception 'Eliminacion no realizada. La Unidad que se inactiva tiene dependencias';
              end if;
               update rhum.tuo
               set estado_reg='eliminado'
               where id_uo=v_parametros.id_uo;
              
               
               v_resp = f_agrega_clave(v_resp,'mensaje','estructura uo eliminada con exito '||v_parametros.id_uo);
               v_resp = f_agrega_clave(v_resp,'id_uo',v_parametros.id_uo::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1691 (class 1255 OID 208192)
-- Dependencies: 16 3246
-- Name: __24nov11_ft_estructura_uo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION __24nov11_ft_estructura_uo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		RHUM.ft_uo_sel
 DESCRIPCIÓN:  listado de uo
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		21-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


v_condicion 		varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_estructura_uo_sel';

/*******************************
 #TRANSACCION:  RH_UO_SEL
 #DESCRIPCION:	Listado de uos
 #AUTOR:		
 #FECHA:		23/05/11	
***********************************/
     if(par_transaccion='RH_ESTRUO_SEL')then

          
          BEGIN

           if(v_parametros.id_padre = '%') then
               v_condicion:='uo.nodo_base=''si'' ';
           else
               v_condicion:='euo.id_uo_padre='||v_parametros.id_padre||' and uo.nodo_base=''no'' ';
           end if;
               v_condicion:=v_condicion ||' and euo.estado_reg=''activo'' and uo.estado_reg=''activo'' ';
               
               
               v_consulta:='SELECT
                                UO.id_uo,
                                UO.codigo,
                                UO.descripcion,
                                UO.cargo_individual,
                                UO.nombre_unidad,
                                UO.nombre_cargo,
                                UO.presupuesta,
                                UO.nodo_base,
                                UO.estado_reg,
                                UO.fecha_reg,
                                UO.id_usuario_reg,
                                UO.fecha_mod,
                                UO.id_usuario_mod,
                                PERREG.nombre_completo2 AS USUREG,
                                PERMOD.nombre_completo2 AS USUMOD,
                                euo.id_uo_padre,
                                euo.id_estructura_uo
                            FROM rhum.tuo UO
                            inner join rhum.testructura_uo euo
                            on UO.id_uo=euo.id_uo_hijo
                            INNER JOIN segu.tusuario USUREG ON  UO.id_usuario_reg=USUREG.id_usuario
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=UO.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE '|| v_condicion;
               
               
             --  v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by euo.id_uo_hijo,UO.nombre_unidad' ;

               return v_consulta;


         END;

/*******************************
 #TRANSACCION:  RH_ESTRUO_CONT
 #DESCRIPCION:	Conteo de estructura uos
 #AUTOR:		
 #FECHA:		24/05/11	
***********************************/
     elsif(par_transaccion='RH_ESTRUO_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(UO.id_uo)
                            FROM rhum.tuo UO
                            inner join rhum.testructura_uo euo
                            on UO.id_uo=euo.id_uo_hijo
                            INNER JOIN segu.tusuario USUREG ON  UO.id_usuario_reg=USUREG.id_usuario
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=UO.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE '|| v_condicion;
              -- v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1692 (class 1255 OID 208193)
-- Dependencies: 16 3246
-- Name: __24nov11_ft_funcionario_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION __24nov11_ft_funcionario_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 funcionario: 		RHUM.ft_funcionario_sel
 DESCRIPCIÓN:  listado de funcionario
 AUTOR: 		
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		21-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_funcionario_sel';


     if(par_transaccion='RH_FUNCIO_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            FUNCIO.id_funcionario,
                            FUNCIO.codigo,
                            FUNCIO.estado_reg,
                            FUNCIO.fecha_reg,
                            FUNCIO.id_persona,
                            FUNCIO.id_usuario_reg,
                            FUNCIO.fecha_mod,
                            FUNCIO.id_usuario_mod,
                            PERSON.nombre_completo1 AS desc_person,
                            PERREG.nombre_completo1 AS desc_usureg,
                            PERSON.ci, PERSON.num_documento,
                            PERSON.telefono1, PERSON.celular1, PERSON.correo
                            FROM rhum.tfuncionario FUNCIO
                            INNER JOIN SEGU.vpersona PERSON ON PERSON.id_persona=FUNCIO.id_persona
                            INNER JOIN SEGU.tusuario USUARI ON USUARI.id_usuario=FUNCIO.id_usuario_reg
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUARI.id_persona
                            WHERE ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='RH_FUNCIO_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(FUNCIO.id_funcionario)
                            FROM rhum.tfuncionario FUNCIO
                            INNER JOIN SEGU.vpersona PERSON ON PERSON.id_persona=FUNCIO.id_persona
                            INNER JOIN SEGU.tusuario USUARI ON USUARI.id_usuario=FUNCIO.id_usuario_reg
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUARI.id_persona
                            WHERE ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1693 (class 1255 OID 208194)
-- Dependencies: 16 3246
-- Name: f_obtener_funcionarios_x_uo(integer); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION f_obtener_funcionarios_x_uo(kp_id_uo integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA ENDESIS - SISTEMA DE KARD
***************************************************************************
 SCRIPT:f_obtener_funcionarios_x_uo
 COMENTARIOS:
 AUTOR: MZM
 Fecha: 19-03-12

*/
DECLARE
v_respuesta varchar;
v_registros record;
v_id_uo     integer;
BEGIN

    for v_registros in (
    select e.desc_funcionario1 as nombre_completo
                         from rhum.vfuncionario e
                         inner join rhum.tuo_funcionario ha on ha.id_funcionario=e.id_funcionario
                         where ha.estado_reg='activo' and ha.id_uo=kp_id_uo) loop

               if(v_respuesta!='') then
                  v_respuesta:= COALESCE(v_respuesta,'')||'<br>-'||v_registros.nombre_completo;
               else
                  v_respuesta:=v_registros.nombre_completo;
               end if;

     end loop;
return v_respuesta;
END;
$$;


--
-- TOC entry 1694 (class 1255 OID 208195)
-- Dependencies: 16 3246
-- Name: f_obtener_uo_x_funcionario(integer, character varying, date); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION f_obtener_uo_x_funcionario(par_id_funcionario integer, par_opcion character varying, par_fecha date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/************************************
FUNCION: f_obtener_uo_x_funcionario
AUTOR: 	    KPLIAN (mzm)
PARAMETROS: par_id_funcionario : Nodo a partir del cual se quiere obtener la uo (que presupuesta, que es gerencia, a la que pertenece en linea directa)
            par_opcion: presupuesto==> presupuesto, gerencia ==> gerencia, inmediato_superior==> superior, funcionario==> funcionario
            par_fecha: indica la fecha a la cual se quiere obtener la dependencia del funcionario, si se envia null, tomar la fecha actual
            Si no existe una asignacion activa para el funcionario a la fecha indicada ==> devolver -1
************************************/
DECLARE
    
    v_id_uo                              integer;
    v_registros                          record;
    v_mensaje_error                      varchar;
    v_uo_funcionario                     integer;
    v_gerencia                           varchar;
    v_presupuesta                        varchar;
    v_tope                               varchar;
    v_uo_padre                           integer;
    v_resp                               varchar;
    v_nombre_funcion                     text;
    

BEGIN

v_nombre_funcion:='rhum.f_obtener_uo_x_funcionario';
v_id_uo:=-1;
v_tope:='no';

    select  euo.id_uo_padre, UOFUNC.id_uo, UO.presupuesta, UO.gerencia, f_iif(UO.nodo_base='si','si','no')
    into v_uo_padre, v_uo_funcionario, v_presupuesta, v_gerencia, v_tope
    from rhum.tuo_funcionario UOFUNC
    inner join rhum.tuo UO on UO.id_uo=UOFUNC.id_uo
    inner join rhum.testructura_uo euo on euo.id_uo_hijo=UO.id_uo and UOFUNC.id_uo=euo.id_uo_hijo
    where
         ((UOFUNC.estado_reg='activo' and UOFUNC.fecha_asignacion<=coalesce(par_fecha,now()::date))
         or (UOFUNC.estado_reg='inactivo' and UOFUNC.fecha_finalizacion>=coalesce(par_fecha,now()::date)))
         and UOFUNC.id_funcionario=par_id_funcionario;
                              

    v_id_uo:= f_iif(((par_opcion='presupuesto' and v_presupuesta='si') or (par_opcion='gerencia' and v_gerencia='si') or (par_opcion='funcionario')), ''||v_uo_funcionario||'','-1')::integer;
 
   while (v_tope='no' and v_id_uo<1) loop

           select euo.id_uo_padre, UO.gerencia, UO.presupuesta, UO.id_uo, f_iif(UO.nodo_base='si','si','no') as nodo_base
           into v_uo_padre, v_gerencia, v_presupuesta, v_uo_funcionario, v_tope
           from rhum.testructura_uo euo
           inner join rhum.tuo UO on UO.id_uo=euo.id_uo_padre
           where euo.id_uo_hijo=v_uo_funcionario;
                 
                 if(par_opcion ='presupuesto') then
                        if(v_presupuesta='si') then
                                v_id_uo:=v_uo_funcionario;
                        else
                                v_uo_funcionario:=v_uo_padre;
                        end if;

                 elsif (par_opcion='gerencia') then
                 elsif (par_opcion='superior') then
                 else -- la uo a la que pertenece el usuario

                 end if;
   
    end loop;
    
    return v_id_uo;
    


EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1695 (class 1255 OID 208196)
-- Dependencies: 16 3246
-- Name: f_sincroniza_uo_empleado_entre_bd(integer, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION f_sincroniza_uo_empleado_entre_bd(p_id_uo_empleado integer, p_host_destino character varying, p_port_destino character varying, p_user_destino character varying, p_pwd_destino character varying, p_bd_destino character varying, p_opcion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    
v_consulta  varchar;
v_respuesta varchar;
v_registros record;

BEGIN
                           
   
       
        IF p_opcion = 'INSERT' THEN
            BEGIN   
            
               
              if not exists (select P.id_uo_empleado from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_historico_asignacion
                                               FROM kard.tkp_historico_asignacion where id_historico_asignacion='||p_id_uo_empleado) AS P(
                                                                                id_uo_empleado integer) ) then
                     
                  select * into v_registros from rhum.tuo_funcionario where id_uo_funcionario=p_id_uo_empleado;                                       
                     
                    
                    --raise exception 'nombre_unidad%,v_registros.nombre_cargo%,v_registros.cargo_individual%,v_registros.descripcion%,v_registros.sw_presto%',v_registros.nombre_unidad,v_registros.nombre_cargo,v_registros.cargo_individual,v_registros.descripcion,v_registros.sw_presto;
                    
                  v_consulta:='insert into kard.tkp_historico_asignacion (id_historico_asignacion, fecha_asignacion, estado, id_unidad_organizacional, id_empleado,fecha_registro, estado_reg, id_lugar, id_usuario_reg) 
                  values ('||p_id_uo_empleado||','''||v_registros.fecha_asignacion||''','''||v_registros.estado_reg||''',
                  '||v_registros.id_uo||','||v_registros.id_funcionario||','''||now()::date||''',''activo'','||2||','||1||'
                   );';
                  
                  v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                  
                  
                  return 'si';
             else 
                  raise exception 'ya existe';
             end if;                                   
            
          end;
        ELSEIF p_opcion='UPDATE' THEN
               BEGIN      
                       if exists (select P.id_uo_empleado from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_historico_asignacion
                                               FROM kard.tkp_historico_asignacion where id_historico_asignacion='||p_id_uo_empleado) AS P(
                                                                                id_uo_empleado integer) ) then 
                                                                                
                          select * into v_registros from rhum.tuo_funcionario where id_uo_funcionario=p_id_uo_empleado;                                       
                 
                          v_consulta:='update kard.tkp_historico_asignacion
                          set id_unidad_organizacional='||v_registros.id_uo||',
                          id_empleado='||v_registros.id_funcionario||',
                          fecha_asignacion='''||v_registros.fecha_asignacion||'''
                          estado='''||v_registros.estado_reg||''',
                          fecha_finalizacion='''||v_registros.fecha_finalizacion||'''
                          where id_historico_asignacion='||p_id_uo_empleado;   
                          
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);  
                           
                           /*----pendiente adicionar control para actualizacion de informacion de relacion entre uo's ----*/
                           
                            
                           return 'si';
                     else
                           return 'no';          
                     end if;
               END;
        ELSIF p_opcion='DELETE' THEN               
               BEGIN           
                      if exists (select P.id_uo_empleado from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_historico_asignacion
                                               FROM kard.tkp_historico_asignacion where id_historico_asignacion='||p_id_uo_empleado) AS P(
                                                                                id_uo_empleado integer) ) then 
                                                                                

                           --eliminamos la relacion en estructura_uo                                                                                
                           v_consulta:='delete from kard.tkp_historico_asignacion where id_historico_asignacion='||p_id_uo_empleado;
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   

                         
                           return 'si';                                                      
                     else
                       return 'no';
                     end if;
                   
               END;
        END IF;     
        
--RETURN NEW;
            
            
           
  RETURN NULL;
END;
$$;


--
-- TOC entry 1696 (class 1255 OID 208197)
-- Dependencies: 16 3246
-- Name: f_sincroniza_uo_entre_bd(integer, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION f_sincroniza_uo_entre_bd(p_id_uo integer, p_host_destino character varying, p_port_destino character varying, p_user_destino character varying, p_pwd_destino character varying, p_bd_destino character varying, p_opcion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    
v_consulta  varchar;
v_respuesta varchar;
v_registros record;

BEGIN
                           
   
       
        IF p_opcion = 'INSERT' THEN
            BEGIN   
            
                                                                                                        /*
              v_consulta:='SELECT id_persona
                                               FROM segu.tpersona where id_persona='||p_id_persona;   */
                  --raise exception 'aa%',coalesce(new.genero,'');          
              if not exists (select P.id_uo from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_unidad_organizacional
                                               FROM kard.tkp_unidad_organizacional where id_unidad_organizacional='||p_id_uo) AS P(
                                                                                id_uo integer) ) then
                     
                  select * into v_registros from rhum.tuo where id_uo=p_id_uo;                                       
                     
                  v_consulta:='insert into kard.tkp_unidad_organizacional(id_unidad_organizacional, nombre_unidad, nombre_cargo, 
                  cargo_individual, descripcion, sw_presto, codigo, gerencia, correspondencia, fecha_reg, id_nivel_organizacional,estado_reg) 
                  values ('||p_id_uo||','''||coalesce(v_registros.nombre_unidad,'-')||''','''||coalesce(v_registros.nombre_cargo,'-')||''',
                  '''||coalesce(v_registros.cargo_individual,'-')||''','''||coalesce(v_registros.descripcion,'-')||''','''||f_iif(v_registros.presupuesta='no','2','1')::numeric||''','''||coalesce(v_registros.codigo,'-')||''','''||coalesce(v_registros.gerencia,'-')||''','''||coalesce(v_registros.correspondencia,'-')||''',
                  '''||now()::date||''','||22||' ,''activo''
                   );';
                        
                  v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);       
                  
                  --insertamos en estructura_organizacional   
                  select * into v_registros from rhum.testructura_uo where id_uo_hijo=p_id_uo;
                  
                  v_consulta:='insert into kard.tkp_estructura_organizacional (relacion, fecha_reg, id_padre, id_hijo)
                  values (''dependiente'','''||now()::date||''','||v_registros.id_uo_padre||','||p_id_uo||');
                  ';
                  v_respuesta:= f_dblink(p_host_destino, p_port_destino, p_bd_destino, p_user_destino, p_pwd_destino, v_consulta);
                  
                  return 'si';
             else 
                  raise exception 'ya existe';
             end if;                                   
            
          end;
        ELSEIF p_opcion='UPDATE' THEN
               BEGIN                
                      if exists (select P.id_uo from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_unidad_organizacional
                                               FROM kard.tkp_unidad_organizacional where id_unidad_organizacional='||p_id_uo) AS P(
                                                                                id_uo integer) ) then   
                                                                                
                          select * into v_registros from rhum.tuo where id_uo=p_id_uo;                                       
                     
                          v_consulta:='update kard.tkp_unidad_organizacional
                          set 
                          nombre_unidad='''||coalesce(v_registros.nombre_unidad,'-')||''', 
                          nombre_cargo='''||coalesce(v_registros.nombre_cargo,'-')||''', 
                          cargo_individual='''||coalesce(v_registros.cargo_individual,'-')||''', 
                          descripcion='''||coalesce(v_registros.descripcion,'-')||''', 
                          sw_presto='||f_iif(v_registros.presupuesta='no','2','1')::numeric||', 
                          codigo='''||coalesce(v_registros.codigo,'-')||''', 
                          gerencia='''||coalesce(v_registros.gerencia,'-')||''', 
                          correspondencia='''||coalesce(v_registros.correspondencia,'-')||'''
                          where id_unidad_organizacional='||p_id_uo;   
                          
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                           return 'si';
                     else
                           return 'no';          
                     end if;
               END;
        ELSIF p_opcion='DELETE' THEN               
               BEGIN     
                     if exists (select P.id_uo from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_unidad_organizacional
                                               FROM kard.tkp_unidad_organizacional where id_unidad_organizacional='||p_id_uo) AS P(
                                                                                id_uo integer) ) then   
                           
                           v_consulta:='delete from kard.tkp_estructura_organizacional where id_hijo='||p_id_uo;
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);  
                                                                          
                           v_consulta:='delete from kard.tkp_unidad_organizacional where id_unidad_organizacional='||p_id_uo;
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                           return 'si';                                                      
                     else
                       return 'no';
                     end if;
                   
               END;
        END IF;     
        
--RETURN NEW;
            
            
           
  RETURN NULL;
END;
$$;


--
-- TOC entry 1697 (class 1255 OID 208198)
-- Dependencies: 16 3246
-- Name: f_uo_arb_inicia(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION f_uo_arb_inicia(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA ENDESIS - SISTEMA DE ...
***************************************************************************
 SCRIPT: 		kard.f_uo_arb_inicia
 DESCRIPCIÓN: 	
 AUTOR: 		Rensi Arteaga Copari
 FECHA:			19/03/2012
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCIÓN:
 AUTOR:       
 FECHA:      

***************************************************************************/
--------------------------
-- CUERPO DE LA FUNCIÓN --
--------------------------

-- PARÁMETROS FIJOS
/*
pm_id_usuario                               integer (si))
pm_ip_origen                                varchar(40) (si)
pm_mac_maquina                              macaddr (si)
pm_log_error                                varchar -- log -- error //variable interna (si)
pm_codigo_procedimiento                     varchar  // valor que identifica el tipo
                                                        de operacion a realizar
                                                        insert  (insertar)
                                                        delete  (eliminar)
                                                        update  (actualizar)
                                                        select  (visualizar)
pm_proc_almacenado                          varchar  // para colocar el nombre del procedimiento en caso de ser llamado
                                                        por otro procedimiento
*/

/*
      0) Crea una tabla temporal con los datos que se utilizaran para generar el arbol JSON   
           v_tabla = organigrama_filtro;
      1) FOR Lista los registros en la tabla original que cumplen con el filtro 
         1.1) Listamos la tabla temporal vara verficar si el registro no este ya insertado
         1.2) IF  Si el  registro NO ESTA insertado 
            1.2.1) si el nodo buscasdo no es la raiz seguimos buscando padres
              1.2.1.1)  Inicia la llamada recursiva para obetener el nivel final 
                       (en el camino va insertando en la tabla temporal todos los padres del regisotro)
            1.2.2) inserta el registro con el nivel final ya obtenido
       END LOOP;
     2) lista la tabla temporal y devuelve el resultado
*/

DECLARE


	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;


v_sw integer;
v_sw2 integer;
v_count integer;
v_consulta varchar;
v_consulta2 varchar;
g_registros  record;  -- PARA ALMACENAR EL CONJUNTO DE DATOS RESULTADO DEL SELECT
v_tabla varchar;
v_valor_nivel varchar;
v_nivel varchar;
v_niveles_acsi varchar;

pm_criterio_filtro varchar;
v_id integer;

BEGIN


 -- 0) Crea una tabla temporal con los datos que se utilizaran para generar el arbol JSON   

    v_tabla = '"organigrama_filtro"';
--raise exception 'en mantenimeinto';

/*
  id_uo SERIAL, 
  nombre_unidad VARCHAR(100), 
  nombre_cargo VARCHAR(50), 
  cargo_individual VARCHAR(2), 
  descripcion VARCHAR(100), 
  presupuesta VARCHAR(2), 
  codigo VARCHAR(15), 
  nodo_base VARCHAR(2), 
  gerencia VARCHAR(2), 
  correspondencia VARCHAR(2), 
*/

raise notice '00000  RH_INIUOARB_SEL=%',p_transaccion;
 
  
  
    v_nombre_funcion = 'rhum.f_uo_arb_inicia';
    v_parametros = f_get_record(p_tabla);
    pm_criterio_filtro= v_parametros.criterio_filtro_arb;
    
raise notice '%',pm_criterio_filtro;
	/*********************************    
 	#TRANSACCION:  'RH_INIUOARB_SEL'
 	#DESCRIPCION:	Filtro en organigrama
 	#AUTOR:		rac	
 	#FECHA:		16-03-2012 17:06:17
	***********************************/

	IF(p_transaccion='RH_INIUOARB_SEL')then
raise notice '11111111';
                    
   CREATE TEMPORARY TABLE organigrama_filtro (
                                  "niveles" varchar,
                                  "id_uo" INTEGER, 
                                  "nombre_unidad" VARCHAR, 
                                  "nombre_cargo" VARCHAR, 
                                  "cargo_individual" VARCHAR, 
                                  "descripcion" VARCHAR, 
                                  "presupuesta" VARCHAR, 
                                  "codigo" VARCHAR, 
                                  "nodo_base" VARCHAR, 
                                  "gerencia" VARCHAR, 
                                  "id_estructura_uo" INTEGER, 
                                  "correspondencia" VARCHAR,
                                  estado_reg varchar,
                                  funcionarios varchar,
                                  resaltar varchar,
                                  id_uo_padre integer
                                 
                                  
                                ) ON COMMIT DROP;
                    

   --        0) Crea una tabla temporal con los datos que se utilizaran para generar el arbol JSON   

            v_consulta := 'SELECT * FROM (SELECT
                           UNIORG.id_uo,
                           UNIORG.nombre_unidad,
                           UNIORG.nombre_cargo,
                           UNIORG.cargo_individual,
                           UNIORG.descripcion,
                           ESTORG.id_estructura_uo,
                           ESTORG.id_uo_padre,
                           UNIORG.estado_reg,
                           (rhum.f_obtener_funcionarios_x_uo(UNIORG.id_uo)) as funcionarios,
                           UNIORG.presupuesta,
                           UNIORG.correspondencia,
                           UNIORG.codigo, 
                           UNIORG.nodo_base, 
                           UNIORG.gerencia
                           FROM rhum.testructura_uo ESTORG
                           INNER JOIN rhum.tuo UNIORG
                           ON UNIORG.id_uo = ESTORG.id_uo_hijo
                           WHERE UNIORG.estado_reg=''activo''  ORDER BY  UNIORG.id_uo asc) AS ORG WHERE  (codigo  ilike ''%'||pm_criterio_filtro||'%''  or funcionarios ilike ''%'||pm_criterio_filtro||'%'' or nombre_cargo ilike ''%'||pm_criterio_filtro||'%'' )  ';
                           
                        
   
     --    1) FOR Lista los registros en la t_uotabla original que cumplen con el filtro 
raise notice '2222222222';
      FOR g_registros in EXECUTE(v_consulta) LOOP
      
      raise notice 'FOR --->';


     
     
       --       1.1) Listamos la tabla temporal vara verficar si el registro no este ya insertado
         
               SELECT  
                id_uo                 
                INTO 
                v_count
             
           FROM organigrama_filtro
           WHERE id_uo =g_registros.id_uo;
          
      --   1.2) IF  Si el  registro NO ESTA insertado 
          
          IF v_count is NULL THEN
                -- 1.2.1) si el nodo buscasdo no es la raiz seguimos buscando padres
                  IF(g_registros.nodo_base <> 'si') THEN
                  
                   --   1.2.1.1) Inicia la llamada recursiva para obetener el nivel final 
              --     (en el camino va insertando en la tabla temporal todos los padres del regisotro)
                            
                   v_nivel=rhum.f_uo_arb_recursivo(g_registros.id_uo_padre);
                   
                   v_nivel=v_nivel||g_registros.id_uo||'a';
                   
                  -- v_niveles_acsi = v_nivel||'_'||ascii(g_registros.id_uo);
                   
                  ELSE
                
                    v_nivel = g_registros.id_uo||'a';
                  --  v_niveles_acsi = ascii(g_registros.id_uo);
                  
                  END IF; 
                  
                           
      --    1.2.2) inserta el registro con el nivel final ya obtenido
                 
            INSERT  INTO organigrama_filtro 
                     (  niveles,
                        id_uo, 
                        nombre_unidad, 
                        nombre_cargo, 
                        cargo_individual, 
                        descripcion, 
                        presupuesta, 
                        codigo, 
                        nodo_base, 
                        gerencia, 
                        id_estructura_uo, 
                        correspondencia,
                        estado_reg,
                        funcionarios,
                        resaltar,
                        id_uo_padre
                     )
                     VALUES
                     (  v_nivel::varchar,
                        g_registros.id_uo, 
                        g_registros.nombre_unidad, 
                        g_registros.nombre_cargo, 
                        g_registros.cargo_individual, 
                        g_registros.descripcion, 
                        g_registros.presupuesta, 
                        g_registros.codigo, 
                        g_registros.nodo_base, 
                        g_registros.gerencia, 
                        g_registros.id_estructura_uo, 
                        g_registros.correspondencia,
                        g_registros.estado_reg,
                        g_registros.funcionarios,
                        'si', --RESALTA LOS REGISTRO QUE COINCIDEN CON EL FILTRO DE LA BUSQUEDA
                        g_registros.id_uo_padre
                        );        
              END IF;        
       END LOOP;
       
       raise notice '33333333';

  --   2) lista la tabla temporal y devuelve el resultado
  
  FOR g_registros in (SELECT                                   
                        niveles,
                        id_uo, 
                        nombre_unidad, 
                        nombre_cargo, 
                        cargo_individual, 
                        descripcion, 
                        presupuesta, 
                        codigo, 
                        nodo_base, 
                        gerencia, 
                        id_estructura_uo, 
                        correspondencia,
                        estado_reg,
                        funcionarios,
                        resaltar,
                        id_uo_padre
                      FROM organigrama_filtro
                      ORDER BY niveles asc ) LOOP
     RETURN NEXT g_registros;
   END LOOP;
   
   
  /* g_registros =(SELECT                                   
                        niveles,
                        id_uo, 
                        nombre_unidad, 
                        nombre_cargo, 
                        cargo_individual, 
                        descripcion, 
                        presupuesta, 
                        codigo, 
                        nodo_base, 
                        gerencia, 
                        id_estructura_uo, 
                        correspondencia,
                        estado_reg,
                        funcionarios,
                        resaltar
                      FROM organigrama_filtro
                      ORDER BY niveles asc);
                       
    RETURN next g_registros;*/
    
    
 END IF;


EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 1698 (class 1255 OID 208200)
-- Dependencies: 16 3246
-- Name: f_uo_arb_recursivo(integer); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION f_uo_arb_recursivo(v_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA ENDESIS - SISTEMA DE ...
***************************************************************************
 SCRIPT: 		rhum.f_uo_arb_recursivo
 DESCRIPCIÓN: 	
 AUTOR: 		Rensi Arteaga Copari
 FECHA:			2012
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCIÓN:
 AUTOR:       
 FECHA:      

***************************************************************************/
--------------------------
-- CUERPO DE LA FUNCIÓN --
--------------------------

-- PARÁMETROS FIJOS
/*
pm_id_usuario                               integer (si))
pm_ip_origen                                varchar(40) (si)
pm_mac_maquina                              macaddr (si)
pm_log_error                                varchar -- log -- error //variable interna (si)
pm_codigo_procedimiento                     varchar  // valor que identifica el tipo
                                                        de operacion a realizar
                                                        insert  (insertar)
                                                        delete  (eliminar)
                                                        update  (actualizar)
                                                        select  (visualizar)
pm_proc_almacenado                          varchar  // para colocar el nombre del procedimiento en caso de ser llamado
                                                        por otro procedimiento
*/


/*
  0) listamos el regisotr con el v_id en la tabla temporal
  1)IF  si no hay registros en la tabla temporal
  1.1) Listamos el registro  con el v_id  de la tabla orignal
  1.2) IF, el registro v_id  NO tiene padre
  1.2.0) insertamos el registro de v_id con niveles = v_id
  1.2.1)  return  v_id 
  1.3) ELSE, si el registro tiene padres  
  1.3.1) nivel = fun_red(v_id) RECURSIVAMENTE
  1.3.2) insertamos el registro de v_id con niveles = nivel+v_id
  1.3.3) return nivel||_||v_id
  2)ELSE  si  hay regisotr registros en la tabla temporal
  2.1) retornamos los niveles del registro existente

*/


DECLARE
v_sw integer;
v_sw2 integer;
v_count integer;
v_consulta varchar;
v_consulta2 text;
v_consulta_ins text;
g_registros                record;  -- PARA ALMACENAR EL CONJUNTO DE DATOS RESULTADO DEL SELECT
v_bool varchar;
v_bool2 varchar;
v_nivel varchar;
BEGIN


  --0) listamos el regisotr con el v_id en la tabla temporal
       
       raise notice '########  arb recursivo ';
       SELECT  
          id_uo,
          niveles 
       INTO 
          v_count,
          v_nivel
       FROM organigrama_filtro
       WHERE id_uo =v_id;
                      
   
  
  --1)IF  si no hay registros en la tabla temporal
   IF v_count is NULL THEN
        --1.1) Listamos el registro  con el v_id  de la tabla orignal
        
         v_consulta := 'SELECT
                           UNIORG.id_uo,
                           UNIORG.nombre_unidad,
                           UNIORG.nombre_cargo,
                           UNIORG.cargo_individual,
                           UNIORG.descripcion,
                           ESTORG.id_estructura_uo,
                           ESTORG.id_uo_padre,
                           UNIORG.estado_reg,
                           (rhum.f_obtener_funcionarios_x_uo(UNIORG.id_uo)) as funcionarios,
                           UNIORG.presupuesta,
                           UNIORG.correspondencia,
                           UNIORG.codigo, 
                           UNIORG.nodo_base, 
                           UNIORG.gerencia
                           FROM rhum.testructura_uo ESTORG
                           INNER JOIN rhum.tuo UNIORG
                           ON UNIORG.id_uo = ESTORG.id_uo_hijo
                           WHERE UNIORG.estado_reg= ''activo''  AND UNIORG.id_uo = '||COALESCE(v_id,'0');
        
      FOR g_registros in EXECUTE (v_consulta) LOOP
        
        --1.2) IF, el registro v_id  NO tiene padre
        IF g_registros.nodo_base = 'si' THEN
        RAISE NOTICE '>>>>>>>>>IF id_uo_padre = %',g_registros.id_uo_padre;
        
        --1.2.0) insertamos el registro de v_id con niveles = v_id
        
            INSERT  INTO organigrama_filtro 
                     (  niveles,
                        id_uo, 
                        nombre_unidad, 
                        nombre_cargo, 
                        cargo_individual, 
                        descripcion, 
                        presupuesta, 
                        codigo, 
                        nodo_base, 
                        gerencia, 
                        id_estructura_uo, 
                        correspondencia,
                        estado_reg,
                        funcionarios,
                        resaltar,
                        id_uo_padre
                     )
                     VALUES
                     (  v_id||'a'::varchar,
                        g_registros.id_uo, 
                        g_registros.nombre_unidad, 
                        g_registros.nombre_cargo, 
                        g_registros.cargo_individual, 
                        g_registros.descripcion, 
                        g_registros.presupuesta, 
                        g_registros.codigo, 
                        g_registros.nodo_base, 
                        g_registros.gerencia, 
                        g_registros.id_estructura_uo, 
                        g_registros.correspondencia,
                        g_registros.estado_reg,
                        g_registros.funcionarios,
                        'no',
                        g_registros.id_uo_padre
                     );
                     
        
        
        --1.2.1)  return  v_id 
        
       RETURN v_id||'a'::varchar;
        
        --1.3) ELSE, si el registro tiene padres  
        ELSE
        
        RAISE NOTICE '>>>>>>>>>ELSE ';
        
        --1.3.1) nivel = fun_red(v_id_padre) RECURSIVAMENTE
        
          v_nivel := rhum.f_uo_arb_recursivo(g_registros.id_uo_padre);
          
        --1.3.2) insertamos el registro de v_id con niveles = nivel+v_id
                     
                     INSERT  INTO organigrama_filtro 
                     (  niveles,
                        id_uo, 
                        nombre_unidad, 
                        nombre_cargo, 
                        cargo_individual, 
                        descripcion, 
                        presupuesta, 
                        codigo, 
                        nodo_base, 
                        gerencia, 
                        id_estructura_uo, 
                        correspondencia,
                        estado_reg,
                        funcionarios,
                        resaltar,
                        id_uo_padre

                     )
                     VALUES
                     (  (v_nivel||v_id||'a')::varchar,
                        g_registros.id_uo, 
                        g_registros.nombre_unidad, 
                        g_registros.nombre_cargo, 
                        g_registros.cargo_individual, 
                        g_registros.descripcion, 
                        g_registros.presupuesta, 
                        g_registros.codigo, 
                        g_registros.nodo_base, 
                        g_registros.gerencia, 
                        g_registros.id_estructura_uo, 
                        g_registros.correspondencia,
                        g_registros.estado_reg,
                        g_registros.funcionarios,
                        'no',
                        g_registros.id_uo_padre
                     );
                     
                     raise notice '<<<<<<< SALE DEL IF';
        
        END IF;
          --1.3.3) return nivel||_||v_id
        return v_nivel||v_id||'a';
        
        END LOOP;
      
      return v_nivel;
--2)ELSE  si  hay regisotr registros en la tabla temporal
  ELSE
   --2.1) retornamos los niveles del registro existente
   
    RETURN v_nivel;

  END IF;

END;
$$;


--
-- TOC entry 1699 (class 1255 OID 208202)
-- Dependencies: 16 3246
-- Name: ft_estructura_uo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION ft_estructura_uo_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		rhum.ft_estructura_uo_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 	    KPLIAN (mzm)
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		23-05-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_uo  				    integer;

--10-04-2012: sincronizacion de UO entre BD
v_respuesta_sinc            varchar;

BEGIN

     v_nombre_funcion:='rhum.ft_estructura_uo_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:  RH_ESTRUO_INS
 #DESCRIPCION:	Inserta estructura de uos
 #AUTOR:			
 #FECHA:		23-05-2011	
***********************************/
     if(par_transaccion='RH_ESTRUO_INS')then

        
          BEGIN                             
               -- validacion de un solo nodo_base
               if exists (select distinct 1 from rhum.tuo where nodo_base='si' and estado_reg='activo' and v_parametros.nodo_base='si') then
                  raise exception 'Insercion no realizada. Ya se definio alguna unidad como nodo base';
               end if;
               
               -- verificar duplicidad de codigo de uo
               if exists (select distinct 1 from rhum.tuo where lower(codigo)=lower(v_parametros.codigo) and estado_reg='activo') then
               end if;
               -- insercion de uo nueva
              
              
               insert into rhum.tuo( codigo,      nombre_unidad,nombre_cargo,   descripcion, cargo_individual,presupuesta,    estado_reg,  fecha_reg,id_usuario_reg, nodo_base, correspondencia, gerencia)
               values(upper(v_parametros.codigo), upper(v_parametros.nombre_unidad), upper(v_parametros.nombre_cargo), v_parametros.descripcion, v_parametros.cargo_individual, v_parametros.presupuesta, 'activo', now()::date, par_id_usuario, v_parametros.nodo_base, v_parametros.correspondencia, v_parametros.gerencia)
               RETURNING id_uo into v_id_uo;

               -- relacion de uo_hijo a o_padre
               INSERT INTO rhum.testructura_uo(id_uo_hijo, id_uo_padre,estado_reg, id_usuario_reg, fecha_reg)
               values(v_id_uo, v_parametros.id_uo_padre,'activo',    par_id_usuario, now()::date);
              
               
               --10-04-2012: sincronizacion de UO entre BD
               v_respuesta_sinc:=rhum.f_sincroniza_uo_entre_bd(v_id_uo,'10.172.0.13','5432','db_link','db_link','dbendesis' ,'INSERT');
      
               if(v_respuesta_sinc!='si')  then
                     raise exception 'Sincronizacion de UO en BD externa no realizada%',v_respuesta_sinc;
               end if;  
               
               v_resp = f_agrega_clave(v_resp,'mensaje','estructura uo '||v_parametros.nombre_unidad ||' insertado con exito a ' || v_parametros.id_uo_padre);
               v_resp = f_agrega_clave(v_resp,'id_uo',v_id_uo::varchar);
         END;
 /*******************************    
 #TRANSACCION:  RH_ESTRUO_MOD
 #DESCRIPCION:	Modifica la parametrizacion seleccionada
 #AUTOR:			
 #FECHA:		23-05-2011
***********************************/
     elsif(par_transaccion='RH_ESTRUO_MOD')then

          
          BEGIN            
               -- validacion de un solo nodo_base
               if exists (select distinct 1 from rhum.tuo where nodo_base='si' and estado_reg='activo' and id_uo!=v_parametros.id_uo and v_parametros.nodo_base='si') then
                  raise exception 'Insercion no realizada. Ya se definio alguna unidad como nodo base';
               end if;
               
               update rhum.tuo
               set codigo=upper(v_parametros.codigo),
                   nombre_unidad= upper(v_parametros.nombre_unidad),
                   nombre_cargo=upper(v_parametros.nombre_cargo),
                   descripcion=v_parametros.descripcion,
                   cargo_individual=v_parametros.cargo_individual,
                   presupuesta=v_parametros.presupuesta,
                   nodo_base=v_parametros.nodo_base,
                   correspondencia=v_parametros.correspondencia,
                   gerencia=v_parametros.gerencia
                where id_uo=v_parametros.id_uo;
                
                --10-04-2012: sincronizacion de UO entre BD
                v_respuesta_sinc:=rhum.f_sincroniza_uo_entre_bd(v_parametros.id_uo,'10.172.0.13','5432','db_link','db_link','dbendesis' ,'UPDATE');
      
                if(v_respuesta_sinc!='si')  then
                     raise exception 'Sincronizacion de UO en BD externa no realizada%',v_respuesta_sinc;
                end if; 
                
                v_resp = f_agrega_clave(v_resp,'mensaje','estructura uo modificado con exito '||v_parametros.id_uo);
                v_resp = f_agrega_clave(v_resp,'id_uo',v_parametros.id_uo::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  RH_ESTRUO_ELI
 #DESCRIPCION:	Inactiva la parametrizacion selecionada. Verifica dependencias hacia abajo
 #AUTOR:			
 #FECHA:		23-05-2011
 *********************************
 #AUTOR_MOD:	KPLIAN (rac)		
 #FECHA_MOD:	23-05-2011
 #DESC_MON:		Valida la eliminacion de nodos solo si sus hijos estan inactivos
***********************************/

    elsif(par_transaccion='RH_ESTRUO_ELI')then
        BEGIN
        
        
         
             
           --1) verificamos si tiene relaciones activas con sus hijos (asumimos que si tiene hijos tendra relaciones activas con ellos)
            
            if exists ( select DISTINCT 1 
                          from rhum.tuo uo
                          inner join  rhum.testructura_uo euo on uo.id_uo = euo.id_uo_padre and euo.estado_reg='activo' 
                          where uo.id_uo = v_parametros.id_uo) then
               
                        --NOTA) sera necesario adicionar  una trsaccion que realize una eliminacion recursiva
                        --      previa confirmacion del usuario despues de este error 
                             
                        raise exception 'Eliminacion no realizada.  La Unidad que se inactiva tiene dependencias  elimine primero los hijos';
              
              end if;
              
              --2) se fija que no tenga funcionarios en estado activo asignados a este uo 
              if exists ( select DISTINCT 1 
                          from rhum.tuo_funcionario uof
                          where uof.id_uo = v_parametros.id_uo and uof.estado_reg='activo') then
             
                             
                        raise exception 'Eliminacion no realizada. La Unidad que se intenta eliminar tiene relaciones vigentes con empleados';
              
              end if;
               
               --3) inactiva la unidad
               update rhum.tuo
               set estado_reg='inactivo'
               where id_uo=v_parametros.id_uo;
               
               
               -- 4) inactiva las relaciones con los padres (para que se cumpla siempre la regla en 1)
               update rhum.testructura_uo
               set estado_reg='inactivo'
               where id_uo_hijo=v_parametros.id_uo;
              
               --10-04-2012: sincronizacion de UO entre BD
                v_respuesta_sinc:=rhum.f_sincroniza_uo_entre_bd(v_parametros.id_uo,'10.172.0.13','5432','db_link','db_link','dbendesis' ,'DELETE');
      
                if(v_respuesta_sinc!='si')  then
                     raise exception 'Sincronizacion de UO en BD externa no realizada%',v_respuesta_sinc;
                end if;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','estructura uo eliminada con exito '||v_parametros.id_uo);
               v_resp = f_agrega_clave(v_resp,'id_uo',v_parametros.id_uo::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1700 (class 1255 OID 208204)
-- Dependencies: 16 3246
-- Name: ft_estructura_uo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION ft_estructura_uo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		RHUM.ft_uo_sel
 DESCRIPCIÓN:  listado de uo
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		21-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


v_condicion 		varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_estructura_uo_sel';

/*******************************
 #TRANSACCION:  RH_UO_SEL
 #DESCRIPCION:	Listado de uos
 #AUTOR:		
 #FECHA:		23/05/11	
***********************************/
     if(par_transaccion='RH_ESTRUO_SEL')then

          
          BEGIN

           if(v_parametros.id_padre = '%') then
               v_condicion:='uo.nodo_base=''si'' ';
           else
               v_condicion:='euo.id_uo_padre='||v_parametros.id_padre||' and uo.nodo_base=''no'' ';
           end if;
               v_condicion:=v_condicion ||' and euo.estado_reg=''activo'' and uo.estado_reg=''activo'' ';
               
               
               v_consulta:='SELECT
                                UO.id_uo,
                                UO.codigo,
                                UO.descripcion,
                                UO.cargo_individual,
                                UO.nombre_unidad,
                                UO.nombre_cargo,
                                UO.presupuesta,
                                UO.nodo_base,
                                UO.estado_reg,
                                UO.fecha_reg,
                                UO.id_usuario_reg,
                                UO.fecha_mod,
                                UO.id_usuario_mod,
                                PERREG.nombre_completo2 AS USUREG,
                                PERMOD.nombre_completo2 AS USUMOD,
                                euo.id_uo_padre,
                                euo.id_estructura_uo,
                                UO.correspondencia,
                                UO.gerencia
                            FROM rhum.tuo UO
                            inner join rhum.testructura_uo euo
                            on UO.id_uo=euo.id_uo_hijo
                            INNER JOIN segu.tusuario USUREG ON  UO.id_usuario_reg=USUREG.id_usuario
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=UO.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE '|| v_condicion;
               
               
             --  v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by euo.id_uo_hijo,UO.nombre_unidad' ;

               return v_consulta;


         END;

/*******************************
 #TRANSACCION:  RH_ESTRUO_CONT
 #DESCRIPCION:	Conteo de estructura uos
 #AUTOR:		
 #FECHA:		24/05/11	
***********************************/
     elsif(par_transaccion='RH_ESTRUO_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(UO.id_uo)
                            FROM rhum.tuo UO
                            inner join rhum.testructura_uo euo
                            on UO.id_uo=euo.id_uo_hijo
                            INNER JOIN segu.tusuario USUREG ON  UO.id_usuario_reg=USUREG.id_usuario
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=UO.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE '|| v_condicion;
              -- v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1701 (class 1255 OID 208205)
-- Dependencies: 16 3246
-- Name: ft_funcionario_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION ft_funcionario_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		rhum.ft_funcionario_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		KPLIAN (rac)
 FECHA:		21-01-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='rhum.ft_funcionario_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   RH_FUNCIO_INS
 #DESCRIPCION:	Inserta Funcionarios
 #AUTOR:			
 #FECHA:		25-01-2011	
***********************************/
     if(par_transaccion='RH_FUNCIO_INS')then

        
          BEGIN


               --insercion de nuevo FUNCIONARIO
               if exists (select 1 from rhum.tfuncionario where codigo=v_parametros.codigo and estado_reg='activo') then
                  raise exception 'Insercion no realizada. CODIGO EN USO';
               end if;

               INSERT INTO rhum.tfuncionario(
               codigo, id_persona,
               estado_reg,
               fecha_reg,
               id_usuario_reg,
               email_empresa,
               interno,
               fecha_ingreso )
               values(
                      v_parametros.codigo,
                      v_parametros.id_persona, 
                      'activo',now()::date, 
                      par_id_usuario,
                      v_parametros.id_persona,
                      v_parametros.interno,
                      v_parametros.fecha_ingreso);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','funcionario '||v_parametros.codigo ||' insertado con exito ');
               v_resp = f_agrega_clave(v_resp,'id_funcionario',v_id_funcion::varchar);
         END;
 /*******************************    
 #TRANSACCION:      RH_FUNCIO_MOD
 #DESCRIPCION:	Modifica la parametrizacion seleccionada
 #AUTOR:			
 #FECHA:		25-01-2011
***********************************/
     elsif(par_transaccion='RH_FUNCIO_MOD')then

          
          BEGIN
        
          
                if exists (select 1 from rhum.tfuncionario where id_funcionario!=v_parametros.id_funcionario and codigo=v_parametros.codigo and estado_reg='activo') then
                  raise exception 'Modificacion no realizada. CODIGO EN USO';
                end if;
                
                update rhum.tfuncionario
                set codigo=v_parametros.codigo,
                    id_usuario_mod=par_id_usuario,
                    id_persona=v_parametros.id_persona,
                    estado_reg=v_parametros.estado_reg,
                   email_empresa=v_parametros.email_empresa,
                    interno=v_parametros.interno,
                    fecha_ingreso=v_parametros.fecha_ingreso,
                    fecha_mod=now()::date
                where id_funcionario=v_parametros.id_funcionario;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','Funcionario modificado con exito '||v_parametros.id_funcionario);
               v_resp = f_agrega_clave(v_resp,'id_funcionario',v_parametros.id_funcionario::varchar);
               
                
          END;
          
/*******************************    
 #TRANSACCION:  RH_FUNCIO_ELI
 #DESCRIPCION:	Inactiva la parametrizacion selecionada
 #AUTOR:			
 #FECHA:		25-01-2011
***********************************/

    elsif(par_transaccion='RH_FUNCIO_ELI')then
        BEGIN
        
         --inactivacion de la periodo
               update rhum.tfuncionario
               set estado_reg='inactivo'
               where id_funcionario=v_parametros.id_funcionario;
               return 'Funcionario eliminado con exito';
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Funcionario eliminado con exito '||v_parametros.id_funcionario);
               v_resp = f_agrega_clave(v_resp,'id_funcionario',v_parametros.id_funcionario::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1702 (class 1255 OID 208206)
-- Dependencies: 16 3246
-- Name: ft_funcionario_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION ft_funcionario_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 funcionario: 		RHUM.ft_funcionario_sel
 DESCRIPCIÓN:  listado de funcionario
 AUTOR: 	    KPLIAN (mzm)
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		21-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;
v_filadd           varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_funcionario_sel';

/*******************************
 #TRANSACCION:  RH_FUNCIO_SEL
 #DESCRIPCION:	Listado de funcionarios
 #AUTOR:		
 #FECHA:		23/05/11	
***********************************/
     if(par_transaccion='RH_FUNCIO_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            FUNCIO.id_funcionario,
                            FUNCIO.codigo,
                            FUNCIO.estado_reg,
                            FUNCIO.fecha_reg,
                            FUNCIO.id_persona,
                            FUNCIO.id_usuario_reg,
                            FUNCIO.fecha_mod,
                            FUNCIO.id_usuario_mod,
                            FUNCIO.email_empresa,
                            FUNCIO.interno,
                            FUNCIO.fecha_ingreso,
                            PERSON.nombre_completo1 AS desc_person,
                            usu1.cuenta as usr_reg,
						    usu2.cuenta as usr_mod,
                            PERSON.ci, 
                            PERSON.num_documento,
                            PERSON.telefono1, 
                            PERSON.celular1, 
                            PERSON.correo
                            
                            
                            FROM rhum.tfuncionario FUNCIO
                            INNER JOIN SEGU.vpersona PERSON ON PERSON.id_persona=FUNCIO.id_persona
                            inner join segu.tusuario usu1 on usu1.id_usuario = FUNCIO.id_usuario_reg
						    left join segu.tusuario usu2 on usu2.id_usuario = FUNCIO.id_usuario_mod
                            
                            WHERE ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

/*******************************
 #TRANSACCION:  RH_FUNCIO_CONT
 #DESCRIPCION:	Conteo de funcionarios
 #AUTOR:		
 #FECHA:		23/05/11	
***********************************/
     elsif(par_transaccion='RH_FUNCIO_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(FUNCIO.id_funcionario)
                            FROM rhum.tfuncionario FUNCIO
                            INNER JOIN SEGU.vpersona PERSON ON PERSON.id_persona=FUNCIO.id_persona
                            inner join segu.tusuario usu1 on usu1.id_usuario = FUNCIO.id_usuario_reg
						    left join segu.tusuario usu2 on usu2.id_usuario = FUNCIO.id_usuario_mod
                            WHERE ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
    
    /*******************************
     #TRANSACCION:  RH_FUNCIOCAR_SEL
     #DESCRIPCION:	Listado de funcionarios con cargos historicos
     #AUTOR:		KPLIAN (RAC)
     #FECHA:		29/10/11	
    ***********************************/
     elseif(par_transaccion='RH_FUNCIOCAR_SEL')then

          --consulta:=';
          BEGIN
          
           v_filadd = '';
            IF (f_existe_parametro(par_tabla,'estado_reg_asi')) THEN
               v_filadd = ' (FUNCAR.estado_reg_asi = '''||v_parametros.estado_reg_asi||''') and ';
            END IF;

               v_consulta:='SELECT 
                            FUNCAR.id_uo_funcionario,
                            FUNCAR.id_funcionario,
                            FUNCAR.desc_funcionario1,
                            FUNCAR.desc_funcionario2,
                            FUNCAR.id_uo,
                            FUNCAR.nombre_cargo,
                            FUNCAR.fecha_asignacion,
                            FUNCAR.fecha_finalizacion,
                            FUNCAR.num_doc,
                            FUNCAR.ci,
                            FUNCAR.codigo,
                            FUNCAR.email_empresa,
                            FUNCAR.estado_reg_fun,
                            FUNCAR.estado_reg_asi
                            FROM rhum.vfuncionario_cargo FUNCAR 
                            WHERE '||v_filadd;
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

              
raise notice '%',v_consulta;            
               return v_consulta;


         END;

/*******************************
 #TRANSACCION:  RH_FUNCIOCAR_CONT
 #DESCRIPCION:	Conteo de funcionarios con cargos historicos
 #AUTOR:		KPLIAN (rac)
 #FECHA:		23/05/11	
***********************************/
     elsif(par_transaccion='RH_FUNCIOCAR_CONT')then

          --consulta:=';
          BEGIN
          
            v_filadd = '';
            IF (f_existe_parametro(par_tabla,'estado_reg_asi')) THEN
               v_filadd = ' (FUNCAR.estado_reg_asi = '''||v_parametros.estado_reg_asi||''') and ';
            END IF;

               v_consulta:='SELECT
                                  count(id_uo_funcionario)
                            FROM rhum.vfuncionario_cargo FUNCAR 
                            WHERE '||v_filadd;
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;   

      else
         raise exception 'No existe la opcion';

     end if;
     
     
     

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1705 (class 1255 OID 208207)
-- Dependencies: 16 3246
-- Name: ft_parametro_rhum_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION ft_parametro_rhum_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		rhum.ft_parametro_rhum_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 	    KPLIAN (mzm)		
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		17-01-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='rhum.ft_parametro_rhum_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   RH_PARRHH_INS
 #DESCRIPCION:	Inserta Funciones
 #AUTOR:			
 #FECHA:		17-01-2011	
***********************************/
     if(par_transaccion='RH_PARRHH_INS')then

        
          BEGIN
               --inactivar cualquier gestion que exista previamente
               if exists (select 1 from rhum.tparametro_rhum where estado_reg='activo') then
                  update rhum.tparametro_rhum
                  set estado_reg='inactivo';
               end if;
               --insercion de nuevo parametro
               INSERT INTO rhum.tparametro_rhum(salario_min_nal, id_gestion,id_moneda_sal_min_nal,estado_reg,fecha_reg,id_usuario_reg )
               values(v_parametros.salario_min_nal,v_parametros.id_gestion, v_parametros.id_moneda_sal_min_nal,'activo',now()::date, par_id_usuario);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','parametro de RRHH insertado con exito ');
               v_resp = f_agrega_clave(v_resp,'id_periodo',v_id_funcion::varchar);
         END;
 /*******************************    
 #TRANSACCION:      RH_PARRHH_MOD
 #DESCRIPCION:	Modifica la parametrizacion seleccionada
 #AUTOR:			
 #FECHA:		17-01-2011
***********************************/
     elsif(par_transaccion='RH_PARRHH_MOD')then

          
          BEGIN
               --modificacion de periodo
                update rhum.tparametro_rhum
                set salario_min_nal=v_parametros.salario_min_nal,
                    id_moneda_sal_min_nal=v_parametros.id_moneda_sal_min_nal,
                    id_gestion=v_parametros.id_gestion,
                    id_usuario_mod=par_id_usuario,
                    fecha_mod=now()::date
                where id_parametro=v_parametros.id_parametro;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','parametro de RRHH modificado con exito '||v_parametros.id_periodo);
               v_resp = f_agrega_clave(v_resp,'id_parametro',v_parametros.id_parametro::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  RH_PARRHH_ELI
 #DESCRIPCION:	Inactiva la parametrizacion selecionada
 #AUTOR:			
 #FECHA:		17-01-2011
***********************************/

    elsif(par_transaccion='RH_PARRHH_ELI')then
        BEGIN
        
         --inactivacion de la periodo
               update rhum.tparametro_rhum
               set estado_reg='inactivo'
               where id_parametro=v_parametros.id_parametro;
               return 'parametro de RRHH eliminado con exito';
               
               v_resp = f_agrega_clave(v_resp,'mensaje','parametro de RRHH eliminado con exito '||v_parametros.id_periodo);
               v_resp = f_agrega_clave(v_resp,'id_parametro',v_parametros.id_parametro::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1706 (class 1255 OID 208208)
-- Dependencies: 16 3246
-- Name: ft_parametro_rhum_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION ft_parametro_rhum_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 parametro_rhum: 		RHUM.ft_parametro_rhum_sel
 DESCRIPCIÓN:  listado de parametro_rhum
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		17-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_parametro_rhum_sel';


     if(par_transaccion='RH_PARRHH_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT PARRHH.id_parametro,
                            PARRHH.salario_min_nal,
                            PARRHH.id_gestion,
                            PARRHH.id_moneda_sal_min_nal,
                            PARRHH.estado_reg,
                            PARRHH.id_usuario_reg,
                            PARRHH.fecha_reg,
                            PARRHH.id_usuario_mod,
                            PARRHH.fecha_mod,
                            GESTIO.gestion,
                            MONEDA.moneda
                            FROM rhum.tparametro_rhum PARRHH
                            INNER JOIN PARAM.tgestion GESTIO
                            ON GESTIO.id_gestion=PARRHH.id_gestion
                            INNER JOIN PARAM.tmoneda MONEDA
                            ON MONEDA.id_moneda=PARRHH.id_moneda_sal_min_nal
                            WHERE ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='RH_PARRHH_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(PARRHH.id_parametro)
                            FROM rhum.tparametro_rhum PARRHH
                            INNER JOIN PARAM.tgestion GESTIO
                            ON GESTIO.id_gestion=PARRHH.id_gestion
                            INNER JOIN PARAM.tmoneda MONEDA
                            ON MONEDA.id_moneda=PARRHH.id_moneda_sal_min_nal
                            WHERE  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1707 (class 1255 OID 208209)
-- Dependencies: 16 3246
-- Name: ft_tipo_columna_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION ft_tipo_columna_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		rhum.ft_tipo_columna_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		31-01-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='rhum.ft_tipo_columna_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   RH_TIPCOL_INS
 #DESCRIPCION:	Inserta tipo columna
 #AUTOR:			
 #FECHA:		31-01-2011	
***********************************/
     if(par_transaccion='RH_TIPCOL_INS')then

        
          BEGIN
               --insercion de nuevo TIPO_COLUMNA
               INSERT INTO rhum.ttipo_columna (
                           codigo,
                           compromete,
                           descripcion,
                           descuento_incremento,
                           formula,
                           id_auxiliar_pasivo,
                           id_cuenta_pasivo,
                           id_moneda,
                           id_parametro_rhum,
                           id_tipo_descuento_bono,
                           id_tipo_obligacion,
                           id_usuario_reg,
                           movimiento_contable,
                           nombre,
                           observacion,
                           prorratea,
                           tipo_aporte,
                           tipo_dato,
                           valor,
                           fecha_reg,
                           estado_reg)

               values(     v_parametros.codigo,
                           v_parametros.compromete,
                           v_parametros.descripcion,
                           v_parametros.descuento_incremento,
                           v_parametros.formula,
                           v_parametros.id_auxiliar_pasivo,
                           v_parametros.id_cuenta_pasivo,
                           v_parametros.id_moneda,
                           v_parametros.id_parametro_rhum,
                           v_parametros.id_tipo_descuento_bono,
                           v_parametros.id_tipo_obligacion,
                           par_id_usuario,
                           v_parametros.movimiento_contable,
                           v_parametros.nombre,
                           v_parametros.observacion,
                           v_parametros.prorratea,
                           v_parametros.tipo_aporte,
                           v_parametros.tipo_dato,
                           0.0::numeric,
                           now()::date,
                           'activo');
              

               v_resp = f_agrega_clave(v_resp,'mensaje','Tipo de columna insertado con exito ');
               v_resp = f_agrega_clave(v_resp,'id_tipo_columna',v_id_funcion::varchar);
         END;
 /*******************************    
 #TRANSACCION:      RH_TIPCOL_MOD
 #DESCRIPCION:	Modifica tipo_columna seleccionado
 #AUTOR:			
 #FECHA:		31-01-2011
***********************************/
     elsif(par_transaccion='RH_TIPCOL_MOD')then

          
          BEGIN raise exception '';
               --modificacion de tipo_columna
                update rhum.ttipo_columna
                set        codigo=v_parametros.codigo,
                           compromete=v_parametros.compromete,
                           descripcion=v_parametros.descripcion,
                           descuento_incremento=v_parametros.descuento_incremento,
                           formula=v_parametros.formula,
                           id_auxiliar_pasivo=v_parametros.id_auxiliar_pasivo,
                           id_cuenta_pasivo=v_parametros.id_cuenta_pasivo,
                           id_moneda=v_parametros.id_moneda,
                           id_parametro_rhum=v_parametros.id_parametro_rhum,
                           id_tipo_descuento_bono=v_parametros.id_tipo_descuento_bono,
                           id_tipo_obligacion=v_parametros.id_tipo_obligacion,

                           movimiento_contable=v_parametros.movimiento_contable,
                           nombre=v_parametros.nombre,
                           observacion=v_parametros.observacion,
                           prorratea=v_parametros.prorratea,
                           tipo_aporte=v_parametros.tipo_aporte,
                           tipo_dato=v_parametros.tipo_dato
                          -- valor=v_parametros.valor
                  
                where id_tipo_columna=v_parametros.id_tipo_columna;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','tipo columna modificado con exito '||v_parametros.id_tipo_columna);
               v_resp = f_agrega_clave(v_resp,'id_tipo_columna',v_parametros.id_tipo_columna::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  RH_TIPCOL_ELI
 #DESCRIPCION:	Inactiva tipo_columna
 #AUTOR:			
 #FECHA:		31-01-2011
***********************************/

    elsif(par_transaccion='RH_TIPCOL_ELI')then
        BEGIN
        
         --inactivacion de tipo_columna
               update rhum.ttipo_columna
               set estado_reg='inactivo'
               where id_tipo_columna=v_parametros.id_tipo_columna;
               return 'Tipo columna eliminado con exito';
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Tipo columna eliminado con exito '||v_parametros.id_tipo_columna);
               v_resp = f_agrega_clave(v_resp,'id_tipo_columna',v_parametros.id_tipo_columna::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1708 (class 1255 OID 208210)
-- Dependencies: 16 3246
-- Name: ft_tipo_columna_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION ft_tipo_columna_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 tipo_columna: 		RHUM.ft_tipo_columna_sel
 DESCRIPCIÓN:  listado de tipo_columna
 AUTOR: 	    KPLIAN (mzm)		
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		27-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_tipo_columna_sel';


     if(par_transaccion='RH_TIPCOL_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            TIPCOL.id_tipo_columna,
                            TIPCOL.codigo,
                            TIPCOL.compromete,
                            TIPCOL.descripcion,
                            TIPCOL.descuento_incremento ,
                            TIPCOL.estado_reg,
                            TIPCOL.fecha_reg,
                            TIPCOL.formula,
                            TIPCOL.id_auxiliar_pasivo,
                            TIPCOL.id_cuenta_pasivo,
                            TIPCOL.id_moneda,
                            TIPCOL.id_parametro_rhum,
                            TIPCOL.id_tipo_descuento_bono,
                            TIPCOL.id_tipo_obligacion ,
                            TIPCOL.movimiento_contable,
                            TIPCOL.nombre,
                            TIPCOL.observacion ,
                            TIPCOL.prorratea,
                            TIPCOL.tipo_aporte,
                            TIPCOL.tipo_dato,
                            TIPCOL.valor,
                            GESTIO.gestion AS desc_parametro_rhum,
                            MONEDA.moneda as desc_moneda,
                            PERREG.nombre_completo1 as desc_usureg,
                            CTA.codigo||''-''||CTA.nombre as desc_cta,
                            AUX.codigo||''-''|| AUX.nombre as desc_aux,
                            TIPOBL.nombre as desc_tipo_obligacion
                            FROM rhum.ttipo_columna TIPCOL
                            LEFT JOIN rhum.tparametro_rhum PARHUM on PARHUM.id_parametro=TIPCOL.id_parametro_rhum
                            LEFT JOIN param.tgestion GESTIO ON GESTIO.id_gestion=PARHUM.id_gestion
                            LEFT JOIN param.tmoneda MONEDA on MONEDA.id_moneda=TIPCOL.id_moneda
                            LEFT JOIN SEGU.tusuario USUREG ON USUREG.id_usuario=TIPCOL.id_usuario_reg
                            LEFT JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN conta.tcuenta CTA on CTA.id_cuenta=TIPCOL.id_cuenta_pasivo
                            LEFT JOIN conta.tauxiliar AUX on AUX.id_auxiliar=TIPCOL.id_auxiliar_pasivo
                            LEFT JOIN RHUM.ttipo_obligacion TIPOBL ON TIPOBL.id_tipo_obligacion=TIPCOL.id_tipo_obligacion
                            WHERE ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='RH_TIPCOL_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(TIPCOL.id_tipo_columna)
                            FROM rhum.ttipo_columna TIPCOL
                            INNER JOIN rhum.tparametro_rhum PARHUM on PARHUM.id_parametro=TIPCOL.id_parametro_rhum
                            INNER JOIN param.tgestion GESTIO ON GESTIO.id_gestion=PARHUM.id_gestion
                            INNER JOIN param.tmoneda MONEDA on MONEDA.id_moneda=TIPCOL.id_moneda
                            INNER JOIN SEGU.tusuario USUREG ON USUREG.id_usuario=TIPCOL.id_usuario_reg
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN conta.tcuenta CTA on CTA.id_cuenta=TIPCOL.id_cuenta_pasivo
                            LEFT JOIN conta.tauxiliar AUX on AUX.id_auxiliar=TIPCOL.id_auxiliar_pasivo
                            LEFT JOIN RHUM.ttipo_obligacion TIPOBL ON TIPOBL.id_tipo_obligacion=TIPCOL.id_tipo_obligacion
                            WHERE ';

               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1709 (class 1255 OID 208211)
-- Dependencies: 16 3246
-- Name: ft_tipo_obligacion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION ft_tipo_obligacion_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		rhum.ft_tipo_obligacion_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		31-01-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='rhum.ft_tipo_obligacion_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:   RH_TIPOBL_INS
 #DESCRIPCION:	Inserta tipo obligacion
 #AUTOR:			
 #FECHA:		14-02-2011	
***********************************/
     if(par_transaccion='RH_TIPOBL_INS')then

        
          BEGIN
               --insercion de nuevo tipo_obligacion
               INSERT INTO rhum.ttipo_obligacion (
                           codigo,
                           nombre,
                           estado_reg,
                           fecha_reg,
                           id_usuario_reg
                           )

               values(     v_parametros.codigo,
                           v_parametros.nombre,
                           'activo',
                           now()::date,
                           par_id_usuario);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','Tipo de obligacion insertado con exito ');
               v_resp = f_agrega_clave(v_resp,'id_tipo_obligacion',v_id_funcion::varchar);
         END;
 /*******************************    
 #TRANSACCION:      RH_TIPOBL_MOD
 #DESCRIPCION:	Modifica tipo_obligacion seleccionado
 #AUTOR:			
 #FECHA:		31-01-2011
***********************************/
     elsif(par_transaccion='RH_TIPOBL_MOD')then

          
          BEGIN 
               --modificacion de tipo_obligacion
                update rhum.ttipo_obligacion
                set        codigo=v_parametros.codigo,
                           nombre=v_parametros.nombre
                where id_tipo_obligacion=v_parametros.id_tipo_obligacion;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','tipo obligacion modificado con exito '||v_parametros.id_tipo_obligacion);
               v_resp = f_agrega_clave(v_resp,'id_tipo_obligacion',v_parametros.id_tipo_obligacion::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  RH_TIPOBL_ELI
 #DESCRIPCION:	Inactiva tipo_obligacion
 #AUTOR:			
 #FECHA:		31-01-2011
***********************************/

    elsif(par_transaccion='RH_TIPOBL_ELI')then
        BEGIN
        
         --inactivacion de tipo_obligacion
               update rhum.ttipo_obligacion
               set estado_reg='inactivo'
               where id_tipo_obligacion=v_parametros.id_tipo_obligacion;
               return 'Tipo obligacion eliminado con exito';
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Tipo obligacion eliminado con exito '||v_parametros.id_tipo_obligacion);
               v_resp = f_agrega_clave(v_resp,'id_tipo_obligacion',v_parametros.id_tipo_obligacion::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1710 (class 1255 OID 208212)
-- Dependencies: 16 3246
-- Name: ft_tipo_obligacion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION ft_tipo_obligacion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 tipo_columna: 		RHUM.ft_tipo_columna_sel
 DESCRIPCIÓN:  listado de tipo_columna
 AUTOR: 	    KPLIAN (mzm)
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		27-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_tipo_columna_sel';


     if(par_transaccion='RH_TIPOBL_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            TIPOBL.id_tipo_columna,
                            TIPOBL.codigo,
                            TIPOBL.nombre,
                            TIPOBL.estado_reg,
                            TIPOBL.id_usuario_reg,
                            TIPOBL.fecha_reg,
                            TIPOBL.id_usuario_mod,
                            TIPOBL.fecha_mod,
                            PERREG.nombre_completo1 AS desc_usuario_reg
                            FROM rhum.ttipo_obligacion TIPOBL
                            INNER JOIN SEGU.tusuario USUREG ON USUREG.id_usuario= TIPOBL.id_usuario_reg
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            WHERE ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='RH_TIPOBL_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(TIPOBL.id_tipo_obligacion)
                            FROM rhum.ttipo_obligacion TIPOBL
                            INNER JOIN SEGU.tusuario USUREG ON USUREG.id_usuario= TIPOBL.id_usuario_reg
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            WHERE ';

               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1711 (class 1255 OID 208213)
-- Dependencies: 16 3246
-- Name: ft_tipo_planilla_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION ft_tipo_planilla_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 tipo_planilla: 		RHUM.ft_tipo_planilla_sel
 DESCRIPCIÓN:  listado de tipo_planilla
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		19-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_tipo_planilla_sel';


     if(par_transaccion='RH_TIPPLA_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            TIPPLA.id_tipo_planilla,
                            TIPPLA.nombre,
                            TIPPLA.descripcion,
                            TIPPLA.basica,
                            TIPPLA.tipo,
                            TIPPLA.id_moneda,
                            TIPPLA.estado_reg,
                            TIPPLA.fecha_reg,
                            TIPPLA.id_usuario_reg,
                            TIPPLA.fecha_mod,
                            TIPPLA.id_usuario_mod,
                            MONEDA.moneda as desc_moneda,
                            PERSON.nombre_completo1 as desc_usuario_reg,
                            PERMOD.nombre_completo1 as desc_usuario_mod
                            FROM rhum.ttipo_planilla TIPPLA
                            INNER JOIN param.tmoneda MONEDA ON MONEDA.id_moneda=TIPPLA.id_moneda
                            INNER JOIN SEGU.tusuario USUARI ON USUARI.id_usuario=TIPPLA.id_usuario_reg
                            INNER JOIN SEGU.vpersona PERSON ON PERSON.id_persona=USUARI.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=TIPPLA.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='RH_TIPPLA_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(TIPPLA.id_tipo_planilla)
                            FROM rhum.ttipo_planilla TIPPLA
                            INNER JOIN param.tmoneda MONEDA ON MONEDA.id_moneda=TIPPLA.id_moneda
                            INNER JOIN SEGU.tusuario USUARI ON USUARI.id_usuario=TIPPLA.id_usuario_reg
                            INNER JOIN SEGU.vpersona PERSON ON PERSON.id_persona=USUARI.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=TIPPLA.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1712 (class 1255 OID 208214)
-- Dependencies: 16 3246
-- Name: ft_uo_funcionario_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION ft_uo_funcionario_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		rhum.ft_uofunc_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		03-06-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_uo  				integer;
v_id_funcionario integer;

--10abr12   
v_respuesta_sinc       varchar;
v_id_uo_funcionario     integer;


BEGIN

     v_nombre_funcion:='rhum.ft_uo_funcionario_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:  RH_UOFUNC_INS
 #DESCRIPCION:	Inserta uos funcionario
 #AUTOR:		KPLIAN (mzm)	
 #FECHA:		25-06-2011	
***********************************/
     if(par_transaccion='RH_UOFUNC_INS')then

        
          BEGIN

               -- verificar si la uo permite multiples asignaciones de funcionario
               --RAC NO ESTA FUNCIOANNDO ESTO DEL CARGO INDIVIDUAL
               /*if (select count(*)=1 
                  from rhum.tuo_funcionario where id_uo=v_parametros.id_uo and estado_reg=v_parametros.estado_reg and
                   id_uo=(select id_uo from rhum.tuo where  id_uo=v_parametros.id_uo and estado_reg='activo' and cargo_individual='si')) then
                             raise exception 'El cargo es individual y ya existe otro funcionario asignado actualmente';
               end if;*/
               
                --verficar que el funcionario no este activo en dos unidades simultaneamente
                
                if ( v_parametros.estado_reg='activo' and
                      ((select count(id_funcionario) from 
                           rhum.tuo_funcionario  UOF
                           where     id_funcionario=v_parametros.id_funcionario AND uof.estado_reg='activo' ))>0) then
                           
                           raise exception 'El Funcionario se encuentra en otro cargo vigente primero inactive su asignacion actual';
                end if;
               
               --insercion de nuevo uo
               if exists (select 1 from rhum.tuo_funcionario where id_funcionario=v_parametros.id_funcionario and
               id_uo=v_parametros.id_uo and estado_reg='activo') then
                  raise exception 'Insercion no realizada. El funcionacio ya esta asignado a la unidad';
               end if;

               INSERT INTO rhum.tuo_funcionario
               (id_uo, id_funcionario, fecha_asignacion, estado_reg)
               values(v_parametros.id_uo, v_parametros.id_funcionario,v_parametros.fecha_asignacion, v_parametros.estado_reg)  
               RETURNING id_uo_funcionario INTO v_id_uo_funcionario;
              
               --10-04-2012: sincronizacion de UO entre BD
               v_respuesta_sinc:=rhum.f_sincroniza_uo_empleado_entre_bd(v_id_uo_funcionario,'10.172.0.13','5432','db_link','db_link','dbendesis' ,'INSERT');
                     
               if(v_respuesta_sinc!='si')  then
                  raise exception 'Sincronizacion de UO en BD externa no realizada%',v_respuesta_sinc;
               end if;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Asignacion empleado-uo registrada con exito: Funcionario ('|| (select desc_funcionario1 from rhum.vfuncionario where id_funcionario=v_parametros.id_funcionario) || ') - UO'|| (select nombre_unidad from rhum.tuo where id_uo=v_parametros.id_uo));
               v_resp = f_agrega_clave(v_resp,'id_uo',v_id_uo::varchar);
         END;
 /*******************************    
 #TRANSACCION:  RH_UOFUNC_MOD
 #DESCRIPCION:	Modifica la parametrizacion seleccionada
 #AUTOR:		KPLIAN (mzm)	
 #FECHA:		03-06-2011
***********************************/
     elsif(par_transaccion='RH_UOFUNC_MOD')then

          
          BEGIN
              if ( select count(*)=1 from 
                           rhum.tuo_funcionario 
                           where    id_uo=v_parametros.id_uo 
                                and estado_reg=v_parametros.estado_reg and
                                    id_funcionario!=v_parametros.id_funcionario and
                                    id_uo=(select id_uo from rhum.tuo where estado_reg='activo' and cargo_individual='si')) then
                           
                           raise exception 'El cargo es individual y ya existe otro funcionario asignado actualmente';
               end if;
                
                
                --verficar que el funcionario no este activo en dos unidades simultaneamente
                
               if ( v_parametros.estado_reg='activo' and
                      ((select count(id_funcionario) from 
                           rhum.tuo_funcionario 
                           where     id_funcionario=v_parametros.id_funcionario ))>0) then
                           
                           raise exception 'El Funcionario se encuentra en otro cargo vigente primero inactive su asignacion actual';
               end if;
                
                
                
                --si el estado es inactivo == la fecha finalizacion debe ser llenada
               
               
                if(v_parametros.estado_reg='inactivo' and v_parametros.fecha_finalizacion is null) then
                   raise exception 'La inactivacion al cargo requiere indicar la fecha de finalizacion';
                end if;
                
                update rhum.tuo_funcionario
                set 
                   fecha_asignacion=v_parametros.fecha_asignacion::date,
                   id_funcionario=v_parametros.id_funcionario
                where id_uo=v_parametros.id_uo
                and id_uo_funcionario=v_parametros.id_uo_funcionario;
                
                --10-04-2012: sincronizacion de UO entre BD
                v_respuesta_sinc:=rhum.f_sincroniza_uo_empleado_entre_bd(v_parametros.id_uo_funcionario,'10.172.0.13','5432','db_link','db_link','dbendesis' ,'UPDATE');
                     
                if(v_respuesta_sinc!='si')  then
                  raise exception 'Sincronizacion de UO en BD externa no realizada%',v_respuesta_sinc;
                end if;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','Modificacion a asignacion empleado-uo modificada con exito '||v_parametros.id_uo_funcionario||': Funcionario ('|| (select desc_funcionario1 from rhum.vfuncionario where id_funcionario=v_parametros.id_funcionario) || ') - UO'|| (select nombre_unidad from rhum.tuo where id_uo=v_parametros.id_uo));
               v_resp = f_agrega_clave(v_resp,'id_uo',v_parametros.id_uo::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  RH_UOFUNC_ELI
 #DESCRIPCION:	Inactiva la parametrizacion selecionada
 #AUTOR:	    KPLIAN (mzm)
 #FECHA:		03-06-2011
***********************************/

    elsif(par_transaccion='RH_UOFUNC_ELI')then
        BEGIN
        
         --inactivacion de la uo
               select id_funcionario,id_uo 
               into v_id_funcionario, v_id_uo
               from rhum.tuo_funcionario
               where  id_uo_funcionario=v_parametros.id_uo_funcionario;
               
               --elimina siempre que puede: como el registro de uo_fun es referncial en RHUM, se posible eliminarlo todo el tiempo
               -- se debe cuidar q en el diseno cuando se requiera obtener la dependencia de un funcionario, se deb guardar la referencia vigente de uo_funcionario
               delete from rhum.tuo_funcionario
               where id_uo_funcionario=v_parametros.id_uo_funcionario;
              
               --10-04-2012: sincronizacion de UO entre BD
                v_respuesta_sinc:=rhum.f_sincroniza_uo_empleado_entre_bd(v_parametros.id_uo_funcionario,'10.172.0.13','5432','db_link','db_link','dbendesis' ,'DELETE');
                     
                if(v_respuesta_sinc!='si')  then
                  raise exception 'Sincronizacion de UO en BD externa no realizada%',v_respuesta_sinc;
                end if;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','asignacion empleado-uo eliminada con exito '||v_parametros.id_uo_funcionario||': Funcionario ('|| (select desc_funcionario1 from rhum.vfuncionario where id_funcionario=v_id_funcionario) || ') - UO'|| (select nombre_unidad from rhum.tuo where id_uo=v_id_uo));
               v_resp = f_agrega_clave(v_resp,'id_uo',v_id_uo::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1713 (class 1255 OID 208216)
-- Dependencies: 16 3246
-- Name: ft_uo_funcionario_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION ft_uo_funcionario_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		RHUM.ft_uo_funcionario_sel
 DESCRIPCIÓN:  listado de uo
 AUTOR: 	    KPLIAN (mzm)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		30-05-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;
v_id_padre         integer;

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_uo_funcionario_sel';

/*******************************
 #TRANSACCION:  RH_UO_SEL
 #DESCRIPCION:	Listado de uo funcionarios
 #AUTOR:		
 #FECHA:		30/05/11	
***********************************/
     if(par_transaccion='RH_UOFUNC_SEL')then

          
          BEGIN

               v_consulta:='SELECT
                                  UOFUNC.id_uo_funcionario,
                                  UOFUNC.id_uo,
                                  UOFUNC.id_funcionario,
                                  FUNCIO.ci,
                                  FUNCIO.codigo,
                                  FUNCIO.desc_funcionario1,
                                  FUNCIO.desc_funcionario2,
                                  FUNCIO.num_doc,
                                  UOFUNC.fecha_asignacion,
                                  UOFUNC.fecha_finalizacion,
                                  UOFUNC.estado_reg,
                                  UOFUNC.fecha_mod,
                                  UOFUNC.fecha_reg,
                                  UOFUNC.id_usuario_mod,
                                  UOFUNC.id_usuario_reg,
                                  PERREG.nombre_completo2 AS USUREG,
                                  PERMOD.nombre_completo2 AS USUMOD
                                  
                            FROM rhum.tuo_funcionario UOFUNC
                            INNER JOIN RHUM.tuo UO ON UO.id_uo=UOFUNC.id_uo
                            INNER JOIN RHUM.vfuncionario FUNCIO ON FUNCIO.id_funcionario=UOFUNC.id_funcionario
                            INNER JOIN segu.tusuario USUREG ON  UO.id_usuario_reg=USUREG.id_usuario
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=UO.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE  UOFUNC.estado_reg !=''eliminado'' and ';

              
                v_id_padre:=v_parametros.id_uo;
              
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta || ' and UOFUNC.id_uo='|| v_id_padre;
               
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

/*******************************
 #TRANSACCION:  RH_UO_CONT
 #DESCRIPCION:	Conteo de uos
 #AUTOR:		
 #FECHA:		23/05/11	
***********************************/
     elsif(par_transaccion='RH_UOFUNC_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(UOFUNC.id_uo_funcionario)
                            FROM rhum.tuo_funcionario UOFUNC
                            INNER JOIN RHUM.tuo UO ON UO.id_uo=UOFUNC.id_uo
                            INNER JOIN RHUM.vfuncionario FUNCIO ON FUNCIO.id_funcionario=UOFUNC.id_funcionario
                            INNER JOIN segu.tusuario USUREG ON  UO.id_usuario_reg=USUREG.id_usuario
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=UO.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE UOFUNC.estado_reg !=''eliminado'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1714 (class 1255 OID 208217)
-- Dependencies: 16 3246
-- Name: ft_uo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION ft_uo_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		rhum.ft_uo_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 	    KPLIAN (mzm)
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		23-05-2011
 ***************************************************************************/
DECLARE


v_parametros                record;
v_resp                      varchar;
v_nombre_funcion            text;
v_mensaje_error             text;

v_id_uo  				integer;


BEGIN

     v_nombre_funcion:='rhum.ft_uo_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
 /*******************************    
 #TRANSACCION:  RH_UO_INS
 #DESCRIPCION:	Inserta uos
 #AUTOR:			
 #FECHA:		25-03-2011	
***********************************/
     if(par_transaccion='RH_UO_INS')then

        
          BEGIN


               --insercion de nuevo uo
               if exists (select 1 from rhum.tuo where codigo=v_parametros.codigo and estado_reg='activo') then
                  raise exception 'Insercion no realizada. CODIGO DE UO EN USO';
               end if;

               INSERT INTO rhum.tuo(cargo_individual,codigo,             descripcion,              estado_reg,  fecha_reg,   id_usuario_reg, nombre_cargo,              nombre_unidad, presupuesta)
               values(v_parametros.cargo_individual, v_parametros.codigo,v_parametros.descripcion, 'activo',    now()::date, par_id_usuario, v_parametros.nombre_cargo, v_parametros.nombre_unidad, v_parametros.presupuesta);
              

               v_resp = f_agrega_clave(v_resp,'mensaje','uo '||v_parametros.codigo ||' insertado con exito ');
               v_resp = f_agrega_clave(v_resp,'id_uo',v_id_uo::varchar);
         END;
 /*******************************    
 #TRANSACCION:  RH_UO_MOD
 #DESCRIPCION:	Modifica la parametrizacion seleccionada
 #AUTOR:			
 #FECHA:		25-01-2011
***********************************/
     elsif(par_transaccion='RH_UO_MOD')then

          
          BEGIN    raise exception 'entra a ft_uo_ime';
                if exists (select 1 from rhum.tuo where id_uo!=v_parametros.id_uo and codigo=v_parametros.codigo and estado_reg='activo') then
                  raise exception 'Modificacion no realizada. CODIGO DE UO EN USO';
                end if;
                
                update rhum.tuo
                set 
                    cargo_individual=v_parametros.cargo_individual,
                    codigo=v_parametros.codigo,
                    descripcion=v_parametros.descripcion,
                    nombre_cargo=v_parametros.nombre_cargo,
                    nombre_unidad=v_parametros.nombre_unidad,
                    presupuesta=v_parametros.presupuesta,
                    fecha_mod=now()::date,
                    id_usuario_mod=par_id_usuario
                where id_uo=v_parametros.id_uo;
                
               v_resp = f_agrega_clave(v_resp,'mensaje','uo modificado con exito '||v_parametros.id_uo);
               v_resp = f_agrega_clave(v_resp,'id_uo',v_parametros.id_uo::varchar);
          END;
          
/*******************************    
 #TRANSACCION:  RH_UO_ELI
 #DESCRIPCION:	Inactiva la parametrizacion selecionada
 #AUTOR:			
 #FECHA:		25-03-2011
***********************************/

    elsif(par_transaccion='RH_UO_ELI')then
        BEGIN
        
         --inactivacion de la uo
               update rhum.tuo
               set estado_reg='inactivo'
               where id_uo=v_parametros.id_uo;
              
               
               v_resp = f_agrega_clave(v_resp,'mensaje','uo eliminada con exito '||v_parametros.id_uo);
               v_resp = f_agrega_clave(v_resp,'id_uo',v_parametros.id_uo::varchar);

        END;
        
   
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1715 (class 1255 OID 208218)
-- Dependencies: 16 3246
-- Name: ft_uo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: rhum; Owner: -
--

CREATE FUNCTION ft_uo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		RHUM.ft_uo_sel
 DESCRIPCIÓN:  listado de uo
 AUTOR: 	    KPLIAN (mzm)
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:		
 FECHA:		21-01-2011
***************************************************************************/


DECLARE


v_consulta         varchar;
v_parametros       record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp             varchar;
v_filadd           varchar;


BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='rhum.ft_uo_sel';

/*******************************
 #TRANSACCION:  RH_UO_SEL
 #DESCRIPCION:	Listado de uos
 #AUTOR:		
 #FECHA:		23/05/11	
***********************************/
     if(par_transaccion='RH_UO_SEL')then

          
          BEGIN
          
          
            v_filadd = '';
            IF (f_existe_parametro(par_tabla,'correspondencia')) THEN
               v_filadd = ' (UO.correspondencia = '''||v_parametros.correspondencia||''') and ';
            END IF;    
            
            --29mar12: para SAJ
            IF (f_existe_parametro(par_tabla,'gerencia')) THEN
               v_filadd = ' (UO.gerencia = '''||v_parametros.gerencia||''') and ';
            END IF;
            
            
               v_consulta:='SELECT UO.id_uo,
                                  UO.cargo_individual,
                                  UO.codigo,
                                  UO.descripcion,
                                  UO.estado_reg,
                                  UO.fecha_mod,
                                  UO.fecha_reg,
                                  
                                  UO.id_usuario_mod,
                                  UO.id_usuario_reg,
                                  UO.nombre_cargo,
                                  UO.nombre_unidad,
                                  UO.presupuesta,
                                  PERREG.nombre_completo2 AS USUREG,
                                  PERMOD.nombre_completo2 AS USUMOD
                            FROM rhum.tuo UO
                            INNER JOIN segu.tusuario USUREG ON  UO.id_usuario_reg=USUREG.id_usuario
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=UO.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE '||v_filadd;
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

/*******************************
 #TRANSACCION:  RH_UO_CONT
 #DESCRIPCION:	Conteo de uos
 #AUTOR:		
 #FECHA:		23/05/11	
***********************************/
     elsif(par_transaccion='RH_UO_CONT')then

          --consulta:=';
          BEGIN
          
           v_filadd = '';
            IF (f_existe_parametro(par_tabla,'correspondencia')) THEN
               v_filadd = ' (UO.correspondencia = '''||v_parametros.correspondencia||''') and ';
            END IF;
           
            --29mar12: para SAJ
            IF (f_existe_parametro(par_tabla,'gerencia')) THEN
               v_filadd = ' (UO.gerencia = '''||v_parametros.gerencia||''') and ';
            END IF;
            
               v_consulta:='SELECT
                                  count(UO.id_uo)
                            FROM rhum.tuo UO
                            INNER JOIN segu.tusuario USUREG ON  UO.id_usuario_reg=USUREG.id_usuario
                            INNER JOIN SEGU.vpersona PERREG ON PERREG.id_persona=USUREG.id_persona
                            LEFT JOIN SEGU.tusuario USUMOD ON USUMOD.id_usuario=UO.id_usuario_mod
                            LEFT JOIN SEGU.vpersona PERMOD ON PERMOD.id_persona=USUMOD.id_persona
                            WHERE  '||v_filadd;
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


SET search_path = saj, pg_catalog;

--
-- TOC entry 1716 (class 1255 OID 208219)
-- Dependencies: 17 3246
-- Name: f_manejo_estado_proceso(integer, character varying, character varying, integer, integer); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_manejo_estado_proceso(p_id integer, p_tipo character varying, p_observaciones character varying, p_id_usuario integer, p_id_responsable integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		f_manejo_estado_proceso
 DESCRIPCION:   maneja el estado del proceso de contratacion avanzando o retrocediendo
 
 AUTOR: 	    ENDE Mercedes Zambrana Meneces
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES  
 DESCRIPCION:        en ves de utlizar id_Estado comollave foranea con la tabla estado se utiliza el codigo
 AUTOR:		ENDE Rensi Arteaga Copari
 FECHA:		5/12/2011
 ***********************************************************************************************/

DECLARE
  /*
  id: id_proceso_contrato
  tipo: avanzar/retroceder
  */
  v_estado_actual   varchar;
  v_estado_anterior varchar;
  v_num_orden       integer;  
  v_id_estado_nuevo integer;
  v_nombre_estado varchar;
  v_id_alarmas integer[];
  
BEGIN
       --0) obtenemos el estado actual del proceso_contrato
       SELECT 
          coalesce(e.orden,0) , ep.estado_vigente
       into 
          v_num_orden,         v_estado_anterior
       FROM saj.testado_proceso ep
       INNER JOIN saj.testado e ON e.codigo=ep.estado_vigente
       WHERE id_proceso_contrato=p_id 
             and ep.estado_reg='activo';
     
       v_num_orden:=coalesce(v_num_orden,0);
       
       --1)  si buscamos el estado siguiente
       if(p_tipo='siguiente') then
             --1.1) si el proceso no tiene estados obtenemos el primero
             if v_estado_anterior is NULL THEN
             
                     select id_estado,codigo , nombre
                        into 
                       v_id_estado_nuevo,v_estado_actual,v_nombre_estado
                     from saj.testado 
                     where orden=1
                     and estado_reg='activo';
                     
                     --raise exception 'anterior...........';
             

             ELSE
              --1.2) si es un estado mayor al primero
                    select id_estado ,codigo,nombre
                      into 
                          v_id_estado_nuevo,v_estado_actual,v_nombre_estado
                     from saj.testado 
                     where orden=v_num_orden+1 
                     and estado_reg='activo';
                         
                     if(v_id_estado_nuevo is null) then
                        raise exception 'No existe un estado siguiente';
                     end if;
                     
                --    raise exception 'auuuuuunterior...........  %  % % %',v_num_orden,v_estado_actual,v_estado_anterior,p_id;
               
             END IF;

        --2)  si buscamos el estado anterior 
       elsif(p_tipo='anterior') then

           if(v_num_orden=0 or  v_estado_anterior is NULL ) then
                raise exception 'Estado anterior inexistente';
           else    
                select 
                   id_estado,codigo, nombre
                into 
                   v_id_estado_nuevo,v_estado_actual,v_nombre_estado
                from saj.testado 
                where orden=v_num_orden-1 and orden>0
                and estado_reg='activo'; 
           end if;
           
     --3)  si buscamos un estado especial
       else --(p_tipo='anulado') then  
       
                select 
                   id_estado,codigo,nombre 
                into 
                   v_id_estado_nuevo,v_estado_actual,v_nombre_estado
                from saj.testado 
                where 
                  lower(codigo)=lower(p_tipo)  
                and
                  estado_reg='activo' limit 1;           
            
                if(v_id_estado_nuevo is null) then
                     raise exception 'Cambio de Estado no permitido';
                end if;
       end if;
        
    --4) inactivamos los estados anteriores
        
       update  saj.testado_proceso set 
         fecha_fin=now()::date ,
         observaciones= 'cambio estado de:'||v_estado_anterior||' a '|| v_estado_actual || ' - OBS: '||coalesce(p_observaciones,'NINGUNA'),
         id_usuario_mod=p_id_usuario,
         fecha_mod=now(),
       estado_reg='inactivo'       
       where estado_reg='activo'
       and id_proceso_contrato=p_id; 
       
       
      --5) insertamos un nuevo estado proceso      
       insert into saj.testado_proceso (estado_anterior,   estado_vigente,fecha_ini, fecha_reg, id_proceso_contrato, observaciones,    id_responsable_proceso, id_usuario_reg) 
       values                          (v_estado_anterior, v_estado_actual, now(),    now(),    p_id,                 p_observaciones, p_id_responsable,       p_id_usuario);
       
      
       
       
     
 
     
     -- 6) si el nuevo estado concluye el cotrato revisamos si tienes alarmas y  las desatvamos
     
     IF ( v_estado_actual='FINCON' and v_estado_anterior='REGCON')THEN
     
      --6.1 )  si el estado es de finalizacion del contrato 
      --      revisamos si tiene alarmas y las
      --      cambiamos a notificaciones  resetamos el id_alarma
                           
           select pc.id_alarma into v_id_alarmas 
           from saj.tproceso_contrato pc
           where pc.id_proceso_contrato=p_id;
                           
           update param.talarma set
           tipo ='notificacion',
           fecha = now(),
           descripcion ='El contrato fue Finalizado ['||descripcion||']',
           id_usuario_mod = p_id_usuario,
           fecha_mod = now()
           where id_alarma = ANY (v_id_alarmas);
           
      --6.2) actualizamos el estado del proceso_contrato     
         update saj.tproceso_contrato pc set
         estado_proceso = v_estado_actual,
         id_usuario_mod = p_id_usuario,
         fecha_mod = now(),
         id_alarma = NULL
         where id_proceso_contrato = p_id;
         
     ELSE  
      
         update saj.tproceso_contrato pc set
         estado_proceso = v_estado_actual,
         id_usuario_mod = p_id_usuario,
         fecha_mod = now()
         where id_proceso_contrato = p_id;     
   
     
     END IF;
     
        
       return 'exito';

END;
$$;


--
-- TOC entry 1717 (class 1255 OID 208221)
-- Dependencies: 17 3246
-- Name: f_tboleta_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_tboleta_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_tboleta_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'saj.tboleta'
 AUTOR: 		 (fprudencio)
 FECHA:	        17-11-2011 11:23:54
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp                    varchar;
    v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_boleta    integer;
    v_id_boleta_fk integer;
    v_id_alarmas integer[];
    v_estado varchar;
                
BEGIN
           
    v_nombre_funcion = 'saj.f_tboleta_ime';
    v_parametros = f_get_record(p_tabla);

    /*********************************    
     #TRANSACCION:  'SA_BOLETA_INS'
     #DESCRIPCION:  Insercion de registros
     #AUTOR:        Mercedes Zambrana Meneses
     #FECHA:        17-11-2011 11:23:54
    ***********************************/

    if(p_transaccion='SA_BOLETA_INS')then
                    
        begin
        
        IF(public.f_existe_parametro(p_tabla,'id_boleta_fk')) then
        
           v_id_boleta_fk = v_parametros.id_boleta_fk;
        else
           v_id_boleta_fk = NULL;
        END IF;
        
       -- veirifico si la institucion es del tipo banco
       
       IF (not exists (select 1 from param.tinstitucion i 
                  where i.id_institucion = v_parametros.id_institucion_banco
                  and i.es_banco='SI'))THEN
                  
              raise exception 'La institución seleccionada no esta señalada como un banco';
                  
       END IF;
        
        
        
            --Sentencia de la insercion
            insert into saj.tboleta(
            --extension,
           -- doc_garantia,
           -- id_alarma,
            id_institucion_banco,
           -- fecha_fin,
            numero,
            fecha_vencimiento,
            fecha_suscripcion,
            orden,
            observaciones,
            monto,
            id_moneda,
            tipo,
           -- version,
            estado_reg,
            id_proceso_contrato,
          --  fecha_ini,
            estado,
            id_usuario_reg,
            fecha_reg,
            id_usuario_mod,
            fecha_mod,
            id_boleta_fk
              ) values(
           -- v_parametros.extension,
          --  v_parametros.doc_garantia,
           -- v_parametros.id_alarma,
            v_parametros.id_institucion_banco,
          --  v_parametros.fecha_fin,
            v_parametros.numero,
            v_parametros.fecha_vencimiento,
            v_parametros.fecha_suscripcion,
            v_parametros.orden,
            v_parametros.observaciones,
            v_parametros.monto,
            v_parametros.id_moneda,
            v_parametros.tipo,
          --  v_parametros.version,
            'activo',
            v_parametros.id_proceso_contrato,
           -- v_parametros.fecha_ini,
            'borrador',
            p_id_usuario,
            now(),
            null,
            null,
            v_id_boleta_fk
            )RETURNING id_boleta into v_id_boleta;
            
            
            --cambiamos el estado de la boelta renovada si existe
            
             
                  if(v_id_boleta_fk is not NULL)THEN
                     
                     update saj.tboleta set
                      id_alarma = NULL,
                      estado = 'renovada',
                      id_usuario_mod = p_id_usuario,
                      fecha_mod = now()
                      where id_boleta=v_id_boleta_fk;
                    
                   	   -- si el estado es renovada, cobrada, finalizada
                       -- quitamos las alertas relacionadas
                       
                     
                           --cambiamos el tipo de alerta a notificacion
                           --las notificaciones pueden ser borradas por lo susuarios
                           --mostramos la solucion
                           
                           select id_alarma into v_id_alarmas 
                           from saj.tboleta b
                           where id_boleta=v_id_boleta_fk;
                           
                           update param.talarma set
                           tipo ='notificacion',
                           fecha = now(),
                           descripcion ='La boleta fue renovada  ['||descripcion||']',
                           id_usuario_mod = p_id_usuario,
                           fecha_mod = now()
                           where id_alarma = ANY (v_id_alarmas); 
                           
             
                  END IF;
           
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Boleta almacenado(a) con exito (id_boleta'||v_id_boleta||')'); 
            v_resp = f_agrega_clave(v_resp,'id_boleta',v_id_boleta::varchar);

            --Devuelve la respuesta
            return v_resp;

        end;

    /*********************************    
     #TRANSACCION:  'SA_BOLETA_MOD'
     #DESCRIPCION:    Modificacion de registros
     #AUTOR:        Mercedes Zambrana Meneses
     #FECHA:        17-11-2011 11:23:54
    ***********************************/

    elsif(p_transaccion='SA_BOLETA_MOD')then

        begin
        
            if (NOT EXISTS (select 1 from saj.tboleta b 
                 where b.id_boleta =v_parametros.id_boleta 
                 and estado_reg='activo')) then
               raise exception 'La boleta se encuentra eliminada (actualice su grilla)';            
 			end if;
            
            
             --obtener etado de bolea antes de modificar
            
            select estado into v_estado from saj.tboleta b where  b.id_boleta =v_parametros.id_boleta ;
            --si la boleta no esta en estado borrado o registrada no pueden hacerce cambios
            if(v_estado not in ('borrador','resgistrada')) then
            
              raise exception 'Solo se pueden editar boletas en estado borrador o registradas';
            
            end if;
            
             -- veirifico si la institucion es del tipo banco
       
           IF (not exists (select 1 from param.tinstitucion i 
                      where i.id_institucion = v_parametros.id_institucion_banco
                      and i.es_banco='SI'))THEN
                      
                  raise exception 'La institución seleccionada no esta señalada como un banco';
                      
           END IF;
            
            
            --Sentencia de la modificacion
            update saj.tboleta set
           -- extension = v_parametros.extension,
           -- doc_garantia = v_parametros.doc_garantia,
           -- id_alarma = v_parametros.id_alarma,
            id_institucion_banco = v_parametros.id_institucion_banco,
           -- fecha_fin = v_parametros.fecha_fin,
            numero = v_parametros.numero,
            fecha_vencimiento = v_parametros.fecha_vencimiento,
            fecha_suscripcion = v_parametros.fecha_suscripcion,
            orden = v_parametros.orden,
            observaciones = v_parametros.observaciones,
            monto = v_parametros.monto,
            id_moneda = v_parametros.id_moneda,
            tipo = v_parametros.tipo,
            id_usuario_mod = p_id_usuario,
            fecha_mod = now()
           
           -- version = v_parametros.version,
          --  id_proceso_contrato = v_parametros.id_proceso_contrato,
           -- fecha_ini = v_parametros.fecha_ini
          --  estado = v_parametros.estado,
           
            where id_boleta=v_parametros.id_boleta;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Boleta modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_boleta',v_parametros.id_boleta::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end;
    /*********************************    
 	#TRANSACCION:  'SA_ARCHBOL_MOD'
 	#DESCRIPCION:	Actualiza datos de la boleta  escaneada
 	#AUTOR:		rac	
 	#FECHA:		16-12-2011 17:25:24
	***********************************/

	elsif(p_transaccion='SA_ARCHBOL_MOD')then

		begin
        
          if (NOT EXISTS (select 1 from saj.tboleta b 
                 where b.id_boleta =v_parametros.id_boleta 
                 and estado_reg='activo')) then
               raise exception 'La boleta se encuentra eliminada (actualice su grilla)';            
 			end if;
            
            
             --obtener etado de bolea antes de modificar
            
            select estado into v_estado from saj.tboleta b where  b.id_boleta =v_parametros.id_boleta ;
           -- raise exception '%',v_estado;
            --si la boleta no esta en estado borrado o registrada no pueden hacerce cambios
            if(v_estado not in ('borrador','registrada')) then
            
              raise exception 'Solo se pueden editar boletas en estado borrador o registradas';
            
            end if;
            
            
            --obtener etado de bolea antes de modificar
            
            select estado into v_estado from saj.tboleta b where  b.id_boleta =v_parametros.id_boleta ;
            --si la boleta no esta en estado borrado o registrada no pueden hacerce cambios
            if(v_estado not in ('borrador','resgistrada')) then
            
              raise exception 'Solo se pueden editar boletas en estado borrador o registradas';
            
            end if;
            
        
           --raise exception 'VERSION %',v_parametros.version;
          
           update saj.tboleta set
           extension = v_parametros.extension,
           doc_garantia = v_parametros.doc_garantia,
            id_usuario_mod = p_id_usuario,
            fecha_mod = now(),
           version = v_parametros.version
           where id_boleta=v_parametros.id_boleta;
            
            --Definicion de la respuesta
           v_resp = f_agrega_clave(v_resp,'mensaje','Archivo escaneado de boleta modificado(a)'); 
           v_resp = f_agrega_clave(v_resp,'id_boleta',v_parametros.id_boleta::varchar);
               
            --Devuelve la respuesta
           return v_resp;
           
     end;        
    /*********************************    
 	#TRANSACCION:  'SA_CMBEST_MOD'
 	#DESCRIPCION:	Cambia de estados la boleta
 	#AUTOR:		rac	
 	#FECHA:		16-12-2011 17:25:24
	***********************************/

	elsif(p_transaccion='SA_CMBEST_MOD')then

		begin
          --verificar que boleta existe 
          
          if (NOT EXISTS (select 1 from saj.tboleta b 
                 where b.id_boleta =v_parametros.id_boleta 
                 and estado_reg='activo')) then
               raise exception 'La boleta se encuentra eliminada (actualice su grilla)';            
 			end if;
            
            
             --obtener etado de bolea antes de modificar
            
            select estado into v_estado from saj.tboleta b where  b.id_boleta =v_parametros.id_boleta ;
            --si la boleta no esta en estado borrado o registrada no pueden hacerce cambios
          /*  if(v_estado !=v_parametros.estado) then
            
              raise exception 'La boleta ya se encuentra en el estado % (Posiblemente otro usuario esta modificando simultaneamente esta boleta)',v_parametros.estado;
            
            end if;*/
        
                  
          --modifica estado boleta 
           update saj.tboleta set
           estado = v_parametros.estado,
            id_usuario_mod = p_id_usuario,
            fecha_mod = now()
           where id_boleta=v_parametros.id_boleta;
        
           
           -- si el estado es renovada, cobrada, finalizada
           -- quitamos las alertas relacionadas
           
           if(v_parametros.estado  in ('renovada','cobrada','anulada','finalizada')) THEN
           
         
               --cambiamos el tipo de alerta a notificacion
               --las notificaciones pueden ser borradas por lo susuarios
               --mostramos la solucion
               
               select id_alarma into v_id_alarmas 
               from saj.tboleta b
               where id_boleta=v_parametros.id_boleta;
               
               update param.talarma set
               tipo ='notificacion',
               fecha = now(),
               descripcion ='La boleta fue '||v_parametros.estado||'  ['||descripcion||']',
               id_usuario_mod = p_id_usuario,
               fecha_mod = now()
               where id_alarma = ANY (v_id_alarmas); 
               
               --eliminamos la relacion con las boletas
               update saj.tboleta set
               id_alarma = NULL
               where id_boleta=v_parametros.id_boleta;
               
               
         
           END IF;
           
           --raise exception 'VERSION %',v_parametros.version;
          
          
           
            
            --Definicion de la respuesta
           v_resp = f_agrega_clave(v_resp,'mensaje','Archivo escaneado de boleta modificado(a)'); 
           v_resp = f_agrega_clave(v_resp,'id_boleta',v_parametros.id_boleta::varchar);
               
            --Devuelve la respuesta
           return v_resp;      
           
            
        end; 
    /*********************************    
     #TRANSACCION:  'SA_BOLETA_ELI'
     #DESCRIPCION:  Eliminacion de registros
     #AUTOR:        Mercedes Zambrana Meneses  
     #FECHA:        17-11-2011 11:23:54
    ***********************************/

    elsif(p_transaccion='SA_BOLETA_ELI')then

        begin
            
            
            /*si la boleta eliminada tiene alarmas*/
            
            --cambiamos el tipo de alerta a notificacion
               --las notificaciones pueden ser borradas por lo susuarios
               --mostramos la solucion
               
               select id_alarma into v_id_alarmas 
               from saj.tboleta b
               where id_boleta=v_parametros.id_boleta;
               
               update param.talarma set
               tipo ='notificacion',
               fecha = now(),
               descripcion ='La boleta fue ELIMINADA  ['||descripcion||']',
               id_usuario_mod = p_id_usuario,
               fecha_mod = now()
               where id_alarma = ANY (v_id_alarmas); 
               
           
               
           
            
            
            /* fin alarmas*/
            
            --verifica que no tengas boeltas renovadas
            
            if(select 1 from saj.tboleta b where b.id_boleta_fk =v_parametros.id_boleta) then
				raise exception 'La boleta que quiere eliminar ha sido renovada con anterioridad, no puede realizar esta acción';            
 			end if;
            
            
             --Sentencia de la eliminacion
             
             --eliminamos la relacion con las boletas
             /*update saj.tboleta set
             id_alarma = NULL
           --  estado_reg='inactiva'
             where id_boleta=v_parametros.id_boleta;*/
               
               
            delete from saj.tboleta
            where id_boleta=v_parametros.id_boleta;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Boleta eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_boleta',v_parametros.id_boleta::varchar);
              
            --Devuelve la respuesta
            return v_resp;

        end;
         
    else
     
        raise exception 'Transaccion inexistente: %',p_transaccion;

    end if;

EXCEPTION
                
    WHEN OTHERS THEN
        v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
        raise exception '%',v_resp;
                        
END;
$$;


--
-- TOC entry 1718 (class 1255 OID 208223)
-- Dependencies: 17 3246
-- Name: f_tboleta_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_tboleta_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_tboleta_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'saj.tboleta'
 AUTOR: 		 (fprudencio)
 FECHA:	        17-11-2011 11:23:54
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_id_funcionario integer;
    v_id_responsable_proceso integer;
    v_filtro varchar;
			    
BEGIN

	v_nombre_funcion = 'saj.f_tboleta_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
     #TRANSACCION:  'SA_BOLETA_SEL'
     #DESCRIPCION:    Consulta de datos
     #AUTOR:        fprudencio    
     #FECHA:        17-11-2011 11:23:54
    ***********************************/

    if(p_transaccion='SA_BOLETA_SEL')then
                     
        begin
       
        
            --Sentencia de la consulta
            v_consulta:='select
                        boleta.id_boleta,
                        boleta.extension,
                        boleta.doc_garantia,
                      --  boleta.id_alarma,
                        boleta.id_institucion_banco,
                        boleta.fecha_fin,
                        boleta.numero,
                        boleta.fecha_vencimiento,
                        boleta.fecha_suscripcion,
                        boleta.orden,
                        boleta.observaciones,
                        boleta.monto,
                        boleta.id_moneda,
                        boleta.tipo,
                        boleta.version,
                        boleta.estado_reg,
                        boleta.id_proceso_contrato,
                        boleta.fecha_ini,
                        boleta.estado,
                        boleta.id_usuario_reg,
                        boleta.fecha_reg,
                        boleta.id_usuario_mod,
                        boleta.fecha_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod ,
                        moneda.moneda as desc_moneda,
                        instit.nombre as nombre   
                        from saj.tboleta boleta                                                  
                        inner join param.tmoneda moneda on moneda.id_moneda=boleta.id_moneda
                        inner join param.tinstitucion instit on instit.id_institucion=boleta.id_institucion_banco
                        inner join segu.tusuario usu1 on usu1.id_usuario = boleta.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = boleta.id_usuario_mod
                        where  ';
            
            --Definicion de la respuesta                    
            v_consulta:=v_consulta||v_parametros.filtro;
            if(public.f_existe_parametro(p_tabla,'id_proceso_contrato')) then
               v_consulta:=v_consulta || ' and boleta.id_proceso_contrato='||v_parametros.id_proceso_contrato;
            end if;
            
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

            --Devuelve la respuesta
            return v_consulta;
                        
        end;

    /*********************************    
     #TRANSACCION:  'SA_BOLETA_CONT'
     #DESCRIPCION:    Conteo de registros
     #AUTOR:        fprudencio    
     #FECHA:        17-11-2011 11:23:54
    ***********************************/

    elsif(p_transaccion='SA_BOLETA_CONT')then

        begin
            --Sentencia de la consulta de conteo de registros
            v_consulta:='select count(id_boleta)
                        from saj.tboleta boleta 
                        inner join param.tmoneda moneda on moneda.id_moneda=boleta.id_moneda
                        inner join param.tinstitucion instit on instit.id_institucion=boleta.id_institucion_banco
                        inner join segu.tusuario usu1 on usu1.id_usuario = boleta.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = boleta.id_usuario_mod
                        where ';
            
            --Definicion de la respuesta            
            v_consulta:=v_consulta||v_parametros.filtro;

            --Devuelve la respuesta
            return v_consulta;

        end;
        
    /*********************************    
     #TRANSACCION:  'SA_BOLETAPR_SEL'
     #DESCRIPCION:    Consulta de boletas y procesos
     #AUTOR:        fprudencio    
     #FECHA:        17-11-2011 11:23:54
    ***********************************/

    elseif(p_transaccion='SA_BOLETAPR_SEL')then
                     
        begin
        
         v_filtro='  0=0 '; 
        
         IF(public.f_existe_parametro(p_tabla,'id_usuario')) then

                IF(v_parametros.tipoFiltro!='solicitante')THEN
                
                       Select 
                         fun.id_funcionario, r.id_responsable_proceso
                       into 
                         v_id_funcionario,v_id_responsable_proceso
                       from rhum.tfuncionario fun
                       inner join segu.tusuario usu 
                       on usu.id_persona=fun.id_persona
                       inner join saj.tresponsable_proceso r
                       on r.id_funcionario = fun.id_funcionario and r.tipo = v_parametros.tipoFiltro
                       and r.estado_reg='activo'
                       where usu.id_usuario=v_parametros.id_usuario;
                   
                 ELSE
                 
                       Select 
                         fun.id_funcionario
                       into 
                         v_id_funcionario
                       from rhum.tfuncionario fun
                       inner join segu.tusuario usu 
                       on usu.id_persona=fun.id_persona
                       where usu.id_usuario=v_parametros.id_usuario and usu.estado_reg='activo';
                 
                 END IF;
                   --arma filtro
                 IF(v_parametros.tipoFiltro='rpc') THEN
                    v_filtro= ' pc.id_rpc = '||coalesce(v_id_responsable_proceso,0)::varchar;             

                 ELSEIF (v_parametros.tipoFiltro='supervisor') THEN
                    
                    v_filtro = ' pc.id_supervisor = '||coalesce(v_id_responsable_proceso,0)::varchar;
                
                 
                 ELSEIF (v_parametros.tipoFiltro='solicitante') THEN

                  v_filtro = ' pc.id_funcionario= '||coalesce(v_id_funcionario,0)::varchar;
                 
                 ELSE
                 
                  v_filtro='  0=0 '; 
                 END IF;
                 
                 
                -- raise exception 'xxxxxxx  %',v_parametros.tipoFiltro;
        
        end if;
        
         --raise exception 'xx zz %',v_filtro;
            --Sentencia de la consulta
            v_consulta:='select
                        boleta.id_boleta,
                        boleta.extension,
                        boleta.doc_garantia,
                      --  boleta.id_alarma,
                        boleta.id_institucion_banco,
                        boleta.fecha_fin,
                        boleta.numero,
                        boleta.fecha_vencimiento,
                        boleta.fecha_suscripcion,
                        boleta.orden,
                        boleta.observaciones,
                        boleta.monto,
                        boleta.id_moneda,
                        boleta.tipo,
                        boleta.version,
                        boleta.estado_reg,
                        boleta.id_proceso_contrato,
                        boleta.fecha_ini,
                        boleta.estado,
                        boleta.id_usuario_reg,
                        boleta.fecha_reg,
                        boleta.id_usuario_mod,
                        boleta.fecha_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod ,
                        moneda.moneda as desc_moneda,
                        instit.nombre as nombre,
                        pc.numero_contrato,
                        provee.desc_proveedor,
                        pc.doc_contrato,
                        pc.numero_requerimiento
                        from saj.tboleta boleta  
                        inner join saj.tproceso_contrato pc 
                        on pc.id_proceso_contrato = boleta.id_proceso_contrato 
                        and '||v_filtro||'                                                
                        INNER join param.vproveedor provee on provee.id_proveedor=pc.id_proveedor
                       
                        inner join param.tmoneda moneda on moneda.id_moneda=boleta.id_moneda
                        inner join param.tinstitucion instit on instit.id_institucion=boleta.id_institucion_banco
                        inner join segu.tusuario usu1 on usu1.id_usuario = boleta.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = boleta.id_usuario_mod
                        where  ';
            
            --Definicion de la respuesta                    
            v_consulta:=v_consulta||v_parametros.filtro;
            if(public.f_existe_parametro(p_tabla,'id_proceso_contrato')) then
               v_consulta:=v_consulta || ' and boleta.id_proceso_contrato='||v_parametros.id_proceso_contrato;
            end if;
            
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

            --Devuelve la respuesta
            return v_consulta;
                        
        end;

    /*********************************    
     #TRANSACCION:  'SA_BOLETAPR_CONT'
     #DESCRIPCION:    Conteo de registros de boletas con proceso
     #AUTOR:        fprudencio    
     #FECHA:        17-11-2011 11:23:54
    ***********************************/

    elsif(p_transaccion='SA_BOLETAPR_CONT')then

        begin
            --Sentencia de la consulta de conteo de registros
            v_consulta:='select count(id_boleta)
                        from saj.tboleta boleta 
                        inner join saj.tproceso_contrato pc on pc.id_proceso_contrato = boleta.id_proceso_contrato                                                
                        INNER join param.vproveedor provee on provee.id_proveedor=pc.id_proveedor
                       
                        inner join param.tmoneda moneda on moneda.id_moneda=boleta.id_moneda
                        inner join param.tinstitucion instit on instit.id_institucion=boleta.id_institucion_banco
                        inner join segu.tusuario usu1 on usu1.id_usuario = boleta.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = boleta.id_usuario_mod
                        where ';
            
            --Definicion de la respuesta            
            v_consulta:=v_consulta||v_parametros.filtro;

            --Devuelve la respuesta
            return v_consulta;

        end;    
                    
    else
                         
        raise exception 'Transaccion inexistente';
                             
    end if;
                    
EXCEPTION
                    
    WHEN OTHERS THEN
            v_resp='';
            v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
            v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
            v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
            raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1719 (class 1255 OID 208225)
-- Dependencies: 17 3246
-- Name: f_tdocumento_anexo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_tdocumento_anexo_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.ft_documento_anexo_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'saj.tdocumento_anexo'
 AUTOR: 		 (fprudencio)
 FECHA:	        17-11-2011 10:24:34
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_documento_anexo	integer;
			    
BEGIN

    v_nombre_funcion = 'saj.f_tdocumento_anexo_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SA_DOCANEX_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 10:24:34
	***********************************/

	if(p_transaccion='SA_DOCANEX_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into saj.tdocumento_anexo(
			estado_reg,
			id_proceso_contrato,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.id_proceso_contrato,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_documento_anexo into v_id_documento_anexo;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Documento Anexo almacenado(a) con exito (id_documento_anexo'||v_id_documento_anexo||')'); 
            v_resp = f_agrega_clave(v_resp,'id_documento_anexo',v_id_documento_anexo::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'SA_DOCANEX_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 10:24:34
	***********************************/

	elsif(p_transaccion='SA_DOCANEX_MOD')then

		begin
			--Sentencia de la modificacion
			update saj.tdocumento_anexo set
			id_proceso_contrato = v_parametros.id_proceso_contrato,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_documento_anexo=v_parametros.id_documento_anexo;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Documento Anexo modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_documento_anexo',v_parametros.id_documento_anexo::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'SA_DOCANEX_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 10:24:34
	***********************************/

	elsif(p_transaccion='SA_DOCANEX_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from saj.tdocumento_anexo
            where id_documento_anexo=v_parametros.id_documento_anexo;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Documento Anexo eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_documento_anexo',v_parametros.id_documento_anexo::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 1720 (class 1255 OID 208226)
-- Dependencies: 17 3246
-- Name: f_tdocumento_anexo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_tdocumento_anexo_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.ft_documento_anexo_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'saj.tdocumento_anexo'
 AUTOR: 		 (fprudencio)
 FECHA:	        17-11-2011 10:24:34
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'saj.f_tdocumento_anexo_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SA_DOCANEX_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 10:24:34
	***********************************/

	if(p_transaccion='SA_DOCANEX_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						docanex.id_documento_anexo,
						docanex.estado_reg,
						docanex.id_proceso_contrato,
						docanex.id_usuario_reg,
						docanex.fecha_reg,
						docanex.id_usuario_mod,
						docanex.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from saj.tdocumento_anexo docanex
						inner join segu.tusuario usu1 on usu1.id_usuario = docanex.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = docanex.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'SA_DOCANEX_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 10:24:34
	***********************************/

	elsif(p_transaccion='SA_DOCANEX_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_documento_anexo)
					    from saj.tdocumento_anexo docanex
					    inner join segu.tusuario usu1 on usu1.id_usuario = docanex.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = docanex.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1721 (class 1255 OID 208227)
-- Dependencies: 17 3246
-- Name: f_testado_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_testado_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.ft_estado_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'saj.testado'
 AUTOR: 		 (fprudencio)
 FECHA:	        17-11-2011 09:35:55
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_estado	integer;
			    
BEGIN

    v_nombre_funcion = 'saj.f_testado_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SA_ESTAD_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 09:35:55
	***********************************/

	if(p_transaccion='SA_ESTAD_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into saj.testado(
			estado_reg,
			admite_boleta,
			orden,
			codigo,
			admite_anexo,
			nombre,
			dias,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.admite_boleta,
			v_parametros.orden,
			v_parametros.codigo,
			v_parametros.admite_anexo,
			v_parametros.nombre,
			v_parametros.dias,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_estado into v_id_estado;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Estado almacenado(a) con exito (id_estado'||v_id_estado||')'); 
            v_resp = f_agrega_clave(v_resp,'id_estado',v_id_estado::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'SA_ESTAD_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 09:35:55
	***********************************/

	elsif(p_transaccion='SA_ESTAD_MOD')then

		begin
			--Sentencia de la modificacion
			update saj.testado set
			admite_boleta = v_parametros.admite_boleta,
			orden = v_parametros.orden,
			codigo = v_parametros.codigo,
			admite_anexo = v_parametros.admite_anexo,
			nombre = v_parametros.nombre,
			dias = v_parametros.dias,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_estado=v_parametros.id_estado;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Estado modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_estado',v_parametros.id_estado::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'SA_ESTAD_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 09:35:55
	***********************************/

	elsif(p_transaccion='SA_ESTAD_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from saj.testado
            where id_estado=v_parametros.id_estado;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Estado eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_estado',v_parametros.id_estado::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 1722 (class 1255 OID 208228)
-- Dependencies: 17 3246
-- Name: f_testado_proceso_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_testado_proceso_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_testado_proceso_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'saj.testado_proceso'
 AUTOR: 		(mflores)
 FECHA:	        13-12-2011 18:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'saj.f_testado_proceso_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'AJ_ESTPRO_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			mflores	
 	#FECHA:			13-12-2011 18:30
	***********************************/

	if(p_transaccion='AJ_ESTPRO_SEL')then
    
    	begin
    		--Sentencia de la consulta
			v_consulta:='select estpro.id_estado_proceso,
                                 estpro.id_proceso_contrato,
                                 estpro.observaciones,
                                 estpro.fecha_ini,
                                 COALESCE(pers.nombre || '' '' || pers.apellido_paterno || '' '' || pers.apellido_materno) as responsable,
                                 estpro.fecha_fin,
                                 est.nombre as vigente,
                                 --est1.nombre as anterior,
                                 estpro.estado_reg,
                                 estpro.fecha_reg,
                                 estpro.id_usuario_reg,
                                 estpro.fecha_mod,
                                 estpro.id_usuario_mod,
                                 usu1.cuenta as usr_reg,
                                 usu2.cuenta as usr_mod
                          from saj.testado_proceso estpro
                          left join saj.testado est
                          on est.codigo = estpro.estado_vigente
                          --left join saj.testado est1
                          --on est1.codigo = estpro.estado_anterior
                          left join saj.tresponsable_proceso resp
                          on estpro.id_responsable_proceso = resp.id_responsable_proceso
                          left join rhum.tfuncionario func
                          on resp.id_funcionario = func.id_funcionario
                          left join segu.tpersona pers
                          on func.id_persona = pers.id_persona
                          inner join segu.tusuario usu1 on usu1.id_usuario = estpro.id_usuario_reg
                          left join segu.tusuario usu2 on usu2.id_usuario = estpro.id_usuario_mod
                          where ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion; -- || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            
            raise notice 'consulta: %',v_consulta;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'AJ_ESTPRO_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:			mflores	
 	#FECHA:			13-12-2011 18:40
	***********************************/

	elsif(p_transaccion='AJ_ESTPRO_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_estado_proceso)
					    from saj.testado_proceso estpro                        
						inner join segu.tusuario usu1 on usu1.id_usuario = estpro.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = estpro.id_usuario_mod
				        where estpro.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
        
    /*********************************    
 	#TRANSACCION:  'AJ_EPDET_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			mflores	
 	#FECHA:			13-01-2011 15:53
	***********************************/

	elsif(p_transaccion='AJ_EPDET_SEL')then
    
    	begin
    		--Sentencia de la consulta
			v_consulta:='select est.nombre as vigente,
                          estad.nombre as anterior,
                          estcon.observaciones,
                          estcon.fecha_ini,
                          estcon.fecha_fin
                          from saj.testado_proceso estcon
                          left join saj.testado est
                          on est.codigo = estcon.estado_vigente
                          left join saj.testado estad
                          on estad.codigo = estcon.estado_anterior
                          where ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion;
            
            raise notice 'consulta: %',v_consulta;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'AJ_EPDET_CONT'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			mflores	
 	#FECHA:			13-01-2011 17:00
	***********************************/

	elsif(p_transaccion='AJ_EPDET_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_estado_proceso)
			 			  from saj.testado_proceso estcon
                          left join saj.testado est
                          on est.codigo = estcon.estado_vigente
                          left join saj.testado estad
                          on estad.codigo = estcon.estado_anterior
                          where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1723 (class 1255 OID 208229)
-- Dependencies: 17 3246
-- Name: f_testado_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_testado_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_testado_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'saj.testado'
 AUTOR: 		 (fprudencio)
 FECHA:	        17-11-2011 09:35:55
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'saj.f_testado_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SA_ESTAD_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 09:35:55
	***********************************/

	if(p_transaccion='SA_ESTAD_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						estad.id_estado,
						estad.estado_reg,
						estad.admite_boleta,
						estad.orden,
						estad.codigo,
						estad.admite_anexo,
						estad.nombre,
						estad.dias,
						estad.id_usuario_reg,
						estad.fecha_reg,
						estad.id_usuario_mod,
						estad.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from saj.testado estad
						inner join segu.tusuario usu1 on usu1.id_usuario = estad.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = estad.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			raise notice 'consulta: %',v_consulta;
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'SA_ESTAD_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		17-11-2011 09:35:55
	***********************************/

	elsif(p_transaccion='SA_ESTAD_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_estado)
					    from saj.testado estad
					    inner join segu.tusuario usu1 on usu1.id_usuario = estad.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = estad.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1724 (class 1255 OID 208230)
-- Dependencies: 17 3246
-- Name: f_tmodalidad_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_tmodalidad_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_tmodalidad_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'saj.tmodalidad'
 AUTOR: 		 (mzm)
 FECHA:	        11-11-2011 15:23:06
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
    v_parametros               record;
    v_id_requerimiento         integer;
    v_resp                    varchar;
    v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_modalidad    integer;
                
BEGIN

    v_nombre_funcion = 'saj.f_tmodalidad_ime';
    v_parametros = f_get_record(p_tabla);

    /*********************************    
     #TRANSACCION:  'SAJ_MODALI_INS'
     #DESCRIPCION:    Insercion de registros
     #AUTOR:        mzm    
     #FECHA:        11-11-2011 15:23:06
    ***********************************/

    if(p_transaccion='SAJ_MODALI_INS')then
                    
        begin
            --Sentencia de la insercion
            insert into saj.tmodalidad(
            nombre,
            estado_reg,
            id_usuario_reg,
            fecha_reg,
            id_usuario_mod,
            fecha_mod
              ) values(
            v_parametros.nombre,
            'activo',
            p_id_usuario,
            now(),
            null,
            null
            )RETURNING id_modalidad into v_id_modalidad;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Modalidad almacenado(a) con exito (id_modalidad'||v_id_modalidad||')'); 
            v_resp = f_agrega_clave(v_resp,'id_modalidad',v_id_modalidad::varchar);

            --Devuelve la respuesta
            return v_resp;

        end;

    /*********************************    
     #TRANSACCION:  'SAJ_MODALI_MOD'
     #DESCRIPCION:    Modificacion de registros
     #AUTOR:        mzm    
     #FECHA:        11-11-2011 15:23:06
    ***********************************/

    elsif(p_transaccion='SAJ_MODALI_MOD')then

        begin
            --Sentencia de la modificacion
            update saj.tmodalidad set
            nombre = v_parametros.nombre,
            id_usuario_mod = p_id_usuario,
            fecha_mod = now()
            where id_modalidad=v_parametros.id_modalidad;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Modalidad modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_modalidad',v_parametros.id_modalidad::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end;

    /*********************************    
     #TRANSACCION:  'SAJ_MODALI_ELI'
     #DESCRIPCION:    Eliminacion de registros
     #AUTOR:        mzm    
     #FECHA:        11-11-2011 15:23:06
    ***********************************/

    elsif(p_transaccion='SAJ_MODALI_ELI')then

        begin
            --Sentencia de la eliminacion
            delete from saj.tmodalidad
            where id_modalidad=v_parametros.id_modalidad;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Modalidad eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_modalidad',v_parametros.id_modalidad::varchar);
              
            --Devuelve la respuesta
            return v_resp;

        end;
         
    else
     
        raise exception 'Transaccion inexistente: %',p_transaccion;

    end if;

EXCEPTION
                
    WHEN OTHERS THEN
        v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
        raise exception '%',v_resp;
                        
END;
$$;


--
-- TOC entry 1725 (class 1255 OID 208231)
-- Dependencies: 17 3246
-- Name: f_tmodalidad_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_tmodalidad_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_tmodalidad_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'saj.tmodalidad'
 AUTOR: 		 (mzm)
 FECHA:	        11-11-2011 15:23:06
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'saj.f_tmodalidad_sel';
    v_parametros = f_get_record(p_tabla);

    /*********************************    
     #TRANSACCION:  'SAJ_MODALI_SEL'
     #DESCRIPCION:    Consulta de datos
     #AUTOR:        mzm    
     #FECHA:        11-11-2011 15:23:06
    ***********************************/

    if(p_transaccion='SAJ_MODALI_SEL')then
                     
        begin
            --Sentencia de la consulta
            v_consulta:='select
                        modal.id_modalidad,
                        modal.nombre,
                        modal.estado_reg,
                        modal.id_usuario_reg,
                        modal.fecha_reg,
                        modal.id_usuario_mod,
                        modal.fecha_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod    
                        from saj.tmodalidad modal
                        inner join segu.tusuario usu1 on usu1.id_usuario = modal.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = modal.id_usuario_mod
                        where  ';
            
            --Definicion de la respuesta
            v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
			raise notice 'consulta: %',v_consulta;
            --Devuelve la respuesta
            return v_consulta;
                        
        end;

    /*********************************    
     #TRANSACCION:  'SAJ_MODALI_CONT'
     #DESCRIPCION:    Conteo de registros
     #AUTOR:        mzm    
     #FECHA:        11-11-2011 15:23:06
    ***********************************/

    elsif(p_transaccion='SAJ_MODALI_CONT')then

        begin
            --Sentencia de la consulta de conteo de registros
            v_consulta:='select count(id_modalidad)
                        from saj.tmodalidad modal
                        inner join segu.tusuario usu1 on usu1.id_usuario = modal.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = modal.id_usuario_mod
                        where ';
            
            --Definicion de la respuesta            
            v_consulta:=v_consulta||v_parametros.filtro;

            --Devuelve la respuesta
            return v_consulta;

        end;
                    
    else
                         
        raise exception 'Transaccion inexistente';
                             
    end if;
                    
EXCEPTION
                    
    WHEN OTHERS THEN
            v_resp='';
            v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
            v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
            v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
            raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1726 (class 1255 OID 208232)
-- Dependencies: 17 3246
-- Name: f_tproceso_contrato_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_tproceso_contrato_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_tproceso_contrato_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'saj.tproceso_contrato'
 AUTOR: 		 (mzm)
 FECHA:	        16-11-2011 17:25:24
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_proceso_contrato	integer;
	v_reg_estado_proceso    varchar;	
    v_accion                varchar; 
    v_num_req				varchar; 
    v_id_gestion 			integer;   
    v_id_abogado 			integer; 
    v_id_rep_legal 			integer; 
    v_id_alarmas integer[];        	    
BEGIN

    v_nombre_funcion = 'saj.f_tproceso_contrato_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SA_CONTRA_INS'
 	#DESCRIPCION:	Insercion de requerimeinto de contratos en estado borrador
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 17:25:24
   	#AUTOR_MOD:		mzm	
 	#DESCRIPCION_MOD:	obtiene numero de contrato
 	#FECHA_MOD:		1-12-2011 

	***********************************/

	if(p_transaccion='SA_CONTRA_INS')then
					
        begin 
        
        --0) Obtener numero de requerimiento en funcion del depto de legal
         v_num_req =  param.f_obtener_correlativo('RSAJ',NULL,NULL,v_parametros.id_depto,p_id_usuario,'SAJ',NULL);
                --raise exception 'aa%',v_num_req;
        --1)obtiene el identificador de la gestion 
        
         select g.id_gestion
         into v_id_gestion
         from param.tgestion g
         where g.estado_reg='activo' and g.gestion=to_char(now()::date,'YYYY')::integer;
          
        --2) obetner el reprsentante legal vigente   
        
        SELECT id_responsable_proceso
          into v_id_rep_legal  
        FROM  saj.tresponsable_proceso rp
        WHERE rp.estado_reg='activo' and rp.tipo ='rep_legal'
        LIMIT 1 OFFSET 0;
        

         
        --3) insertar solicitud de requerimietno en estado borrador
        	--Sentencia de la insercion
        	insert into saj.tproceso_contrato(
			--notario,
			--numero_oc,
			fecha_convocatoria,
			numero_requerimiento,
			--multas,
			id_modalidad,
			--fecha_aprobacion,
			fecha_fin,
			plazo,
			objeto_contrato,
			id_depto,
			--extension,
			--id_proyecto,
			forma_pago,
			--id_lugar_suscripcion,
			numero_cuce,
			--fecha_suscripcion,
			--testimonio,
			--monto_contrato,
			--numero_contrato,
			id_rpc,
			--id_alarma,
			--observaciones,
			id_proveedor,
			--origen_recursos,
			id_uo,
			id_representante_legal,
			id_tipo_contrato,
			--fecha_testimonio,
			--doc_contrato,
			id_supervisor,
			--beneficiario,
			--version,
			id_gestion,
			fecha_ini,
			--fecha_ap_acta,
			--id_oc,
			id_funcionario,
			id_moneda ,
            monto_contrato,
            id_usuario_reg,
			numero_licitacion
          	) values(
			--v_parametros.notario,
			--v_parametros.numero_oc,
			v_parametros.fecha_convocatoria,
			v_num_req,
			--v_parametros.multas,
			v_parametros.id_modalidad,
			--v_parametros.fecha_aprobacion,
			v_parametros.fecha_fin,
			v_parametros.plazo,
			v_parametros.objeto_contrato,
			v_parametros.id_depto,
			--v_parametros.extension,
			--v_parametros.id_proyecto,
			v_parametros.forma_pago,
			--v_parametros.id_lugar_suscripcion,
			v_parametros.numero_cuce,
			--v_parametros.fecha_suscripcion,
			--v_parametros.testimonio,
			--v_parametros.monto_contrato,
			--v_parametros.numero_contrato,
			v_parametros.id_rpc,
		--	v_parametros.id_alarma,
			--v_parametros.observaciones,
			v_parametros.id_proveedor,
			--v_parametros.origen_recursos,
			v_parametros.id_uo,
			v_id_rep_legal,
			v_parametros.id_tipo_contrato,
			--v_parametros.fecha_testimonio,
			--v_parametros.doc_contrato,
			v_parametros.id_supervisor,
			--v_parametros.beneficiario,
			--v_parametros.version,
			v_id_gestion,
			v_parametros.fecha_ini,
			--v_parametros.fecha_ap_acta,
			--v_parametros.id_oc,
			v_parametros.id_funcionario,
			v_parametros.id_moneda,
            v_parametros.monto_contrato,
            p_id_usuario,
			v_parametros.numero_licitacion
			)RETURNING id_proceso_contrato into v_id_proceso_contrato;
               
            
            --4) inserta el estado correpondiente al proceso es este caso el inicial
            raise notice 'actualiza el estado';
            v_reg_estado_proceso:=saj.f_manejo_estado_proceso(v_id_proceso_contrato,'siguiente','formulacion de requerimiento',p_id_usuario,null);
            
            
            if(v_reg_estado_proceso!='exito') then                 
	            raise exception 'Error con registro en estado proceso para id_proceso_contrato %', v_id_proceso_contrato;            
            end if;
            
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Proceso de Contratacion almacenado(a) con exito (id_proceso_contrato'||v_id_proceso_contrato||')'); 
            v_resp = f_agrega_clave(v_resp,'id_proceso_contrato',v_id_proceso_contrato::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'SA_CONTRA_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 17:25:24
	***********************************/

	elsif(p_transaccion='SA_CONTRA_MOD')then

		begin
			--Sentencia de la modificacion     
            
            if(public.f_existe_parametro(p_tabla,'operacion')) then      
              

              -- identificar el jefe de abogados vigente al entra al estado de asignacion
              --en otros casos agarra el id_abogado
              
              if(v_parametros.operacion!='anterior') then
                 v_accion:='siguiente';
              else            
                 v_accion:=v_parametros.operacion;
              end if;

            --operacion identifica al estado que se debe cambiar el proceso contrato       
            
            
              v_reg_estado_proceso:=saj.f_manejo_estado_proceso(v_parametros.id_proceso_contrato,v_accion,
              'cambio de estado a:'|| v_parametros.operacion,p_id_usuario,
              null);
              
              if(v_reg_estado_proceso!='exito') then
                 raise exception 'Problema con modificacion a registro';
              end if;
            
            else
            
            --raise exception 'xxxx';
               update saj.tproceso_contrato set
			        --  notario = v_parametros.notario,
			        --  numero_oc = v_parametros.numero_oc,
			          fecha_convocatoria = v_parametros.fecha_convocatoria,
			        --  numero_requerimiento = v_parametros.numero_requerimiento,
                    --  multas = v_parametros.multas,
                      id_modalidad = v_parametros.id_modalidad,
                    --  fecha_aprobacion = v_parametros.fecha_aprobacion,
                      fecha_fin = v_parametros.fecha_fin,
                      plazo = v_parametros.plazo,
                      objeto_contrato = v_parametros.objeto_contrato,
                      id_depto = v_parametros.id_depto,
                    --  extension = v_parametros.extension,
                    --  id_proyecto = v_parametros.id_proyecto,
                      forma_pago = v_parametros.forma_pago,
                    --  id_lugar_suscripcion = v_parametros.id_lugar_suscripcion,
                      numero_cuce = v_parametros.numero_cuce,
                    --  fecha_suscripcion = v_parametros.fecha_suscripcion,
                    --  testimonio = v_parametros.testimonio,
                      monto_contrato = v_parametros.monto_contrato,
                     -- numero_contrato = v_parametros.numero_contrato,
                      id_rpc = v_parametros.id_rpc,
                    --  id_alarma = v_parametros.id_alarma,
                   --   observaciones = v_parametros.observaciones,
                      id_proveedor = v_parametros.id_proveedor,
                    --  origen_recursos = v_parametros.origen_recursos,
                      id_uo = v_parametros.id_uo,
                     -- id_representante_legal = v_parametros.id_representante_legal,
                      id_tipo_contrato = v_parametros.id_tipo_contrato,
                    --  fecha_testimonio = v_parametros.fecha_testimonio,
                    --  doc_contrato = v_parametros.doc_contrato,
                      id_supervisor = v_parametros.id_supervisor,
                     -- beneficiario = v_parametros.beneficiario,
                     -- version = v_parametros.version,
                     -- id_gestion = v_parametros.id_gestion,
                      fecha_ini = v_parametros.fecha_ini,
                     -- fecha_ap_acta = v_parametros.fecha_ap_acta,
                     -- id_oc = v_parametros.id_oc,
                      id_funcionario = v_parametros.id_funcionario,
                      id_moneda = v_parametros.id_moneda,
                      numero_licitacion = v_parametros.numero_licitacion,
                       id_usuario_mod = p_id_usuario,
                       fecha_mod = now()
                      where id_proceso_contrato=v_parametros.id_proceso_contrato;
               end if;
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proceso de Contratacion modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proceso_contrato',v_parametros.id_proceso_contrato::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end;
        
    /*********************************    
 	#TRANSACCION:  'SA_CAMEST_MOD'
 	#DESCRIPCION:	Cambia estados del proceso contrato
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 17:25:24
	***********************************/

	elsif(p_transaccion='SA_CAMEST_MOD')then

		begin
			-- identificar el jefe de abogados vigente al entra al estado de asignacion
              --en otros casos agarra el id_abogado
              
              if(v_parametros.operacion!='anterior') then
                 v_accion:='siguiente';
              else            
                 v_accion:=v_parametros.operacion;
              end if;
              
              
              
              IF(public.f_existe_parametro(p_tabla,'id_abogado')) then      
                   v_id_abogado=v_parametros.id_abogado;
              ELSE
	              v_id_abogado = NULL;
              END IF;
              
              --operacion identifica al estado que se debe cambiar el proceso contrato       
              v_reg_estado_proceso:=saj.f_manejo_estado_proceso(v_parametros.id_proceso_contrato,v_accion,
              'cambio de estado a:'|| v_parametros.operacion,p_id_usuario,
              v_id_abogado);
              
              if(v_reg_estado_proceso!='exito') then
                 raise exception 'Problema con el cambio de estado del proceso';
              end if;
            
            
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proceso de Contratacion modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proceso_contrato',v_parametros.id_proceso_contrato::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end; 
        
        
	/*********************************    
 	#TRANSACCION:  'SA_CONELA_MOD'
 	#DESCRIPCION:	Modificacionde contratos en elaboración
 	#AUTOR:		rac	
 	#FECHA:		20-12-2011 17:25:24
	***********************************/
        
        elsif(p_transaccion='SA_CONELA_MOD')then

		begin
			--Sentencia de la modificacion     
            
           
               update saj.tproceso_contrato set
			          notario = v_parametros.notario,
			          --numero_oc = v_parametros.numero_oc,
			          fecha_convocatoria = v_parametros.fecha_convocatoria,
			        --  numero_requerimiento = v_parametros.numero_requerimiento,
                    --  multas = v_parametros.multas,
                      id_modalidad = v_parametros.id_modalidad,
                    --  fecha_aprobacion = v_parametros.fecha_aprobacion,
                      fecha_fin = v_parametros.fecha_fin,
                      plazo = v_parametros.plazo,
                      objeto_contrato = v_parametros.objeto_contrato,
                    --  id_depto = v_parametros.id_depto,
                    --  extension = v_parametros.extension,
                    --  id_proyecto = v_parametros.id_proyecto,
                      forma_pago = v_parametros.forma_pago,
                    --  id_lugar_suscripcion = v_parametros.id_lugar_suscripcion,
                      numero_cuce = v_parametros.numero_cuce,
                      fecha_suscripcion = v_parametros.fecha_suscripcion,
                    --  testimonio = v_parametros.testimonio,
                      monto_contrato = v_parametros.monto_contrato,
                      numero_contrato = v_parametros.numero_contrato,
                      id_rpc = v_parametros.id_rpc,
                    --  id_alarma = v_parametros.id_alarma,
                      observaciones = v_parametros.observaciones,
                      id_proveedor = v_parametros.id_proveedor,
                    --  origen_recursos = v_parametros.origen_recursos,
                    --  id_uo = v_parametros.id_uo,
                      id_representante_legal = v_parametros.id_representante_legal,
                      id_tipo_contrato = v_parametros.id_tipo_contrato,
                    --  fecha_testimonio = v_parametros.fecha_testimonio,
                    --  doc_contrato = v_parametros.doc_contrato,
                      id_supervisor = v_parametros.id_supervisor,
                     -- beneficiario = v_parametros.beneficiario,
                     -- version = v_parametros.version,
                     -- id_gestion = v_parametros.id_gestion,
                      fecha_ini = v_parametros.fecha_ini,
                     -- fecha_ap_acta = v_parametros.fecha_ap_acta,
                     -- id_oc = v_parametros.id_oc,
                    -- id_funcionario = v_parametros.id_funcionario,
                      id_moneda = v_parametros.id_moneda,
                      numero_licitacion = v_parametros.numero_licitacion,
                       id_usuario_mod = p_id_usuario,
                        fecha_mod = now()::date
                      where id_proceso_contrato=v_parametros.id_proceso_contrato;
             
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proceso de Contratacion modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proceso_contrato',v_parametros.id_proceso_contrato::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end; 
        
        
     
     /*********************************    
 	#TRANSACCION:  'SA_ARCHCON_MOD'
 	#DESCRIPCION:	Actualiza datos del archivo escaneado
 	#AUTOR:		rac	
 	#FECHA:		16-12-2011 17:25:24
	***********************************/

	elsif(p_transaccion='SA_ARCHCON_MOD')then

		begin
        
        --raise exception 'VERSION %',v_parametros.version;
          
           update saj.tproceso_contrato set
           extension = v_parametros.extension,
           doc_contrato = v_parametros.doc_contrato,
           version = v_parametros.version,
           id_usuario_mod = p_id_usuario,
           fecha_mod = now()
           where id_proceso_contrato=v_parametros.id_proceso_contrato;
            
            --Definicion de la respuesta
           v_resp = f_agrega_clave(v_resp,'mensaje','Archivo escaneado de contrato modificado(a)'); 
           v_resp = f_agrega_clave(v_resp,'id_proceso_contrato',v_parametros.id_proceso_contrato::varchar);
               
            --Devuelve la respuesta
           return v_resp;
            
        end; 
  
        
    /*********************************    
 	#TRANSACCION:  'SA_CONASIG_MOD'
 	#DESCRIPCION:	Modificacion de contratos desde la pantalla de asignacion
 	#AUTOR:		rac	
 	#FECHA:		13-12-2011 17:25:24
	***********************************/

	elsif(p_transaccion='SA_CONASIG_MOD')then

		begin
			--Sentencia de la modificacion   
            
            --raise exception 'v_parametros.numero_contrato %',v_parametros.numero_contrato;  
           
                   update saj.tproceso_contrato set
			          notario = v_parametros.notario,
			        --  numero_oc = v_parametros.numero_oc,
			          fecha_convocatoria = v_parametros.fecha_convocatoria,
			        --  numero_requerimiento = v_parametros.numero_requerimiento,
                    --  multas = v_parametros.multas,
                      id_modalidad = v_parametros.id_modalidad,
                    --  fecha_aprobacion = v_parametros.fecha_aprobacion,
                      fecha_fin = v_parametros.fecha_fin,
                      plazo = v_parametros.plazo,
                    --  objeto_contrato = v_parametros.objeto_contrato,
                    --  id_depto = v_parametros.id_depto,
                    --  extension = v_parametros.extension,
                    --  id_proyecto = v_parametros.id_proyecto,
                      forma_pago = v_parametros.forma_pago,
                    --  id_lugar_suscripcion = v_parametros.id_lugar_suscripcion,
                      numero_cuce = v_parametros.numero_cuce,
                     fecha_suscripcion = v_parametros.fecha_suscripcion,
                    --  testimonio = v_parametros.testimonio,
                      monto_contrato = v_parametros.monto_contrato,
                      numero_contrato = v_parametros.numero_contrato,
                      id_rpc = v_parametros.id_rpc,
                    --  id_alarma = v_parametros.id_alarma,
                      observaciones = v_parametros.observaciones,
                      id_proveedor = v_parametros.id_proveedor,
                    --  origen_recursos = v_parametros.origen_recursos,
                    --  id_uo = v_parametros.id_uo,
                     -- id_representante_legal = v_parametros.id_representante_legal,
                      id_tipo_contrato = v_parametros.id_tipo_contrato,
                    --  fecha_testimonio = v_parametros.fecha_testimonio,
                    --  doc_contrato = v_parametros.doc_contrato,
                      id_supervisor = v_parametros.id_supervisor,
                     -- beneficiario = v_parametros.beneficiario,
                     -- version = v_parametros.version,
                     -- id_gestion = v_parametros.id_gestion,
                      fecha_ini = v_parametros.fecha_ini,
                     -- fecha_ap_acta = v_parametros.fecha_ap_acta,
                     -- id_oc = v_parametros.id_oc,
                     -- id_funcionario = v_parametros.id_funcionario,
                      id_moneda = v_parametros.id_moneda,
                      numero_licitacion = v_parametros.numero_licitacion,
                       id_usuario_mod = p_id_usuario,
                       fecha_mod = now()
                      where id_proceso_contrato=v_parametros.id_proceso_contrato;
            
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proceso de Contratacion modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proceso_contrato',v_parametros.id_proceso_contrato::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
          end; 
        

    /*********************************    
     #TRANSACCION:  'SA_CONTRA_ELI'
     #DESCRIPCION:    Eliminacion de registros
     #AUTOR:        mzm    
     #FECHA:        16-11-2011 17:25:24
    ***********************************/

    elsif(p_transaccion='SA_CONTRA_ELI')then

        begin               
            
             v_reg_estado_proceso:=saj.f_manejo_estado_proceso(v_parametros.id_proceso_contrato,'ANULADO','anulacion de proceso contrato',p_id_usuario,null);
              
            if(v_reg_estado_proceso!='exito') then
                 raise exception 'Error con anulacion de proceso';
            end if;
            
            --verifica si el contrato tiene alarmas
            
             select pc.id_alarma into v_id_alarmas 
             from saj.tproceso_contrato pc
             where pc.id_proceso_contrato=v_parametros.id_proceso_contrato;
                           
             update param.talarma set
             tipo ='notificacion',
             fecha = now(),
             descripcion ='El contrato fue Eliminado ['||descripcion||']',
             id_usuario_mod = p_id_usuario,
             fecha_mod = now()
             where id_alarma = ANY (v_id_alarmas);
           
        
              
            --Sentencia de la eliminacion
            update saj.tproceso_contrato
            set estado_reg='inactivo',
            fecha_mod=now(),
            id_alarma = NULL,
            id_usuario_mod=p_id_usuario
            where id_proceso_contrato=v_parametros.id_proceso_contrato;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proceso de Contratacion eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_proceso_contrato',v_parametros.id_proceso_contrato::varchar);
              
            --Devuelve la respuesta
            return v_resp;

        end;
         
    else
     
        raise exception 'Transaccion inexistente: %',p_transaccion;

    end if;

EXCEPTION
                
    WHEN OTHERS THEN
        v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
        raise exception '%',v_resp;
                        
END;
$$;


--
-- TOC entry 1727 (class 1255 OID 208234)
-- Dependencies: 17 3246
-- Name: f_tproceso_contrato_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_tproceso_contrato_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_tproceso_contrato_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'saj.tproceso_contrato'
 AUTOR: 		 (mzm)
 FECHA:	        16-11-2011 17:25:24
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
    v_filtro            varchar;
    v_criterio_join     varchar;
    v_id_responsable integer;
    v_id_funcionario integer;
    v_id_responsable_proceso integer;
    v_id_supervidor integer;
    v_id_rpc integer;
			    
BEGIN

	v_nombre_funcion = 'saj.f_tproceso_contrato_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SA_CONTRA_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 17:25:24
	***********************************/

	if(p_transaccion='SA_CONTRA_SEL')then
     				
    	begin
             v_criterio_join ='LEFT JOIN';
            
             
             IF(public.f_existe_parametro(p_tabla,'tipo_interfaz')) then
             
             
               
                     IF(v_parametros.tipo_interfaz='REQUER')THEN
                     --si es la interface de requerimiento se linstan los procesos en todos los
                     --estados 
                     
                    
                           
                           IF(public.f_existe_parametro(p_tabla,'id_funcionario') ) then
                               
                                     IF p_administrador =1 THEN
                                     
                                      v_filtro=' and 0=0 ';
                                     
                                     ELSEIF(v_parametros.id_funcionario is not null) then 
                                     v_filtro = ' and (contra.id_usuario_reg= '||p_id_usuario||' 
                                                  or contra.id_funcionario = '||v_parametros.id_funcionario::varchar||')  ';
                                     ELSE 
                                     raise exception 'el usuario no tiene funcionario relacionado (Registre al usuario como funcionario en el sistema de recursos humanos)';
                                     END IF;
                            END IF;
                     END IF;
                 
                     IF (v_parametros.tipo_interfaz='FINREQ') THEN
                        v_filtro:=' and (estpro.estado_vigente=''FINREQ'' or estpro.estado_vigente=''ASIGNA'')';
                     END IF;
               
               
                     IF (v_parametros.tipo_interfaz='ELABORACION') THEN
                           --raise exception 'LLEGA';
                   
                           v_criterio_join ='LEFT JOIN';
                           
                           IF p_administrador =1 THEN
                             v_filtro:=' and (estpro.estado_vigente in (''ASIGNA'',''BORCON'',''REVCON'',''REGCON''))';
                           ELSEIF(v_parametros.id_funcionario is not null ) then 
                         
                               select id_responsable_proceso
                                 into v_id_responsable
                               from saj.tresponsable_proceso rp
                               where rp.id_funcionario = v_parametros.id_funcionario::integer;
                                 v_filtro:=' and (estpro.estado_vigente in (''ASIGNA'',''BORCON'',''REVCON'',''REGCON'',''FINCON'') 
                                                   and abogado.id_responsable_proceso='||v_id_responsable::varchar||')';
                         
                           ELSE 
                                         raise exception 'el usuario no tiene funcionario relacionado';
                           END IF;
                     END IF;
            
             
                IF (v_parametros.tipo_interfaz='CONCLUIDO') THEN
                      v_filtro:=' and (estpro.estado_vigente=''FINCON'')';
                 END IF;
           
                 IF (v_parametros.tipo_interfaz='VIGENTE') THEN
                        v_filtro:=' and (estpro.estado_vigente=''REGCON'')';
                 END IF;
             
                 IF (v_parametros.tipo_interfaz='ADMIN') THEN
                        v_filtro:=' and (estpro.estado_vigente!=''REQUER'')';
                 END IF;
                 
                 
                 
                 IF (v_parametros.tipo_interfaz='BUSQUEDA') THEN
                 
                 
                    --TIPO FILTRO
                    IF(public.f_existe_parametro(p_tabla,'tipoFiltro') ) then 
                    
                     
                     --raise exception 'tipoFiltro = %',v_parametros.tipoFiltro;
                    
                     
                                 --SI TIPO FILTRO ESTA HABILITADO ACCEDE DESDE ALARMAS
                                 --puede ver todos los estados pero hace un filtro por el tipo 
                                 --de usuario  que revisa: solicitante, rpc, supervidor
                               IF(v_parametros.tipoFiltro!='solicitante')THEN
                              
                                         Select 
                                            r.id_responsable_proceso
                                         into 
                                           v_id_responsable_proceso
                                         from saj.tresponsable_proceso r
                                         where r.id_funcionario = v_parametros.id_funcionario 
                                         and r.estado_reg='activo' and r.tipo = v_parametros.tipoFiltro;
                                     
                               ELSEIF(v_parametros.id_funcionario is  null ) then 
                                    
                                    raise exception 'el usuario no tiene funcionario relacionado';
                               
                               END IF;
                          
                              IF (v_parametros.tipoFiltro='solicitante') THEN
                              
                                     v_filtro:=' and (contra.id_funcionario='||COALESCE(v_parametros.id_funcionario,0)||')';
                                
                              ELSEIF (v_parametros.tipoFiltro='rpc') THEN
                              
                                    v_filtro:=' and (contra.id_rpc='||COALESCE(v_id_responsable_proceso,0)||')';
                                
                                
                              ELSEIF (v_parametros.tipoFiltro='supervidor') THEN
                          
                                    v_filtro:=' and (contra.id_supervisor='||COALESCE(v_id_responsable_proceso,0)||')';
                            
                              ELSE
                                    v_filtro=' and 0=0 ';
                              END IF;
                   ELSE
                      --SIN TIPO FILTRO ACCEDE DIRECTO
                               --raise exception 'XXXXXXXX    11111111';
                               
                               Select 
                                  r.id_responsable_proceso
                               into 
                                 v_id_rpc                                 
                               from saj.tresponsable_proceso r
                               where r.id_funcionario::integer = v_parametros.id_funcionario::integer 
                               and r.estado_reg::varchar='activo' and r.tipo::varchar = 'rpc';
                               
                               
                               --raise notice 'zz  22222222';
                               
                               Select 
                                  r.id_responsable_proceso
                               into 
                                 v_id_supervidor
                               from saj.tresponsable_proceso r
                               where r.id_funcionario = v_parametros.id_funcionario::integer 
                               and r.estado_reg::Varchar='activo' and r.tipo::varchar = 'supervisor';
                              
                              
                              --raise notice '33333333333333';
                              
                              
                              
                          IF(p_administrador=1) then 
                          
                               v_filtro=' and 0=0 ';
                          
                          ELSE
                          
                                IF(v_parametros.id_funcionario is  null ) then 
                                  
                                  raise exception 'el usuario no tiene funcionario relacionado';
                               
                               ELSE
                                   --mflores: revisar el filtro para las busquedas porque no lista nada para el rol SAJ - abogado                  
                                 v_filtro:=' and (contra.id_supervisor='||COALESCE(v_id_supervidor,0)::varchar||' OR contra.id_rpc='||COALESCE(v_id_rpc,0)::varchar||' OR contra.id_funcionario='||COALESCE(v_parametros.id_funcionario,0)::varchar||')';
                               
                               END IF; 
                          
                          END IF;
                        
                          --raise exception 'v_filtro: %', v_filtro; --and (contra.id_supervisor=0 OR contra.id_rpc=0 OR contra.id_funcionario=518
                                                     --raise notice '5555555555'; 
                          
                   END IF;    
               END IF;
                 
              else
                     v_filtro=' and 0=0 ';
              end if;    
                 
        
    		--Sentencia de la consulta
			v_consulta:='select
						contra.id_proceso_contrato,
						contra.notario,
						contra.numero_oc,
						contra.fecha_convocatoria,
						contra.numero_requerimiento,
						contra.multas,
						contra.id_modalidad,
						contra.fecha_aprobacion,
						contra.fecha_fin,
						contra.plazo,
						contra.objeto_contrato,
						contra.id_depto,
						contra.extension,
						contra.id_proyecto,
						contra.forma_pago,
						contra.id_lugar_suscripcion,
						contra.numero_cuce,
						contra.fecha_suscripcion,
						contra.testimonio,
						contra.monto_contrato,
						contra.numero_contrato,
						contra.id_rpc,
						--contra.id_alarma,
						contra.observaciones,
						contra.id_proveedor,
						contra.origen_recursos,
						contra.id_uo,
						contra.id_representante_legal,
						contra.id_tipo_contrato,
						contra.fecha_testimonio,
						contra.doc_contrato,
						contra.id_supervisor,
						contra.beneficiario,
						contra.version,
						contra.id_gestion,
						contra.fecha_ini,
						contra.fecha_ap_acta,
						contra.id_oc,
						contra.id_funcionario,
						contra.id_moneda,
						contra.numero_licitacion,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	,
                        
                        modali.nombre as desc_modalidad,
                        depto.nombre as desc_depto,
                        rpc.desc_responsable_proceso as desc_rpc,
                        provee.desc_proveedor,
                        uo.nombre_unidad as desc_uo,
                        rep_legal.desc_responsable_proceso as desc_rep_legal,
                        tipcon.nombre as desc_tipo_contrato,
                        superv.desc_responsable_proceso as desc_supervisor,
                        gestio.gestion as desc_gestion ,
                        funcio.desc_funcionario1::varchar as desc_funcionario,
                        moneda.moneda as desc_moneda,
                        --alarma.descripcion as desc_alarma,
                        proyec.nombre_proyecto as desc_proyecto,
                        lugar.nombre as desc_lugar,
                        est.nombre as nombre_estado,
                        contra.estado_proceso,
                        abogado.id_responsable_proceso as id_abogado,
                        abogado.desc_responsable_proceso as abogado,
                        contra.fecha_reg,
                        contra.fecha_mod,
                        contra.estado_reg
                            
					from saj.tproceso_contrato contra
                        inner join saj.testado_proceso estpro 
                          on estpro.id_proceso_contrato=contra.id_proceso_contrato 
                          and estpro.estado_reg=''activo''
                        inner join saj.testado est on est.codigo = estpro.estado_vigente
						inner join rhum.vfuncionario funcio on funcio.id_funcionario=contra.id_funcionario
                        inner join segu.tusuario usu1 on usu1.id_usuario = contra.id_usuario_reg
						inner join param.tdepto depto on depto.id_depto=contra.id_depto --inner
                        inner join rhum.tuo uo on uo.id_uo=contra.id_uo
						INNER join param.tgestion gestio on gestio.id_gestion=contra.id_gestion           
                        INNER join param.tmoneda moneda on moneda.id_moneda=contra.id_moneda
                        INNER join saj.ttipo_contrato tipcon on tipcon.id_tipo_contrato=contra.id_tipo_contrato
                        INNER join saj.vresponsable_proceso rep_legal on rep_legal.id_responsable_proceso=contra.id_representante_legal
						INNER join param.vproveedor provee on provee.id_proveedor=contra.id_proveedor

                        
                        --inner join param.tdepto_usuario depto_usuario on depto_usuario.id_depto 
                        '||v_criterio_join||'  saj.vresponsable_proceso abogado on estpro.id_responsable_proceso=abogado.id_responsable_proceso  
                        left join saj.tmodalidad modali on modali.id_modalidad=contra.id_modalidad
                        left join segu.tusuario usu2 on usu2.id_usuario = contra.id_usuario_mod   

                        left join saj.vresponsable_proceso rpc on rpc.id_responsable_proceso=contra.id_rpc  
                        

                        left join saj.vresponsable_proceso superv on superv.id_responsable_proceso=contra.id_supervisor  

                        
                        --left join param.talarma alarma on alarma.id_alarma=contra.id_alarma
                        left join param.tpm_proyecto proyec on proyec.id_proyecto=contra.id_proyecto
                        left join param.tlugar lugar on lugar.id_lugar=contra.id_lugar_suscripcion    
                       
                         
                        
                        
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;     
            		
            
             IF v_filtro is not null then
                v_consulta:=v_consulta || v_filtro;
             END IF;
            
           
   
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            raise notice  'cons: %',v_consulta;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'SA_CONTRA_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 17:25:24
	***********************************/

	elsif(p_transaccion='SA_CONTRA_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(contra.id_proceso_contrato)
					    from saj.tproceso_contrato contra
                        inner join saj.testado_proceso estpro 
                          on estpro.id_proceso_contrato=contra.id_proceso_contrato 
                          and estpro.estado_reg=''activo''
                        inner join saj.testado est on est.codigo = estpro.estado_vigente
						inner join rhum.vfuncionario funcio on funcio.id_funcionario=contra.id_funcionario
                        inner join segu.tusuario usu1 on usu1.id_usuario = contra.id_usuario_reg
						inner join param.tdepto depto on depto.id_depto=contra.id_depto --inner
                        inner join rhum.tuo uo on uo.id_uo=contra.id_uo
						INNER join param.tgestion gestio on gestio.id_gestion=contra.id_gestion           
                        INNER join param.tmoneda moneda on moneda.id_moneda=contra.id_moneda
                        INNER join saj.ttipo_contrato tipcon on tipcon.id_tipo_contrato=contra.id_tipo_contrato
                        INNER join saj.vresponsable_proceso rep_legal on rep_legal.id_responsable_proceso=contra.id_representante_legal
                        INNER join param.vproveedor provee on provee.id_proveedor=contra.id_proveedor
                       
                        
                        left join saj.tmodalidad modali on modali.id_modalidad=contra.id_modalidad
                        left join segu.tusuario usu2 on usu2.id_usuario = contra.id_usuario_mod   

                        left join saj.vresponsable_proceso rpc on rpc.id_responsable_proceso=contra.id_rpc  
                        
                        left join saj.vresponsable_proceso superv on superv.id_responsable_proceso=contra.id_supervisor  

                        
                        --left join param.talarma alarma on alarma.id_alarma=contra.id_alarma
                        left join param.tpm_proyecto proyec on proyec.id_proyecto=contra.id_proyecto
                        left join param.tlugar lugar on lugar.id_lugar=contra.id_lugar_suscripcion    
                       
                        left join saj.vresponsable_proceso abogado on estpro.id_responsable_proceso=abogado.id_responsable_proceso  
                         
                        
                        where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;
             IF(public.f_existe_parametro(p_tabla,'estado_proceso')) then
               v_consulta:=v_consulta || ' and estpro.estado_vigente='''||v_parametros.estado_proceso||'''';
            end if;
			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
/*					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;*/
END;
$$;


--
-- TOC entry 1728 (class 1255 OID 208236)
-- Dependencies: 17 3246
-- Name: f_tresponsable_proceso_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_tresponsable_proceso_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_tresponsable_proceso_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'saj.tresponsable_proceso'
 AUTOR: 		 (mzm)
 FECHA:	        16-11-2011 16:54:59
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_responsable_proceso	integer;
			    
BEGIN

    v_nombre_funcion = 'saj.f_tresponsable_proceso_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SA_RESPRO_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 16:54:59
	***********************************/

	if(p_transaccion='SA_RESPRO_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into saj.tresponsable_proceso(
			estado_reg,
			tipo,
			id_funcionario,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.tipo,
			v_parametros.id_funcionario,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_responsable_proceso into v_id_responsable_proceso;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Responsable de Proceso almacenado(a) con exito (id_responsable_proceso'||v_id_responsable_proceso||')'); 
            v_resp = f_agrega_clave(v_resp,'id_responsable_proceso',v_id_responsable_proceso::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'SA_RESPRO_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 16:54:59
	***********************************/

	elsif(p_transaccion='SA_RESPRO_MOD')then

		begin
			--Sentencia de la modificacion
            --05ene12: validamos si se trata de una asignacion de nuevo responsable para uno q esten dando de baja        
            if(public.f_existe_parametro(p_tabla,'id_funcionario_')) then  
            
                if(v_parametros.id_funcionario_>0) then    
                   --damos de baja(estado=inactivo) e insertamos otro registro q dependa del q estamos inactivando
                   update saj.tresponsable_proceso
                   set estado_reg='inactivo',      
                   fecha_mod=now()::date
                   where id_responsable_proceso=v_parametros.id_responsable_proceso;
               
                   insert into saj.tresponsable_proceso(
                       estado_reg,
                      tipo,
                      id_funcionario,
                      id_usuario_reg,
                      fecha_reg,
                      id_usuario_mod,
                      fecha_mod   ,
                      id_responsable_proceso_anterior
                      ) values(
                      'activo',
                      v_parametros.tipo,
                      v_parametros.id_funcionario_,
                      p_id_usuario,
                      now(),
                      null,
                      null   ,
                      v_parametros.id_responsable_proceso
                      )  ;        
    
                else   --modificacion simple de datos     
                    --verificar q no tenga procesos en los q esté con el tipo indicado 
                    if exists (select 1 from saj.tresponsable_proceso where id_responsable_proceso=v_parametros.id_responsable_proceso and tipo!=v_parametros.tipo) then
                    
                        if (v_parametros.tipo='abogado') then
                         --validamos en proceso_contrato 

                            if exists(select 1 from saj.testado_proceso where id_responsable_proceso=v_parametros.id_responsable_proceso) then
                                raise exception 'El responsable indicado tiene procesos en otro rol';
                            end if;
                        else                                    
                         --validamos en proceso_contrato_estado  
                            if exists (select 1 from saj.tproceso_contrato 
                                       where (id_supervisor=v_parametros.id_responsable_proceso
                                              or id_rpc=v_parametros.id_responsable_proceso 
                                              or id_representante_legal=v_parametros.id_responsable_proceso )
                            ) then
                                  raise exception 'El responsable indicado tiene procesos en otro rol';
                            end if;                      
                        end if;  
                    end if;
                    
                    
                    
                    update saj.tresponsable_proceso set
			            tipo = v_parametros.tipo,
                        id_funcionario = v_parametros.id_funcionario,
                        id_usuario_mod = p_id_usuario,
                        fecha_mod = now()
                        where id_responsable_proceso=v_parametros.id_responsable_proceso;
                end if;
            end if; 
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Responsable de Proceso modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_responsable_proceso',v_parametros.id_responsable_proceso::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'SA_RESPRO_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 16:54:59
	***********************************/

	elsif(p_transaccion='SA_RESPRO_ELI')then

        begin
            
            --validamos q se pueda eliminar el registro
            if exists(select 1 from saj.tresponsable_proceso where id_responsable_proceso_anterior=v_parametros.id_responsable_proceso) then
            end if;
               
            --Sentencia de la eliminacion         
            delete from saj.tresponsable_proceso
            where id_responsable_proceso=v_parametros.id_responsable_proceso;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Responsable de Proceso eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_responsable_proceso',v_parametros.id_responsable_proceso::varchar);
              
            --Devuelve la respuesta
            return v_resp;

        end;
         
    else
     
        raise exception 'Transaccion inexistente: %',p_transaccion;

    end if;

EXCEPTION
                
    WHEN OTHERS THEN
        v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
        raise exception '%',v_resp;
                        
END;
$$;


--
-- TOC entry 1729 (class 1255 OID 208238)
-- Dependencies: 17 3246
-- Name: f_tresponsable_proceso_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_tresponsable_proceso_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_tresponsable_proceso_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'saj.tresponsable_proceso'
 AUTOR: 		 (mzm)
 FECHA:	        16-11-2011 16:54:59
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'saj.f_tresponsable_proceso_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SA_RESPRO_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 16:54:59
	***********************************/

	if(p_transaccion='SA_RESPRO_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						respro.id_responsable_proceso,
						respro.estado_reg,
						respro.tipo,
						respro.id_funcionario,
						respro.id_usuario_reg,
						respro.fecha_reg,
						respro.id_usuario_mod,
						respro.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod,
                       -- person.nombre_completo1,
                       funcio.desc_funcionario1 as nombre_completo1,
                        coalesce((select distinct 1 from saj.tproceso_contrato where estado_proceso not in (''FINCON'',''ANULADO'')
                           and (
                                   (id_supervisor=respro.id_responsable_proceso and respro.tipo=''supervisor'') 
                                or (id_rpc=respro.id_responsable_proceso and respro.tipo=''rpc'') 
                                or (id_representante_legal=respro.id_responsable_proceso and respro.tipo=''rep_legal'')
                                or (id_proceso_contrato in (select id_proceso_contrato from saj.testado_proceso where estado_vigente not in (''FINCON'',''ANULADO'')
                                    and estado_reg=''activo'' and respro.id_responsable_proceso=id_responsable_proceso) and respro.tipo=''abogado'')
                           )
                        ),0)::integer as tiene_procesos_pendientes     ,
                        funcio_ant.desc_funcionario1 as desc_resp_ant
						from saj.tresponsable_proceso respro
						inner join segu.tusuario usu1 on usu1.id_usuario = respro.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = respro.id_usuario_mod      
                        inner join rhum.vfuncionario funcio on funcio.id_funcionario=respro.id_funcionario   
--                        inner join segu.persona person on person.id_persona=funcio.id_persona
                        left join saj.tresponsable_proceso respro_ant on respro_ant.id_responsable_proceso=respro.id_responsable_proceso_anterior
                        left join rhum.vfuncionario  funcio_ant on funcio_ant.id_funcionario=respro_ant.id_funcionario
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;   
               -- raise exception '%', 'and respro.tipo like  '' '''||v_parametros.tipo||''' ';
            if(f_existe_parametro(p_tabla,'tipo')) then                        --        raise exception 'aa%',v_parametros.tipo;
               v_consulta:=v_consulta ||  ' and respro.tipo like ''' ||v_parametros.tipo ||'''';     
            end if;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
               
			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'SA_RESPRO_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		mzm	
 	#FECHA:		16-11-2011 16:54:59
	***********************************/

	elsif(p_transaccion='SA_RESPRO_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(respro.id_responsable_proceso)
					    from saj.tresponsable_proceso respro
						inner join segu.tusuario usu1 on usu1.id_usuario = respro.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = respro.id_usuario_mod      
                        inner join rhum.vfuncionario funcio on funcio.id_funcionario=respro.id_funcionario   
--                        inner join segu.persona person on person.id_persona=funcio.id_persona
                        left join saj.tresponsable_proceso respro_ant on respro_ant.id_responsable_proceso=respro.id_responsable_proceso_anterior
                        left join rhum.vfuncionario  funcio_ant on funcio_ant.id_funcionario=respro_ant.id_funcionario
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;   
               -- raise exception '%', 'and respro.tipo like  '' '''||v_parametros.tipo||''' ';
            if(f_existe_parametro(p_tabla,'tipo')) then                        --        raise exception 'aa%',v_parametros.tipo;
               v_consulta:=v_consulta ||  ' and respro.tipo ilike ''' ||v_parametros.tipo ||'''';     
            end if;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1730 (class 1255 OID 208240)
-- Dependencies: 17 3246
-- Name: f_ttipo_contrato_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_ttipo_contrato_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_ttipo_contrato_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'saj.ttipo_contrato'
 AUTOR: 		 (mzm)
 FECHA:	        16-11-2011 16:54:07
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_tipo_contrato    integer;
                
BEGIN

    v_nombre_funcion = 'saj.f_ttipo_contrato_ime';
    v_parametros = f_get_record(p_tabla);

    /*********************************    
     #TRANSACCION:  'SA_TIPCON_INS'
     #DESCRIPCION:    Insercion de registros
     #AUTOR:        mzm    
     #FECHA:        16-11-2011 16:54:07
    ***********************************/

    if(p_transaccion='SA_TIPCON_INS')then
                    
        begin
            --Sentencia de la insercion
            insert into saj.ttipo_contrato(
            nombre,
            estado_reg,
            id_usuario_reg,
            fecha_reg,
            id_usuario_mod,
            fecha_mod
              ) values(
            v_parametros.nombre,
            'activo',
            p_id_usuario,
            now(),
            null,
            null
            )RETURNING id_tipo_contrato into v_id_tipo_contrato;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo de Contrato almacenado(a) con exito (id_tipo_contrato'||v_id_tipo_contrato||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_contrato',v_id_tipo_contrato::varchar);

            --Devuelve la respuesta
            return v_resp;

        end;

    /*********************************    
     #TRANSACCION:  'SA_TIPCON_MOD'
     #DESCRIPCION:    Modificacion de registros
     #AUTOR:        mzm    
     #FECHA:        16-11-2011 16:54:07
    ***********************************/

    elsif(p_transaccion='SA_TIPCON_MOD')then

        begin
            --Sentencia de la modificacion
            update saj.ttipo_contrato set
            nombre = v_parametros.nombre,
            id_usuario_mod = p_id_usuario,
            fecha_mod = now()
            where id_tipo_contrato=v_parametros.id_tipo_contrato;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo de Contrato modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_contrato',v_parametros.id_tipo_contrato::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end;

    /*********************************    
     #TRANSACCION:  'SA_TIPCON_ELI'
     #DESCRIPCION:    Eliminacion de registros
     #AUTOR:        mzm    
     #FECHA:        16-11-2011 16:54:07
    ***********************************/

    elsif(p_transaccion='SA_TIPCON_ELI')then

        begin
            --Sentencia de la eliminacion
            delete from saj.ttipo_contrato
            where id_tipo_contrato=v_parametros.id_tipo_contrato;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Tipo de Contrato eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_contrato',v_parametros.id_tipo_contrato::varchar);
              
            --Devuelve la respuesta
            return v_resp;

        end;
         
    else
     
        raise exception 'Transaccion inexistente: %',p_transaccion;

    end if;

EXCEPTION
                
    WHEN OTHERS THEN
        v_resp='';
        v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
        v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
        v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
        raise exception '%',v_resp;
                        
END;
$$;


--
-- TOC entry 1731 (class 1255 OID 208241)
-- Dependencies: 17 3246
-- Name: f_ttipo_contrato_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_ttipo_contrato_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Asesoria Juridica
 FUNCION: 		saj.f_ttipo_contrato_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'saj.ttipo_contrato'
 AUTOR: 		 (mzm)
 FECHA:	        16-11-2011 16:54:07
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

    v_consulta            varchar;
    v_parametros          record;
    v_nombre_funcion       text;
    v_resp                varchar;
                
BEGIN

    v_nombre_funcion = 'saj.f_ttipo_contrato_sel';
    v_parametros = f_get_record(p_tabla);

    /*********************************    
     #TRANSACCION:  'SA_TIPCON_SEL'
     #DESCRIPCION:    Consulta de datos
     #AUTOR:        mzm    
     #FECHA:        16-11-2011 16:54:07
    ***********************************/

    if(p_transaccion='SA_TIPCON_SEL')then
                     
        begin
            --Sentencia de la consulta
            v_consulta:='select
                        tipcon.id_tipo_contrato,
                        tipcon.nombre,
                        tipcon.estado_reg,
                        tipcon.id_usuario_reg,
                        tipcon.fecha_reg,
                        tipcon.id_usuario_mod,
                        tipcon.fecha_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod    
                        from saj.ttipo_contrato tipcon
                        inner join segu.tusuario usu1 on usu1.id_usuario = tipcon.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = tipcon.id_usuario_mod
                        where  ';
            
            --Definicion de la respuesta
            v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

            --Devuelve la respuesta
            return v_consulta;
                        
        end;

    /*********************************    
     #TRANSACCION:  'SA_TIPCON_CONT'
     #DESCRIPCION:    Conteo de registros
     #AUTOR:        mzm    
     #FECHA:        16-11-2011 16:54:07
    ***********************************/

    elsif(p_transaccion='SA_TIPCON_CONT')then

        begin
            --Sentencia de la consulta de conteo de registros
            v_consulta:='select count(id_tipo_contrato)
                        from saj.ttipo_contrato tipcon
                        inner join segu.tusuario usu1 on usu1.id_usuario = tipcon.id_usuario_reg
                        left join segu.tusuario usu2 on usu2.id_usuario = tipcon.id_usuario_mod
                        where ';
            
            --Definicion de la respuesta            
            v_consulta:=v_consulta||v_parametros.filtro;

            --Devuelve la respuesta
            return v_consulta;

        end;
                    
    else
                         
        raise exception 'Transaccion inexistente';
                             
    end if;
                    
EXCEPTION
                    
    WHEN OTHERS THEN
            v_resp='';
            v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
            v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
            v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
            raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1732 (class 1255 OID 208242)
-- Dependencies: 17 3246
-- Name: f_verifica_alarma(integer); Type: FUNCTION; Schema: saj; Owner: -
--

CREATE FUNCTION f_verifica_alarma(p_id_usuario integer) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: 		f_verifica_alarma
 DESCRIPCION:   Verifica las alarmas correspondientes al subsistema enviado desde el control si no existe la alarma la inserta,
                para los casos que se tengan alarmas con tiempo de vencimiento
 
 AUTOR: 	    Fernando Prudencio Cardona
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES  
 DESCRIPCION:  TErmino la funcion que quedo a medias
 AUTOR:		Rensi Artega Copari
 FECHA:		14/01/2012
 ***********************************************************************************************/

DECLARE
 
    v_dif_dias				integer;
    v_id_subsistema			integer;
    v_id_rpc				integer;
    v_id_sup    			integer;
    v_id_rep_legal			integer; 
    v_id_sup_boleta			integer;  
    v_dias_boleta			integer;
    v_dias_contrato			integer;
    v_descrip_boleta		varchar;
    v_descrip_contrato		varchar;
    v_registros				record;  
    v_alarmas				integer[];
    v_alarmas_con			integer[];
    v_id_funcionario		integer;
    v_id_alarma				integer; 
    v_funcionarios			integer[];
    v_funcionarios_cargo	varchar[];
    v_funcionarios_con		integer[]; 
    v_funcionarios_url      varchar[]; 
	v_funcionarios_class	varchar[];
    v_indice				integer;
    
    v_desc_alarma           varchar;
    v_num_cotrato varchar;
    v_contratista varchar;
BEGIN       
         v_indice:=0;
       --0) obtenemos el id_subsistema
          SELECT id_subsistema INTO v_id_subsistema
          FROM segu.tsubsistema 
          WHERE codigo='SAJ';
       
       --1)  obtenemos los datos de configuracion de boleta y contratos
       
       SELECT descripcion,dias INTO v_descrip_boleta,v_dias_boleta
       FROM param.tconfig_alarma 
       WHERE codigo='tboleta' AND id_subsistema=v_id_subsistema;
       
       SELECT descripcion,dias INTO v_descrip_contrato,v_dias_contrato
       FROM param.tconfig_alarma 
       WHERE codigo='tproceso_contrato' AND id_subsistema=v_id_subsistema; 
       
       
    --2) iniciamos el recorrido para boleta solo para las boletas que no tienen alarmas
         FOR v_registros IN (SELECT b.id_boleta,
                                    b.id_proceso_contrato,
                                    b.fecha_vencimiento,
                                    b.monto,
                                    b.id_moneda,
                                    b.numero,
                                    m.codigo
                             FROM saj.tboleta b
                             INNER JOIN param.tmoneda m on m.id_moneda = b.id_moneda
                             WHERE id_alarma IS NULL
                             and ((fecha_vencimiento-now()::date)<=v_dias_boleta)
                             and b.estado not in ('finalizada','renovada','anulada','cobrada') 
                          )LOOP
                             
                             
                           
                             
                              --falta filtro de boleas ya finalizadas, renovadas y cobradas  
             
             --calculo cuanto de cuantos dias falta para vencer
             --numero negativo indica que ya vencio
             v_dif_dias= v_registros.fecha_vencimiento-now()::date;
             
             --VERIFICA SI CUMPLE LA DIFERENCIA DE DIAS PARA CREAR UNA ALARMA
             if(v_dif_dias <= v_dias_boleta)THEN
              
              --  crea alarmas para:
              --   rpc,supervisor,representante legal,funcionario solicitante
              
                 SELECT c.id_rpc,c.id_supervisor,c.id_representante_legal,
                        c.id_funcionario 		,c.numero_contrato,desc_proveedor
                 INTO   v_id_rpc,v_id_sup,v_id_rep_legal,
                        v_id_funcionario,v_num_cotrato, v_contratista
                 FROM saj.tproceso_contrato c
                 INNER JOIN param.vproveedor provee 
                 on provee.id_proveedor=c.id_proveedor
                 WHERE id_proceso_contrato=v_registros.id_proceso_contrato;
                 
                 --obtiene el identificador de los funcionario
                 v_id_rpc:=id_funcionario FROM saj.tresponsable_proceso 
                                          WHERE id_responsable_proceso=v_id_rpc;
                 
                 v_id_sup:=id_funcionario FROM saj.tresponsable_proceso 
                                          WHERE id_responsable_proceso=v_id_sup;
                 
                 v_id_rep_legal:=id_funcionario FROM saj.tresponsable_proceso 
                                                WHERE id_responsable_proceso=v_id_rep_legal;

                 --obtiene el usuario responsable de las boletas para el departamento correspondiente
                 v_id_sup_boleta:=  fun.id_funcionario 
                                          FROM rhum.tfuncionario fun
                                          inner join segu.tusuario usu 
                                                 on usu.id_persona=fun.id_persona
                                          inner join param.tdepto_usuario dusu 
                                                 on dusu.id_usuario=usu.id_usuario and dusu.estado_reg='activo'
                                          where dusu.cargo='resp_bolet';


                   raise NOTICE 'FUNCIONARIO %',v_id_funcionario;   
                   
                 
                  v_funcionarios=NULL;
                     v_funcionarios_cargo=NULL;
                     
                     
                     v_funcionarios[1] =v_id_funcionario;
                     v_funcionarios_cargo[1] ='solicitante';
                     v_funcionarios[2] =v_id_rpc;
                     v_funcionarios_cargo[2] ='rpc';
                     v_funcionarios[3] =v_id_sup;
                     v_funcionarios_cargo[3] ='supervisor';
                     v_funcionarios[4] =v_id_sup_boleta;
                     v_funcionarios_cargo[4] ='encargadobol';
                 
                  raise NOTICE '>>>>> dias % , % % % % ',v_dias_boleta,v_funcionarios[1],v_funcionarios[2],v_funcionarios[3],v_funcionarios[4];
                  
                   
                   --inserta alarmas
                  v_indice:=1;
                   
                 --arma la descripcion de la alarma
                 v_desc_alarma='Se esta cumpliendo la Boleta de garantia Nº '||coalesce(v_registros.numero::varchar,'NR') ||' por '||coalesce(v_registros.monto::varchar,'NR')||' '||coalesce(v_registros.codigo,'NR') ||'  del contraro Nº '||coalesce(v_num_cotrato,'NR')||' del Contratista '||coalesce(v_contratista,'NR');
                   
              --  raise notice '%',v_desc_alarma;
                   
                   WHILE (v_indice <= 4)Loop
                   
                   --raise notice '%, %',v_funcionarios_cargo[v_indice],v_registros.id_boleta;
                   
                      v_id_alarma:=param.f_inserta_alarma(
                                     v_funcionarios[v_indice],
                                     v_desc_alarma,
                                     '../../../sis_legal/vista/boleta/AdministracionBoleta.php',
                                     v_registros.fecha_vencimiento,
                                     'alarma',
                                     'SAJ-Boletas',
                                     p_id_usuario,
                                     'AdministracionBoleta',
                                     'Boletas',
                                     '{tipoFiltro:'''||v_funcionarios_cargo[v_indice]::varchar||''',filtrar:true,id_boleta:'||v_registros.id_boleta::varchar||'}'
                                     ); 
                       
                      v_alarmas[v_indice]:=v_id_alarma;                        
                      v_indice:=v_indice+1;
                   End Loop;                                          
                   
                   --Actualizamos la tabla boleta con el array de alarmas
                   Update saj.tboleta SET
                      id_alarma=v_alarmas
                   WHERE id_boleta=v_registros.id_boleta;
                                            
                                          
             end if;
         END LOOP; 
       --3) iniciamos el recorrido para contrato solo para los que no tienen alarmas
      
       
       FOR v_registros IN (SELECT c.id_proceso_contrato,c.fecha_fin,c.id_funcionario,
                                  c.id_rpc,id_supervisor,c.id_representante_legal,
                                  provee.desc_proveedor,c.numero_contrato
                           FROM saj.tproceso_contrato c 
                           INNER JOIN param.vproveedor provee 
                           on provee.id_proveedor=c.id_proveedor
                           WHERE id_alarma IS NULL
                           and ((c.fecha_fin-now()::date)<=v_dias_contrato)
                           and c.estado_reg='activo' and c.estado_proceso in ('REGCON','REVCON','BORCON')
                           )LOOP 
                               
                 v_dif_dias= v_registros.fecha_fin-now()::date;
                 
                 If (v_dif_dias<=v_dias_contrato)then
             
                 
                 v_id_rpc:=id_funcionario FROM saj.tresponsable_proceso 
                                          WHERE id_responsable_proceso=v_registros.id_rpc;
                 
                 v_id_sup:=id_funcionario FROM saj.tresponsable_proceso 
                                          WHERE id_responsable_proceso=v_registros.id_supervisor;
                 
                 v_id_rep_legal:=id_funcionario FROM saj.tresponsable_proceso 
                                                WHERE id_responsable_proceso=v_registros.id_representante_legal; 
                 
                 
                 
                     v_funcionarios_con[1] =v_registros.id_funcionario;
                     v_funcionarios_cargo[1] ='solicitante';
  
					 v_funcionarios_url[1] ='../../../sis_legal/vista/proceso_contrato/ProcesoRequerimiento.php';
                     v_funcionarios_class[1] = 'ProcesoRequerimiento';
                     v_funcionarios_con[2] =v_id_rpc;
                     v_funcionarios_cargo[2] ='rpc';
					 v_funcionarios_url[2] ='../../../sis_legal/vista/proceso_contrato/ProcesoBusqueda.php';
					 v_funcionarios_class[2] = 'ProcesoBusqueda';
                     v_funcionarios_con[3] =v_id_sup;
                     v_funcionarios_cargo[3] ='supervisor';
  					 v_funcionarios_url[3] ='../../../sis_legal/vista/proceso_contrato/ProcesoBusqueda.php';
                     v_funcionarios_class[3] = 'ProcesoBusqueda';
            
                 
                 -- arma la descripcion de la alarma
                 v_desc_alarma='Se esta cumpliendo el contrato Nº '||coalesce(v_registros.numero_contrato,'NR')||' del Contratista '||coalesce(v_registros.desc_proveedor,'NR');
                 v_indice:=1;
                 
                   WHILE (v_indice <= 3)Loop
                      v_id_alarma:=param.f_inserta_alarma(
                      v_funcionarios_con[v_indice],
                      v_desc_alarma,
                      v_funcionarios_url[v_indice],
                      v_registros.fecha_fin,
                      'alarma',
                      'SAJ - Contratos',
                      p_id_usuario,
                      v_funcionarios_class[v_indice],--clase
                      'Contratos - '||v_funcionarios_cargo[v_indice],--titulo
                      '{tipoFiltro:'''||v_funcionarios_cargo[v_indice]::varchar||''',filtrar:true,id_proceso_contrato:'||v_registros.id_proceso_contrato::varchar||'}'
                     );
                                      
                         
                      v_alarmas_con[v_indice]:=v_id_alarma;                        
                      v_indice:=v_indice+1;
                   End Loop;  
                                                           
                   --Actualizamos la tabla contrato con el array de alarmas
                   Update saj.tproceso_contrato SET
                      id_alarma=v_alarmas_con
                   WHERE id_proceso_contrato=v_registros.id_proceso_contrato;
                   
                 end if;
                 
       END Loop;
           
       return 'exito';

END;
$$;


SET search_path = sast, pg_catalog;

--
-- TOC entry 1733 (class 1255 OID 208244)
-- Dependencies: 18 3246
-- Name: f_manejo_estado_requerimiento(integer, character varying, character varying, integer, integer); Type: FUNCTION; Schema: sast; Owner: -
--

CREATE FUNCTION f_manejo_estado_requerimiento(p_id integer, p_tipo character varying, p_observaciones character varying, p_id_usuario integer, p_id_responsable integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**********************************************************************************************
 HISTORIA DE MODIFICACIONES  
 DESCRIPCION:   en ves de utlizar id_estado como llave foranea con la tabla estado se utiliza el codigo
 AUTOR:			rortiz
 FECHA:			8/12/2011
 ***********************************************************************************************/

DECLARE
  v_estado_actual   varchar;
  v_estado_anterior varchar;
  v_num_orden       integer;  
  v_id_estado_nuevo integer;
  v_nombre_estado 	varchar;
  
BEGIN
       --0) obtenemos el estado actual del requerimiento
       SELECT 
          coalesce(e.orden,0) , er.estado_vigente
       into 
          v_num_orden, v_estado_anterior
       FROM sast.testado_requerimiento er
       INNER JOIN sast.testado e ON e.codigo =er.estado_vigente
       WHERE id_requerimiento=p_id 
             and er.estado_reg='activo';
             v_num_orden:=coalesce(v_num_orden,0);
       
       --1)  si buscamos el estado siguiente
       if(p_tipo='siguiente') then
       
        raise notice 'ELSE siguiente %',p_tipo;
             --1.1) si el requerimiento no tiene estados obtenemos el primero
             if v_estado_anterior is NULL THEN
             
                     select id_estado,codigo , nombre
                        into 
                       v_id_estado_nuevo,v_estado_actual,v_nombre_estado
                     from sast.testado 
                     where orden=1
                     and estado_reg='activo';
             

             ELSE
              --1.2) si es un estado mayor al primero
                    select id_estado,codigo,nombre
                      into 
                          v_id_estado_nuevo,v_estado_actual,v_nombre_estado
                     from sast.testado 
                     where orden=v_num_orden+1 
                     and estado_reg='activo';
                         
                     if(v_id_estado_nuevo is null) then
                        raise exception 'No existe un estado siguiente';
                     end if;
               
             END IF;

        --2)  si buscamos el estado anterior 
       elsif(p_tipo='anterior') then
       
              raise notice 'ELSE anterior %',p_tipo;

           if(v_num_orden=0 or  v_estado_anterior is NULL ) then
                raise exception 'Estado anterior inexistente';
           else    
                select 
                   id_estado,codigo, nombre
                into 
                   v_id_estado_nuevo,v_estado_actual,v_nombre_estado
                from sast.testado 
                where orden=v_num_orden-1 and orden>0
                and estado_reg='activo'; 
           end if;
           
     --3)  si buscamos un estado especial
       else  --if (p_tipo='proceso') then  
       
       raise notice 'ELSE  %',p_tipo;
       
                select 
                   id_estado,codigo,nombre 
                into 
                   v_id_estado_nuevo,v_estado_actual,v_nombre_estado
                from sast.testado 
                where lower(codigo)=lower(p_tipo) 
                and  estado_reg='activo' limit 1;           
            
                if(v_id_estado_nuevo is null) then
                     raise exception 'Cambio de Estado no permitido';
                end if;
       end if;
       
        --raise exception 'XXXXXX  % % %',  v_id_estado_nuevo,v_estado_actual,v_nombre_estado  ;
        
        
    --4) inactivamos los estados anteriores
        
       update  sast.testado_requerimiento set 
      -- fecha_fin=now()::date ,
         observaciones= 'cambio estado de:'||v_estado_anterior||' a '|| v_estado_actual || ' - OBS: '||coalesce(p_observaciones,'NINGUNA'),
         id_usuario_mod=p_id_usuario,
         fecha_mod=now(),
       estado_reg='inactivo'       
       where estado_reg='activo'
       and id_requerimiento=p_id; 
       
       
      --5) insertamos un nuevo estado requerimiento                                                    
       insert into sast.testado_requerimiento (estado_anterior,   estado_vigente,  fecha_ini, fecha_reg, id_requerimiento, observaciones,   id_depto_usuario,  id_usuario_reg,hora, fecha_fin)
       values                          		  (v_estado_anterior, v_estado_actual, now(),     now(),     p_id,             p_observaciones, p_id_responsable,  p_id_usuario,  now(),now());
     --6) actualizamos el estado del requerimiento
     
     update sast.trequerimientos req set
     estado_requerimiento = v_estado_actual
     where id_requerimiento = p_id;
        
       return 'exito';

END;
$$;


--
-- TOC entry 1703 (class 1255 OID 208245)
-- Dependencies: 18 3246
-- Name: f_testado_requerimiento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: sast; Owner: -
--

CREATE FUNCTION f_testado_requerimiento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Atencion en Servicio Tecnico
 FUNCION: 		sast.f_testado_requerimiento_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'sast.testado_requerimiento'
 AUTOR: 		(rortiz)
 FECHA:	        13-03-2012 18:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'sast.f_testado_requerimiento_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SAST_ESTREQ_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			rortiz	
 	#FECHA:			20-03-2012 18:30
	***********************************/

	if(p_transaccion='SAST_ESTREQ_SEL')then
    
    raise notice '%', v_parametros;
    
    	begin
    		--Sentencia de la consulta
			v_consulta:='SELECT 
            					 estreq.id_estado_requerimiento,
                                 estreq.id_requerimiento,
                                 estreq.observaciones,
                                 estreq.fecha_ini,
                                 COALESCE(pers.nombre || '' '' || pers.apellido_paterno || '' '' || pers.apellido_materno) as responsable,
                                 estreq.fecha_fin,
                                 est.nombre as vigente,
                                 --est1.nombre as anterior,
                                 estreq.estado_reg,
                                 estreq.fecha_reg,
                                 estreq.id_usuario_reg,
                                 estreq.fecha_mod,
                                 estreq.id_usuario_mod,
                                 usu1.cuenta as usr_reg,
                                 usu2.cuenta as usr_mod
                          from sast.testado_requerimiento estreq
                          left join sast.testado est on est.codigo = estreq.estado_vigente
                          inner join param.tdepto_usuario resp on resp.id_depto_usuario = estreq.id_depto_usuario 
                          inner join param.tdepto depto on depto.id_depto = resp.id_depto
                          left join sast.trequerimientos requer on requer.id_depto = depto.id_depto                         
                          left join rhum.tfuncionario func on func.id_funcionario = requer.id_funcionario
                          left join segu.tpersona pers on func.id_persona = pers.id_persona
                          inner join segu.tusuario usu1 on usu1.id_usuario = estreq.id_usuario_reg
                          left join segu.tusuario usu2 on usu2.id_usuario = estreq.id_usuario_mod
                          where ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion; -- || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            
            raise notice 'consulta: %',v_consulta;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'SAST_ESTREQ_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:			rortiz	
 	#FECHA:			20-03-2012 18:40
	***********************************/

	elsif(p_transaccion='SAST_ESTREQ_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_estado_requerimiento)
					    from sast.testado_requerimiento estreq                        
						inner join segu.tusuario usu1 on usu1.id_usuario = estreq.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = estreq.id_usuario_mod
				        where estreq.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
  
    /*********************************    
 	#TRANSACCION:  'AJ_EPDET_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			rortiz	
 	#FECHA:			13-03-2012 15:53
	***********************************/

	elsif(p_transaccion='AJ_EPDET_SEL')then
    
    	begin
    		--Sentencia de la consulta
			v_consulta:='select est.nombre as vigente,
                          estad.nombre as anterior,
                          estcon.observaciones,
                          estcon.fecha_ini,
                          estcon.fecha_fin
                          from sast.testado_requerimiento estcon
                          left join sast.testado est
                          on est.codigo = estcon.estado_vigente
                          left join sast.testado estad
                          on estad.codigo = estcon.estado_anterior
                          where ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion;
            
            raise notice 'consulta: %',v_consulta;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'AJ_EPDET_CONT'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			rortiz	
 	#FECHA:			13-03-2012 17:00
	***********************************/

	elsif(p_transaccion='AJ_EPDET_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_estado_requerimiento)
			 			  from sast.testado_requerimiento estcon
                          left join sast.testado est
                          on est.codigo = estcon.estado_vigente
                          left join sast.testado estad
                          on estad.codigo = estcon.estado_anterior
                          where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaste',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1704 (class 1255 OID 208247)
-- Dependencies: 18 3246
-- Name: ft_estado_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: sast; Owner: -
--

CREATE FUNCTION ft_estado_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de atencion en servicio técnico 
 FUNCION: 		sast.ft_estado_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'sast.testado'
 AUTOR: 		 (rortiz)
 FECHA:	        22-11-2011 18:23:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_estado 			integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
			    
BEGIN

    v_nombre_funcion = 'sast.ft_estado_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'ST_EST_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		22-11-2011 18:23:30
	***********************************/

	if(p_transaccion='ST_EST_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into sast.testado(			
			id_usuario_reg,
            id_usuario_mod,
            fecha_reg,
            fecha_mod,
            estado_reg,
            nombre,
            orden,
            codigo	           			
          	) values(          
			p_id_usuario,
            null,
            now()::date,
            null,
            'activo',
			v_parametros.nombre,
            v_parametros.orden,
            v_parametros.codigo            
			)RETURNING id_estado into v_id_estado;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida almacenado(a) con exito (id_estado'||v_id_estado||')'); 
            v_resp = f_agrega_clave(v_resp,'id_estado',v_id_estado::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'ST_EST_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		22-11-2011 18:23:30
	***********************************/

	elsif(p_transaccion='ST_EST_MOD')then

		begin
			--Sentencia de la modificacion
			update sast.testado set
			nombre = v_parametros.nombre,
            orden=v_parametros.orden,
            codigo=v_parametros.codigo,
			fecha_mod = now()::date,
			id_usuario_mod = p_id_usuario
			where id_estado=v_parametros.id_estado;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_estado',v_parametros.id_estado::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'ST_EST_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		22-11-2011 18:23:30
	***********************************/

	elsif(p_transaccion='ST_EST_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from sast.testado
            
             --rortiz 22-11-11 estado inactivo en vez de eliminar el registro
            UPDATE sast.testado
            SET estado_reg = 'inactivo'
            where id_estado=v_parametros.id_estado;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_estado',v_parametros.id_estado::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 1734 (class 1255 OID 208248)
-- Dependencies: 18 3246
-- Name: ft_estado_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: sast; Owner: -
--

CREATE FUNCTION ft_estado_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		sast.testado
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'sast.testado'
 AUTOR: 		rortiz
 FECHA:	        21-11-2011 15:23:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE
	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'sast.f_testado_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'ST_EST_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			rortiz	
 	#FECHA:			21-11-2011 15:23:30
	***********************************/

	if(p_transaccion='ST_EST_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						est.id_estado,	                     
                        est.nombre,	
                        est.orden,
                        est.codigo,
                        est.id_usuario_reg,
                        est.estado_reg,
                        est.fecha_reg,
						est.id_usuario_mod,						
						est.fecha_mod,																						
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod											
						from sast.testado est
                        inner join segu.tusuario usu1 on usu1.id_usuario = est.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = est.id_usuario_mod                        					
				        where est.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;   

	/*********************************    
 	#TRANSACCION:  'ST_EST_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rortiz	
 	#FECHA:		18-11-2011 
	***********************************/

	elsif(p_transaccion='ST_EST_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_estado)
					    from sast.testado est
					    inner join segu.tusuario usu1 on usu1.id_usuario = est.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = est.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
        				
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1735 (class 1255 OID 208249)
-- Dependencies: 18 3246
-- Name: ft_requerimientos_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: sast; Owner: -
--

CREATE FUNCTION ft_requerimientos_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de atencion en servicio técnico 
 FUNCION: 		sast.ft_requerimientos
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'sast.trequerimientos'
 AUTOR: 		 (rortiz)
 FECHA:	        24-11-2011 15:23:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_parametros           		record;
	v_id_requerimiento			integer;
	v_resp		            	varchar;
	v_nombre_funcion        	text;
    v_reg_estado_requerimiento  varchar;	
    v_accion                	varchar; 
	v_mensaje_error         	text;
    v_num_req					varchar; 
    v_id_gestion 				integer; 
    v_id_tec					integer; 
    v_id_tecnico 				integer; 
   			    
BEGIN

    v_nombre_funcion = 'sast.ft_requerimientos_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'ST_REQ_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		24-11-2011 15:23:30
	***********************************/

	if(p_transaccion='ST_REQ_INS')then				
        begin
         --0) Obtener numero de requerimiento en funcion del depto de legal
         v_num_req =  param.f_obtener_correlativo('RSAST',NULL,NULL,v_parametros.id_depto,p_id_usuario,'SAST',NULL);
         
        --1)obtiene el identificador de la gestion 
        
         select g.id_gestion
         into v_id_gestion
         from param.tgestion g
         where g.estado_reg='activo' and g.gestion=to_char(now()::date,'YYYY')::integer;
         
       --2) obtener el tecnico vigente   
        
        SELECT id_depto_usuario
          into v_id_tec  
        FROM  param.tdepto_usuario tdu
        WHERE tdu.estado_reg='activo' and tdu.cargo ='tec'
        LIMIT 1 OFFSET 0;
         
        --3) insertar solicitud de requerimietno en estado borrador
        --Sentencia de la insercion
        	insert into sast.trequerimientos(			
			id_usuario_reg,
            id_usuario_mod,
            fecha_reg,
            fecha_mod,
            estado_reg,
            numero_requerimiento,
            id_funcionario,
            id_tipo_requerimiento,
            id_depto,
            descripcion,
            id_gestion,
      --	solucion,
            hora_requer,
            fecha_requer
          	) values(          
			p_id_usuario,
            null,
            now()::date,
            null,
            'activo',
            v_num_req,
            v_parametros.id_funcionario,
            v_parametros.id_tipo_requerimiento,
            v_parametros.id_depto,
            v_parametros.descripcion,
            v_id_gestion,
       --v_parametros.solucion,
            now(),
            now()::date
                      
			)RETURNING id_requerimiento into v_id_requerimiento;
            
       	--4) inserta el estado correpondiente al requerimiento inicial
            raise notice 'actualiza el estado';
            v_reg_estado_requerimiento:=sast.f_manejo_estado_requerimiento(v_id_requerimiento,'siguiente','formulacion de requerimiento',p_id_usuario,null);
            
            
            if(v_reg_estado_requerimiento!='exito') then        
                 raise exception 'Error con registro en estado requerimiento para id_requerimiento %', v_id_requerimiento;
            end if;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida almacenado(a) con exito (id_requerimiento'||v_id_requerimiento||')'); 
            v_resp = f_agrega_clave(v_resp,'id_requerimiento',v_id_requerimiento::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'ST_REQ_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		24-11-2011 15:23:30
	***********************************/

	elsif(p_transaccion='ST_REQ_MOD')then

		begin                
			--Sentencia de la modificacion
            
            if(public.f_existe_parametro(p_tabla,'operacion')) then      
                If(v_parametros.operacion!='anterior') then
                	v_accion:='siguiente';
                else            
                   	v_accion:=v_parametros.operacion;
                End if;
         
              --operacion identifica al estado que se debe cambiar el requerimiento                
                v_reg_estado_requerimiento:=sast.f_manejo_estado_requerimiento(v_parametros.id_requerimiento,v_accion,
                'cambio de estado a:'|| v_parametros.operacion,p_id_usuario, v_id_tecnico);              
                if(v_reg_estado_requerimiento!='exito') then
                   raise exception 'Problema con modificacion a registro';
                end if;   
                                        
            else  
                update sast.trequerimientos set
                  descripcion = v_parametros.descripcion,
                  id_funcionario = v_parametros.id_funcionario,
                  id_tipo_requerimiento = v_parametros.id_tipo_requerimiento,
                  id_depto = v_parametros.id_depto,            
                  fecha_mod = now()::date,
                  id_usuario_mod = p_id_usuario,
                  v_id_tecnico = v_parametros.id_tecnico
                  --solucion=v_parametros.solucion
                where id_requerimiento=v_parametros.id_requerimiento;
        	end if;             
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_requerimiento',v_parametros.id_requerimiento::varchar);              
            --Devuelve la respuesta
            return v_resp;            
		end;
        
    /*********************************    
 	#TRANSACCION:  'ST_REQASIG_MOD'
 	#DESCRIPCION:	Modificacion de asignacion de tecnico desde pantalla de asignacion
 	#AUTOR:			RORTIZ	
 	#FECHA:		13-12-2011 17:25:24
	***********************************/

	elsif(p_transaccion='ST_REQASIG_MOD')then

		begin
			--Sentencia de la modificacion   
			update sast.trequerimientos set
              descripcion = v_parametros.descripcion,
              id_funcionario = v_parametros.id_funcionario,
              id_tipo_requerimiento = v_parametros.id_tipo_requerimiento,
              id_depto = v_parametros.id_depto,            
              fecha_mod = now()::date,
              id_usuario_mod = p_id_usuario
          	-- v_id_tecnico = v_parametros.id_tecnico
			where id_requerimiento=v_parametros.id_requerimiento;
            
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proceso de Requerimiento Modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_requerimiento',v_parametros.id_requerimiento::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
          end; 
   
    /*********************************    
 	#TRANSACCION: 'ST_CAMEST_MOD'
 	#DESCRIPCION: Cambia estados del requerimiento
 	#AUTOR:	      RORTIZ
 	#FECHA:		  16-11-2011 17:25:24
	***********************************/

	elsif(p_transaccion='ST_CAMEST_MOD')then
		begin 
        	if(public.f_existe_parametro(p_tabla,'operacion')) then
                                 
                     v_accion:=v_parametros.operacion;
                     
                     if  v_accion = 'proceso' THEN
                        v_accion='PROREQ';            
                     end if;
                                 
                    IF(public.f_existe_parametro(p_tabla,'id_tecnico')) THEN
                        v_id_tecnico=v_parametros.id_tecnico;                    
                    ELSE
                        v_id_tecnico = NULL;
                    END IF;
                  --operacion identifica al estado que se debe cambiar el requerimiento                
                    v_reg_estado_requerimiento:=sast.f_manejo_estado_requerimiento(v_parametros.id_requerimiento,v_accion,
                    'cambio de estado a:'|| v_parametros.operacion,p_id_usuario,
                    v_id_tecnico);  
                    
                    IF(public.f_existe_parametro(p_tabla,'solucion'))THEN
                          update sast.trequerimientos
                              set solucion = v_parametros.solucion
                          where id_requerimiento = v_parametros.id_requerimiento;
                    END IF;  
                               
                    if(v_reg_estado_requerimiento!='exito') then
                       raise exception 'Problema con el cambio de estado del requerimiento';
                    end if; 
            end if;
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Requerimiento modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_requerimiento',v_parametros.id_requerimiento::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
        end; 
        
/*******************************
 #TRANSACCION:  ST_UPCAPTREQ_MOD
 #DESCRIPCION:	Modifica la captura1 de la persona
 #AUTOR:		RORTIZ	
 #FECHA:		29/11/11	
***********************************/
     elsif(p_transaccion='ST_UPCAPTREQ_MOD')then

          --consulta:=';
          BEGIN

			   update sast.trequerimientos
               set 
               captura1	= v_parametros.captura1,
               extension = v_parametros.extension,
               version = v_parametros.version,
           	   id_usuario_mod = p_id_usuario,
           	   fecha_mod = now()::date
               where id_requerimiento = v_parametros.id_requerimiento;
             
             v_resp = f_agrega_clave(v_resp,'mensaje','captura1 del requerimiento modificada con exito '||v_parametros.id_requerimiento); 
             v_resp = f_agrega_clave(v_resp,'id_requerimiento',v_parametros.id_requerimiento::varchar);
             
             return v_resp;

               
          END;
 
	/*********************************    
 	#TRANSACCION:  'ST_REQ_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		24-11-2011 15:23:30
	***********************************/

	elsif(p_transaccion='ST_REQ_ELI')then

		begin
             v_reg_estado_requerimiento:=sast.f_manejo_estado_requerimiento(v_parametros.id_requerimiento,'ANUREQ','anulacion de requerimiento',p_id_usuario,null);
              
              if(v_reg_estado_requerimiento!='exito') then
                 raise exception 'Error con anulacion de requerimiento';
              end if;
            --Sentencia de la eliminacion
            UPDATE sast.trequerimientos
            SET estado_reg = 'inactivo',
            fecha_mod=now()::date,
            id_usuario_mod=p_id_usuario
            where id_requerimiento=v_parametros.id_requerimiento;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_requerimiento',v_parametros.id_requerimiento::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 1736 (class 1255 OID 208251)
-- Dependencies: 18 3246
-- Name: ft_requerimientos_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: sast; Owner: -
--

CREATE FUNCTION ft_requerimientos_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:			rortiz		
 FECHA:			23/11/11
***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp 				varchar;
v_filtro            varchar;
v_criterio_join     varchar;
v_id_depto_usuario integer;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(p_tabla);
     v_nombre_funcion:='sast.ft_requerimientos_sel';

/*********************************    
#TRANSACCION:  'ST_CAPTU_SEL'
#DESCRIPCION:	Obtiene la captura del requerimiento
 #AUTOR:		rortiz		
 #FECHA:		23/11/11	
***********************************/

	    if(p_transaccion='ST_CAPTU_SEL')then

          --  Se arma la consulta de personas
          BEGIN
          v_criterio_join ='LEFT JOIN';
                   IF(public.f_existe_parametro(p_tabla,'tipo_interfaz')) then             
                     IF(v_parametros.tipo_interfaz='BORREQ')THEN
                     --si es la interface de requerimiento se linstan los procesos en todos los
                     --estados 
                           
                           IF(public.f_existe_parametro(p_tabla,'id_funcionario') ) then                           
                                     IF p_administrador =1 THEN                                 
                                      v_filtro=' and 0=0 ';                              
                                     ELSEIF(v_parametros.id_funcionario is not null and v_parametros.id_funcionario!='') then 
                                     v_filtro = ' and (contra.id_usuario_reg= '||p_id_usuario||' 
                                                  or contra.id_funcionario = '||v_parametros.id_funcionario||')  ';
                                     ELSE 
                                     raise exception 'el usuario no tiene funcionario relacionado';
                                     END IF;
                     END IF;
                   END IF;
                   
     	--Face de Asignacion del requerimiento                              
                   IF (v_parametros.tipo_interfaz='PENREQ') THEN
                      v_filtro:=' and (estreq.estado_vigente=''PENREQ'' or estreq.estado_vigente=''ASIGNA'')';
                   END IF;    
       				
        --Face de elaboracion del requerimiento
                    IF (v_parametros.tipo_interfaz='ELABORACION') THEN
                       --raise exception 'hhhhhhhh';              
                       v_criterio_join ='LEFT JOIN';                       
                       IF p_administrador =1 THEN
                         		v_filtro:=' and (estreq.estado_vigente in (''ASIGNA'',''PENREQ'',''FINREQ''))';
                       ELSEIF(v_parametros.id_usuario is not null and v_parametros.id_usuario!='') then 
                     
                           		select id_depto_usuario
                             	into v_id_depto_usuario
                           		from param.tdepto_usuario du
                           		where du.id_usuario = v_parametros.id_usuario::integer;
                             	v_filtro:=' and (estreq.estado_vigente in (''ASIGNA'',''PENREQ'',''FINREQ''); 
                                and tecnico.id_depto_usuario='||v_id_depto_usuario::varchar||')';
                     
                       ELSE 
                                     raise exception 'el usuario no tiene funcionario relacionado';
                       END IF;
                 END IF;
             end if;
          		
		--Sentencia de la consulta   
               v_consulta:='SELECT 
               				req.id_requerimiento,
               				req.id_funcionario,
                            req.id_tipo_requerimiento,
                            req.id_depto,
               				req.id_gestion,
                            req.numero_requerimiento,
                            req.version,
                            req.descripcion,
               				req.estado_reg,
                        	req.id_usuario_reg,
                        	req.fecha_reg,
							req.id_usuario_mod,						
							req.fecha_mod,
                        	usu1.cuenta as usr_reg,
                        	usu2.cuenta as usr_mod,
                            req.estado_requerimiento,                           
                        	funcio.desc_funcionario1::varchar as desc_funcionario,
       						tipreq.nombre as requerimiento,
       						depto.nombre as departamento,               
                            gestio.gestion as desc_gestion,
                            estado.nombre as nombre_estado,
                            tecnico.id_depto_usuario as id_tecnico,
                        	tecnico.desc_depto_usuario as tecnico,
                            req.fecha_requer,
                            estreq.fecha_ini,
                            req.hora_requer,
                         	req.solucion,
                      		estreq.fecha_fin,
                            estreq.hora,
                            req.extension,                                   
                            req.captura1                           
                        	                            
   							FROM sast.trequerimientos req                                             
								inner join rhum.vfuncionario funcio on funcio.id_funcionario=req.id_funcionario
                            	inner join sast.ttipo_requerimiento tipreq on tipreq.id_tipo_requerimiento = req.id_tipo_requerimiento
                        		inner join segu.tusuario usu1 on usu1.id_usuario = req.id_usuario_reg
                                inner join param.tdepto depto on depto.id_depto = req.id_depto
                                left join sast.testado_requerimiento estreq 
                        		on estreq.id_requerimiento=req.id_requerimiento 
                        		and estreq.estado_reg=''activo''
                        		left join sast.testado estado on estado.codigo = estreq.estado_vigente                             
                                left join param.tgestion gestio on gestio.id_gestion=req.id_gestion                        
								left join segu.tusuario usu2 on usu2.id_usuario = req.id_usuario_mod
                            	'||v_criterio_join||'  sast.vdepto_usuario  tecnico on estreq.id_depto_usuario=tecnico.id_depto_usuario
                          WHERE';
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;     
            		
            
             IF v_filtro is not null then
                v_consulta:=v_consulta || v_filtro;
             END IF;
            
            raise notice '%',v_consulta;
   
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
         END;     


/*******************************
 #TRANSACCION:  ST_CAPTU_CONT
 #DESCRIPCION:	Cuenta Requerimientos con captura
 #AUTOR:		rortiz		
 #FECHA:		23/11/11	
***********************************/

     elsif(p_transaccion='ST_CAPTU_CONT')then

          --se arma la sonsulta que cuenta personas
          BEGIN
               
               v_consulta:='select count(req.id_requerimiento)
   							FROM sast.trequerimientos req                                             
								inner join rhum.vfuncionario funcio on funcio.id_funcionario=req.id_funcionario
                            	inner join sast.ttipo_requerimiento tipreq on tipreq.id_tipo_requerimiento = req.id_tipo_requerimiento
                        		inner join segu.tusuario usu1 on usu1.id_usuario = req.id_usuario_reg
                                inner join param.tdepto depto on depto.id_depto = req.id_depto
                                left join sast.testado_requerimiento estreq 
                        		on estreq.id_requerimiento=req.id_requerimiento 
                        		and estreq.estado_reg=''activo''
                        		left join sast.testado estado on estado.codigo = estreq.estado_vigente                             
                                left join param.tgestion gestio on gestio.id_gestion=req.id_gestion                        
								left join segu.tusuario usu2 on usu2.id_usuario = req.id_usuario_mod
                            	left join sast.vdepto_usuario  tecnico on estreq.id_depto_usuario=tecnico.id_depto_usuario
                           WHERE';
              v_consulta:=v_consulta||v_parametros.filtro;
              
            IF(public.f_existe_parametro(p_tabla,'requerimientos')) then
               v_consulta:=v_consulta || ' and estreq.estado_vigente='''||v_parametros.estado_requerimiento||'''';
            end if;
			--Devuelve la respuesta
			return v_consulta;
         END;
         
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1737 (class 1255 OID 208253)
-- Dependencies: 18 3246
-- Name: ft_tipo_requerimiento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: sast; Owner: -
--

CREATE FUNCTION ft_tipo_requerimiento_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de atencion en servicio técnico 
 FUNCION: 		sast.f_tipo_requerimiento_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'sast.ttipo_requerimiento'
 AUTOR: 		 (rortiz)
 FECHA:	        18-11-2011 15:23:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_tipo_requerimiento integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
			    
BEGIN

    v_nombre_funcion = 'sast.f_tipo_requerimiento_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'ST_TIPREQ_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		18-11-2011 15:23:30
	***********************************/

	if(p_transaccion='ST_TIPREQ_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into sast.ttipo_requerimiento(			
			id_usuario_reg,
            id_usuario_mod,
            fecha_reg,
            fecha_mod,
            estado_reg,
            nombre	           			
          	) values(          
			p_id_usuario,
            null,
            now()::date,
            null,
            'activo',
			v_parametros.nombre
            
			)RETURNING id_tipo_requerimiento into v_id_tipo_requerimiento;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida almacenado(a) con exito (id_tipo_requerimiento'||v_id_tipo_requerimiento||')'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_requerimiento',v_id_tipo_requerimiento::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'ST_TIPREQ_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		18-11-2011 15:23:30
	***********************************/

	elsif(p_transaccion='ST_TIPREQ_MOD')then

		begin
			--Sentencia de la modificacion
			update sast.ttipo_requerimiento set
			nombre = v_parametros.nombre,
			fecha_mod = now()::date,
			id_usuario_mod = p_id_usuario
			where id_tipo_requerimiento=v_parametros.id_tipo_requerimiento;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_requerimiento',v_parametros.id_tipo_requerimiento::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'ST_TIPREQ_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rortiz	
 	#FECHA:		18-11-2011 15:23:30
	***********************************/

	elsif(p_transaccion='ST_TIPREQ_ELI')then

		begin
			--Sentencia de la eliminacion
			--delete from sast.ttipo_requerimiento
            
             --rortiz 03-10-11 estado inactivo en vez de eliminar el registro
            UPDATE sast.ttipo_requerimiento
            SET estado_reg = 'inactivo'
            where id_tipo_requerimiento=v_parametros.id_tipo_requerimiento;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Dato Medida eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_tipo_requerimiento',v_parametros.id_tipo_requerimiento::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 1738 (class 1255 OID 208254)
-- Dependencies: 18 3246
-- Name: ft_tipo_requerimiento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: sast; Owner: -
--

CREATE FUNCTION ft_tipo_requerimiento_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		sast.ttipo_requerimiento
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'sast.ttipo_requerimiento'
 AUTOR: 		rortiz
 FECHA:	        18-11-2011 15:23:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE
	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'sast.f_ttipo_requerimiento_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'ST_TIPREQ_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			rortiz	
 	#FECHA:			18-11-2011 15:23:30
	***********************************/

	if(p_transaccion='ST_TIPREQ_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						tipreq.id_tipo_requerimiento,
                        tipreq.nombre,
                        tipreq.estado_reg,		
                        tipreq.id_usuario_reg,
                        tipreq.fecha_reg,
						tipreq.id_usuario_mod,						
						tipreq.fecha_mod,																	
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod											
						from sast.ttipo_requerimiento tipreq
                        inner join segu.tusuario usu1 on usu1.id_usuario = tipreq.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipreq.id_usuario_mod                        					
				        where tipreq.estado_reg = ''activo'' and ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;   

	/*********************************    
 	#TRANSACCION:  'ST_TIPREQ_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rortiz	
 	#FECHA:		18-11-2011 
	***********************************/

	elsif(p_transaccion='ST_TIPREQ_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_tipo_requerimiento)
					    from sast.ttipo_requerimiento tipreq
					    inner join segu.tusuario usu1 on usu1.id_usuario = tipreq.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = tipreq.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
        				
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


SET search_path = secont, pg_catalog;

--
-- TOC entry 1739 (class 1255 OID 208255)
-- Dependencies: 19 3246
-- Name: f_cambiar_estado_requerimiento(character varying, integer, text); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_cambiar_estado_requerimiento(par_tipo_cambio character varying, par_id_requerimiento integer, par_observaciones text) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nombre_funcion            text;
v_mensaje_error             text;
v_indice_actual             integer;
v_id_estado_siguiente       integer;
v_id_estado_requerimiento   integer;
BEGIN
v_nombre_funcion:='secont.f_cambiar_estado_requerimiento';

if(par_tipo_cambio='siguiente')then
    select  e.orden,er.id_estado_requerimiento into v_indice_actual,v_id_estado_requerimiento from secont.estado_requerimiento er inner join secont.estado e on (e.id_estado=er.id_estado)
    where er.id_requerimiento=par_id_requerimiento
    and er.estado_reg='activo';

    select e.id_estado into v_id_estado_siguiente from secont.estado e where e.orden=v_indice_actual+1;
    
    if(v_id_estado_siguiente is not null)then
        update secont.estado_requerimiento set estado_reg='inactivo',fecha_fin=now() where id_estado_requerimiento=v_id_estado_requerimiento;

        insert into secont.estado_requerimiento (id_requerimiento,id_estado,fecha_ini,estado_reg,observaciones)
        values(par_id_requerimiento,v_id_estado_siguiente,now(),'activo',par_observaciones);
    else
        raise exception 'No existe estado siguiente para el requerimiento: %',par_id_requerimiento;

    end if;

elsif(par_tipo_cambio='anterior')then

    select  e.orden,er.id_estado_requerimiento into v_indice_actual,v_id_estado_requerimiento from secont.estado_requerimiento er inner join secont.estado e on (e.id_estado=er.id_estado)
    where er.id_requerimiento=par.id_requerimiento
    and er.estado_reg='activo';
    
    select e.id_estado into v_id_estado_siguiente from secont.estado e where e.orden=v_indice_actual-1;

    if(v_id_estado_siguiente is not null)then
        update secont.estado_requerimiento set estado_reg='inactivo',fecha_fin=now() where id_estado_requerimiento=v_id_estado_requerimiento;

        insert into secont.estado_requerimiento (id_requerimiento,id_estado,fecha_ini,estado_reg,observaciones)
        values(par_id_requerimiento,v_id_estado_siguiente,now(),'activo',par_observaciones);
    else
        raise exception 'No existe estado anterior para el requerimiento: %',par_id_requerimiento;

    end if;
ELSE

    raise exception 'No existe el cambio: %',par_tipo_cambio;

end if;
    
    return 'exito';
    
    
EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null,null);
         raise exception '%', v_mensaje_error;
END;
$$;


--
-- TOC entry 1740 (class 1255 OID 208256)
-- Dependencies: 19 3246
-- Name: f_t_alarma_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_alarma_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_alarma_contrato           boolean;
v_alarma_garantia           boolean;


/*

 id_unidad 
 cod_unidad 
 nombre_unidad 
 gerencia_unidad 
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='secont.f_t_alarma_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_ALARMA_INS')then

          --consulta:=';
          BEGIN
               v_alarma_contrato=false;
               v_alarma_garantia=false;
               if(v_parametros.alarma_contrato='on')then
                    v_alarma_contrato=true;
               end if;

               if(v_parametros.alarma_garantia='on')then
                    v_alarma_garantia=true;
               end if;
               update secont.alarma set estado_reg='inactivo' where id_proyecto=v_parametros.id_proyecto and estado_reg='activo';
               
               insert into secont.alarma(id_proyecto,alarma_contrato,alarma_garantia,dias_contrato,dias_garantia,dias_proceso,fecha_reg,estado_reg,fecha_cambio)
               values(v_parametros.id_proyecto,v_alarma_contrato,v_alarma_garantia,v_parametros.dias_contrato,
               v_parametros.dias_garantia,v_parametros.dias_proceso,now(),'activo',v_parametros.fecha_cambio);

               return 'Unidad insertada con exito';

         END;

     elsif(par_transaccion='SCO_ALARMA_MOD')then

          --consulta:=';
          BEGIN

               v_alarma_contrato=false;
               v_alarma_garantia=false;
               if(v_parametros.alarma_contrato='on')then
                    v_alarma_contrato=true;
               end if;

               if(v_parametros.alarma_garantia='on')then
                    v_alarma_garantia=true;
               end if;
               
               update secont.alarma set alarma_contrato=v_alarma_contrato,
               alarma_garantia=v_alarma_garantia,
               dias_contrato=v_parametros.dias_contrato,
               dias_garantia=v_parametros.dias_garantia,
               dias_proceso=v_parametros.dias_proceso,
               fecha_cambio=v_parametros.fecha_cambio
               where id_alarma=v_parametros.id_alarma;
               return 'Alarma modificada con exito';
          END;

     elsif(par_transaccion='SCO_ALARMA_ELI')then

          --consulta:=';
          BEGIN

               update secont.alarma set estado_reg='inactivo'
               where id_alarma=v_parametros.id_alarma;
               return 'Alarma eliminada con exito';
          END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1741 (class 1255 OID 208257)
-- Dependencies: 19 3246
-- Name: f_t_alarma_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_alarma_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_alarma_sel';


     if(par_transaccion='SCO_ALARMA_SEL')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select id_alarma,p.id_proyecto,denominacion,
               case
               when (alarma_contrato)then
                    ''true''::varchar
               ELSE
                   ''false''::varchar
               end,
               case
               when (alarma_garantia)then
                    ''true''::varchar
               ELSE
                   ''false''::varchar
               end,dias_contrato,dias_garantia,dias_proceso,a.fecha_reg,a.estado_reg,a.fecha_cambio
               from secont.alarma a inner join secont.proyecto p on (p.id_proyecto=a.id_proyecto) where a.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_ALARMA_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(a.id_alarma)
               from secont.alarma a inner join secont.proyecto p on (p.id_proyecto=a.id_proyecto) where a.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1742 (class 1255 OID 208258)
-- Dependencies: 19 3246
-- Name: f_t_contratista_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_contratista_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;


/*

 id_unidad 
 cod_unidad 
 nombre_unidad 
 gerencia_unidad 
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='secont.f_t_contratista_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_TRATISTA_INS')then

          --consulta:=';
          BEGIN

               
               if(v_parametros.tipo='Persona Natural')then
                   insert into secont.contratista (id_persona,nit,tipo,obs,estado_reg)
                   values(v_parametros.id_persona,v_parametros.nit,
                   v_parametros.tipo,v_parametros.obs,'activo');
               ELSE
                    insert into secont.contratista (id_persona_juridica,id_persona,nit,tipo,obs,estado_reg)
                   values(v_parametros.id_persona_juridica,v_parametros.id_persona,v_parametros.nit,
                   v_parametros.tipo,v_parametros.obs,'activo');
               end if;
               
               return 'Contratista insertado con exito';

         END;

     elsif(par_transaccion='SCO_TRATISTA_MOD')then

          --consulta:=';
          BEGIN
               if(v_parametros.tipo='Persona Natural')then
                    update secont.contratista set id_persona_juridica=null,
                    id_persona=v_parametros.id_persona,
                    nit=v_parametros.nit,
                    tipo=v_parametros.tipo,
                    obs=v_parametros.obs
                    where id_contratista=v_parametros.id_contratista;
               ELSE
                     update secont.contratista set id_persona_juridica=v_parametros.id_persona_juridica,
                     id_persona=null,
                     nit=v_parametros.nit,
                     tipo=v_parametros.tipo,
                     obs=v_parametros.obs

               where id_contratista=v_parametros.id_contratista;
               end if;


              
               return 'Contratista modificado con exito';
          END;

    elsif(par_transaccion='SCO_TRATISTA_ELI')then

          --consulta:=';
          BEGIN
               update secont.contratista set estado_reg='inactivo'
               where id_contratista=v_parametros.id_contratista;
               return 'Contratista eliminado con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1743 (class 1255 OID 208259)
-- Dependencies: 19 3246
-- Name: f_t_contratista_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_contratista_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_contratista_sel';


     if(par_transaccion='SCO_TRATISTA_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:=' select c.id_contratista,
                             c.id_persona_juridica,
                             c.id_persona,
                             c.nit,
                             c.tipo,
                             c.obs,
                             c.nombre,
                             c.nombre_institucion,
                             c.nombre_persona
                             from secont.v_contratista c
                             where c.estado_reg=''activo'' and ';
                             v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
 return v_consulta;


         END;


     elsif(par_transaccion='SCO_TRATISTA_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(c.id_contratista)
               from secont.v_contratista c
               where c.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opción';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1744 (class 1255 OID 208260)
-- Dependencies: 19 3246
-- Name: f_t_contrato_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_contrato_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion       text;
v_mensaje_error        text;

v_id_repre             integer;
/*

 id_unidad
 cod_unidad
 nombre_unidad
 gerencia_unidad
 estado_reg

*/

BEGIN


     v_nombre_funcion:='secont.f_t_contrato_ime';
     v_parametros:=f_get_record(par_tabla);
     
     

     if(par_transaccion='SCO_CONTRA_INS')then
     v_id_repre:=(select id_representante from secont.representante where id_contratista=v_parametros.id_representante and estado_reg='activo');

     if(v_id_repre is null)then
                   raise exception 'No existe representante legal para el contratista';
     end if;
     
          BEGIN
          
               insert into secont.contrato(id_representante,
                                           id_empleado,
                                           id_proyecto,
                                           emp_id_empleado,
                                           numero,
                                           objeto,
                                           gerencia,
                                           moneda,
                                           monto_cifra,
                                           multas,
                                           forma_pago,
                                           origen_recursos,
                                           fecha_ini,
                                           fecha_fin,
                                           forma_contratacion,
                                           tipo_contrato,
                                           doc_contrato,
                                           numero_licitacion,
                                           numero_cuce,
                                           lugar_sus,
                                           fecha_sus,
                                           obs,
                                           intermediario,
                                           estado_reg,
                                           beneficiario,
                                           id_requerimiento
                                           )
               values(v_id_repre,
                                           
                                           v_parametros.emp_id_empleado,
                                           v_parametros.id_proyecto,
                                           v_parametros.emp_id_empleado,
                                           v_parametros.numero,
                                           v_parametros.objeto,
                                           v_parametros.gerencia,
                                           v_parametros.moneda,
                                           v_parametros.monto_cifra,
                                           v_parametros.multas,
                                           v_parametros.forma_pago,
                                           v_parametros.origen_recursos,
                                           v_parametros.fecha_ini,
                                           v_parametros.fecha_fin,
                                           v_parametros.forma_contratacion,
                                           v_parametros.tipo_contrato,
                                           v_parametros.doc_contrato,
                                           v_parametros.numero_licitacion,
                                           v_parametros.numero_cuce,
                                           v_parametros.lugar_sus,
                                           v_parametros.fecha_sus,
                                           v_parametros.obs,
                                           v_parametros.intermediario,
                                           'activo',
                                           v_parametros.beneficiario,
                                           v_parametros.id_requerimiento);

               update secont.requerimiento set num_contrato=v_parametros.numero
               where id_requerimiento=v_parametros.id_requerimiento;

               return 'Contrato insertado con exito';
         END;

     elsif(par_transaccion='SCO_CONTRA_MOD')then

          --consulta:=';
          BEGIN
          
           v_id_repre:=(select id_representante from secont.representante where id_contratista=v_parametros.id_representante and estado_reg='activo');

     if(v_id_repre is null)then
                   raise exception 'No existe representante legal para el contratista';
     end if;

               update secont.contrato set
                      id_representante=v_id_repre,
                      id_empleado     =v_parametros.id_empleado,
                      id_proyecto     =v_parametros.id_proyecto,
                      emp_id_empleado =v_parametros.emp_id_empleado,
                      numero          =v_parametros.numero,
                      objeto          =v_parametros.objeto,
                      gerencia        =v_parametros.gerencia,
                      moneda          =v_parametros.moneda,
                      monto_cifra     =v_parametros.monto_cifra,
                      multas          =v_parametros.multas,
                      forma_pago      =v_parametros.forma_pago,
                      origen_recursos =v_parametros.origen_recursos,
                      fecha_ini       =v_parametros.fecha_ini,
                      fecha_fin       =v_parametros.fecha_fin,
                      forma_contratacion=v_parametros.forma_contratacion,
                      tipo_contrato   =v_parametros.tipo_contrato,
                      doc_contrato    =v_parametros.doc_contrato,
                      numero_licitacion=v_parametros.numero_licitacion,
                      numero_cuce     =v_parametros.numero_cuce,
                      lugar_sus       =v_parametros.lugar_sus,
                      fecha_sus       =v_parametros.fecha_sus,
                      obs             =v_parametros.obs,
                      intermediario   =v_parametros.intermediario,
                      beneficiario    =v_parametros.beneficiario,
                      id_requerimiento=v_parametros.id_requerimiento
               where id_contrato=v_parametros.id_contrato;

               update secont.requerimiento set num_contrato=v_parametros.numero
               where id_requerimiento=v_parametros.id_requerimiento;
               
               return 'Contrato modificado con exito';
          END;

    elsif(par_transaccion='SCO_CONTRA_ELI')then

          --consulta:=';
          BEGIN
               update secont.contrato
               set estado_reg='inactivo'
               where id_contrato=v_parametros.id_contrato;

               return 'Contrato eliminado con exito';
         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1745 (class 1255 OID 208261)
-- Dependencies: 19 3246
-- Name: f_t_contrato_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_contrato_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_contrato_sel';


     if(par_transaccion='SCO_CONTRA_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select c.id_contrato,
                                   c.id_representante,
                                   c.id_empleado,
                                   c.id_proyecto,
                                   c.emp_id_empleado,
                                   c.numero,
                                   c.objeto,
                                   c.gerencia,
                                   c.moneda,
                                   c.monto_cifra,
                                   c.multas,
                                   c.forma_pago,
                                   c.origen_recursos,
                                   c.fecha_ini,
                                   c.fecha_fin,
                                   c.forma_contratacion,
                                   c.tipo_contrato,
                                   c.doc_contrato,
                                   c.numero_licitacion,
                                   c.numero_cuce,
                                   c.lugar_sus,
                                   c.fecha_sus,
                                   c.obs,
                                   c.intermediario,
                                   c.estado_reg,
                                   c.beneficiario,
                                   c.id_requerimiento ,
                                   con.nombre as contratista,
                                   abo.nombre_completo1 as abogado,
                                   p.denominacion as proyecto,
                                   resp_contrata.nombre_completo1 as resp_contratacion,
                                   req.descripcion as requerimiento
               from secont.contrato c
                                   inner join secont.v_empleado abo
                                   on abo.id_personal=c.id_empleado
                                   and abo.estado_reg=''activo''
                                   inner join secont.proyecto p
                                   on p.id_proyecto=c.id_proyecto
                                   and p.estado_reg=''activo''
                                   inner join secont.representante r
                                   on r.id_representante=c.id_representante
                                   and r.estado_reg=''activo''
                                   inner join secont.v_contratista con
                                   on con.id_contratista=r.id_contratista
                                   and con.estado_reg=''activo''
                                   inner join secont.v_empleado resp_contrata
                                   on resp_contrata.id_personal=c.emp_id_empleado
                                   and resp_contrata.estado_reg=''activo''
                                   inner join secont.v_requerimiento req
                                   on req.id_requerimiento=c.id_requerimiento
                                   and req.estado_reg=''activo''
                                   where c.estado_reg=''activo''
                                   and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_CONTRA_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(c.id_contrato)
                            from secont.contrato c
                            inner join secont.v_empleado abo
                            on abo.id_personal=c.id_empleado
                            and abo.estado_reg=''activo''
                            inner join secont.proyecto p
                            on p.id_proyecto=c.id_proyecto
                            and p.estado_reg=''activo''
                            inner join secont.representante r
                            on r.id_representante=c.id_representante
                            and r.estado_reg=''activo''
                            inner join secont.v_contratista con
                            on con.id_contratista=r.id_contratista
                            and con.estado_reg=''activo''
                            inner join secont.v_empleado resp_contrata
                            on resp_contrata.id_personal=c.emp_id_empleado
                            and resp_contrata.estado_reg=''activo''
                            inner join secont.v_requerimiento req
                            on req.id_requerimiento=c.id_requerimiento
                            and req.estado_reg=''activo''
                            where c.estado_reg=''activo''
                            and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1746 (class 1255 OID 208262)
-- Dependencies: 19 3246
-- Name: f_t_empleado_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_empleado_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;


/*

  id_personal
  id_persona
  id_unidad
  cod_empleado
  oficina
  regional
  gerencia
  cargo
  obs
  estado_reg

*/

BEGIN

     v_nombre_funcion:='secont.f_t_empleado_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_EMPLEA_INS')then

          --consulta:=';
          BEGIN

               
               
               insert into secont.empleado (id_persona,id_unidad,cod_empleado,oficina,regional,gerencia,
               cargo,obs,estado_reg)
               values(v_parametros.id_persona,v_parametros.id_unidad,v_parametros.cod_empleado,v_parametros.oficina,
               v_parametros.regional,v_parametros.gerencia,v_parametros.cargo,v_parametros.obs,'activo');
               
               return 'Empleado insertado con exito';

         END;

     elsif(par_transaccion='SCO_EMPLEA_MOD')then

          --consulta:=';
          BEGIN

               update secont.empleado set id_persona=v_parametros.id_persona,
               id_unidad=v_parametros.id_unidad,
               cod_empleado=v_parametros.cod_empleado,
               oficina=v_parametros.oficina,
               regional=v_parametros.regional,
               gerencia=v_parametros.gerencia,
               cargo=v_parametros.cargo,
               obs=v_parametros.obs
               where id_personal=v_parametros.id_personal;
               return 'Empleado modificado con exito';
          END;

    elsif(par_transaccion='SCO_EMPLEA_ELI')then

          --consulta:=';
          BEGIN
               update secont.empleado set estado_reg='inactivo'
               where id_personal=v_parametros.id_personal;
               return 'Empleado eliminado con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1747 (class 1255 OID 208263)
-- Dependencies: 19 3246
-- Name: f_t_empleado_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_empleado_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_empleado_sel';


     if(par_transaccion='SCO_EMPLEA_SEL')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select id_persona,
                            ap_materno,
                            ap_paterno,
                                nombre,
                                    ci,
                            id_personal,
                            cod_empleado,
                                    cargo,
                                estado_reg,
                                gerencia,
                                oficina,
                                regional,
                                    obs,
                        nombre_completo1,
                        nombre_completo2,
                        id_unidad,
                        nombre_unidad
                        from secont.v_empleado e where estado_reg=''activo'' and ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(par_transaccion='SCO_EMPLEA_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(e.id_personal) from secont.v_empleado e where estado_reg=''activo'' and  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1748 (class 1255 OID 208264)
-- Dependencies: 19 3246
-- Name: f_t_estado_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_estado_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;


/*

 id_unidad 
 cod_unidad 
 nombre_unidad 
 gerencia_unidad 
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='secont.f_t_estado_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_ESTADO_INS')then

          --consulta:=';
          BEGIN

               
               
               insert into secont.estado (nombre_estado,desc_estado,orden,rango_inf,rango_sup,estado_reg)
               values(v_parametros.nombre_estado,v_parametros.desc_estado,v_parametros.orden,
               v_parametros.rango_inf,v_parametros.rango_sup,'activo');
               
               return 'Estado insertado con exito';

         END;

     elsif(par_transaccion='SCO_ESTADO_MOD')then

          --consulta:=';
          BEGIN
                
               update secont.estado set nombre_estado=v_parametros.nombre_estado,
               desc_estado=v_parametros.desc_estado,
               orden=v_parametros.orden,
               rango_inf=v_parametros.rango_inf,
               rango_sup=v_parametros.rango_sup
               
               where id_estado=v_parametros.id_estado;
               return 'Estado modificado con exito';
          END;

    elsif(par_transaccion='SCO_ESTADO_ELI')then

          --consulta:=';
          BEGIN
               update secont.estado set estado_reg='inactivo'
               where id_estado=v_parametros.id_estado;
               return 'Estado eliminada con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1749 (class 1255 OID 208265)
-- Dependencies: 19 3246
-- Name: f_t_estado_requerimiento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_estado_requerimiento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_estado_requerimiento_sel';


     if(par_transaccion='SCO_REPHIS_SEL')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select *
               from secont.v_estado_requerimiento er where ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1752 (class 1255 OID 208266)
-- Dependencies: 19 3246
-- Name: f_t_estado_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_estado_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_estado_sel';


     if(par_transaccion='SCO_ESTADO_SEL')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select * from secont.estado e where e.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
              
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_ESTADO_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(e.id_estado) from secont.estado e where estado_reg=''activo'' and  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1753 (class 1255 OID 208267)
-- Dependencies: 19 3246
-- Name: f_t_garantia_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_garantia_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;


/*

  id_garantia
  id_contrato
  tipo
  numero
  orden
  moneda
  monto_cifra
  fecha_vencimiento
  banco
  fecha_sus
  lugar_suc
  obs
  doc_garantia
  estado_reg

*/

BEGIN

     v_nombre_funcion:='secont.f_t_garantia_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_REQUER_INS')then

          --consulta:=';
          BEGIN

               
               
               insert into secont.garantia (id_contrato,tipo,numero,orden,moneda,monto_cifra,
               fecha_vencimiento,banco,fecha_sus,lugar_suc,obs,doc_garantia,estado_reg)
               values(v_parametros.id_contrato,v_parametros.tipo,v_parametros.numero,v_parametros.orden,v_parametros.moneda,
               v_parametros.monto_cifra,v_parametros.fecha_vencimiento,v_parametros.banco,v_parametros.fecha_sus,
               v_parametros.lugar_suc,v_parametros.obs,v_parametros.doc_garantia,'activo');
               
               return 'Garantia insertada con exito';

         END;

     elsif(par_transaccion='SCO_REQUER_MOD')then

          --consulta:=';
          BEGIN

               update secont.garantia set
               tipo=v_parametros.tipo,
               numero=v_parametros.numero,
               orden=v_parametros.orden,
               moneda=v_parametros.moneda,
               monto_cifra=v_parametros.monto_cifra,
               fecha_vencimiento=v_parametros.fecha_vencimiento,
               banco=v_parametros.banco,
               fecha_sus=v_parametros.fecha_sus,
               lugar_suc=v_parametros.lugar_suc,
               obs=v_parametros.obs,
               doc_garantia=v_parametros.doc_garantia
               where id_garantia=v_parametros.id_garantia;
               return 'Garantia modificada con exito';
          END;

    elsif(par_transaccion='SCO_REQUER_ELI')then

          --consulta:=';
          BEGIN
               update secont.garantia set estado_reg='inactivo'
               where id_garantia=v_parametros.id_garantia;
               return 'Garantia eliminada con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1754 (class 1255 OID 208268)
-- Dependencies: 19 3246
-- Name: f_t_garantia_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_garantia_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_garantia_sel';


     if(par_transaccion='SCO_GARANTIA_SEL')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select g.id_garantia,g.id_contrato,
                                    g.tipo,g.numero,
                                    g.orden,g.moneda,g.monto_cifra,
                                    g.fecha_vencimiento,g_banco,g.fecha_sus,g.obs,c.numero
                                    from secont.garantia g
                                    inner join secont.contrato c on(c.id_contrato=g.id_contrato)
                                    where estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta|| ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_GARANTIA_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(g.id_garantia) from secont.garantia g
                                    inner join secont.contrato c on(c.id_contrato=g.id_contrato)
                                    where estado_reg=''activo'' and  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1755 (class 1255 OID 208269)
-- Dependencies: 19 3246
-- Name: f_t_persona_juridica_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_persona_juridica_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;


/*

 id_persona_juridica
 nombre
 domicilio
 telefono
 correo
 pag_web
 obs
 estado_reg
*/

BEGIN

     v_nombre_funcion:='secont.f_t_persona_juridica_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_PERJUR_INS')then

          --consulta:=';
          BEGIN

               
               
               insert into secont.persona_juridica (nombre,domicilio,telefono,correo,pag_web,obs,estado_reg)
               values(v_parametros.nombre,v_parametros.domicilio,v_parametros.telefono,v_parametros.correo,v_parametros.pag_web,v_parametros.obs,'activo');
               
               return 'Persona Juridica insertada con exito';

         END;

     elsif(par_transaccion='SCO_PERJUR_MOD')then

          --consulta:=';
          BEGIN

               update secont.persona_juridica set nombre=v_parametros.nombre,
               domicilio=v_parametros.domicilio,
               telefono=v_parametros.telefono,
               correo=v_parametros.correo,
               pag_web=v_parametros.pag_web,
               obs=v_parametros.obs
               where id_persona_juridica=v_parametros.id_persona_juridica;
               return 'Persona Juridica modificada con exito';
          END;

    elsif(par_transaccion='SCO_PERJUR_ELI')then

          --consulta:=';
          BEGIN
               update secont.persona_juridica set estado_reg='inactivo'
               where id_persona_juridica=v_parametros.id_persona_juridica;
               return 'Persona Juridica eliminada con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1756 (class 1255 OID 208270)
-- Dependencies: 19 3246
-- Name: f_t_persona_juridica_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_persona_juridica_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_persona_juridica_sel';


     if(par_transaccion='SCO_PERJUR_SEL')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select * from secont.persona_juridica pj where estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta || ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_PERJUR_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(pj.id_persona_juridica) from secont.persona_juridica pj where estado_reg=''activo'' and  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1757 (class 1255 OID 208271)
-- Dependencies: 19 3246
-- Name: f_t_proyecto_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_proyecto_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

    v_nro_requerimiento    	integer;
    v_parametros           	record;
    v_id_requerimiento     	integer;
    v_resp		            varchar;
    v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_proyecto			integer;


/*

 id_proyecto
 denominacion 
 descripcion
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='secont.f_t_proyecto_ime';
     v_parametros:=f_get_record(p_tabla);

     if(p_transaccion='SCO_PROYEC_INS')then

          --consulta:=';
          BEGIN
				
               v_id_proyecto = nextval('secont.proyecto_id_proyecto_seq'::regclass);
               
               insert into secont.proyecto (id_proyecto,denominacion,descripcion,estado_reg)
               values(v_id_proyecto,v_parametros.denominacion,v_parametros.descripcion,'activo');
               
               --v_mensaje_error = f1();

			   v_resp = f_agrega_clave(v_resp,'mensaje','Proyecto almacenado'); 
               v_resp = f_agrega_clave(v_resp,'id_proyecto',v_id_proyecto::varchar);

               return v_resp;

         END;

     elsif(p_transaccion='SCO_PROYEC_MOD')then

          BEGIN
				v_id_proyecto = 3/0;
               update secont.proyecto set denominacion=v_parametros.denominacion,
               descripcion=v_parametros.descripcion
               where id_proyecto=v_parametros.id_proyecto;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Proyecto modificado'); 
               v_resp = f_agrega_clave(v_resp,'id_proyecto',v_parametros.id_proyecto::varchar);
               
               return v_resp;
          END;

    elsif(p_transaccion='SCO_PROYEC_ELI')then

          --consulta:=';
          BEGIN
               --raise exception 'Error al eliminar';
               update secont.proyecto set estado_reg='inactivo'
               where id_proyecto=v_parametros.id_proyecto;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Proyecto eliminado'); 
               v_resp = f_agrega_clave(v_resp,'id_proyecto',v_parametros.id_proyecto::varchar);
              
               return v_resp;
         END;
         
     else
     
         raise exception 'Transacción inexistente: %',p_transaccion;

     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1758 (class 1255 OID 208272)
-- Dependencies: 19 3246
-- Name: f_t_proyecto_ime_orig(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_proyecto_ime_orig(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;


/*

 id_proyecto
 denominacion 
 descripcion
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='secont.f_t_proyecto_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_PROYEC_INS')then

          --consulta:=';
          BEGIN

               
               
               insert into secont.proyecto (denominacion,descripcion,estado_reg)
               values(v_parametros.denominacion,v_parametros.descripcion,'activo');
               
               return 'Proyecto insertada con exito';

         END;

     elsif(par_transaccion='SCO_PROYEC_MOD')then

          --consulta:=';
          BEGIN

               update secont.proyecto set denominacion=v_parametros.denominacion,
               descripcion=v_parametros.descripcion
               where id_proyecto=v_parametros.id_proyecto;
               return 'Proyecto modificada con exito';
          END;

    elsif(par_transaccion='SCO_PROYEC_ELI')then

          --consulta:=';
          BEGIN
               --raise exception 'Error al eliminar';
               update secont.proyecto set estado_reg='inactivo'
               where id_proyecto=v_parametros.id_proyecto;
               return 'Proyecto eliminada con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1759 (class 1255 OID 208273)
-- Dependencies: 19 3246
-- Name: f_t_proyecto_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_proyecto_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_proyecto_sel';


     if(par_transaccion='SCO_PROYEC_SEL')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select * from secont.proyecto p where estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_PROYEC_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(p.id_proyecto) from secont.proyecto p where estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1750 (class 1255 OID 208274)
-- Dependencies: 19 3246
-- Name: f_t_representante_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_representante_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;


/*

 id_unidad 
 cod_unidad 
 nombre_unidad 
 gerencia_unidad 
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='secont.f_t_representante_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_REPRES_INS')then

          --consulta:=';
          BEGIN

               
               
               insert into secont.representante (id_contratista,cargo,respaldo,estado_reg,obs,id_persona)
               values(v_parametros.id_contratista,v_parametros.cargo,v_parametros.respaldo,
               'activo',v_parametros.obs,v_parametros.id_persona);
               
               return 'Representante insertado con exito';

         END;

     elsif(par_transaccion='SCO_REPRES_MOD')then

          --consulta:=';
          BEGIN

               update secont.representante set cargo=v_parametros.cargo,
               respaldo=v_parametros.respaldo,
               obs=v_parametros.obs,
               id_persona=v_parametros.id_persona
               where id_representante=v_parametros.id_representante;
               return 'Representante modificado con exito';
          END;

    elsif(par_transaccion='SCO_REPRES_ELI')then

          --consulta:=';
          BEGIN
               update secont.representante set estado_reg='inactivo'
               where id_representante=v_parametros.id_representante;
               return 'Representante eliminado con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1751 (class 1255 OID 208275)
-- Dependencies: 19 3246
-- Name: f_t_representante_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_representante_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_representante_sel';


     if(par_transaccion='SCO_REPRES_SEL')then

          --consulta:=';
          BEGIN
               --raise exception 'llega';
               v_consulta:=' select r.id_representante,
                             r.id_contratista,r.cargo,
                             r.respaldo,r.obs,
                             r.id_persona,
                             p.ci,
                             p.nombre_completo1,
                             c.nombre
                             from secont.representante r inner join segu.v_persona p on(r.id_persona=p.id_persona)
                             inner join secont.v_contratista c on (r.id_contratista=c.id_contratista)
                             where r.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_REPRES_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(r.id_representante)
               from secont.representante r inner join segu.v_persona p on(r.id_persona=p.id_persona)
               inner join secont.v_contratista c on (r.id_contratista=c.id_contratista)
               where r.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opción';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1760 (class 1255 OID 208276)
-- Dependencies: 19 3246
-- Name: f_t_requerimiento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_requerimiento_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_id_personal          integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_nro_contrato              numeric;


/*

id_requerimiento
id_personal
emp_id_personal
fecha_requerimiento
hora_requerimiento
descripcion
estado_reg
num_contrato
id_unidad
nro_requerimiento

*/

BEGIN

     v_nombre_funcion:='secont.f_t_requerimiento_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_REQUER_INS')then

          --consulta:=';
          BEGIN
               select id_personal into v_id_personal from secont.v_empleado
               where id_persona=(select id_persona from segu.usuario where id_usuario=par_id_usuario);
               if(v_id_personal is null)then
                                raise exception 'El usuario que registra el requerimiento no es empleado';
               end if;

               v_nro_requerimiento:=(select coalesce(max(nro_requerimiento),0) from secont.requerimiento
               where id_unidad=v_parametros.id_unidad)::integer;
               v_nro_requerimiento=v_nro_requerimiento+1;
               v_id_requerimiento:=(select nextval('secont.requerimiento_id_requerimiento_seq'));
               --raise exception '%',v_nro_requerimiento;
               insert into secont.requerimiento (id_requerimiento,id_personal,fecha_requerimiento,hora_requerimiento,
               descripcion,estado_reg,id_unidad,nro_requerimiento)
               values(v_id_requerimiento,v_id_personal,now()::date,now()::time,v_parametros.descripcion,
               'activo',v_parametros.id_unidad,v_nro_requerimiento);
               
               insert into secont.estado_requerimiento (id_requerimiento,id_estado,fecha_ini,estado_reg,observaciones)
               values(v_id_requerimiento,0,now(),'activo','Primer estado del requerimiento');
               
               return 'Requerimiento insertado con exito';

         END;

     elsif(par_transaccion='SCO_REQUER_MOD')then

          --consulta:=';
          BEGIN

               update secont.requerimiento set descripcion=v_parametros.descripcion,
               id_unidad=v_parametros.id_unidad
               
               where id_requerimiento=v_parametros.id_requerimiento;
               return 'Requerimiento modificado con exito';
          END;

     elsif(par_transaccion='SCO_RESIEST_MOD')then

          --consulta:=';
          BEGIN
               
               update secont.requerimiento set
               emp_id_personal=v_parametros.emp_id_personal
               where id_requerimiento=v_parametros.id_requerimiento;
               
               v_respuesta:=secont.f_cambiar_estado_requerimiento('siguiente',v_parametros.id_requerimiento,v_parametros.observaciones);
                
               return 'Estado cambiado con exito para el requerimiento';

         END;

     elsif(par_transaccion='SCO_RESIASI_MOD')then

          --consulta:=';
          BEGIN
          
               update secont.requerimiento set emp_id_personal=v_parametros.emp_id_personal
               where id_requerimiento=parametros.id_requerimiento;
               
               v_respuesta:=secont.f_cambiar_estado_requerimiento('siguiente',v_parametros.id_requerimiento,v_parametros.observaciones);
               return 'Estado cambiado con exito para el requerimiento: %',v_parametros.id_requerimiento;

         END;

     elsif(par_transaccion='SCO_REANEST_MOD')then

          --consulta:=';
          BEGIN
               v_respuesta:=secont.f_cambiar_estado_requerimiento('anterior',v_parametros.id_requerimiento,v_parametros.observaciones);
               return 'Estado cambiado con exito para el requerimeinto: %',v_parametros.id_requerimiento;

         END;

     elsif(par_transaccion='SCO_REQUER_ELI')then

          --consulta:=';
          BEGIN
               update secont.requerimiento set estado_reg='inactivo'
               where id_requerimiento=v_parametros.id_requerimiento;
               return 'Requerimiento eliminado con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1761 (class 1255 OID 208277)
-- Dependencies: 19 3246
-- Name: f_t_requerimiento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_requerimiento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_id_persona       integer;
v_cargo            varchar;

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_primo_sel';
    
     
     if(par_transaccion='SCO_REQSEG_SEL')then

          --consulta:=';
          BEGIN
               select id_persona into v_id_persona  from segu.usuario where id_usuario=par_id_usuario;
               select e.cargo into v_cargo from secont.empleado e where id_persona=v_id_persona and estado_reg='activo';
               v_consulta:='select * from secont.v_requerimiento r where estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;

               if(par_administrador!=1 and v_cargo!='Jefe Departamento Legal')then
                   v_consulta:=v_consulta||' and (r.id_unidad in (select id_unidad from secont.empleado e on (e.id_persona='|| v_id_persona ||' and e.estado_reg=''activo''))
                   or r.id_persona_abo='||v_id_persona||')';
               end if;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_REQSEG_CONT')then

          --consulta:=';
          BEGIN
               select id_persona into v_id_persona  from segu.usuario where id_usuario=par_id_usuario;
               select e.cargo into v_cargo from secont.empleado e where id_persona=v_id_persona and estado_reg='activo';
               v_consulta:='select count(r.id_requerimiento) from secont.v_requerimiento r where estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;

               if(par_administrador!=1 and v_cargo!='Jefe Departamento Legal')then
                    v_consulta:=v_consulta||' and (r.id_unidad in (select id_unidad from secont.empleado e on (e.id_persona='|| v_id_persona ||' and e.estado_reg=''activo''))
                   or r.id_persona_abo='||v_id_persona||')';
               end if;
               return v_consulta;


         END;

     else
         raise exception 'No existe la transaccion: %',par_transaccion;

     end if;
     
EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1762 (class 1255 OID 208278)
-- Dependencies: 19 3246
-- Name: f_t_unidad_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_unidad_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;


/*

 id_unidad 
 cod_unidad 
 nombre_unidad 
 gerencia_unidad 
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='secont.f_t_unidad_ime';
     v_parametros:=f_get_record(par_tabla);

     if(par_transaccion='SCO_UNIDAD_INS')then

          --consulta:=';
          BEGIN

               
               
               insert into secont.unidad (cod_unidad,nombre_unidad,gerencia_unidad,estado_reg)
               values(v_parametros.cod_unidad,v_parametros.nombre_unidad,v_parametros.gerencia_unidad,'activo');
               
               return 'Unidad insertada con exito';

         END;

     elsif(par_transaccion='SCO_UNIDAD_MOD')then

          --consulta:=';
          BEGIN

               update secont.unidad set cod_unidad=v_parametros.cod_unidad,
               nombre_unidad=v_parametros.nombre_unidad,
               gerencia_unidad=v_parametros.gerencia_unidad
               where id_unidad=v_parametros.id_unidad;
               return 'Unidad modificada con exito';
          END;

    elsif(par_transaccion='SCO_UNIDAD_ELI')then

          --consulta:=';
          BEGIN
               update secont.unidad set estado_reg='inactivo'
               where id_unidad=v_parametros.id_unidad;
               return 'Unidad eliminada con exito';
         END;
         
     else
     
         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1763 (class 1255 OID 208279)
-- Dependencies: 19 3246
-- Name: f_t_unidad_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION f_t_unidad_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_unidad_sel';


     if(par_transaccion='SCO_UNIDAD_SEL')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select * from secont.unidad u where estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta || ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;


         END;


     elsif(par_transaccion='SCO_UNIDAD_CONT')then

          --consulta:=';
          BEGIN
               
               v_consulta:='select count(u.id_unidad) from secont.unidad u where estado_reg=''activo'' and  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1764 (class 1255 OID 208280)
-- Dependencies: 19 3246
-- Name: funcion1(); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION funcion1() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare


begin

raise exception 'veremos q pasa';


EXCEPTION
       
       WHEN OTHERS THEN
         --DBMS_OUTPUT.PUT_LINE("Error, abortando ejecucin.");
         raise exception '%,%',  SQLERRM,SQLSTATE;
         
     

end;
$$;


--
-- TOC entry 1765 (class 1255 OID 208281)
-- Dependencies: 19 3246
-- Name: prueba(); Type: FUNCTION; Schema: secont; Owner: -
--

CREATE FUNCTION prueba() RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$
DECLARE
	v varchar[];
    
BEGIN

	--v=array_append(v,f_forma_array('mensaje','Funcion ejecutada con exito'));
    --v=array_append(v,f_forma_array('id_clardad','12'));
    v=f_resp_array(v,'mensaje','Funcion ejecutada con exito');
    v=f_resp_array(v,'id_clardad','12');
    v=f_resp_array(v,'tipo','CEFALO');
    
--v[1][1]='adas';
--v[2][1]='sss';
--v[2]='CCC';
--v[1][2]='xxxx';
	--v='zxkczlkchzklhchhxzkxz';--'{{mensaje,todobien}'||',{id_col,5}}';
    /*v[0:0]='mensaje';
    v[0:1]='todovabien';
    v[1:0]='id_colasd';
    v[1:1]='123';*/
    
    --v=ARRAY[['mensaje','todovabien']['id_colasd','123']];
    
    return v;
END;
$$;


SET search_path = segu, pg_catalog;

--
-- TOC entry 1766 (class 1255 OID 208282)
-- Dependencies: 20 3246
-- Name: f_actualiza_persona_entre_bd(); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION f_actualiza_persona_entre_bd() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_nombre_bd       varchar;
    v_nombre_usuario  varchar;
    v_id_usuario      integer;
    g_consulta        varchar;  
    v_id_tipo_doc     integer;
BEGIN
    
                     
    v_id_usuario:=1;


   SELECT P.id_tipo_doc_identificacion    into v_id_tipo_doc
   FROM dblink('hostaddr=10.172.0.13 port=5432 dbname=dbendesis user=db_link password=db_link',
                                             'select id_tipo_doc_identificacion from sss.tsg_tipo_doc_identificacion where nombre_tipo_documento ilike ''ci'' ') AS P(
                                                                                  "id_tipo_doc_identificacion" integer);   
   
 
                   
        IF TG_OP = 'INSERT' THEN
            BEGIN
                     
                 /*  if not exists (select P.id_persona from dblink('hostaddr=10.172.0.13 port=5432 dbname=dbendesis user=db_link password=db_link',
                                             'SELECT id_persona
                                               FROM sss.tsg_persona where id_persona='|| new.id_persona) AS P(
                                                                                 id_persona integer) ) then
                   raise exception 'en otra bd... cobra';
                          perform dblink_connect('hostaddr=10.172.0.13 port=5432 dbname=dbendesis user=db_link password=db_link');
                       --   perform dblink_exec ('LOCK TABLE sss.tsg_persona in SHARE ROW EXCLUSIVE MODE');        
                          perform dblink_exec('insert into sss.tsg_persona(id_persona , nombre , apellido_paterno
                                  
                                  , apellido_materno   
                                  ,doc_id, email1 , celular1 , telefono1, telefono2,celular2, extension,  genero
                                  , fecha_nacimiento, direccion     
                                  
                                  , id_tipo_doc_identificacion        
                                  )
                                  values ('||new.id_persona||','''||NEW.nombre||''','''||NEW.apellido_paterno||'''
                                   ,'''||NEW.apellido_materno||''' 
                                  ,'''||coalesce(new.ci,'')||''' ,'''||coalesce(new.correo,'')||''' ,'''||coalesce(new.celular1,'')||'''
                                   ,'''||coalesce(new.telefono1,'')||''','''||coalesce(new.telefono2,'')||''' ,'''||coalesce(new.celular2,'')||''',
                                  '''||coalesce(new.extension,'')||''','''||f_iif(NEW.genero='m','varon','mujer')||''' 
                                  
                                 ,'''||coalesce(new.fecha_nacimiento,now()::date)||''',
                                  '''||coalesce(new.direccion,'')||'''
                                  , '||coalesce(v_id_tipo_doc,'1')||'     
                                            
                                  
                                  );
                                   '); 
         
                          perform dblink_disconnect();  
                    end if;    */
            end;
       /* ELSEIF TG_OP='UPDATE' THEN
               BEGIN            
                   perform dblink_connect('hostaddr=10.172.0.11 port=5432 dbname=dbendesis_cobra user=db_link password=db_link');
                   perform dblink_exec('update segu.tpersona set 
                   nombre='''||new.nombre||''' , 
                   apellido_paterno='''||new.apellido_paterno||''', 
                   apellido_materno='''||coalesce(new.apellido_materno,'')||''',
                   ci='''||coalesce(new.doc_id,'')||''', 
                   correo='''||coalesce(new.email1,'')||''' , 
                   celular1= '''||coalesce(new.celular1,'0')||''', 
                   telefono1='''||coalesce(new.telefono1,'0')||''', 
                   telefono2= '''||coalesce(new.telefono2,'0')||''',
                   celular2='''||coalesce(new.celular2,'0')||''', 
                   extension='''||coalesce(new.extension,'')||''',  
                   genero= '''||f_iif(NEW.genero='varon','m','f')||'''   , 
                   fecha_nacimiento='''||coalesce(new.fecha_nacimiento,now()::date)||''', 
                   direccion='''||coalesce(new.direccion,'')||'''
                   where id_persona='||old.id_persona||';' ); 

                   --perform dblink_exec('insert into product_product(product_tmpl_id) values (currval(''product_template_id_seq''::regclass));');
                   perform dblink_disconnect();  
               END;
        ELSIF TG_OP='DELETE' THEN
               BEGIN           
                   perform dblink_connect('hostaddr=10.172.0.13 port=5432 dbname=dbendesis user=db_link password=db_link');   
                   perform dblink_exec('delete from sss.tsg_persona where id_persona='|| OLD.id_persona||';');
                   perform dblink_disconnect();
                   
               END;  */
        END IF;     
        
RETURN NEW;
            
            
              
  RETURN NULL;
END;
$$;


--
-- TOC entry 1770 (class 1255 OID 208283)
-- Dependencies: 20 3246
-- Name: f_actualizar_log_bd(character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION f_actualizar_log_bd(par_url_log character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.f_actualizar_log_bd
 DESCRIPCION: 	Actualiza la tabla log a partir de los logs del
                motor de bd
 AUTOR: 		KPLIAN(jrr)
 FECHA:			08/03/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/
DECLARE
    v_registros       record;
    v_nombre_funcion  varchar;
    v_resp            varchar;
    v_fecha_actual    date;
    v_fecha_max_log   timestamp;
    v_fecha_min_tt    timestamp;
    v_tipo_log        varchar;
    v_consulta        varchar;
BEGIN
    v_nombre_funcion:='segu.f_actualizar_log_bd';

    select max(l.fecha_reg)
    into v_fecha_max_log
    from segu.tlog l
    where l.tipo_log='LOG_BD' or l.tipo_log='ERROR_BD';
    
    v_fecha_actual=now();
    
    execute ('
    create temporary table tt_log_bd(
        fecha_hora timestamp(3) with time zone, usuario text, bd text,  pid integer,
        ip_puerto text, id_sesion text, numero_accion bigint,
        etiqueta_comando text,fecha_hora_sesion timestamp with time zone,
        id_transaccion_vir text, id_transaccion_regu bigint,tipo_log varchar,
        codigo_error varchar, mensaje text, detalle_mensaje text,
        sugerencia text, consulta_interna_error text,
        carac_pos_error integer, error_context text,
        consulta_error text, cantidad_carac_pos_error integer,
        ubicacion text,
        nombre_aplicacion text) on commit drop');
    
    execute ('
    COPY tt_log_bd
    FROM '''||par_url_log||'-'||to_char(v_fecha_actual,'YYYY-MM-DD')||'.csv''
    WITH csv;');
    
    select min(fecha_hora)
    into v_fecha_min_tt
    from tt_log_bd;
    
    while(v_fecha_max_log is not null and v_fecha_min_tt is not null and v_fecha_min_tt>v_fecha_max_log)loop
        execute ('
        COPY tt_log_bd
        FROM '''||par_url_log||'-'||to_char(v_fecha_actual-interval '1 day','YYYY-MM-DD')||'.csv''
        WITH csv;');
        
        select min(fecha_hora)
        into v_fecha_min_tt
        from tt_log_bd;
        
    end loop;
    
    for v_registros in
    (select *
    from tt_log_bd
    where v_fecha_max_log is null or date_trunc('second',fecha_hora)>v_fecha_max_log)loop
    
    if(current_database()::text=v_registros.bd and v_registros.codigo_error!='P0001')then
        if(v_registros.tipo_log='ERROR')then
            v_tipo_log='ERROR_BD';
            v_consulta=v_registros.consulta_error;
        else
            v_tipo_log='LOG_BD';
            v_consulta=v_registros.mensaje;
        end if;
    
    
        insert into segu.tlog(
            ip_maquina,tipo_log,descripcion,
            fecha_reg,estado_reg,procedimientos,
            transaccion,consulta,tiempo_ejecucion,
            usuario_base,codigo_error,
            dia_semana,
            pid_db,pid_web,sid_web,si_log
        ) values(
            v_registros.ip_puerto,v_tipo_log,v_registros.mensaje,
            v_registros.fecha_hora,'activo','base de datos',
            'ninguna',v_consulta,0,
            v_registros.usuario,v_registros.codigo_error,
            to_char(v_registros.fecha_hora,'D')::integer,
            v_registros.pid,0,v_registros.id_sesion,1
        );
    end if;
     
    
    
    end loop;

    return 'exito';

EXCEPTION

       WHEN OTHERS THEN

       	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%,%',v_resp,v_consulta;

END;
$$;


--
-- TOC entry 1771 (class 1255 OID 208284)
-- Dependencies: 20 3246
-- Name: f_actualizar_sesion(integer, character varying, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION f_actualizar_sesion(p_pid_bd integer, p_sid_web character varying, p_pid_web integer, p_transaccion character varying, p_procedimiento character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: 		segu.f_actualizar_log_bd
 DESCRIPCION: 	Actualiza llos datos de sesion del usuario cada vez que se realiza una
                transaccion
 AUTOR: 		KPLIAN(jrr)
 FECHA:			08/03/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/
DECLARE
    v_resp      varchar;
    v_nombre_funcion   text;
    v_mensaje_error    text;
BEGIN
    v_nombre_funcion:='segu.f_actualizar_sesion';
    
    update segu.tsesion
    set pid_bd=p_pid_bd,
    transaccion_actual=p_transaccion,
    funcion_actual=p_procedimiento
    where pid_web=p_pid_web and estado_reg='activo' and variable=p_sid_web;

    return 'exito';
EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1772 (class 1255 OID 208285)
-- Dependencies: 20 3246
-- Name: f_get_id_usuario(character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION f_get_id_usuario(v_cuenta character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: 		segu.f_get_id_usuario
 DESCRIPCION: 	recupera id de usuario apartir del nombre de cuenta
 AUTOR: 		KPLIAN(RAC)
 FECHA:			29/02/2011
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/
DECLARE
  v_id_usuario integer;
BEGIN
        select u.id_usuario
        into v_id_usuario
        from segu.tusuario u
        where u.cuenta=v_cuenta;
        
   RETURN v_id_usuario;


END;
$$;


--
-- TOC entry 1773 (class 1255 OID 208286)
-- Dependencies: 20 3246
-- Name: f_grant_all_privileges(text, text); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION f_grant_all_privileges(p_user text, p_esquema text) RETURNS void
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA ENDESIS - SISTEMA DE SSS
***************************************************************************
 SCRIPT: 		segu.f_grant_all_privileges
 DESCRIPCIÓN: 	Función para asignar todos los privilegios 
               objetos de esquema sobre un usuario o rol
 AUTOR: 		RAC
 FECHA:			29/02/2012
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE
   objeto record;
   v_record record;
   x	varchar;
   consulta varchar;
   v_conjunto_esquemas varchar;
BEGIN
   IF p_esquema = 'todos' THEN
      --listas esquemas
     v_conjunto_esquemas='';
      FOR v_record IN (select * from segu.tsubsistema) LOOP
             x=' GRANT ALL PRIVILEGES ON SCHEMA '||v_record.codigo||' TO "'||p_user||'"';
              RAISE NOTICE  '%',x;
              EXECUTE (x);              
              if(v_conjunto_esquemas='') THEN
	              v_conjunto_esquemas=''''|| lower(v_record.codigo)||'''';
              ELSE
                 v_conjunto_esquemas=v_conjunto_esquemas||','''||lower(v_record.codigo)||'''';
              END IF;
              
      END LOOP;
      
      
               consulta:= 'SELECT viewname as d , schemaname as c FROM pg_views WHERE schemaname IN ('||v_conjunto_esquemas||')
               UNION
               SELECT tablename as d, schemaname as c FROM pg_tables WHERE schemaname IN ('||v_conjunto_esquemas||')
               UNION
               SELECT relname as d, schemaname as c FROM pg_statio_all_sequences WHERE schemaname IN ('||v_conjunto_esquemas||')';

      
       
   ELSE
   
  
  
       x='GRANT ALL PRIVILEGES ON SCHEMA "'||p_esquema||'" TO "'||p_user'"';   
       RAISE NOTICE  '%',x;
       EXECUTE (x);
       
       
   consulta:= 'SELECT viewname as d, schemaname as c FROM pg_views WHERE schemaname='''||p_esquema||'''
               UNION
               SELECT tablename as d, schemaname as c FROM pg_tables WHERE schemaname='''||p_esquema||'''
               UNION
               SELECT relname as d, schemaname as c FROM pg_statio_all_sequences WHERE schemaname='''||p_esquema||'''';
   
   END IF;
    
    raise notice '%',consulta;

   FOR objeto IN   EXECUTE (consulta)   LOOP
    --  RAISE NOTICE 'Asignando todos los privilegios a % sobre %  en el esquema %', p_user, objeto.d, p_esquema;
      

       if((objeto.c||'.'||objeto.d) not in ('segu.tusuario','segu.tlog')
        
       ) THEN
       
         x= 'GRANT ALL PRIVILEGES ON  "'||objeto.c||'"."'|| objeto.d ||'"  TO "'||p_user||'"';
         RAISE NOTICE  '%',x;
         EXECUTE (x);
         
       ELSE
         raise notice '>>>>>>>>>>>>>>>>>>   Ingnorar %.%',objeto.c,objeto.d;
       END IF;
       
   END LOOP;
END;
$$;


--
-- TOC entry 1774 (class 1255 OID 208287)
-- Dependencies: 20 3246
-- Name: f_importar_menu(integer, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION f_importar_menu(p_id_gui integer, p_cadena_nonexion character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA ENDESIS - SISTEMA DE SSS
***************************************************************************
 SCRIPT: 		segu.f_importar_menu
 DESCRIPCIÓN: 	Esta funcion permite  importar el menu de otra base de datos

 AUTOR: 		RAC
 FECHA:			14/03/2012
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE
   objeto record;
   v_record record;
   x	varchar;
   consulta varchar;
   v_conjunto_esquemas varchar;
   v_sw integer;
   v_id_subsistema_equi integer;
   v_id_gui_equi integer;
   v_codigo varchar;
   v_id_subsistema integer;
   v_id_gui_padre_equi integer;
   v_id_procedimiento integer;
   v_id_procedimiento_gui integer;
   v_respuesta varchar;
   
   
BEGIN

    /*
     A) MIGRAR MENU
     
        1)  buscamos equivalencia del id_subsistema. 
            
        
        
        2)  crear tabla temporal de equivalencias
        3)  for para recorrer los resultados, 
            consulta con deblink toda la rama a partir del id del padre señalado
        
            3.1) si primer registro
             
             3.1.1 buscamos ei el codigo de gui ya existe recuperamos id
            
                 3.1.1.1)  insertar nuevo gui  y salvar id 
                 3.1.1.2)  inserta  nueva estructura gui con el id salvado y padre (mismo padre que tabla original)
             
             
          
            
            3.2) si no es el primer registro
            
                3.2.1) buscar equivalencia del padre 
            	3.2.2) insertar nuevo gui con equivalencia del padre  y salvar id 
                3.2.3) inserta  nueva estructura gui con el id salvado y padre equivalente
                
           3.3)  guardar equivalencia en la tabla temporal    
  
   B) MIGRAR metaprocesos 
       (PENDIENTE)        
             
        
        
        
    
    */
  

-- A) MIGRAR MENU
     
  --      1)  buscamos equivalencia del ide del subsistema
  		  v_sw = 0;
          
          
          --hostaddr=10.172.0.11 port=5432 dbname=bdweb_gv user=db_link password=db_link
          
           SELECT P.id_subsistema,P.codigo  into  v_id_subsistema, v_codigo
           FROM dblink(p_cadena_nonexion,
                       'select s.id_subsistema, s.codigo 
                        from segu.tsubsistema s          
                        inner join segu.tgui g on s.id_subsistema = g.id_subsistema
                        where g.id_gui = '||p_id_gui::varchar) AS P(id_subsistema integer , 
                                                            codigo varchar);
                                                            
             select s.id_subsistema into v_id_subsistema
             from  segu.tsubsistema s
             where s.codigo = v_codigo;                                                
  
  
  IF(v_id_subsistema is null) THEN
  
  		raise exception 'solo nodo de sistema pueden migrarse o el sistema con dodigo % no existe en el destino',v_codigo;
  
  END IF;
  
  
  --      2)  crear tabla temporal de equivalencias
  create 
  temporary 
  table t_gui_equivalencia_temp (id_gui_orig integer , 
                                 id_gui_dest integer) on commit drop;


  --      3)  for para recorrer los resultados
  
  raise notice 'inicia FOR';
  
  FOR objeto IN   (SELECT id_gui , 
                                        nombre , 
                                        descripcion , 
                                        fecha_reg , 
                                        codigo_gui , 
                                        visible , 
                                        orden_logico , 
                                        ruta_archivo , 
                                        nivel , 
                                        icono , 
                                        id_subsistema, 
                                        clase_vista,
                                        fk_id_gui
                               FROM dblink(p_cadena_nonexion,
                                          'WITH RECURSIVE recursegui( id_gui , 
                                        nombre , 
                                        descripcion , 
                                        fecha_reg , 
                                        codigo_gui , 
                                        visible , 
                                        orden_logico , 
                                        ruta_archivo , 
                                        nivel , 
                                        icono , 
                                        id_subsistema, 
                                        clase_vista,
                                        fk_id_gui ) AS (
                                          SELECT g.id_gui , 
                                                 g.nombre , 
                                                 g.descripcion , 
                                                 g.fecha_reg , 
                                                 g.codigo_gui , 
                                                 g.visible , 
                                                 g.orden_logico , 
                                                 g.ruta_archivo , 
                                                 g.nivel , 
                                                 g.icono , 
                                                 g.id_subsistema, 
                                                 g.clase_vista,
                                                 eg.fk_id_gui
                                          FROM segu.tgui g 
                                          join segu.testructura_gui eg 
                                               on g.id_gui = eg.id_gui
                                          WHERE  g.id_gui= '||p_id_gui::varchar||'
                                        UNION
                                          SELECT  g.id_gui , 
                                                 g.nombre , 
                                                 g.descripcion , 
                                                 g.fecha_reg , 
                                                 g.codigo_gui , 
                                                 g.visible , 
                                                 g.orden_logico , 
                                                 g.ruta_archivo , 
                                                 g.nivel , 
                                                 g.icono , 
                                                 g.id_subsistema, 
                                                 g.clase_vista,
                                                 eg.fk_id_gui
                                          FROM segu.tgui g 
                                          join segu.testructura_gui eg 
                                               on g.id_gui = eg.id_gui
                                          JOIN recursegui  rt ON rt.id_gui = eg.fk_id_gui
                                        )
                                      SELECT * FROM recursegui;') AS P(
                                                                         id_gui INTEGER, 
                                                                          nombre VARCHAR(50), 
                                                                          descripcion TEXT, 
                                                                          fecha_reg DATE , 
                                                                          codigo_gui VARCHAR, 
                                                                          visible VARCHAR, 
                                                                          orden_logico INTEGER, 
                                                                          ruta_archivo TEXT, 
                                                                          nivel INTEGER, 
                                                                          icono VARCHAR, 
                                                                          id_subsistema INTEGER, 
                                                                          clase_vista VARCHAR,  
                                                                          fk_id_gui integer))   LOOP
                                                                          
        
   --          3.1) si primer registro
               IF (v_sw = 0) THEN
               
         --          3.1.1 buscamos ei el codigo si ya existe recuperamos id
         
                     select g.id_gui  into v_id_gui_equi
                     from segu.tgui g 
                     where g.codigo_gui = objeto.codigo_gui;
                     
                     if(v_id_gui_equi is null) THEN
                     
         --         3.1.1.1)  insertar nuevo gui  y salvar id 
         
                  insert into  segu.tgui(
                                        codigo_gui,
                                        nombre, 
                                        descripcion, 
                                        visible,
                                        orden_logico,
                                        ruta_archivo,
                                        nivel,
                                        icono,
                                        id_subsistema,
                                        clase_vista)
                                 values(
                                      
                                        objeto.codigo_gui,
                                        objeto.nombre,
                                        objeto.descripcion,
                                        objeto.visible,
                                        objeto.orden_logico,
                                        objeto.ruta_archivo,
                                        objeto.nivel, 
                                        objeto.icono,
                                        v_id_subsistema,
                                        objeto.clase_vista)
                                 RETURNING id_gui into v_id_gui_equi;
         
         
         --         3.1.1.2)  inserta  nueva estructura gui con el id salvado y padre (mismo padre que tabla original)
         
                                  insert into segu.testructura_gui(
                                         id_gui,
                                         fk_id_gui
                                         )
                                  values(
                                         v_id_gui_equi,
                                         objeto.fk_id_gui);




                     END IF;
                     -- para indicar que la raiz ya fue procesada
                     v_sw=1;

                
               ELSE 
                
               
               
   --         3.2) si no es el primer registro
   
   
                select g.id_gui  into v_id_gui_equi
                from segu.tgui g 
                where g.codigo_gui = objeto.codigo_gui;
                
                 if(v_id_gui_equi is null) THEN
            
             --           3.2.1) buscar equivalencia del padre 
                          select id_gui_dest  into v_id_gui_padre_equi
                          from  t_gui_equivalencia_temp et 
                          where et.id_gui_orig = objeto.fk_id_gui; 
             
             --         	3.2.2) insertar nuevo gui con equivalencia del padre  y salvar id 
             
                          insert into  segu.tgui(
                                                  codigo_gui,
                                                  nombre, 
                                                  descripcion, 
                                                  visible,
                                                  orden_logico,
                                                  ruta_archivo,
                                                  nivel,
                                                  icono,
                                                  id_subsistema,
                                                  clase_vista)
                                           values(
                                                
                                                  objeto.codigo_gui,
                                                  objeto.nombre,
                                                  objeto.descripcion,
                                                  objeto.visible,
                                                  objeto.orden_logico,
                                                  objeto.ruta_archivo,
                                                  objeto.nivel, 
                                                  objeto.icono,
                                                  NULL,
                                                  objeto.clase_vista)
                                           RETURNING id_gui into v_id_gui_equi;
                   
                        
             
             
             --           3.2.3) inserta  nueva estructura gui con el id salvado y padre equivalente
                               insert into segu.testructura_gui(
                                                                     id_gui,
                                                                     fk_id_gui
                                                                     )
                                                              values(
                                                                     v_id_gui_equi,
                                                                     v_id_gui_padre_equi);
   				END IF;
              END IF;
              
          --3.3   guardar equivalencia en la tabla temporal
   
               insert into t_gui_equivalencia_temp(id_gui_orig, id_gui_dest)
               values(objeto.id_gui,v_id_gui_equi);
   
   
                            
   
  
   END LOOP;

  
   -- B) MIGRAR metaprocesos 
   --    (PENDIENTE) 
   
   
   -- 1) correr la funcion de sincronizacion para insertar los metaprocesos de las funciones del sistema a importar
   
    v_respuesta:=segu.f_sinc_funciones_subsistema(v_id_subsistema);
    
   -- 2) FOR del istado de las relaciones entre gui y procedimientos por 
   --    las funciones del sistema
   
   FOR objeto IN   (SELECT  P.id_gui, P.id_procedimiento, P.boton, P.nombre, P.codigo
                    FROM dblink(p_cadena_nonexion,
                                             'select  pg.id_gui, pg.id_procedimiento, pg.boton,f.nombre,p.codigo
                                              from  segu.tfuncion f
                                              inner join segu.tprocedimiento p on f.id_funcion = p.id_funcion
                                              inner join segu.tprocedimiento_gui pg on pg.id_procedimiento=p.id_procedimiento
                                              where f.id_subsistema ='||v_id_subsistema::varchar) AS P( id_gui integer, 
                                                                                                        id_procedimiento integer, 
                                                                                                        boton varchar,
                                                                                                        nombre varchar,
                                                                                                        codigo varchar)) LOOP 
   
   
           -- 2.1) buscamos el procedimeinto en el destino y guardamos el id equivalente   
           v_id_procedimiento =NULL;
            select id_procedimiento into v_id_procedimiento 
            FROM segu.tprocedimiento p where p.codigo = objeto.codigo;
           
           
           if (v_id_procedimiento is null) THEN
           -- 2.1.1)   si no existe lanzamos error  para que revisen las funcion y el codigo faltantes en el destino
              raise exception 'No existe el procedimiento % en la funcion % o la sincronizacion fallor por comentarios mal hechos',objeto.codigo,objeto.nombre;
           END IF;
           
           
           
           -- 2.2)  buscamos equivalencia de gui en la tabla temporal
           
           select id_gui_dest into v_id_gui_equi
           from  t_gui_equivalencia_temp et 
           where et.id_gui_orig = objeto.id_gui; 
   
   
   
           -- 2.5) buscamos si ya existe la relacion entre gui y procedimiento
           v_id_procedimiento_gui=NULL;
           select id_procedimiento_gui   into v_id_procedimiento_gui
           from segu.tprocedimiento_gui pg 
           where pg.id_gui=v_id_gui_equi 
           and pg.id_procedimiento=v_id_procedimiento;
       
           if(v_id_procedimiento_gui is NULL )THEN   
           -- 2.5.1) si no existe insertamos en gui_procedimiento con las equivalencias
           
                 INSERT INTO segu.tprocedimiento_gui(
                                   id_procedimiento, 
                                   id_gui,
                                   boton)
                 VALUES (v_id_procedimiento, 
                         v_id_gui_equi,
                         objeto.boton);
                         
              raise notice 'procedimiento insertado %',objeto.codigo;              
           ELSE
           
             raise notice 'procedimiento existiente %',objeto.codigo;
           
           END IF;
   
   END LOOP;

   
   
  
END;
$$;


--
-- TOC entry 1767 (class 1255 OID 208289)
-- Dependencies: 20 3246
-- Name: f_monitorear_recursos(); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION f_monitorear_recursos() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.f_monitorear_recursos
 DESCRIPCION: 	Monitorea el uso de recursos en el servidor de base de datos
 AUTOR: 		KPLIAN(jrr)
 FECHA:			08/03/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/
DECLARE
    v_res       integer;
    v_curdb     varchar;
    v_resp          varchar;
    v_nombre_funcion   text;
    
BEGIN
    v_nombre_funcion='segu.f_monitorear_recursos';
    v_curdb=current_database();
    v_res=monitor_phx(1);
    execute ('
    create temporary table tt_procesos_so(
        pid integer, proceso varchar, usuario varchar,  pcpu numeric,
        pmem numeric, vmstat varchar) on commit drop');
        
    COPY tt_procesos_so
    FROM '/tmp/procesos.csv'
    WITH csv;
    
    execute ('CREATE TEMPORARY TABLE tt_monitor_recursos ON COMMIT DROP AS
                select pa.usename::varchar as usuario_bd,
                s.transaccion_actual,s.funcion_actual,
                pa.current_query::text as consulta,to_char(s.inicio_proceso,''DD/MM/YYYY HH24:MI:SS'') as hora_inicio_proceso,
                to_char(query_start,''DD/MM/YYYY HH24:MI:SS'') as hora_inicio_consulta,
                mbd.pid as pid_bd,
                mbd.proceso as proceso_bd,
                mbd.usuario as usuario_pbd,
                mbd.pcpu as pcpu_bd,
                mbd.pmem as pmem_bd,
                mbd.vmstat as vmstat_bd,
                mweb.pid as pid_web,
                mweb.proceso as proceso_web,
                mweb.usuario as usuario_web,
                mweb.pcpu as pcpu_web,
                mweb.pmem as pmem_web,
                mweb.vmstat as vmstat_web,
                s.variable as sid_web
                from segu.tsesion s
                inner join tt_procesos_so mbd
                on(mbd.pid=s.pid_bd)
                inner join pg_stat_activity pa
                on(pa.procpid=mbd.pid)
                inner join tt_procesos_so mweb
                on(mweb.pid=s.pid_web)
                where datname='''||v_curdb||'''');
    return 'exito';
EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1768 (class 1255 OID 208290)
-- Dependencies: 20 3246
-- Name: f_permiso_rol(integer, integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION f_permiso_rol(par_id_gui integer, par_id_procedimiento_gui integer, par_id_rol integer, par_accion character varying, par_direccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************

 FUNCION: 		segu.f_permiso_rol
 DESCRIPCION: 	Asigna permisos a un rol de forma recursiva en el arbol
 AUTOR: 		KPLIAN(JRR)
 FECHA:			19/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/
DECLARE

v_consulta    varchar;
v_registros  record;
v_respuesta     varchar;
v_nombre_funcion varchar;
v_mensaje_error  varchar;
v_resp		varchar;

/*
paramteros:

solo se puede tener id_gui o id_procedimiento (uno a la vez)


par_id_gui: id_gui al que se quiere otorgar o quitar permisos
par_id_procedimiento:id_procedimiento al q se quiere otorgar o quitar permisos
par_id_rol: id_del rol al que se totorga o se quitan los permisos
par_accion: "dar"=> da permisos al rol sobre la interfaz o la transaccion
        "quitar" =>revoca permisos sobre la interfaz o la transaccion
par_direccion:  "subir" => llamada q va dando permisos sobre las transacciones padre
                "bajar" => llamada q va dando permiso sobre todos los hijos
                "subir_bajar"=>otorga permisos tanto de subida comod e bajada (Para la primera llamada "subir_bajar")




1) Validamos la accion a realizar dar permiso o quitar permiso
    1.1) "dar" Se otorga permiso sobre la interfaz o transaccion
    1.2) "quitar" Se quita permiso sobre la interfaz o transaccion
2) Validamos la sigueinte accionde acuerdo a la direccion "subir","bajar","subir_bajar"
    2.1) Si es "subir" o "subir_bajar" hacemos una llamada recursiva a esta funcion para el padre de esta transaccion
        o vista
    2.2) Si es "bajar" o "subir_bajar" y no es una transaccion
        hacemos una llamada recursiva a esta funcion para cada hijo de este metaproceso

*/

BEGIN


    v_nombre_funcion:='segu.fpermiso_rol';
--1) Validamos la accion a realizar dar permiso o quitar permiso
    --1.1) "dar" Se otorga permiso sobre la interfaz o transaccion
    if(par_accion='dar')then
        --1.1.1) Si no existe el permiso sobre la transaccion lo insertamos
        if(par_id_gui is null)then
            if(not exists(select
                            1
                        from segu.trol_procedimiento_gui
                        where id_rol=par_id_rol and id_procedimiento_gui=par_id_procedimiento_gui
                        and estado_reg='activo'))then

            insert into segu.trol_procedimiento_gui (
                id_rol,
                id_procedimiento_gui)
            values(
                par_id_rol,
                par_id_procedimiento_gui);
            end if;
        --1.1.2) Si no existe el permiso sobre la vista lo insertamos
        else
            if(not exists(select
                            1
                        from segu.tgui_rol
                        where id_rol=par_id_rol and id_gui=par_id_gui
                        and estado_reg='activo'))then

            insert into segu.tgui_rol (
                id_rol,
                id_gui)
            values(
                par_id_rol,
                par_id_gui);
            end if;
        end if;
    
    --1.2) "quitar" Se quita permiso sobre la interfaz o transaccion
    ELSE
        --1.2.1) Quitamos cualquier permiso sobre la transaccion
        if(par_id_gui is null)then
            update segu.trol_procedimiento_gui set
                estado_reg='inactivo'
            where id_rol=par_id_rol and id_procedimiento_gui=par_id_procedimiento_gui;
        --1.2.1) Quitamos cualquier permiso sobre la vista
        else
            if(par_direccion='subir')then
                if(not exists(select 1 from segu.tgui_rol gr 
                              inner join segu.testructura_gui eg on(gr.id_gui=eg.id_gui)
                        where fk_id_gui=par_id_gui
                    and id_rol=par_id_rol and gr.estado_reg='activo' 
                    and eg.estado_reg='activo'))then
                    if(not exists(select 1 from segu.tprocedimiento_gui pg 
                                           inner join segu.trol_procedimiento_gui rpg 
                                           on(pg.id_procedimiento_gui=rpg.id_procedimiento_gui)
                        where pg.id_gui=par_id_gui
                          and id_rol=par_id_rol and rpg.estado_reg='activo' and pg.estado_reg='activo'))then
                            update segu.tgui_rol set
                                estado_reg='inactivo'
                            where id_rol=par_id_rol and id_gui=par_id_gui;
                    end if;
                end if;

            else
                update segu.tgui_rol set
                    estado_reg='inactivo'
                where id_rol=par_id_rol and id_gui=par_id_gui;
            end if;
        end if;
    
    
    end if;
--2) Validamos la sigueinte accionde acuerdo a la direccion "subir","bajar","subir_bajar"
    --2.1) Si es "subir" o "subir_bajar" hacemos una llamada recursiva a esta funcion para el padre de esta transaccion
        --o vista
    if(par_direccion='subir' or par_direccion='subir_bajar')then
        if(par_id_gui is null)THEN
            v_consulta:='select id_gui
                         from segu.tprocedimiento_gui
                         where estado_reg=''activo'' 
                         and id_procedimiento_gui='||par_id_procedimiento_gui;

        else
            v_consulta:='select fk_id_gui as id_gui
                         from segu.testructura_gui
                         where estado_reg=''activo'' and id_gui='||par_id_gui;
        
        end if;


        for v_registros in
        execute(v_consulta)loop
            v_respuesta:= segu.f_permiso_rol(v_registros.id_gui,null,par_id_rol,par_accion,'subir');

        end loop;
    end if;
    
    --2.2) Si es "bajar" o "subir_bajar" y no es una transaccion
        --hacemos una llamada recursiva a esta funcion para cada hijo de este metaproceso
    if((par_direccion='bajar' or par_direccion='subir_bajar') and par_id_gui is not null)then
         v_consulta:='select id_procedimiento_gui
                         from segu.tprocedimiento_gui
                         where estado_reg=''activo'' 
                         and id_gui='||par_id_gui;
                         
         for v_registros in
         execute(v_consulta)loop
             v_respuesta:= segu.f_permiso_rol(null,v_registros.id_procedimiento_gui,par_id_rol,par_accion,'bajar');

         end loop;

        
         v_consulta:='select id_gui
                       from segu.testructura_gui
                       where estado_reg=''activo'' and fk_id_gui='||par_id_gui;

        
        for v_registros in
         execute(v_consulta)loop
             v_respuesta:= segu.f_permiso_rol(v_registros.id_gui,null,par_id_rol,par_accion,'bajar');

         end loop;

    end if;
    return 'exito';


EXCEPTION

       WHEN OTHERS THEN

       	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


--
-- TOC entry 1769 (class 1255 OID 208293)
-- Dependencies: 20 3246
-- Name: f_sinc_funciones_subsistema(integer); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION f_sinc_funciones_subsistema(par_id_subsistema integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.f_sinc_funciones_subsistema
 DESCRIPCIÓN:   sincronizacion de la funciones de un subsistema a partir de los metadatos der SGBD
        
 AUTOR: 		KPLIAN(RAC)
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	- actualizacion a nueva version xph
                - listado de ufnciones en vez de tablas
                - ahora tambien saca las descripcion de la transaccion a partir de
                  de los comentarios del programador                     
 AUTOR:		KPLIAN(RAC)	
 FECHA:		27/11/10
 ***************************************************************************
 DESCRIPCION:	- arreglo para omitir funciones bakup con barra baja por delante '_'
                - se hicieron unicos los nombre de funcion, los codigos de procedimientos y de gui
                   
 AUTOR:		KPLIAN(RAC)	
 FECHA:		15/03/12


***************************************************************************/

DECLARE
v_registros       record;
v_esquema         varchar;
v_mensaje_error   text;
v_nombre_funcion  varchar;

v_prefijo          varchar;
v_cant             integer;
v_bandera          boolean;
v_contenido        text;
v_codigo           varchar;
v_id_funcion       integer;
v_nombre_function          varchar;
v_nombre_tabla          varchar;
v_desc_transaccion varchar;
v_bandera_desc boolean;
v_nombre_fun   varchar;

BEGIN

v_nombre_funcion:='segu.f_sinc_funciones_subsistema';

     --  raise exception 'LLEGA';
     select lower(codigo), lower(prefijo)
     into v_esquema, v_prefijo
     from segu.tsubsistema
     where id_subsistema=par_id_subsistema;
     
     
    -- raise exception 'LLEGA %',v_esquema;
     
    
     --RAC 15032012  se incremente el NOT LIKE para que no se considere las copias de las funciones
     --estas se distinguen por que comienzan con una '_' por delante
     --si existe una funcion backup sin esta caracteristica podemos obtener un error
     --de codigos duplicados
     
     for v_registros in (  SELECT p.proname AS v_funcion
                           FROM pg_proc p
                              INNER JOIN pg_namespace n ON p.pronamespace = n.oid
                           WHERE n.nspname = v_esquema AND   ( p.proname  LIKE '_%')) loop   -- p.proname not like '_%'  ==> 9-04-2012 ==> no listaba nada
                         
                       v_nombre_function=v_registros.v_funcion; 
                       
                       if(v_nombre_function != 'f_sinc_funciones_subsistema')THEN
                         --
                         
                         -- verifica la existencia de la funcion tipo sel con prefijo ft
                         
                                   
                                   --raise exception '%',substr(v_nombre_tabla, 2);

                                   v_cant:=2;
                                   v_bandera:=true;

                                   if not exists(select 1
                                                  from segu.tfuncion
                                                  where nombre = v_nombre_function
                                                  and id_subsistema=par_id_subsistema and estado_reg='activo') then

                                         -- si no existe inserta una funcion 

                                          insert into segu.tfuncion(nombre,descripcion,id_subsistema,estado_reg)
                                          values(v_nombre_function,
                                          'Funcion para tabla     ',par_id_subsistema,'activo')
                                          returning id_funcion into v_id_funcion ;

                                   else
                                   
                                    --si existe recupera el id de la fucion
                                          v_id_funcion:=(select id_funcion
                                                     from segu.tfuncion
                                                     where nombre = v_nombre_function
                                                     and id_subsistema=par_id_subsistema
                                                     and estado_reg='activo');
                                   end if;
                                   
                                   --recupera el cuerpo de la funcion

                                   select prosrc
                                   into v_contenido
                                   from pg_proc 
                                   where proname = v_nombre_function;

                                 
                                    raise notice '%   %',v_nombre_function,v_esquema; 
                                    
                                    
                                   while((v_bandera) or (v_cant<20)) loop
                                   
                                    
                                        
                                           
                                     --busca las transacciones en el cuerpo de la funcion       
                                    if(strpos(split_part(TRIM(v_contenido),'_transaccion=''',v_cant),''')')<1) then
                                                v_bandera:=false;
                                           else
                                           
                                           
                                            
                                               --Verifica si la trasanccion tiene descripcion    
                                               v_bandera_desc:=true;  
                                               v_desc_transaccion= 'CODIGO NO DOCUMENTADO';
                                            
                                              if(strpos(split_part(v_contenido,'#DESCRIPCION:',v_cant),'#AUTOR:')<1) then
                                                 
                                                   
                                                 v_bandera_desc:=false;
                                             
                                              else 
                                              
                                                 
                                                  v_desc_transaccion:=TRIM((select substr(split_part(v_contenido,'#DESCRIPCION:',v_cant),1,strpos(split_part(v_contenido,'#DESCRIPCION:',v_cant),'#AUTOR:')-1))::varchar);
                                              
                                              end IF;
                                            
                                            v_codigo:=(select substr(split_part(TRIM(v_contenido),'_transaccion=''',v_cant),1,strpos(split_part(TRIM(v_contenido),'_transaccion=''',v_cant),''')')-1))::varchar;

                                                     
                                            raise notice '% ---  %',v_codigo, v_desc_transaccion;   
                                            
                                             if(v_codigo is null or v_codigo='') then
                                                     v_bandera:=false;
                                                end if;


                                                if not exists(select 1 
                                                              from segu.tprocedimiento
                                                              where codigo =v_codigo --)then
--                                                              and id_funcion=v_id_funcion and estado_reg='activo') then
                                                               and id_funcion=v_id_funcion) then
                                                               
                                                               
                                                           
                                                           if exists(select 1 
                                                              from segu.tprocedimiento
                                                              where codigo =v_codigo )then 
                                                              
                                                              
                                                                select  f.nombre into v_nombre_fun
                                                                from segu.tprocedimiento p
                                                                inner join segu.tfuncion f on f.id_funcion = p.id_funcion
                                                                where p.codigo =v_codigo ;
                                                                --OFFSET  START 0 LIMIT 1;
                                                              
                                                                raise exception 'el se duplica para la funcion  % existe en la funcion % y minimamente en %',v_codigo,v_nombre_function,v_nombre_fun;
                                                           
                                                           
                                                           END IF;   
                                                  


                                                
                                                   insert into segu.tprocedimiento(codigo,descripcion,id_funcion,estado_reg)
                                                   values(v_codigo,v_desc_transaccion, v_id_funcion,'activo');
                                                
                                                else
                                                        
                                                    UPDATE segu.tprocedimiento 
                                                      SET descripcion= v_desc_transaccion
                                                    WHERE codigo =v_codigo 
                                                       and id_funcion=v_id_funcion;
                                                       
                                                       
                                                end if;
                                                
                                                
                                                
                                                
                                                
                                           end if;
                                           v_cant=v_cant+1;
                                           
                                           -- busca los mensaje de descripcion en el cuerpo de la funcion 
                                           
                                           
                                           
                                   end loop;

                         
                      END IF; 

     end loop;

    return 'exito';

END;
$$;


--
-- TOC entry 1776 (class 1255 OID 208296)
-- Dependencies: 20 3246
-- Name: f_sincroniza_persona_entre_bd(integer, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION f_sincroniza_persona_entre_bd(p_id_persona integer, p_host_destino character varying, p_port_destino character varying, p_user_destino character varying, p_pwd_destino character varying, p_bd_destino character varying, p_opcion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    
v_consulta  varchar;
v_respuesta varchar;
v_registros record;

BEGIN
                           
   
       
        IF p_opcion = 'INSERT' THEN
            BEGIN   
            
                                                                                                        /*
              v_consulta:='SELECT id_persona
                                               FROM segu.tpersona where id_persona='||p_id_persona;   */
                  --raise exception 'aa%',coalesce(new.genero,'');          
              if not exists (select P.id_persona from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_persona
                                               FROM sss.tsg_persona where id_persona='||p_id_persona) AS P(
                                                                                id_persona integer) ) then
                     
                  select * into v_registros from segu.tpersona where id_persona=p_id_persona;                                       
                     
                  v_consulta:='insert into sss.tsg_persona(id_persona,nombre,apellido_paterno,apellido_materno, doc_id, email2,celular1,telefono1,telefono2,celular2,extension,id_usuario_reg,fecha_reg,genero,fecha_nacimiento,direccion) 
                  values ('||p_id_persona||','''||coalesce(v_registros.nombre,'-')||''','''||coalesce(v_registros.apellido_paterno,'-')||''','''||coalesce(v_registros.apellido_materno,'-')||''','''||coalesce(v_registros.ci,'-')||''','''||coalesce( v_registros.correo,'-')||''','''||coalesce(v_registros.celular1,'-')||''','''||coalesce(v_registros.telefono1,'-')||''','''||coalesce(v_registros.telefono2,'-')||''',
                  '''||coalesce(v_registros.celular2,'-')||''','''||coalesce(v_registros.extension,'-')||''','||1||','''||now()::date||''','''||f_iif(coalesce(v_registros.genero,'m')='m','varon','mujer')::varchar||''','''|| coalesce(v_registros.fecha_nacimiento,now()::date)||''', 
                  '''||coalesce( v_registros.direccion,'')||''' );'    ;
                        
                  v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                  return 'si';
             else 
                  raise exception 'ya existe';
             end if;                                   
            
          end;
        ELSEIF p_opcion='UPDATE' THEN
               BEGIN       
               
                      if exists (select P.id_persona from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_persona
                                               FROM sss.tsg_persona where id_persona='||p_id_persona) AS P(
                                                                                id_persona integer) ) then   
                                                                                
                          select * into v_registros from segu.tpersona where id_persona=p_id_persona;                                       
                     
                          v_consulta:='update sss.tsg_persona
                          set 
                          nombre='''||coalesce(v_registros.nombre,'-')||''',
                          apellido_paterno='''||coalesce(v_registros.apellido_paterno,'-')||''',
                          apellido_materno='''||coalesce(v_registros.apellido_materno,'-')||''', 
                          doc_id='''||coalesce(v_registros.ci,'-')||''', 
                          email2='''||coalesce( v_registros.correo,'-')||''',
                          celular1='''||coalesce(v_registros.celular1,'-')||''',
                          telefono1='''||coalesce(v_registros.telefono1,'-')||''',
                          telefono2='''||coalesce(v_registros.telefono2,'-')||''',
                          celular2='''||coalesce(v_registros.celular2,'-')||''',
                          extension='''||coalesce(v_registros.extension,'-')||''',
                          genero='''||f_iif(coalesce(v_registros.genero,'m')='m','varon','mujer')::varchar||''',
                          fecha_nacimiento='''|| coalesce(v_registros.fecha_nacimiento,now()::date)||''',
                          direccion= '''||coalesce( v_registros.direccion,'')||'''
                          where id_persona='||p_id_persona;
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                           return 'si';
                     else
                           return 'no';          
                     end if;
               END;
        ELSIF p_opcion='DELETE' THEN               
               BEGIN     
                     if exists (select P.id_persona from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_persona
                                               FROM sss.tsg_persona where id_persona='||p_id_persona) AS P(
                                                                                id_persona integer) ) then   
                                                                                
                           v_consulta:='delete from sss.tsg_persona where id_persona='||p_id_persona;
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                           return 'si';                                                      
                     else
                       return 'no';
                     end if;
                   
               END;
        END IF;     
        
--RETURN NEW;
            
            
           
  RETURN NULL;
END;
$$;


--
-- TOC entry 1777 (class 1255 OID 208297)
-- Dependencies: 20 3246
-- Name: f_sincroniza_usuario_entre_bd(integer, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION f_sincroniza_usuario_entre_bd(p_id_usuario integer, p_host_destino character varying, p_port_destino character varying, p_user_destino character varying, p_pwd_destino character varying, p_bd_destino character varying, p_opcion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    
v_consulta  varchar;
v_respuesta varchar;
v_registros record;

BEGIN
                           
   
       
        IF p_opcion = 'INSERT' THEN
            BEGIN   
            
              
              if not exists (select P.id_usuario from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_usuario
                                               FROM sss.tsg_usuario where id_usuario='||p_id_usuario) AS P(
                                                                                id_usuario integer) ) then
                     
                  select * into v_registros from segu.tusuario where id_usuario=p_id_usuario;                                       
                     
                  v_consulta:='insert into sss.tsg_usuario(id_usuario, id_nivel_seguridad, login, contrasenia,fecha_expiracion , estilo_usuario, id_persona, autentificacion, estado_usuario) 
                                   values ('||p_id_usuario||',
                                           '||v_registros.id_clasificador||',
                                           '''||coalesce(v_registros.cuenta,'-')||''',
                                           '''||coalesce(v_registros.contrasena,'-')||''',
                                           '''||v_registros.fecha_caducidad||''',
                                           '''||coalesce( v_registros.estilo,'-')||''',
                                           '||v_registros.id_persona||',
                                           '''||coalesce(v_registros.autentificacion,'local')||'''
                                           ,''activo''
                  );' ;
                        
                  v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                  return 'si';
             else 
                  raise exception 'ya existe';
             end if;                                   
            
          end;
        ELSEIF p_opcion='UPDATE' THEN
               BEGIN                
                      if exists (select P.id_usuario from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_usuario
                                               FROM sss.tsg_usuario where id_usuario='||p_id_usuario) AS P(
                                                                                id_usuario integer) ) then   
                                                                                
                          select * into v_registros from segu.tusuario where id_usuario=p_id_usuario;                                       
                     
                          v_consulta:='update sss.tsg_usuario
                          set 
                          id_nivel_seguridad='||v_registros.id_clasificador||',
                          login='''||coalesce(v_registros.cuenta,'-')||''',
                          contrasenia='''||coalesce(v_registros.contrasena,'-')||''',       
                          fecha_expiracion='''||v_registros.fecha_caducidad||''', 
                          estilo_usuario='''||coalesce( v_registros.estilo,'-')||''', 
                          id_persona='||v_registros.id_persona||', 
                          autentificacion='''||coalesce(v_registros.autentificacion,'local')||''', 
                          estado_usuario='''||coalesce(v_registros.estado_reg,'activo')||'''
                          where id_usuario='||p_id_usuario;
                          v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                           return 'si';
                     else
                           return 'no';          
                     end if;
               END;
        ELSIF p_opcion='DELETE' THEN               
               BEGIN     
                     if exists (select P.id_usuario from dblink('hostaddr='||p_host_destino||' port='||p_port_destino||' dbname='||p_bd_destino||' user='||p_user_destino||' password='||p_pwd_destino,
                                             'SELECT id_usuario
                                               FROM sss.tsg_usuario where id_usuario='||p_id_usuario) AS P(
                                                                                id_usuario integer) ) then   
                                                                                
                           v_consulta:='update sss.tsg_usuario set estado_usuario=''inactivo'' where id_usuario='||p_id_usuario;
                           v_respuesta:= f_dblink(p_host_destino,p_port_destino,p_bd_destino,p_user_destino,p_pwd_destino,v_consulta);   
                           return 'si';                                                      
                     else
                       return 'no';
                     end if;
                   
               END;
        END IF;     
        
--RETURN NEW;
            
            
           
  RETURN NULL;
END;
$$;


--
-- TOC entry 1778 (class 1255 OID 208298)
-- Dependencies: 20 3246
-- Name: f_verif_eliminado(integer); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION f_verif_eliminado(par_id_subsistema integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.f_verif_eliminado
 DESCRIPCION:   
 AUTOR: 		KPLIAN(rac)
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)	
 FECHA:		08/01/11
***************************************************************************/
DECLARE
v_registros       record;
v_esquema         varchar;
v_mensaje_error   text;
v_nombre_funcion  varchar;
v_contenido        text;
v_cant             integer;
v_bandera          boolean;
v_codigo           varchar;
v_array_cod        integer[];
i                  integer;
cont               integer;
v_array_id         integer[];
j                  integer;
cont_id            integer;

BEGIN


v_nombre_funcion:='segu.f_verif_eliminado';

     for v_registros in (select nombre, id_funcion from segu.tfuncion where id_subsistema=par_id_subsistema order by nombre) loop
                         
                 if not exists(select * from pg_proc where proname ~ v_registros.nombre order by proname) then
                        if exists(select 1 from segu.tprocedimiento where id_funcion=v_registros.id_funcion) then
                             delete from segu.tprocedimiento where id_funcion=v_registros.id_funcion;
                        end if;
                        delete from segu.tfuncion where lower(nombre) ~ v_registros.nombre and id_subsistema=par_id_subsistema;
                 else
                 --existe la funcion (verificar q todos los procedimientos sigan existiendo)
                          select prosrc
                                 into v_contenido
                                 from pg_proc where proname ~ v_registros.nombre;

                                 v_bandera:=true;
                                 v_cant:=2;
                                 cont:=0;
                                 while((v_bandera) or (v_cant<20)) loop

                                           if(strpos(split_part(v_contenido,'par_transaccion=''',v_cant),''')then')<1) then
                                                v_bandera:=false;
                                           else
                                                v_codigo:=(select substr(split_part(v_contenido,'par_transaccion=''',v_cant),1,strpos(split_part(v_contenido,'par_transaccion=''',v_cant),''')then')-1))::varchar;
                                                v_array_cod[v_cant-1]:=(select id_procedimiento from segu.tprocedimiento where lower(codigo)=lower(v_codigo) and id_funcion=v_registros.id_funcion);
                                                cont=cont+1;
                                           end if;
                                           v_cant=v_cant+1;
                                 end loop;

                                 
                                 i=(array_upper(v_array_cod,1));
                                 select aggarray(id_procedimiento) into v_array_id
                                 from segu.tprocedimiento where id_funcion=v_registros.id_funcion;

                                 j=(array_upper(v_array_id,1));

                                 if(j>i) then
                                   j:=j;
                                 else
                                   j:=i;
                                 end if;

raise exception 'id%',v_array_cod;
                                /* for i in 1..j loop
                                     if(v_array_cod[i]=v_array_id[i]) then
                                     else
                                     end if;
                                 
                                 end loop;*/



                                /* while (cont>=i) loop

                                        if exists (select 1 from segu.procedimiento where lower(v_array_cod[i])~ lower(codigo) and id_funcion=v_registros.id_funcion) then

                                           v_array_id[j]:=(select id_procedimiento from segu.procedimiento where lower(v_array_cod[i])~ lower(codigo) and id_funcion=v_registros.id_funcion);
                                            j:=j+1;

                                            cont_id:=cont_id+1;
                                        end if;
                                        i=i+1;
                                    end loop;



                                    while(cont_id>0) loop

                                       delete from segu.procedimiento where id_funcion=v_registros.id_funcion
                                       and id_procedimiento not in (v_array_id [cont_id]);
                                    
                                    end loop;*/
                                    
                                 --end if;
                                 
                                 
                 end if;

     end loop;
    return 'exito';

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1779 (class 1255 OID 208299)
-- Dependencies: 20 3246
-- Name: ft_actividad_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_actividad_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_actividad_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'segu.tactividad'
 AUTOR: 		 (w)
 FECHA:	        17-10-2011 06:48:53
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_actividad	integer;
			
BEGIN

    v_nombre_funcion = 'segu.ft_actividad_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************
 	#TRANSACCION:  'SG_ACT_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:48:53
	***********************************/

	if(p_transaccion='SG_ACT_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into segu.tactividad(
			codigo,
			descripcion,
			estado_reg,
			nombre,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			v_parametros.codigo,
			v_parametros.descripcion,
			'activo',
			v_parametros.nombre,
			now(),
			p_id_usuario,
			null,
			null
			)RETURNING id_actividad into v_id_actividad;

			--Definici?n de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Actividad almacenado(a) con exito (id_actividad'||v_id_actividad||')');
            v_resp = f_agrega_clave(v_resp,'id_actividad',v_id_actividad::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************
 	#TRANSACCION:  'SG_ACT_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:48:53
	***********************************/

	elsif(p_transaccion='SG_ACT_MOD')then

		begin
			--Sentencia de la modificacion
			update segu.tactividad set
			codigo = v_parametros.codigo,
			descripcion = v_parametros.descripcion,
			nombre = v_parametros.nombre,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_actividad=v_parametros.id_actividad;

			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Actividad modificado(a)');
            v_resp = f_agrega_clave(v_resp,'id_actividad',v_parametros.id_actividad::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************
 	#TRANSACCION:  'SG_ACT_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:48:53
	***********************************/

	elsif(p_transaccion='SG_ACT_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from segu.tactividad
            where id_actividad=v_parametros.id_actividad;

            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Actividad eliminado(a)');
            v_resp = f_agrega_clave(v_resp,'id_actividad',v_parametros.id_actividad::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	else

    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				
END;
$$;


--
-- TOC entry 1780 (class 1255 OID 208300)
-- Dependencies: 20 3246
-- Name: ft_actividad_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_actividad_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_actividad_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'segu.tactividad'
 AUTOR: 		 (w)
 FECHA:	        17-10-2011 06:48:53
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			
BEGIN

	v_nombre_funcion = 'segu.ft_actividad_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************
 	#TRANSACCION:  'SG_ACT_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:48:53
	***********************************/

	if(p_transaccion='SG_ACT_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						act.id_actividad,
						act.codigo,
						act.descripcion,
						act.estado_reg,
						act.nombre,
						act.fecha_reg,
						act.id_usuario_reg,
						act.fecha_mod,
						act.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from segu.tactividad act
						inner join segu.tusuario usu1 on usu1.id_usuario = act.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = act.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			
			if(f_existe_parametro(p_tabla,'estado_reg')) then
			  v_consulta:=v_consulta || ' and act.estado_reg='''||v_parametros.estado_reg||'''';
			end if;
			
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************
 	#TRANSACCION:  'SG_ACT_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:48:53
	***********************************/

	elsif(p_transaccion='SG_ACT_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_actividad)
					    from segu.tactividad act
					    inner join segu.tusuario usu1 on usu1.id_usuario = act.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = act.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		
			v_consulta:=v_consulta||v_parametros.filtro;
            if(f_existe_parametro(p_tabla,'estado_reg')) then
			  v_consulta:=v_consulta || ' and act.estado_reg='''||v_parametros.estado_reg||'''';
			end if;
			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					
		raise exception 'Transaccion inexistente';
					
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1781 (class 1255 OID 208301)
-- Dependencies: 20 3246
-- Name: ft_bloqueo_notificacion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_bloqueo_notificacion_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_bloqueo_notificacion_ime
 DESCRIPCION:   Cambia el estado de las notificaciones y bloqueos
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/

DECLARE

    v_nro_requerimiento    	integer;
    v_parametros           	record;
    v_id_requerimiento     	integer;
    v_resp		            varchar;
    v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_proyecto			integer;


/*

 id_proyecto
 denominacion 
 descripcion
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='segu.ft_bloqueo_notificacion_ime';
     v_parametros:=f_get_record(p_tabla);

/*******************************
 #TRANSACCION:  SEG_ESBLONO_MOD
 #DESCRIPCION:	Cambia el estado de notificacion y bloqueos
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
    if(p_transaccion='SEG_ESBLONO_MOD')then

          --consulta:=';
          BEGIN
               
               update segu.tbloqueo_notificacion
               set estado_reg='inactivo'
               where id_bloqueo_notificacion=v_parametros.id_bloqueo_notificacion;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Bloqueo Notificacion desactivado');
               v_resp = f_agrega_clave(v_resp,'id_bloqueo_notificacion',v_parametros.id_bloqueo_notificacion::varchar);
              
               return v_resp;
         END;
         
     else
     
         raise exception 'Transaccion inexistente: %',p_transaccion;

     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
        
END;
$$;


--
-- TOC entry 1782 (class 1255 OID 208302)
-- Dependencies: 20 3246
-- Name: ft_bloqueo_notificacion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_bloqueo_notificacion_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_bloqueo_notificacion_sel
 DESCRIPCIÓN:   listado de los bloquos y notificaciones del sistema
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:
 AUTOR:		
 FECHA:	
***************************************************************************/

DECLARE                  

v_consulta    varchar;
v_parametros  record;
v_resp          varchar;
v_nombre_funcion   text;
v_mensaje_error    text;
v_res_actualiz    varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(p_tabla);
     v_nombre_funcion:='segu.f_t_bloqueo_notificacion_sel';

/*******************************    
 #TRANSACCION:  SEG_NOTI_SEL
 #DESCRIPCION:	Listado del notificacion de eventos del sistema
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     if(p_transaccion='SEG_NOTI_SEL')then

          
          BEGIN
               v_consulta:='select blono.id_bloqueo_notificacion,
                                    blono.nombre_patron,
                                    blono.aplicacion,
                                    blono.tipo_evento,
                                    blono.usuario,
                                    blono.ip,
                                    to_char(blono.fecha_hora_ini,''DD/MM/YYYY HH:MI:SS''),
                                    to_char(blono.fecha_hora_fin,''DD/MM/YYYY HH:MI:SS'')
               
                        from segu.tbloqueo_notificacion blono
                        where tipo=''notificacion'' and estado_reg=''activo'' and ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************    
 #TRANSACCION:  SEG_NOTI_CONT
 #DESCRIPCION:	Contar registros de notificaciones de enventos del sistema
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_NOTI_CONT')then

          --consulta:=';
          BEGIN
               v_consulta:='select count(blono.id_bloqueo_notificacion)
                              from segu.tbloqueo_notificacion blono
                              where tipo=''notificacion'' and estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
         
/*******************************
 #TRANSACCION:  SEG_BLOQUE_SEL
 #DESCRIPCION:	Listado de bloqueos del sistema
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_BLOQUE_SEL')then


          BEGIN
               v_consulta:='select blono.id_bloqueo_notificacion,
                                    blono.nombre_patron,
                                    blono.aplicacion,
                                    blono.tipo_evento,
                                    blono.usuario,
                                    blono.ip,
                                    to_char(blono.fecha_hora_ini,''DD/MM/YYYY HH:MI:SS''),
                                    to_char(blono.fecha_hora_fin,''DD/MM/YYYY HH:MI:SS'')

                        from segu.tbloqueo_notificacion blono
                        where tipo=''bloqueo'' and estado_reg=''activo'' and
                                fecha_hora_fin>now() and ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************
 #TRANSACCION:  SEG_BLOQUE_CONT
 #DESCRIPCION:	Contar registros de bloqueos del sistema
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_BLOQUE_CONT')then

          --consulta:=';
          BEGIN
               v_consulta:='select count(blono.id_bloqueo_notificacion)
                              from segu.tbloqueo_notificacion blono
                              where tipo=''bloqueo'' and estado_reg=''activo'' and
                                fecha_hora_fin>now() and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1783 (class 1255 OID 208303)
-- Dependencies: 20 3246
-- Name: ft_clasificador_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_clasificador_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_clasificador_ime
 DESCRIPCION:   modificaciones de clasificador
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/

DECLARE


v_parametros           record;
v_resp                 varchar;
v_nombre_funcion       text;
v_mensaje_error        text;
v_id_clasificador      integer;

BEGIN

     v_nombre_funcion:='segu.ft_clasificador_ime';
     v_parametros:=f_get_record(p_tabla);

 /*******************************
 #TRANSACCION:  SEG_CLASIF_INS
 #DESCRIPCION:	Inserta Actividades
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/

     if(p_transaccion='SEG_CLASIF_INS')then

        
          BEGIN
               insert into segu.tclasificador(
               codigo,              descripcion,                prioridad)
               values(
               v_parametros.codigo, v_parametros.descripcion,   v_parametros.prioridad
               )RETURNING id_clasificador into v_id_clasificador;


		      v_resp = f_agrega_clave(v_resp,'mensaje','Clasificador insertado con exito(id_clasificador'||v_id_clasificador||')');
              v_resp = f_agrega_clave(v_resp,'id_clasificador',v_id_clasificador::varchar);

         END;

 /*******************************
 #TRANSACCION:  SEG_CLASIF_MOD
 #DESCRIPCION:	Modifica Clasificacion
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     elsif(p_transaccion='SEG_CLASIF_MOD')then

          
          BEGIN
               
               update segu.tclasificador set

                     codigo=v_parametros.codigo,
                     descripcion=v_parametros.descripcion,
                     prioridad=v_parametros.prioridad

               where id_clasificador=v_parametros.id_clasificador;



               v_resp = f_agrega_clave(v_resp,'mensaje','Clasificador modificado: '||v_parametros.id_clasificador);
               v_resp = f_agrega_clave(v_resp,'id_clasificador',v_parametros.id_clasificador::varchar);

          END;

 /*******************************
 #TRANSACCION:  SEG_CLASIF_ELI
 #DESCRIPCION:	Elimina Clasificacion
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
    elsif(p_transaccion='SEG_CLASIF_ELI')then

         
          BEGIN
               update segu.tclasificador set estado_reg='inactivo'
               where id_clasificador=v_parametros.id_clasificador;


               v_resp = f_agrega_clave(v_resp,'mensaje','Clasificador eliminado: '||v_parametros.id_clasificador);
               v_resp = f_agrega_clave(v_resp,'id_clasificador',v_parametros.id_clasificador::varchar);

         END;

     else

         raise exception 'No existe la transaccion: %',p_transaccion;
     end if;
    return v_resp;
EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1784 (class 1255 OID 208304)
-- Dependencies: 20 3246
-- Name: ft_clasificador_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_clasificador_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_clasificador_sel
 DESCRIPCION:   consultas de clasificador
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/



DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp                 varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(p_tabla);
     v_nombre_funcion:='segu.ft_clasificador_sel';

 /*******************************
 #TRANSACCION:  SEG_CLASIF_SEL
 #DESCRIPCION:	Selecciona Clasificador
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/

     if(p_transaccion='SEG_CLASIF_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select id_clasificador,
                            codigo,
                            descripcion,
                            prioridad,
                            fecha_reg
                            --estado_reg
                        from segu.tclasificador where estado_reg=''activo'' and ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

 /*******************************
 #TRANSACCION:  SEG_CLASIF_CONT
 #DESCRIPCION:	Cuenta Clasificador
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/

     elsif(p_transaccion='SEG_CLASIF_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(id_clasificador)
               from segu.tclasificador where  estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1785 (class 1255 OID 208305)
-- Dependencies: 20 3246
-- Name: ft_configurar_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_configurar_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Esquema de seguridad
 FUNCION: 		segu.ft_configurar_ime
 DESCRIPCION:   Funcion que modifica la configuración de la vista, la autentificación y las contraseñas
 AUTOR: 		 (mflores)
 FECHA:	        01-12-2011 15:03
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    		integer;
	v_parametros           		record;
	v_id_requerimiento     		integer;
	v_resp		            	varchar;
	v_nombre_funcion       	 	text;
	v_mensaje_error         	text;
    v_clave_anterior			varchar;
    v_mod_exito 				varchar;
    v_clave_actual				varchar;
			    
BEGIN

    v_nombre_funcion = 'segu.ft_configurar_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SG_CONF_MOD'
 	#DESCRIPCION:	Configuración de cuenta de usuario
 	#AUTOR:			mflores	
 	#FECHA:			01-12-2011
	***********************************/

	if(p_transaccion='SG_CONF_MOD')then				
        
	--1) IF Si la opcion es modifcar contraseña (mod_contraseña = SI) y autentificacion = local
    --1.1) IF verifico si la contraseña actual es valida
    --1.1.1) IF si la contraseña nueva es igual a la confirmacion
    --1.1.1.1) modifico contraseña
    --1.1.2) ELSE, mensaje de error las ontraseñas no son iguales
    --1.2) ELSE, mensaje de error la contraseñaa actual no es valida
    --2) ELSE, modifico estilo, filtro avanzado y autentificacion (LDAP)
    
		begin
        
        if (v_parametros.autentificacion = 'Contraseña ENDESIS') then
        	v_parametros.autentificacion = 'local';
        else
        	v_parametros.autentificacion = 'ldap';
        end if;
        
        select contrasena
        into v_clave_anterior
        from segu.tusuario
        where id_usuario = p_id_usuario;
        
        /*v_parametros.clave_anterior = md5(v_parametros.clave_anterior);
        v_parametros.clave_nueva = md5(v_parametros.clave_nueva);
        v_parametros.clave_confirmacion = md5(v_parametros.clave_confirmacion);*/
        
        --1) IF Si la opcion es modifcar contraseña (mod_contraseña = SI) y autentificacion = local
         IF (v_parametros.modificar_clave = 'SI' AND v_parametros.autentificacion = 'local') THEN         	      	
            
            --1.1) IF verifico si la contraseña actual es valida         
			IF EXISTS(SELECT 1 FROM segu.tusuario usuari WHERE usuari.contrasena = v_parametros.clave_anterior
            and usuari.id_usuario = p_id_usuario) THEN
			
            --  guarda nueva contraseña solo si coinciden la nueva y la confirmacion
		
                --1.1.1) IF si la contraseña nueva es igual a la confirmacion
				IF (v_parametros.clave_nueva = v_parametros.clave_confirmacion) THEN
		
		        --1.1.1.1) modifico contraseña
	            -- se actualiza la clave  
                  UPDATE segu.tusuario SET
                   		 contrasena_anterior = v_clave_anterior,
			             contrasena = v_parametros.clave_nueva,
                         estilo = v_parametros.estilo,
                         autentificacion = v_parametros.autentificacion
                         
					WHERE segu.tusuario.id_usuario = p_id_usuario;
                    
                    v_mod_exito = 1;
                    
                    select contrasena
                    into v_clave_actual
                    from segu.tusuario
                    where id_usuario = p_id_usuario;
    			
                --1.1.2) ELSE, mensaje de error las ontraseñas no son iguales
                ELSE
       	            raise exception 'LOS DATOS NUEVOS NO COINCIDEN';

                END IF;
			--1.2) ELSE, mensaje de error la contraseña actual no es valida
            ELSE
   	            raise exception 'LA CONTRASEÑA ANTIGUA NO ES CORRECTA';           
            
            END IF;
            
          --2) ELSE, modifico estilo y filtro avanzado
          ELSE  
          -- se actualiza el estilo y el filtro avanzado
                                        
               UPDATE segu.tusuario SET
                    estilo = v_parametros.estilo,
                    autentificacion = v_parametros.autentificacion
                         
                WHERE segu.tusuario.id_usuario = p_id_usuario;
                      
                v_mod_exito = 0;
                
                select contrasena
                into v_clave_actual
                from segu.tusuario
                where id_usuario = p_id_usuario;
                
          END IF;
                         
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Preferencias de usuario modificadas)'); 
            v_resp = f_agrega_clave(v_resp,'id_usuario',p_id_usuario::varchar);
            v_resp = f_agrega_clave(v_resp,'mod_exito',v_mod_exito::varchar);  
            v_resp = f_agrega_clave(v_resp,'clave',v_clave_actual::varchar);      
			v_resp = f_agrega_clave(v_resp,'autentificacion',v_parametros.autentificacion::varchar);  
               
            --Devuelve la respuesta
            return v_resp;
            
		end;
	         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 1786 (class 1255 OID 208307)
-- Dependencies: 20 3246
-- Name: ft_ep_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_ep_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_ep_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'segu.tep'
 AUTOR: 		 (w)
 FECHA:	        18-10-2011 02:09:50
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_ep	integer;
			
BEGIN

    v_nombre_funcion = 'segu.ft_ep_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************
 	#TRANSACCION:  'SG_ESP_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		w	
 	#FECHA:		18-10-2011 02:09:50
	***********************************/

	if(p_transaccion='SG_ESP_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into segu.tep(
			estado_reg,
			id_actividad,
			id_programa,
			id_proyecto,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			'activo',
			v_parametros.id_actividad,
			v_parametros.id_programa,
			v_parametros.id_proyecto,
			now(),
			p_id_usuario,
			null,
			null
			)RETURNING id_ep into v_id_ep;

			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Estructura Programatica almacenado(a) con exito (id_ep'||v_id_ep||')');
            v_resp = f_agrega_clave(v_resp,'id_ep',v_id_ep::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************
 	#TRANSACCION:  'SG_ESP_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		w	
 	#FECHA:		18-10-2011 02:09:50
	***********************************/

	elsif(p_transaccion='SG_ESP_MOD')then

		begin
			--Sentencia de la modificacion
			update segu.tep set
			id_actividad = v_parametros.id_actividad,
			id_programa = v_parametros.id_programa,
			id_proyecto = v_parametros.id_proyecto,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_ep=v_parametros.id_ep;

			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Estructura Programatica modificado(a)');
            v_resp = f_agrega_clave(v_resp,'id_ep',v_parametros.id_ep::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************
 	#TRANSACCION:  'SG_ESP_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		w	
 	#FECHA:		18-10-2011 02:09:50
	***********************************/

	elsif(p_transaccion='SG_ESP_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from segu.tep
            where id_ep=v_parametros.id_ep;

            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Estructura Programatica eliminado(a)');
            v_resp = f_agrega_clave(v_resp,'id_ep',v_parametros.id_ep::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	else

    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				
END;
$$;


--
-- TOC entry 1787 (class 1255 OID 208308)
-- Dependencies: 20 3246
-- Name: ft_ep_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_ep_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_ep_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'segu.tep'
 AUTOR: 		 (w)
 FECHA:	        18-10-2011 02:09:50
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			
BEGIN

	v_nombre_funcion = 'segu.ft_ep_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************
 	#TRANSACCION:  'SG_ESP_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		w	
 	#FECHA:		18-10-2011 02:09:50
	***********************************/

	if(p_transaccion='SG_ESP_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						ep.id_ep,
						ep.estado_reg,
						ep.id_actividad,
						ep.nombre_actividad,
						ep.id_programa,
						ep.nombre_programa,
						ep.id_proyecto,
						ep.nombre_proyecto,
						ep.fecha_reg,
						ep.id_usuario_reg,
						ep.fecha_mod,
						ep.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from segu.vep ep
						inner join segu.tusuario usu1 on usu1.id_usuario = ep.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ep.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************
 	#TRANSACCION:  'SG_ESP_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		w	
 	#FECHA:		18-10-2011 02:09:50
	***********************************/

	elsif(p_transaccion='SG_ESP_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_ep)
					    from segu.vep ep
					    inner join segu.tusuario usu1 on usu1.id_usuario = ep.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = ep.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					
		raise exception 'Transaccion inexistente';
					
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1788 (class 1255 OID 208309)
-- Dependencies: 20 3246
-- Name: ft_estructura_dato_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_estructura_dato_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_estructura_dato_ime
 DESCRIPCION:   modificaciones de estructura_dato
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/

DECLARE


v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_resp                  varchar;
v_id_estructura_dato    integer;

BEGIN

     v_nombre_funcion:='segu.ft_estructura_dato_ime';
     v_parametros:=f_get_record(par_tabla);


 /*******************************
 #TRANSACCION:  SEG_ESTDAT_INS
 #DESCRIPCION:	Inserta Estructura Dato
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_ESTDAT_INS')then

        
          BEGIN
               insert into segu.testructura_dato(
                id_subsistema,              nombre,             descripcion,
                encripta,                   log,                tipo)
               values(
                v_parametros.id_subsistema, v_parametros.nombre,v_parametros.descripcion,
                v_parametros.encripta,      v_parametros.log,   v_parametros.tipo
               )RETURNING id_estructura_dato into v_id_estructura_dato;

                v_resp = f_agrega_clave(v_resp,'mensaje','Estructura Dato insertado con exito: '||v_id_estructura_dato);
                v_resp = f_agrega_clave(v_resp,'id_estructura_dato',v_id_estructura_dato::varchar);


         END;

 /*******************************
 #TRANSACCION:  SEG_ESTDAT_MOD
 #DESCRIPCION:	Modifica Estructura Dato
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_ESTDAT_MOD')then

          
          BEGIN
               
               update segu.testructura_dato set
                      id_subsistema=v_parametros.id_subsistema,
                     nombre=v_parametros.nombre,
                     descripcion=v_parametros.descripcion,
                     encripta=v_parametros.encripta,
                     log=v_parametros.log,
                     tipo=v_parametros.tipo

               where id_estructura_dato=v_parametros.id_estructura_dato;

                v_resp = f_agrega_clave(v_resp,'mensaje','Estructura Dato modificado con exito: '||v_parametros.id_estructura_dato);
                v_resp = f_agrega_clave(v_resp,'id_estructura_dato',v_parametros.id_estructura_dato::varchar);


          END;

 /*******************************
 #TRANSACCION:  SEG_ESTDAT_ELI
 #DESCRIPCION:	Elimina Estructura Dato
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
    elsif(par_transaccion='SEG_ESTDAT_ELI')then

         
          BEGIN
               update segu.testructura_dato set estado_reg='inactivo'
               where id_estructura_dato=v_parametros.id_estructura_dato;

                v_resp = f_agrega_clave(v_resp,'mensaje','Estructura Dato eliminado con exito: '||v_parametros.id_estructura_dato);
                v_resp = f_agrega_clave(v_resp,'id_estructura_dato',v_parametros.id_estructura_dato::varchar);

         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     return v_resp;

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1789 (class 1255 OID 208310)
-- Dependencies: 20 3246
-- Name: ft_estructura_dato_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_estructura_dato_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_estructura_dato_sel
 DESCRIPCION:   consultas de estructura_dato
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp           varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_estructura_dato_sel';


 /*******************************
 #TRANSACCION:  SEG_ESTDAT_SEL
 #DESCRIPCION:	Selecciona Estructura dato
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_ESTDAT_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select estdat.id_estructura_dato,
                            estdat.id_subsistema,
                            estdat.nombre,
                            estdat.descripcion,
                            estdat.encripta,
                            estdat.log,
                            estdat.fecha_reg,
                            estdat.estado_reg,
                            estdat.tipo,
                            subsis.nombre as nombre_subsis
                        from segu.testructura_dato estdat
                        inner join segu.tsubsistema subsis
                        on subsis.id_subsistema=estdat.id_subsistema where
                        estdat.estado_reg=''activo'' and';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


 /*******************************
 #TRANSACCION:  SEG_ESTDAT_CONT
 #DESCRIPCION:	Cuenta Estructura dato
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_ESTDAT_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(estdat.id_estructura_dato)
                        from segu.testructura_dato estdat
                        inner join segu.tsubsistema subsis
                        on subsis.id_subsistema=estdat.id_subsistema where
                        estdat.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

        WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1790 (class 1255 OID 208311)
-- Dependencies: 20 3246
-- Name: ft_estructura_gui_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_estructura_gui_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_estructura_gui_ime
 DESCRIPCION:   modificaciones de estructura_gui
 AUTOR: 		
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		Jaime Rivera Rojas	
 FECHA:		08/01/11
***************************************************************************/


DECLARE


v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_resp                  varchar;
v_id_estructura_gui    integer;
BEGIN

     v_nombre_funcion:='segu.ft_estructura_gui_ime';
     v_parametros:=f_get_record(par_tabla);


 /*******************************
 #TRANSACCION:  SEG_ESTGUI_INS
 #DESCRIPCION:	Inserta Estructura gui
 #AUTOR:		Jaime Rivera Rojas	
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_ESTGUI_INS')then

        
          BEGIN
               insert into segu.testructura_gui(id_gui, fk_id_gui)
               values(v_parametros.id_gui,v_parametros.fk_id_gui
               )RETURNING id_estructura_gui into v_id_estructura_gui;

               v_resp = f_agrega_clave(v_resp,'mensaje','Estructura gui insertado con exito: '||v_id_estructura_gui);
               v_resp = f_agrega_clave(v_resp,'id_estructura_gui',v_id_estructura_gui::varchar);

         END;


 /*******************************
 #TRANSACCION:  SEG_ESTGUI_MOD
 #DESCRIPCION:	Modifica Estructura gui
 #AUTOR:		Jaime Rivera Rojas	
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_ESTGUI_MOD')then

          
          BEGIN
               
               update segu.testructura_gui set

                     id_gui=v_parametros.id_gui,
                     fk_id_gui=v_parametros.fk_id_gui

               where id_estructura_gui=v_parametros.id_estructura_gui;
                v_resp = f_agrega_clave(v_resp,'mensaje','Estructura Gui modificado con exito: '||v_parametros.id_estructura_gui);
                v_resp = f_agrega_clave(v_resp,'id_estructura_gui',v_parametros.id_estructura_gui::varchar);




          END;


 /*******************************
 #TRANSACCION:  SEG_ESTGUI_ELI
 #DESCRIPCION:	Elimina Estructura gui
 #AUTOR:		Jaime Rivera Rojas	
 #FECHA:		08/01/11	
***********************************/
    elsif(par_transaccion='SEG_ESTGUI_ELI')then

         
          BEGIN
               update segu.testructura_gui set estado_reg='inactivo'
               where id_estructura_gui=v_parametros.id_estructura_gui;
               v_resp = f_agrega_clave(v_resp,'mensaje','Estructura Gui modificado con exito: '||v_parametros.id_estructura_gui);
               v_resp = f_agrega_clave(v_resp,'id_estructura_gui',v_parametros.id_estructura_gui::varchar);
         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     return v_resp;

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;



END;
$$;


--
-- TOC entry 1791 (class 1255 OID 208312)
-- Dependencies: 20 3246
-- Name: ft_estructura_gui_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_estructura_gui_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_estructura_gui_sel
 DESCRIPCION:   consultas de estructura_gui
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp          varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_estructura_gui_sel';


 /*******************************
 #TRANSACCION:  SEG_ESTGUI_SEL
 #DESCRIPCION:	Selecciona Estructura gui
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_ESTGUI_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select id_estructura_gui,
                            id_gui,
                            fk_id_gui,
                            fecha_reg,
                            estado_reg
                        from segu.testructura_gui estgui
                        inner join segu.tgui guihij
                        on guihij.id_gui=estgui.id_gui
                        inner join segu.tgui guipad
                        on guipad.id_gui=estgui.fk_id_gui where
                        guihij.estado_reg=''activo'' and guipad.estado_reg=''activo'' and
                        estgui. estado_reg=''activo'' and ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


 /*******************************
 #TRANSACCION:  SEG_ESTGUI_CONT
 #DESCRIPCION:	Cuenta Estructura gui
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_ESTGUI_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(id_estructura_gui) from segu.testructura_gui estgui
                        inner join segu.tgui guihij
                        on guihij.id_gui=estgui.id_gui
                        inner join segu.tgui guipad
                        on guipad.id_gui=estgui.fk_id_gui where
                        guihij.estado_reg=''activo'' and guipad.estado_reg=''activo'' and
                        estgui. estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1792 (class 1255 OID 208313)
-- Dependencies: 20 3246
-- Name: ft_funcion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_funcion_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_funcion_ime
 DESCRIPCIÓN:   modificaciones de funciones
 AUTOR: 		KPLIAN(rac)		
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(rac)		
 FECHA:		27/11/10
***************************************************************************/
DECLARE


v_parametros                record;
v_resp                		varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_sinc_funcion_subsis       varchar;
v_id_funcion  				integer;

BEGIN

     v_nombre_funcion:='segu.ft_funcion_ime';
     v_parametros:=f_get_record(par_tabla);             
     
 /*******************************    
 #TRANSACCION:  SEG_FUNCIO_INS
 #DESCRIPCION:	Inserta Funciones
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		16-11-2010	
***********************************/
     if(par_transaccion='SEG_FUNCIO_INS')then

        
          BEGIN
          
          --insercion de nueva funcion
               INSERT INTO segu.tfuncion(nombre, descripcion,id_subsistema)
               values(v_parametros.nombre,v_parametros.descripcion,v_parametros.id_subsistema)
               returning  id_funcion into v_id_funcion;

               v_resp = f_agrega_clave(v_resp,'mensaje','Funcion insertada con exito '||v_id_funcion); 
               v_resp = f_agrega_clave(v_resp,'id_funcion',v_id_funcion::varchar);


         END;     
         
 /*******************************    
 #TRANSACCION:  SEG_FUNCIO_MOD
 #DESCRIPCION:	Modifica la funcion seleccionada 
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		16-11-2010	
***********************************/
     elsif(par_transaccion='SEG_FUNCIO_MOD')then

          
          BEGIN
               --modificacion de funciones
               update segu.tfuncion set

                     nombre=v_parametros.id_gui,
                     descripcion=v_parametros.descripcion,
                     id_subsistema=v_parametros.id_subsistema

               where id_funcion=v_parametros.id_funcion;

               v_resp = f_agrega_clave(v_resp,'mensaje','Funcion modificada con exito '||v_parametros.id_funcion); 
               v_resp = f_agrega_clave(v_resp,'id_funcion',v_parametros.id_funcion::varchar);

             
          END;
          
/*******************************    
 #TRANSACCION:   SEG_FUNCIO_ELI
 #DESCRIPCION:	Inactiva las funcion selecionada 
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		16-11-2010	
***********************************/

    elsif(par_transaccion='SEG_FUNCIO_ELI')then
        BEGIN
        
         --inactivacion de la funcion
               DELETE FROM segu.tfuncion 
               where id_funcion=v_parametros.id_funcion;
               return 'Funcion eliminada con exito';
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Funcion eliminada con exito: '||v_parametros.id_funcion); 
               v_resp = f_agrega_clave(v_resp,'id_funcion',v_parametros.id_funcion::varchar);

               
        END;                    
        
/*******************************    
 #TRANSACCION:  SEG_SINCFUN_MOD
 #DESCRIPCION:	Este proceso busca todas las funciones de base de datos para el esquema seleccionado
                las  introduce en la tabla de fucniones luego revisa el cuerpo de la funcion 
                y saca los codigos de procedimiento y sus descripciones
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		16-11-2010	
***********************************/
        
    elsif(par_transaccion='SEG_SINCFUN_MOD') then
        BEGIN
             --sincronizacion de la funciones de un subsistema a partir de los metadatos der SGBD
        
             v_sinc_funcion_subsis:=(select segu.f_sinc_funciones_subsistema(v_parametros.id_subsistema));
             
             v_resp = f_agrega_clave(v_resp,'mensaje','Funcion sincronizadas con exito para el sistema '||v_parametros.id_subsistema); 
             v_resp = f_agrega_clave(v_resp,'id_subsistema',v_parametros.id_subsistema::varchar);
        END;
    else

         raise exception 'No existe la transaccion: %',par_transaccion;
    end if;
    
 return v_resp;  

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1793 (class 1255 OID 208314)
-- Dependencies: 20 3246
-- Name: ft_funcion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_funcion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_funcion_sel
 DESCRIPCIÓN:   listado de interfaces en formato arbol
 AUTOR: 		KPLIAN(rac)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(rac)		
 FECHA:		27/11/10
***************************************************************************/


DECLARE


v_consulta   		varchar;
v_parametros  		record;
v_nombre_funcion  	text;
v_mensaje_error    	text;
v_resp              varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_funcion_sel';   
     
/*******************************    
 #TRANSACCION:  SEG_FUNCIO_SEL
 #DESCRIPCION:	Listado de funciones registradas del sistema
 #AUTOR:		Rensi Arteaga Copari	
 #FECHA:		27/11/10	
***********************************/

     if(par_transaccion='SEG_FUNCIO_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                             funcio.id_funcion,
                             funcio.nombre,
                             funcio.descripcion,
                             funcio.fecha_reg,
                             funcio.id_subsistema,
                             funcio.estado_reg
                             FROM segu.tfuncion funcio 
                             INNER JOIN  segu.tsubsistema subsis 
                             on subsis.id_subsistema=funcio.id_subsistema
                             WHERE funcio.estado_reg=''activo'' and funcio.id_subsistema = '|| v_parametros.id_subsistema || '  and ';
               
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;
         
/*******************************    
 #TRANSACCION:  SEG_FUNCIO_CONT
 #DESCRIPCION:	Contar  funciones registradas del sistema
 #AUTOR:		Rensi Arteaga Copari	
 #FECHA:		27/11/10	
***********************************/
     elsif(par_transaccion='SEG_FUNCIO_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(funcio.id_funcion)
                            FROM segu.tfuncion funcio 
                            INNER JOIN  segu.tsubsistema subsis 
                            on subsis.id_subsistema=funcio.id_subsistema
                            WHERE funcio.estado_reg=''activo'' and  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;      
END;
$$;


--
-- TOC entry 1794 (class 1255 OID 208315)
-- Dependencies: 20 3246
-- Name: ft_gui_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_gui_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 CAPA:          MODELO
 FUNCION: 		segu.ft_gui_ime
 DESCRIPCIÓN: 	Permite la gestion de interfaces 
                de usario con todas sus operaciones basicas                
 AUTOR: 		KPLIAN(rac)	
 FECHA:			19/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:
***************************************************************************/
DECLARE


v_parametros 				record;
v_respuesta           		varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_id_gui                    integer;
v_resp          			varchar;
v_cont_padre    			integer;
v_cont_hijo      			integer;
v_cont_prodecimiento_hijo 	integer;
v_cont_rol				  	integer;
v_nivel                 	integer;	
v_tipo_dato              	varchar;
v_orden_logico integer;

BEGIN

     v_nombre_funcion:='segu.ft_gui_ime';
     v_parametros:=f_get_record(par_tabla); 
     
 /*******************************    
 #TRANSACCION:	SEG_GUIDD_IME
 #DESCRIPCION:	Inserta interfaces en el arbol
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		02-03-2012
 #RESUMEN:		1) si point es igual append
                  1.1) eliminamos la relacion de dependecias con el anterior padre
                  1.2) verificamos orden_logico mayor de los hijos del nodo target
                  1.3) insertamos como nodo hijo del target 
                  1.4) modificamos el orden logico del nodo para que sea el ultimo en el listado
 				2) regresar error point no soportados
                
                
***********************************/

     if(par_transaccion='SEG_GUIDD_IME')then                
          BEGIN
           
        --  1) si point es igual append
        IF(v_parametros.punto='append')then 
        
        --raise exception '% % %',v_parametros.id_target,v_parametros.id_nodo,v_parametros.id_olp_parent;
        --  1.1) eliminamos la relacion de dependecias con el anterior padre
               DELETE FROM segu.testructura_gui
                      WHERE id_gui=v_parametros.id_nodo  
                      AND  fk_id_gui=v_parametros.id_olp_parent;
            --  1.2) verificamos orden_logico mayor de los hijos den nodo target
                    select orden_logico 
                    into v_orden_logico
                    FROM segu.tgui g 
                    inner join segu.testructura_gui eg on eg.id_gui = g.id_gui
                    WHERE eg.fk_id_gui = v_parametros.id_target
                    order by g.orden_logico desc
                    limit 1 offset 0;
            
            --  1.3) insertamos como nodo hijo del target
            
               insert into segu.testructura_gui(
                               id_gui,
                               fk_id_gui
                               )
                        values(
                               v_parametros.id_nodo,
                               v_parametros.id_target); 
            
             --  1.4) modificamos el orden logico del nodo para que sea el ultimo en el listado
             
                update segu.tgui set
                orden_logico=v_orden_logico+1
                where id_gui=v_parametros.id_nodo;
              
        ELSE
 		  --	2) regresar error point no soportados
          raise exception 'POINT no soportado %',v_parametros.punto;
        
        END IF;
          
        
               
               v_resp = f_agrega_clave(v_resp,'mensaje','DRANG AND DROP exitoso id_gui='||v_parametros.id_nodo||' id_target= '|| v_parametros.id_target||'  id_old_gui='|| v_parametros.id_olp_parent); 
               --datos obligados a regresar para configurar el 
               --traslado del nodo si regargar el padre
               --v_resp = f_agrega_clave(v_resp,'id_gui',v_parametros.id_nodo::varchar);--nuevo ide del nodo
               v_resp = f_agrega_clave(v_resp,'id_p',v_parametros.id_target::varchar);--nuevo id del padre
               v_resp = f_agrega_clave(v_resp,'id_gui_padre',v_parametros.id_target::varchar);--nuevo id del padre
               v_resp = f_agrega_clave(v_resp,'orden_logico',v_orden_logico::varchar);--algun dato extra
               return v_resp;  
                    
        END;
     
     
/*******************************    
 #TRANSACCION:	SEG_GUI_INS
 #DESCRIPCION:	Inserta interfaces en el arbol
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		10-10-2010
 #RESUMEN:		1) inserta la intergace en la tabla t_gui
 				2) inserta la relacion con el padre y la interface recien
                creada en estructura_gui              
***********************************/
     elseif(par_transaccion='SEG_GUI_INS')then                
          BEGIN
          --0) calcula el nivel del nodo padre
            select g.nivel into v_nivel 
               from segu.tgui g 
               where g.id_gui = v_parametros.id_gui_padre;                     
              
          -- 1) inserta la intergace en la tabla t_gui
          
            insert into  segu.tgui(
                                
                                codigo_gui,
                                nombre, 
                                descripcion, 
                                visible,
                                orden_logico,
                                ruta_archivo,
                                nivel,
                                icono,
                                --id_subsistema,
                                clase_vista)
                         values(
                              
                                v_parametros.codigo_gui,
                                v_parametros.nombre,
                                v_parametros.descripcion,
                                v_parametros.visible,
                                v_parametros.orden_logico,
                                v_parametros.ruta_archivo,
                                v_nivel+1, 
                                v_parametros.icono,
                                --v_parametros.id_subsistema,
                                v_parametros.clase_vista)
                         RETURNING id_gui into v_id_gui;
                            

          --  1) inserta la relacion con el padre y la interface recien creada en estructura_gui
              
             
          	--introcude la relacion con el nodo padre
          
               insert into segu.testructura_gui(
                           id_gui,
                           fk_id_gui
                           )
                    values(
                           v_id_gui,
                           v_parametros.id_gui_padre);
               
               v_resp = f_agrega_clave(v_resp,'mensaje','GUI insertada con exito '||v_id_gui); 
               v_resp = f_agrega_clave(v_resp,'id_gui',v_id_gui::varchar);
               return v_resp;  
                    
        END;
        
 /*******************************    
 #TRANSACCION:  SEG_FUNCIO_MOD
 #DESCRIPCION:	Modifica la interfaz del arbol seleccionada 
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		10-10-2010
***********************************/
     elsif(par_transaccion='SEG_GUI_MOD')then        
          
          BEGIN
          if(v_parametros.ruta_archivo is null or v_parametros.ruta_archivo='') then
          v_tipo_dato:='carpeta';
          else
          v_tipo_dato:='interface';
          end if;
          

               IF v_tipo_dato='carpeta' THEN
               
                  update segu.tgui set

                       codigo_gui=v_parametros.codigo_gui,
                       visible=v_parametros.visible,
                       nombre=v_parametros.nombre,
                       descripcion=v_parametros.descripcion,
                       orden_logico=v_parametros.orden_logico
                       --id_subsistema=v_parametros.id_subsistema

                 where id_gui=v_parametros.id_gui;
              
               ELSEIF v_tipo_dato='interface' THEN
                
                 update segu.tgui set

                       codigo_gui=v_parametros.codigo_gui,
                       visible=v_parametros.visible,
                       nombre=v_parametros.nombre,
                       descripcion=v_parametros.descripcion,
                       orden_logico=v_parametros.orden_logico,
                       ruta_archivo=v_parametros.ruta_archivo,                      
                       icono=v_parametros.icono,
                       --id_subsistema=v_parametros.id_subsistema,
                       clase_vista=v_parametros.clase_vista

                 where id_gui=v_parametros.id_gui;  
                 
               END IF;          
               
               v_resp = f_agrega_clave(v_resp,'mensaje','GUI modificada con exito '||v_parametros.id_gui);
               v_resp = f_agrega_clave(v_resp,'id_gui',v_parametros.id_gui::varchar);
               
               return 'GUI '||v_parametros.id_gui||' modificado con exito';
          END;
          
 /*******************************    
 #TRANSACCION:  SEG_GUI_ELI
 #DESCRIPCION:	Inactiva la interfaz del arbol seleccionada 
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		03-10-2010
 #RESUMEN:		0) Verificamos que el uig no tenga roles asociados
 				1) Verificamos que el gui no tenga mas de un padre
                    
                2.1) IF si tiene mas de un padre 
                	2.1.1)  solamente eliminamos la relacion con el padre indicado 
                    en estructura_gui
                             
                2.2) ELSE si solo tiene un padre
                	2.2.0) Contamos cueantos gui hijos tiene el nodo que se quiere eliminar
                    2.2.1) Contamos cuantos procedimientos hijo tiene  el nodo que se quiere eliminar
                	2.2.2) IF si no tienen hijos eliminamos su relacion con el padre
                    en estructura_gui
                    	2.2.2.1) eliminamos el gui
                	2.2.3) ELSE Retornamos un error
***********************************/
    elsif(par_transaccion='SEG_GUI_ELI')then          
         
          BEGIN
                             
                v_cont_padre=0;                     
    
          --0) verificamos que el gui no tenga roles asociados
           v_cont_rol=0;
           SELECT 
               count(gr.id_gui_rol)
           INTO
                   v_cont_rol
           FROM segu.tgui_rol gr
           WHERE gr.id_gui=v_parametros.id_gui and gr.estado_reg='activo';
           
           IF  (v_cont_rol > 0) THEN
           
           raise exception 'La interface no puede eliminarce por que tiene roles relacionados';
           END IF;                  
                                             
          --1) verificamos que el gui no tenga mas de un padre
           SELECT 
               count(eg.fk_id_gui)
           INTO
                   v_cont_padre
           FROM segu.testructura_gui eg
           WHERE id_gui=v_parametros.id_gui;
          
             --2.1) IF si tiene mas de un padre 
            IF  (v_cont_padre > 1) THEN      
              
              -- 2.1.1)  solamente eliminamos la relacion con el padre indicado en estructura_gui
                    update segu.testructura_gui
                            set estado_reg='inactivo'
                    WHERE     id_gui=v_parametros.id_gui  
                       AND  fk_id_gui=v_parametros.id_gui_padre;
              
           -- 2.2) ELSEIF si solo tiene un padre
              
           ELSEIF v_cont_padre = 1 THEN
              
              -- 2.2.0) Contamos cueantos gui hijos tiene el nodo que se quiere eliminar                  SELECT 
                     
                      v_cont_hijo=0;
                      
                      SELECT
                        count(eg.id_gui)
                      INTO
                         v_cont_hijo
                      FROM segu.testructura_gui eg
                      WHERE fk_id_gui=v_parametros.id_gui;
                      
              -- 2.2.1) Contamos cuantos procedimientos hijo tiene  el nodo que se quiere eliminar
                      
                      v_cont_prodecimiento_hijo=0;
                      SELECT 
                         count(pg.id_procedimiento)
                      INTO
                         v_cont_prodecimiento_hijo
                      FROM segu.tprocedimiento_gui pg
                      WHERE pg.id_gui=v_parametros.id_gui;
                      
               
              -- 2.2.2) IF si no tienen hijos
                IF (v_cont_prodecimiento_hijo = 0 AND v_cont_hijo = 0) THEN 
                    
                    -- 2.2.2.1 eliminamos su relacion con el padre en estructura_gui
                    DELETE FROM segu.testructura_gui
                    WHERE     id_gui=v_parametros.id_gui  
                         AND  fk_id_gui=v_parametros.id_gui_padre;
                
                     -- 2.2.2.2) eliminamos el gui
                    
                    update segu.tgui set estado_reg='inactivo'
                    WHERE  id_gui=v_parametros.id_gui;
                    
                    -- 2.2.3) ELSE Retornamos un error 
                 
                 ELSE
              
                   raise exception 'La interfaz que quiera elimminar tiene nodos dependientes';
                   
                 END IF;
              
          -- 2.3) ELSEIF no tiene un padre
              
           ELSE
              --2.3.1 retornamos un error de consistencia todos los gui deberian tener padre
              --(excepto la raiz que no puede eliminarce)
            
                raise exception 'No puede eliminar la interfaz raiz';
              
           END IF;

             v_resp = f_agrega_clave(v_resp,'mensaje','GUI eliminado con exito '||v_parametros.id_gui); 
             v_resp = f_agrega_clave(v_resp,'id_gui',v_parametros.id_gui::varchar);

            return v_resp;
               
         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

       	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


--
-- TOC entry 1795 (class 1255 OID 208318)
-- Dependencies: 20 3246
-- Name: ft_gui_rol_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_gui_rol_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************

 FUNCION: 		segu.ft_gui_rol_ime
 DESCRIPCIÓN: 	registro de permisos sobre gui y procedimiento en roles
 AUTOR: 		KPLIAN(jrr)	
 FECHA:			19/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE

v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion       text;
v_mensaje_error        text;
v_accion               varchar;
v_resp                 varchar;

BEGIN

     v_nombre_funcion:='segu.ft_gui_rol_ime';
     v_parametros:=f_get_record(par_tabla); 
     
 /*******************************    
 #TRANSACCION:  SEG_GUIROL_INS
 #DESCRIPCION:	Modifica los permisos del un rol ID_ROL sobre un  tipo TIPO
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		19-07-2010	
***********************************/

     if(par_transaccion='SEG_GUIROL_INS')then

        
          BEGIN
               if(v_parametros.checked='true')then
                   v_accion='dar';
               else
                   v_accion='quitar';
               end if;
               
               if(v_parametros.tipo='gui')then
                   v_respuesta:=segu.f_permiso_rol(v_parametros.id,null,v_parametros.id_rol,v_accion,'subir_bajar');
               else
                   v_respuesta:=segu.f_permiso_rol(null,v_parametros.id,v_parametros.id_rol,v_accion,'subir_bajar');
               end if;   
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Se modifico con exito los permisos del rol '||v_parametros.id_rol ||' sobre '|| v_parametros.tipo ||'  id='||v_parametros.id); 
               v_resp = f_agrega_clave(v_resp,'id_rol',v_parametros.id_rol::varchar);
    
         END;          
   
     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     
   return v_resp; 

EXCEPTION

       WHEN OTHERS THEN

       	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


--
-- TOC entry 1775 (class 1255 OID 208319)
-- Dependencies: 20 3246
-- Name: ft_gui_rol_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_gui_rol_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.fr_gui_rol_sel
 DESCRIPCIÓN: 	listado de interfaces con privilegios sobre procedimientos
                segun el rol especificado                     
 AUTOR: 		KPLIAN(rac)	
 FECHA:			26/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/


DECLARE



v_consulta    		varchar;
v_parametros  		record;
v_nombre_funcion	text;
v_mensaje_error		text;
v_id_padre         	integer;

v_resp              varchar;
v_where 			varchar;
                            

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

 --raise exception 'XXXXXXXXXXXXXXXXXXXXxxx   No existe la opcion';

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_gui_rol_sel';

/*******************************    
 #TRANSACCION:  SEG_GUIROL_SEL
 #DESCRIPCION:	Listado de interfaces con privilegios sobre procedimientos
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		26/07/10	
***********************************/
     if(par_transaccion='SEG_GUIROL_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                             estgui.id_estructura_gui,
                             gui.id_gui,
                             gui.id_subsistema,
                             subsis.nombre as desc_subsistema,
                             gui_padre.id_gui as id_p,
                             gui.nivel,
                             coalesce(gui.nombre,'' '') as nombre,
                             gui.descripcion,
							 gui.codigo_gui,
                             gui.visible,
                             gui.orden_logico,
                             gui.ruta_archivo,
							 gui.icono,
                                (case
                                 when exists (  SELECT 1
                                                FROM segu.tgui_rol gr
                                                WHERE gr.id_gui=gui.id_gui
                                                AND gr.estado_reg=''activo'' 
                                                AND gr.id_rol='||v_parametros.id_rol||')then
                                   ''true''
                                 ELSE
                                    ''false''
                                 end)::varchar as checked,
                               -- (''gui''::varchar) as tipo_meta,
                                 case
                                        when (gui.ruta_archivo is null or gui.ruta_archivo='''')then
                                             ''carpeta''::varchar
                                        ELSE
                                            ''interface''::varchar
                                        END as tipo_meta,
                                
                                (gui.id_gui||''_gui'')::varchar  as id_nodo,
                                
                                '||v_parametros.id_rol||'::integer as id_rol
                        FROM segu.tgui gui 
                        LEFT JOIN segu.tsubsistema subsis 
                         ON subsis.id_subsistema=gui.id_subsistema
                        LEFT JOIN segu.testructura_gui estgui 
                         ON estgui.id_gui=gui.id_gui
                        LEFT JOIN segu.tgui gui_padre 
                         ON gui_padre.id_gui=estgui.fk_id_gui
                        WHERE gui.estado_reg=''activo'' and gui_padre.estado_reg=''activo'' ';
              

              if(v_parametros.id_padre = '%') then
                v_id_padre:=0;
              --  v_consulta:=v_consulta|| ' AND gui.id_subsistema= '|| v_parametros.id_subsistema;
              else
                v_id_padre:=v_parametros.id_padre;
              end if;
--raise exception 'sss%',v_id_padre;
               v_consulta:=v_consulta|| ' AND estgui.fk_id_gui= '|| v_id_padre;
               --v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               
              -- raise exception '%',v_consulta;
              
            --  v_consulta='select id_gui from segu.tgui gui';
              
               return v_consulta;


         END;

/*******************************    
 #TRANSACCION:  SEG_GUIROL_CONT
 #DESCRIPCION:	Contar las interfaces con privilegios sobre procedimientos
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		26/07/10	
***********************************/    
     elsif(par_transaccion='SEG_GUIROL_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(guirol.id_gui_rol)
                            FROM segu.tgui_rol guirol 
                            INNER JOIN segu.tgui gui 
                              ON gui.id_gui=guirol.id_gui
                            INNER JOIN segu.trol rol
                              ON rol.id_rol=guirol.id_rol 
                            WHERE guirol.estado_reg=''activo'' and   ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;


EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;          
END;
$$;


--
-- TOC entry 1796 (class 1255 OID 208322)
-- Dependencies: 20 3246
-- Name: ft_gui_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_gui_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.fgui_wel
 DESCRIPCIÓN:   listado de interfaces en formato arbol
 AUTOR: 		KPLIAN(rac)	
 FECHA:			26/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/
                                                                          
DECLARE            

v_consulta    		varchar;
v_parametros  		record;
v_nombre_funcion   	text;
v_mensaje_error    	text;
v_id_padre         	integer;

v_resp             	varchar;
v_where 			varchar;
v_join  			varchar;      

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_gui_sel';

/*******************************    
 #TRANSACCION:  SEG_GUI_SEL
 #DESCRIPCION:	Listado de interfaces en formato de arbol
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		26/07/10
 *******************************    
 #DESCRIPCION:	se modifica el filtro inicial para que considera nivel 0 o nivel 1
 #AUTOR_MOD:		KPLIAN(rac)		
 #FECHA_MOD:		22/11/11	
***********************************/
     if(par_transaccion='SEG_GUI_SEL')then

          --consulta:=';
          BEGIN
          
              if(v_parametros.id_padre = '%') then
                v_where := '  (g.nivel = 1 or  g.nivel = 0)
                              AND  g.id_subsistema = '||v_parametros.id_subsistema;
                 v_join:= 'LEFT';      
                      
              else
                v_where := ' eg.fk_id_gui = '||v_parametros.id_padre;
                v_join := 'INNER';
              end if;
          

                               v_consulta =  'SELECT
                                        g.id_gui,
                                        g.id_subsistema,
                                        eg.fk_id_gui as id_gui_padre,
                                        g.codigo_gui,
                                        g.nombre,
                                        g.descripcion,
                                        g.nivel,
                                        g.visible,
                                        g.orden_logico,
                                        g.ruta_archivo,
                                        g.icono,
                                        g.clase_vista,
                                        case
                                        when (g.ruta_archivo is null or g.ruta_archivo='''')then
                                             ''carpeta''::varchar
                                        ELSE
                                            ''interface''::varchar
                                        END as tipo_dato,
                                        case
                                           when (g.ruta_archivo is null or g.ruta_archivo = '''') then 
                                           (g.id_gui||''_carpeta'')::varchar
                                           ELSE 
                                           (g.id_gui||''_interface'')::varchar
                                         END 
                                         as id_nodo
                                  FROM segu.tgui g
                                       '||v_join||' JOIN segu.testructura_gui eg
                                       ON g.id_gui=eg.id_gui
                                   WHERE '|| v_where ||' 
                       
                                  ORDER BY g.orden_logico, eg.fk_id_gui';
               
               return v_consulta;


         END;

/*******************************    
 #TRANSACCION:  SEG_GUI_CONT
 #DESCRIPCION:	Contar  vistas registradas del sistema
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		26/07/10	
***********************************/
     elsif(par_transaccion='SEG_GUI_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(gui.id_gui)
                        from segu.tgui gui inner join
                        segu.subsistema subsis on subsis.id_subsistema=gui.id_subsistema
                        left join segu.testructura_gui estgui on estgui.id_gui=gui.id_gui
                        left join segu.tgui gui_padre on gui_padre.id_gui=estgui.fk_id_gui
                        where gui.estado_reg=''activo'' and gui_padre.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               
               if(v_parametros.id_padre like '%') then
                v_id_padre:=0;
              else
                v_id_padre:=v_parametros.id_padre;
              end if;
              v_consulta:=v_consulta|| ' and estgui.fk_id_gui= '||v_id_padre;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;      
END;
$$;


--
-- TOC entry 1797 (class 1255 OID 208323)
-- Dependencies: 20 3246
-- Name: ft_horario_trabajo_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_horario_trabajo_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************

 FUNCION: 		segu.ft_horario_trabajo_ime
 DESCRIPCIÓN: 	
 AUTOR: 		KPLIAN(jrr)	
 FECHA:			
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE

v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion       text;
v_mensaje_error        text;
v_accion               varchar;
v_resp                 varchar;

BEGIN

     v_nombre_funcion:='segu.ft_horario_trabajo_ime';
     v_parametros:=f_get_record(par_tabla); 
     

     if(par_transaccion='SEG_HORTRA_INS')then

        --raise exception 'lelga%',v_parametros.hora_ini;--||'---'||(select to_char(v_parametros.hora_ini,'HH24:mm'));
          BEGIN
              INSERT INTO segu.thorario_trabajo (
                          dia_semana,
                          hora_ini,
                          hora_fin
                           )

               values(     v_parametros.dia_semana,
                           v_parametros.hora_ini,
                           v_parametros.hora_fin);


               v_resp = f_agrega_clave(v_resp,'mensaje','Horario de Trabajo insertado con exito ');
               v_resp = f_agrega_clave(v_resp,'horario_trabajo',1::varchar);
    
         END;          
   
     elsif(par_transaccion='SEG_HORTRA_MOD')then


          BEGIN
               --modificacion de tipo_obligacion
                update segu.thorario_trabajo
                set
                          dia_semana=v_parametros.dia_semana,
                          hora_ini=v_parametros.hora_ini,
                          hora_fin=v_parametros.hora_fin
                where id_horario_trabajo=v_parametros.id_horario_trabajo;

                v_resp = f_agrega_clave(v_resp,'mensaje','horario_trabajo modificado con exito '||v_parametros.id_horario_trabajo);
                v_resp = f_agrega_clave(v_resp,'id_horario_trabajo',v_parametros.id_horario_trabajo::varchar);
          END;
     elsif(par_transaccion='SEG_HORTRA_ELI')then
        BEGIN

         --inactivacion de tipo_obligacion
              delete from segu.thorario_trabajo
              where id_horario_trabajo=v_parametros.id_horario_trabajo;

               v_resp = f_agrega_clave(v_resp,'mensaje','horario_trabajo eliminado con exito '||v_parametros.id_horario_trabajo);
               v_resp = f_agrega_clave(v_resp,'horario_trabajo',v_parametros.id_horario_trabajo::varchar);

        END;
     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     
   return v_resp; 

EXCEPTION

       WHEN OTHERS THEN

       	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


--
-- TOC entry 1801 (class 1255 OID 208324)
-- Dependencies: 20 3246
-- Name: ft_horario_trabajo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_horario_trabajo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.fhorario_trabajo_sel
 DESCRIPCIÓN:   listado de horario de trabajo
 AUTOR: 		KPLIAN(jrr)	
 FECHA:			
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/
                                                                          
DECLARE            

v_consulta    		varchar;
v_parametros  		record;
v_nombre_funcion   	text;
v_mensaje_error    	text;
v_id_padre         	integer;

v_resp             	varchar;
v_where 			varchar;
v_join  			varchar;      

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_horario_trabajo_sel';


     if(par_transaccion='SEG_HORTRA_SEL')then

          --consulta:=';
          BEGIN
          
              v_consulta =  'SELECT
                             HORTRA.id_horario_trabajo,
                             HORTRA.dia_semana,
                             HORTRA.hora_ini,
                             HORTRA.hora_fin,
                             (f_iif(to_char(HORTRA.dia_semana,''d'') = ''1'',''Domingo'',f_iif(to_char(HORTRA.dia_semana,''d'') = ''2'',''Lunes'',f_iif(to_char(HORTRA.dia_semana,''d'') = ''3'',''Martes'', f_iif(to_char(HORTRA.dia_semana,''d'') = ''4'',''Jueves'',f_iif(to_char(HORTRA.dia_semana,''d'') = ''5'',''Viernes'',''Sabado'')))))) ::varchar as dia_literal

                             from segu.thorario_trabajo HORTRA
                             WHERE
                             ';
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;
         END;

     elsif(par_transaccion='SEG_HORTRA_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(HORTRA.id_horario_trabajo)
                            from segu.thorario_trabajo HORTRA  WHERE ';
               v_consulta:=v_consulta||v_parametros.filtro;
               --v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;      
END;
$$;


--
-- TOC entry 1802 (class 1255 OID 208325)
-- Dependencies: 20 3246
-- Name: ft_libreta_her_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_libreta_her_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_libreta_her_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'segu.libreta_her'
 AUTOR: 		 (rac)
 FECHA:	        18-06-2012 16:45:50
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_libreta_her	integer;
			    
BEGIN

    v_nombre_funcion = 'segu.ft_libreta_her_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SG_LIB_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		rac	
 	#FECHA:		18-06-2012 16:45:50
	***********************************/

	if(p_transaccion='SG_LIB_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into segu.libreta_her(
			estado_reg,
			telefono,
			nombre,
			obs,
			id_usuario_reg,
			fecha_reg,
			id_usuario_mod,
			fecha_mod
          	) values(
			'activo',
			v_parametros.telefono,
			v_parametros.nombre,
			v_parametros.obs,
			p_id_usuario,
			now(),
			null,
			null
			)RETURNING id_libreta_her into v_id_libreta_her;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','LIBRETA almacenado(a) con exito (id_libreta_her'||v_id_libreta_her||')'); 
            v_resp = f_agrega_clave(v_resp,'id_libreta_her',v_id_libreta_her::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'SG_LIB_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		rac	
 	#FECHA:		18-06-2012 16:45:50
	***********************************/

	elsif(p_transaccion='SG_LIB_MOD')then

		begin
			--Sentencia de la modificacion
			update segu.libreta_her set
			telefono = v_parametros.telefono,
			nombre = v_parametros.nombre,
			obs = v_parametros.obs,
			id_usuario_mod = p_id_usuario,
			fecha_mod = now()
			where id_libreta_her=v_parametros.id_libreta_her;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','LIBRETA modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_libreta_her',v_parametros.id_libreta_her::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'SG_LIB_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		rac	
 	#FECHA:		18-06-2012 16:45:50
	***********************************/

	elsif(p_transaccion='SG_LIB_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from segu.libreta_her
            where id_libreta_her=v_parametros.id_libreta_her;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','LIBRETA eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_libreta_her',v_parametros.id_libreta_her::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 1803 (class 1255 OID 208326)
-- Dependencies: 20 3246
-- Name: ft_libreta_her_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_libreta_her_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_libreta_her_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'segu.libreta_her'
 AUTOR: 		 (rac)
 FECHA:	        18-06-2012 16:45:50
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'segu.ft_libreta_her_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'SG_LIB_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		rac	
 	#FECHA:		18-06-2012 16:45:50
	***********************************/

	if(p_transaccion='SG_LIB_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						lib.id_libreta_her,
						lib.estado_reg,
						lib.telefono,
						lib.nombre,
						lib.obs,
						lib.id_usuario_reg,
						lib.fecha_reg,
						lib.id_usuario_mod,
						lib.fecha_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from segu.libreta_her lib
						inner join segu.tusuario usu1 on usu1.id_usuario = lib.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = lib.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'SG_LIB_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rac	
 	#FECHA:		18-06-2012 16:45:50
	***********************************/

	elsif(p_transaccion='SG_LIB_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_libreta_her)
					    from segu.libreta_her lib
					    inner join segu.tusuario usu1 on usu1.id_usuario = lib.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = lib.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1804 (class 1255 OID 208327)
-- Dependencies: 20 3246
-- Name: ft_log_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_log_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_log_sel
 DESCRIPCIÓN:   listado de los eventos (log) del sistema
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:
 AUTOR:		
 FECHA:	
***************************************************************************/

DECLARE                  

v_consulta    varchar;
v_parametros  record;
v_resp          varchar;
v_nombre_funcion   text;
v_mensaje_error    text;
v_res_actualiz    varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(p_tabla);
     v_nombre_funcion:='segu.f_t_log_sel';

/*******************************    
 #TRANSACCION:  SEG_LOGMON_SEL
 #DESCRIPCION:	Listado del monitoreo de eventos del  XPH sistema
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     if(p_transaccion='SEG_LOGMON_SEL')then

          --consulta:=';
          BEGIN
-- to_char(logg.fecha_reg,''dd/mm/yyyy hh24:mi:ss''),


               v_consulta:='select logg.id_log,
                            logg.id_usuario,
                            logg.cuenta_usuario,
                            logg.mac_maquina,
                            logg.ip_maquina,
                            logg.tipo_log,
                            logg.descripcion,
                            logg.fecha_reg,
                            logg.procedimientos,
                            logg.transaccion,
                            logg.consulta,
                            logg.usuario_base,
                            logg.tiempo_ejecucion,
                            logg.pid_web,
                            logg.pid_db,
                            logg.sid_web,
                            logg.codigo_error,
                            logg.descripcion_transaccion,
                            logg.codigo_subsistema
                            
                        from segu.vlog logg
                        where  ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************    
 #TRANSACCION:  SEG_LOGMON_CONT
 #DESCRIPCION:	Contar registros del monitor de enventos del sistema(Actualiza eventos de BD)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_LOGMON_CONT')then

          --consulta:=';
          BEGIN
                /*Actualiza eventos de BD*/
                v_res_actualiz=segu.f_actualizar_log_bd (v_parametros.archivo_log);
                
               v_consulta:='select count(logg.id_log)
                              from segu.vlog logg
                           where  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
     elsif(p_transaccion='SEG_LOG_SEL')then

          --consulta:=';
          BEGIN
-- to_char(logg.fecha_reg,''dd/mm/yyyy hh24:mi:ss''),

            if(not exists (select 1
                FROM pg_namespace n
                INNER JOIN pg_class c ON c.relnamespace = n.oid
                where n.nspname like 'log'
                and c.relkind='r' and
                c.relname='tlog_'||v_parametros.gestion||'_'||v_parametros.periodo))then
                raise exception 'No se tienen registros para la gestion y periodo seleccionados';
            end if;

               v_consulta:='select logg.id_log,
                            logg.id_usuario,
                            logg.cuenta_usuario,
                            logg.mac_maquina,
                            logg.ip_maquina,
                            logg.tipo_log,
                            logg.descripcion,
                            logg.fecha_reg,
                            logg.procedimientos,
                            logg.transaccion,
                            logg.consulta,
                            logg.usuario_base,
                            logg.tiempo_ejecucion,
                            logg.pid_web,
                            logg.pid_db,
                            logg.sid_web,
                            logg.codigo_error,
                            logg.descripcion_transaccion,
                            logg.codigo_subsistema

                        from log.tlog_'||v_parametros.gestion||'_'||v_parametros.periodo||' logg
                        where  si_log=1 and ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************
 #TRANSACCION:  SEG_LOG_CONT
 #DESCRIPCION:	Contar  los eventos del sistema registrados
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_LOG_CONT')then

          --consulta:=';
          BEGIN

                if(not exists (select 1
                    FROM pg_namespace n
                    INNER JOIN pg_class c ON c.relnamespace = n.oid
                    where n.nspname like 'log'
                    and c.relkind='r' and
                    c.relname='tlog_'||v_parametros.gestion||'_'||v_parametros.periodo))then
                    raise exception 'No se tienen registros para la gestion y periodo seleccionados';
                end if;
               v_consulta:='select count(logg.id_log)
                              from log.tlog_'||v_parametros.gestion||'_'||v_parametros.periodo||' logg
                           where  si_log=1 and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

 /*******************************
 #TRANSACCION:  SEG_LOGHOR_SEL
 #DESCRIPCION:	Lista eventos del sistema sucedidos fuera de horarios de trabajo
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
    elsif(p_transaccion='SEG_LOGHOR_SEL')then

          --consulta:=';
          BEGIN
-- to_char(logg.fecha_reg,''dd/mm/yyyy hh24:mi:ss''),

            if(not exists (select 1
                FROM pg_namespace n
                INNER JOIN pg_class c ON c.relnamespace = n.oid
                where n.nspname like 'log'
                and c.relkind='r' and
                c.relname='tlog_'||v_parametros.gestion||'_'||v_parametros.periodo))then
                raise exception 'No se tienen registros para la gestion y periodo seleccionados';
            end if;

               v_consulta:='select logg.id_log,
                            logg.id_usuario,
                            logg.cuenta_usuario,
                            logg.mac_maquina,
                            logg.ip_maquina,
                            logg.tipo_log,
                            logg.descripcion,
                            logg.fecha_reg,
                            logg.procedimientos,
                            logg.transaccion,
                            logg.consulta,
                            logg.usuario_base,
                            logg.tiempo_ejecucion,
                            logg.pid_web,
                            logg.pid_db,
                            logg.sid_web,
                            logg.codigo_error,
                            logg.descripcion_transaccion,
                            logg.codigo_subsistema,
                            (case when logg.dia_semana=1 then
                                ''domingo''
                            when logg.dia_semana=2 then
                                ''lunes''
                            when logg.dia_semana=3 then
                                ''martes''
                            when logg.dia_semana=4 then
                                ''miercoles''
                            when logg.dia_semana=5 then
                                ''jueves''
                            when logg.dia_semana=6 then
                                ''viernes''
                            else
                                ''sabado''
                            end)::varchar as dia_semana

                        from log.tlog_'||v_parametros.gestion||'_'||v_parametros.periodo||' logg
                        inner join segu.thorario_trabajo hor
                        on(hor.dia_semana=logg.dia_semana and logg.fecha_reg::time between hor.hora_ini and hor.hora_fin)
                        where ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************
 #TRANSACCION:  SEG_LOGHOR_CONT
 #DESCRIPCION:	Contar  los eventos fuera de horario de trabajo
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_LOGHOR_CONT')then

          --consulta:=';
          BEGIN

                if(not exists (select 1
                    FROM pg_namespace n
                    INNER JOIN pg_class c ON c.relnamespace = n.oid
                    where n.nspname like 'log'
                    and c.relkind='r' and
                    c.relname='tlog_'||v_parametros.gestion||'_'||v_parametros.periodo))then
                    raise exception 'No se tienen registros para la gestion y periodo seleccionados';
                end if;
               v_consulta:='select count(logg.id_log)
                              from log.tlog_'||v_parametros.gestion||'_'||v_parametros.periodo||' logg
                        inner join segu.thorario_trabajo hor
                        on(hor.dia_semana=logg.dia_semana and logg.fecha_reg::time between hor.hora_ini and hor.hora_fin)
                        where ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1805 (class 1255 OID 208330)
-- Dependencies: 20 3246
-- Name: ft_menu_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_menu_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_menu_sel
 DESCRIPCION:   consultas de la tabla gui para armar el menu
 AUTOR: 	    KPLIAN(jrr)		
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		Jaime Rivera Rojas	
 FECHA:		08/01/11
***************************************************************************/


DECLARE

    v_consulta    varchar;
    v_parametros  record;
    v_nombre_funcion   text;
    v_mensaje_error    text;
    v_nivel             varchar;
    v_resp				varchar;

/*

'id_padre'
'id_subsistema'

*/

BEGIN

    v_parametros:=f_get_record(par_tabla);
    v_nombre_funcion:='segu.ft_menu_sel';

 /*******************************
 #TRANSACCION:  SEG_MENU_SEL
 #DESCRIPCION:	Arma el menu que aparece en la parte izquierda
                de la pantalla del sistema
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
    if(par_transaccion='SEG_MENU_SEL')then
        if(v_parametros.id_padre='%')then
            v_nivel:='1';
        else
            v_nivel='%';
        end if;

        IF(par_administrador=1) THEN
           BEGIN
              v_consulta:= 'SELECT
                                        g.id_gui,
                                        g.nombre,
                                        g.descripcion,
                                        g.nivel,
                                        g.orden_logico,
                                        g.ruta_archivo,
                                        g.clase_vista,
                                        case
                                        when (g.ruta_archivo is null or g.ruta_archivo='''')then
                                             ''carpeta''::varchar
                                        ELSE
                                            ''hoja''::varchar
                                        END,
                                        g.icono 
                                  FROM segu.tgui g
                                       INNER JOIN segu.testructura_gui eg
                                       ON g.id_gui=eg.id_gui
                                  WHERE g.visible=''si''
                                  AND eg.fk_id_gui::text like '''||v_parametros.id_padre||'''
                                  AND g.nivel::text like '''||v_nivel||'''
                                  ORDER BY g.orden_logico,eg.fk_id_gui';
                                  
                                  raise notice 'adm: %',v_consulta;
              
              return v_consulta;
           END;
        ELSE
           BEGIN
           
              v_consulta:=
                   'SELECT g.id_gui,
                   g.nombre,
                   g.descripcion,
                   g.nivel,
                   g.orden_logico,
                   g.ruta_archivo,
                   g.clase_vista,
                   case
                       when (g.ruta_archivo is null or g.ruta_archivo='''')then
                            ''carpeta''::varchar
                       ELSE
                           ''hoja''::varchar
                   END,
                   g.icono 
                   FROM segu.tgui g
                   inner join segu.testructura_gui eg
                   on g.id_gui=eg.id_gui
                   and g.estado_reg=''activo''
                   and eg.estado_reg=''activo''
                   inner join segu.tgui_rol gr
                   on gr.id_gui=g.id_gui
                   and gr.estado_reg=''activo''
                   inner join segu.trol r
                   on r.id_rol=gr.id_rol
                   and r.estado_reg=''activo''
                   inner join segu.tusuario_rol ur
                   on ur.id_rol=r.id_rol
                   and ur.estado_reg=''activo''
                   inner join segu.tusuario u
                   on u.id_usuario=ur.id_usuario
                   and u.estado_reg=''activo''
                   where g.visible=''si''
                   and eg.fk_id_gui::text like '''||v_parametros.id_padre||'''
                   AND g.nivel::text like '''||v_nivel||'''
                   and u.id_usuario ='|| par_id_usuario||'
                   order by g.orden_logico,eg.fk_id_gui';
                   raise notice 'pueblo: %',v_consulta;
                  
              return v_consulta;
           END;
        END IF;
     else
         raise exception 'No existe la opcion';

     end if;

    EXCEPTION

  	 WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


--
-- TOC entry 1806 (class 1255 OID 208331)
-- Dependencies: 20 3246
-- Name: ft_monitor_bd_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_monitor_bd_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_monitor_bd_sel
 DESCRIPCIÓN:   listado de los objetos dela bd
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	        
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:
 AUTOR:		
 FECHA:	
***************************************************************************/

DECLARE                  

v_consulta    varchar;
v_parametros  record;
v_resp          varchar;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(p_tabla);
     v_nombre_funcion:='segu.f_t_log_sel';

/*******************************    
 #TRANSACCION:  SEG_MONESQ_SEL
 #DESCRIPCION:	Listado de registros del monitor de objetos de bd (Esquemas)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     if(p_transaccion='SEG_MONESQ_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select *
                            
                        from segu.vmonitor_bd_esquema mes
                        where  ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************    
 #TRANSACCION:  SEG_MONESQ_CONT
 #DESCRIPCION:	Contar registros del monitor de objetos de bd (Esquemas)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_MONESQ_CONT')then

          --consulta:=';
          BEGIN
                
               v_consulta:='select count(mes.nspoid)
                            from segu.vmonitor_bd_esquema mes
                            where  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
/*******************************
 #TRANSACCION:  SEG_MONTAB_SEL
 #DESCRIPCION:	Listado de registros del monitor de objetos de bd (Tablas)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_MONTAB_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select *

                        from segu.vmonitor_bd_tabla mta
                        where  ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************
 #TRANSACCION:  SEG_MONTAB_CONT
 #DESCRIPCION:	Contar registros del monitor de objetos de bd (Tablas)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_MONTAB_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(mta.oid)
                            from segu.vmonitor_bd_tabla mta
                            where  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
/*******************************
 #TRANSACCION:  SEG_MONFUN_SEL
 #DESCRIPCION:	Listado de registros del monitor de objetos de bd (Funciones)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_MONFUN_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select *

                        from segu.vmonitor_bd_funcion mfu
                        where  ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************
 #TRANSACCION:  SEG_MONFUN_CONT
 #DESCRIPCION:	Contar registros del monitor de objetos de bd (funciones)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_MONFUN_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(mfu.oid)
                            from segu.vmonitor_bd_funcion mfu
                            where  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
/*******************************
 #TRANSACCION:  SEG_MONIND_SEL
 #DESCRIPCION:	Listado de registros del monitor de objetos de bd (Indices)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_MONIND_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select *

                        from segu.vmonitor_bd_indice min
                        where  ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;


         END;

 /*******************************
 #TRANSACCION:  SEG_MONIND_CONT
 #DESCRIPCION:	Contar registros del monitor de objetos de bd (indices)
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_MONIND_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(min.indexrelid)
                            from segu.vmonitor_bd_indice min
                            where  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
/*******************************
 #TRANSACCION:  SEG_MONREC_SEL
 #DESCRIPCION:	Monitorear recursos usados por el sistema
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		
***********************************/
     elsif(p_transaccion='SEG_MONREC_SEL')then

          --consulta:=';
          BEGIN
                v_resp=segu.f_monitorear_recursos();
                --raise exception 'llega';
               v_consulta:='select *
                            from tt_monitor_recursos mr
                            where  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
                --raise exception '%',v_parametros.puntero;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1807 (class 1255 OID 208332)
-- Dependencies: 20 3246
-- Name: ft_patron_evento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_patron_evento_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************

 FUNCION: 		segu.ft_patron_evento_ime
 DESCRIPCIÓN: 	
 AUTOR: 		KPLIAN(jrr)	
 FECHA:			
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE

v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion       text;
v_mensaje_error        text;
v_accion               varchar;
v_resp                 varchar;

BEGIN

     v_nombre_funcion:='segu.ft_patron_evento_ime';
     v_parametros:=f_get_record(par_tabla); 
     

     if(par_transaccion='SEG_PATEVE_INS')then

        
          BEGIN
              INSERT INTO segu.tpatron_evento (
                           tipo_evento,
                           operacion,
                           aplicacion,
                           cantidad_intentos,
                           periodo_intentos,
                           tiempo_bloqueo,
                           email,
                           nombre_patron,
                           estado_reg
                           )

               values(     v_parametros.tipo_evento,
                           v_parametros.operacion,
                           v_parametros.aplicacion,
                           v_parametros.cantidad_intentos,
                           v_parametros.periodo_intentos,
                           v_parametros.tiempo_bloqueo,
                           v_parametros.email,
                           v_parametros.nombre_patron,
                           'activo');


               v_resp = f_agrega_clave(v_resp,'mensaje','Patron evento insertado con exito ');
               v_resp = f_agrega_clave(v_resp,'patron_evento',1::varchar);
    
         END;          
   
     elsif(par_transaccion='SEG_PATEVE_MOD')then


          BEGIN
               --modificacion de tipo_obligacion
                update segu.tpatron_evento
                set
                           tipo_evento=v_parametros.tipo_evento,
                           operacion=v_parametros.operacion,
                           aplicacion=v_parametros.aplicacion,
                           cantidad_intentos=v_parametros.cantidad_intentos,
                           periodo_intentos=v_parametros.periodo_intentos,
                           tiempo_bloqueo=v_parametros.tiempo_bloqueo,
                           email=v_parametros.email,
                           nombre_patron=v_parametros.nombre_patron
                where id_patron_evento=v_parametros.id_patron_evento;

                v_resp = f_agrega_clave(v_resp,'mensaje','patron_evento modificado con exito '||v_parametros.id_patron_evento);
                v_resp = f_agrega_clave(v_resp,'id_patron_evento',v_parametros.id_patron_evento::varchar);
          END;
     elsif(par_transaccion='SEG_PATEVE_ELI')then
        BEGIN

         --inactivacion de patron_evento
              update segu.tpatron_evento
              set estado_reg='inactivo'
              where id_patron_evento=v_parametros.id_patron_evento;

               v_resp = f_agrega_clave(v_resp,'mensaje','patron_evento eliminado con exito '||v_parametros.id_patron_evento);
               v_resp = f_agrega_clave(v_resp,'patron_evento',v_parametros.id_patron_evento::varchar);

        END;
     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     
   return v_resp; 

EXCEPTION

       WHEN OTHERS THEN

       	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


--
-- TOC entry 1798 (class 1255 OID 208333)
-- Dependencies: 20 3246
-- Name: ft_patron_evento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_patron_evento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.fpatron_evento_sel
 DESCRIPCIÓN:   listado de patrones de evento
 AUTOR: 		KPLIAN(jrr)	
 FECHA:			
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/
                                                                          
DECLARE            

v_consulta    		varchar;
v_parametros  		record;
v_nombre_funcion   	text;
v_mensaje_error    	text;
v_id_padre         	integer;

v_resp             	varchar;
v_where 			varchar;
v_join  			varchar;      

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_patron_evento_sel';


     if(par_transaccion='SEG_PATEVE_SEL')then

          --consulta:=';
          BEGIN
          
              v_consulta =  'SELECT
                             PATEVE.id_patron_evento,
                             PATEVE.tipo_evento,
                             PATEVE.operacion,
                             PATEVE.aplicacion,
                           
                             PATEVE.cantidad_intentos,
                             
                             PATEVE.periodo_intentos,
                             PATEVE.tiempo_bloqueo,
                             PATEVE.email,
                             PATEVE.nombre_patron
                             from segu.tpatron_evento PATEVE
                             WHERE PATEVE.estado_reg=''activo'' AND
                             ';
               
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;
         END;

     elsif(par_transaccion='SEG_PATEVE_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(PATEVE.id_patron_evento)
                            from segu.tpatron_evento PATEVE  WHERE
                            PATEVE.estado_reg=''activo'' AND ';
               v_consulta:=v_consulta||v_parametros.filtro;
               --v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;      
END;
$$;


--
-- TOC entry 1799 (class 1255 OID 208334)
-- Dependencies: 20 3246
-- Name: ft_persona_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_persona_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_persona_ime
 DESCRIPCION:   modificaciones de persona
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		Jaime Rivera Rojas	
 FECHA:		08/01/11
***************************************************************************/

DECLARE

v_nro_requerimiento    integer;
v_parametros           record;
v_id_requerimiento     integer;
v_resp                 varchar;
v_nombre_funcion       text;
v_mensaje_error        text;
v_id_persona           integer;

--04/04/2012
v_respuesta_sinc       varchar;
/*
 id_persona_juridica
 nombre
 domicilio
 telefono
 correo
 pag_web
 obs
 estado_reg
*/

BEGIN

           

     v_nombre_funcion:='segu.ft_persona_ime';
     v_parametros:=f_get_record(par_tabla);

 /*******************************
 #TRANSACCION:  SEG_PERSON_INS
 #DESCRIPCION:	Inserta Persona
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_PERSON_INS')then

          --consulta:=';
          BEGIN

                       
               insert into segu.tpersona (
                               nombre,
                               apellido_paterno,
                               apellido_materno,
                               ci,
                               correo,
                               celular1,
               				   telefono1,
                               telefono2,
                               celular2)
               values(
                      v_parametros.nombre,
                      v_parametros.ap_paterno,
                      v_parametros.ap_materno,
                      v_parametros.ci,
                      v_parametros.correo,
                      v_parametros.celular1,
                      v_parametros.telefono1,
                      v_parametros.telefono2,
                      v_parametros.celular2)  
                        
               RETURNING id_persona INTO v_id_persona;
              
               v_respuesta_sinc:= segu.f_sincroniza_persona_entre_bd(v_id_persona,'10.172.0.13','5432','db_link','db_link','dbendesis','INSERT');
               if(v_respuesta_sinc!='si')  then
                  raise exception 'Sincronizacion de persona en BD externa no realizada%',v_respuesta_sinc;
               end if;
               --raise exception 'lega al final del insert';
               v_resp = f_agrega_clave(v_resp,'mensaje','Persona insertada con exito '||v_id_persona); 
               v_resp = f_agrega_clave(v_resp,'id_persona',v_id_persona::varchar);

              

         END;

 /*******************************
 #TRANSACCION:  SEG_PERSON_MOD
 #DESCRIPCION:	Modifica Persona
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_PERSON_MOD')then

          --consulta:=';
          BEGIN
          
   -- raise exception 'ERROR al subir archivo';

               update segu.tpersona 
               set nombre=v_parametros.nombre,
               apellido_paterno=v_parametros.ap_paterno,
               apellido_materno=v_parametros.ap_materno,
               ci=v_parametros.ci,
               correo=v_parametros.correo,
               celular1=v_parametros.celular1,
               telefono1=v_parametros.telefono1,
               telefono2=v_parametros.telefono2,
               celular2=v_parametros.celular2
               where id_persona=v_parametros.id_persona;
              
               v_respuesta_sinc:= segu.f_sincroniza_persona_entre_bd(v_parametros.id_persona,'10.172.0.13','5432','db_link','db_link','dbendesis','UPDATE');
               if(v_respuesta_sinc!='si')  then
                  raise exception 'Sincronizacion a actualizacion de persona en BD externa no realizada%',v_respuesta_sinc;
               end if;
   
             v_resp = f_agrega_clave(v_resp,'mensaje','Persona modificada con exito '||v_parametros.id_persona); 
             v_resp = f_agrega_clave(v_resp,'id_persona',v_parametros.id_persona::varchar);
               
             --v_resp = 'exito'; 
             
            -- raise exception 'XXXXXXXXXXXXXxxx' ;  
               
          END;

 /*******************************
 #TRANSACCION:  SEG_UPFOTOPER_MOD
 #DESCRIPCION:	Modifica la foto de la persona
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_UPFOTOPER_MOD')then

          --consulta:=';
          BEGIN

   -- raise exception 'ERROR al subir archivo';

               update segu.tpersona 
               set 
               foto=v_parametros.foto,
               extension=v_parametros.extension
               where id_persona=v_parametros.id_persona;
             
             v_resp = f_agrega_clave(v_resp,'mensaje','Foto de la persona modificada con exito '||v_parametros.id_persona); 
             v_resp = f_agrega_clave(v_resp,'id_persona',v_parametros.id_persona::varchar);

               
          END;
/*******************************
 #TRANSACCION:  SEG_PERSON_ELI
 #DESCRIPCION:	Elimina Persona
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
    elsif(par_transaccion='SEG_PERSON_ELI')then
                     
          --consulta:=';
          BEGIN
             
            delete from segu.tpersona where id_persona=v_parametros.id_persona;
          
            v_respuesta_sinc:= segu.f_sincroniza_persona_entre_bd(v_parametros.id_persona,'10.172.0.13','5432','db_link','db_link','dbendesis','DELETE');
            if(v_respuesta_sinc!='si')  then
                  raise exception 'Sincronizacion a eliminacion de persona en BD externa no realizada%',v_respuesta_sinc;
            end if;
            v_resp = f_agrega_clave(v_resp,'mensaje','Persona eliminada '||v_parametros.id_persona); 
            v_resp = f_agrega_clave(v_resp,'id_persona',v_parametros.id_persona::varchar);
            
         END;
         
     else
     
         raise exception 'Transacción inexistente: %',par_transaccion;

     end if;
     
       
    return v_resp;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1808 (class 1255 OID 208337)
-- Dependencies: 20 3246
-- Name: ft_persona_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_persona_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_persona_sel
 DESCRIPCION:   consultas de persona
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_persona_sel';


 /*******************************
 #TRANSACCION:  SEG_PERSON_SEL
 #DESCRIPCION:	Selecciona Personas
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_PERSON_SEL')then

          --  Se arma la consulta de personas
          BEGIN

               v_consulta:='SELECT 
                              p.id_persona,
                              p.ap_materno,
                              p.ap_paterno,
                              p.nombre,
                              p.nombre_completo1,
                              p.nombre_completo2,
                              p.ci,
                              p.correo,
                              p.celular1,
                              p.num_documento,
                              p.telefono1,
                              p.telefono2,
                              p.celular2
                          FROM segu.vpersona p WHERE ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta || ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               --raise exception '%',v_consulta;
               return v_consulta;


         END;
         
         


/*******************************
 #TRANSACCION:  SEG_PERSON_CONT
 #DESCRIPCION:	Cuenta Personas
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/

     elsif(par_transaccion='SEG_PERSON_CONT')then

          --se arma la sonsulta que cuenta personas
          BEGIN
               
               v_consulta:='select count(p.id_persona)
               from segu.vpersona p where ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
         
         
 /*******************************
 #TRANSACCION:  SEG_PERSONMIN_SEL
 #DESCRIPCION:	Selecciona Personas + fotografia
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_PERSONMIN_SEL')then

          --  Se arma la consulta de personas
          BEGIN
          
               v_consulta:='SELECT p.id_persona,
                             p.apellido_materno AS ap_materno,
                             p.apellido_paterno AS ap_paterno,
                             p.nombre,
                             (((COALESCE(p.nombre, '''' ::character varying) ::text || '' '' ::text) ||
                              COALESCE(p.apellido_paterno, '''' ::character varying) ::text) || '' ''
                               ::text) || COALESCE(p.apellido_materno, '''' ::character varying)
                                ::text AS nombre_completo1,
                             (((COALESCE(p.apellido_paterno, '''' ::character varying) ::text || '' ''
                              ::text) || COALESCE(p.apellido_materno, '''' ::character varying) ::text
                              ) || '' '' ::text) || COALESCE(p.nombre, '''' ::character varying) ::text
                               AS nombre_completo2,
                             p.ci,
                             p.correo,
                             p.celular1,
                             p.num_documento,
                             p.telefono1,
                             p.telefono2,
                             p.celular2,                             
                             p.extension,
                             p.foto
                          FROM segu.tpersona p WHERE ';
                          
                         
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta || ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               --raise exception '%',v_consulta;
               return v_consulta;


         END;    


/*******************************
 #TRANSACCION:  SEG_PERSONMIN_CONT
 #DESCRIPCION:	Cuenta Personas con foto
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/

     elsif(par_transaccion='SEG_PERSONMIN_CONT')then
                            

          --se arma la sonsulta que cuenta personas
          BEGIN
               
               v_consulta:='select count(p.id_persona)
               from segu.tpersona p where ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
         
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1809 (class 1255 OID 208338)
-- Dependencies: 20 3246
-- Name: ft_primo_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_primo_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_primo_sel
 DESCRIPCIÓN: 	manejo de consultas en a tabla primo
 AUTOR: 		KPLIAN(jrr)		
 FECHA:		    28/02/2008
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR: 		Rensi Arteaga Copari
 FECHA:			16/11/2010			
***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp varchar;

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_primo_sel';
     
 /*******************************    
 #TRANSACCION:  SEG_FUNCIO_INS
 #DESCRIPCION:	Obtienen un numero primo segun indice
                el indice se obtiene en el servidor web randomicamente
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2008	
***********************************/


     if(par_transaccion='SEG_OBTEPRI_SEL')then
     
          --consulta:=';
          BEGIN
               v_consulta:='SELECT numero 
                            from segu.tprimo u 
                            where id_primo='||v_parametros.id_primo;
               return v_consulta;
               
               
         END;
    
/*******************************    
 #TRANSACCION:  SEG_FUNCIO_INS
 #DESCRIPCION:	listado de numeros primo
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2008	
***********************************/     
     elsif(par_transaccion='SEG_PRIMO_SEL')then
     
          --consulta:=';
          BEGIN
               --raise exception 'entra';
               v_consulta:='select * from segu.tprimo p where '|| v_parametros.filtro ||'
               order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               return v_consulta;

         END;
/*******************************    
 #TRANSACCION:  SEG_FUNCIO_INS
 #DESCRIPCION:	cuenta el listado de numeros primos
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2008	
***********************************/
     elsif(par_transaccion='SEG_PRIMO_CONT')then

          --consulta:=';
          BEGIN
               v_consulta:='select count(*) 
                            from segu.primo p 
                            where '|| v_parametros.filtro;
               return v_consulta;


         END;
     end if;
     
EXCEPTION

        WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1810 (class 1255 OID 208339)
-- Dependencies: 20 3246
-- Name: ft_procedimiento_gui_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_procedimiento_gui_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_procedimiento_gui
 DESCRIPCIÓN: 	gestion de procedimiento GUI
 AUTOR: 		KPLIAN(rac)	
 FECHA:			18/10/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/

DECLARE


v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_id_procedimiento_gui      integer;
v_resp varchar;

BEGIN

     v_nombre_funcion:='segu.ft_procedimiento_gui_ime';
     v_parametros:=f_get_record(par_tabla);
/*******************************
 #TRANSACCION:  SEG_PROGUI_INS
 #DESCRIPCION:	Inserta Procedimiento_Gui
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_PROGUI_INS')then

        
          BEGIN
               INSERT INTO segu.tprocedimiento_gui(
                     id_procedimiento, 
                     id_gui,
                     boton)
               VALUES (
                       v_parametros.id_procedimiento, 
                       v_parametros.id_gui,
               		   v_parametros.boton)
               RETURNING id_procedimiento_gui into v_id_procedimiento_gui;

             --  return 'Procedimiento GUI insertado con exito';
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Procedimiento GUI  insertada con exito '||v_id_procedimiento_gui); 
               v_resp = f_agrega_clave(v_resp,'id_procedimiento_gui',v_id_procedimiento_gui::varchar);

         END;
/*******************************
 #TRANSACCION:  SEG_PROGUI_MOD
 #DESCRIPCION:	Modifica Procedimiento_Gui
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_PROGUI_MOD')then

          
          BEGIN
               
               update segu.tprocedimiento_gui set
                      id_procedimiento=v_parametros.id_procedimiento,
                      id_gui=v_parametros.id_gui,
                      boton=v_parametros.boton
                     

               where id_procedimiento_gui=v_parametros.id_procedimiento_gui;


             
            v_resp = f_agrega_clave(v_resp,'mensaje','Procedimiento GUI modificado con exito '||v_parametros.id_procedimiento_gui::varchar); 
            v_resp = f_agrega_clave(v_resp,'id_procedimiento_gui',v_parametros.id_procedimiento_gui::varchar);
          
     
      END;
/*******************************
 #TRANSACCION:  SEG_PROGUI_ELI
 #DESCRIPCION:	Elimina Procedimiento_Gui
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
    elsif(par_transaccion='SEG_PROGUI_ELI')then

         
          BEGIN
            
          DELETE FROM segu.tprocedimiento_gui
          WHERE id_procedimiento_gui=v_parametros.id_procedimiento_gui;
              
              
              v_resp = f_agrega_clave(v_resp,'mensaje','Procedimiento GUI inactivado con exito '|| v_parametros.id_procedimiento_gui); 
              v_resp = f_agrega_clave(v_resp,'id_procedimiento_gui',v_parametros.id_procedimiento_gui::varchar);
         
    
    
      END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
 
 return v_resp;  

EXCEPTION

       WHEN OTHERS THEN

       	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


--
-- TOC entry 1811 (class 1255 OID 208340)
-- Dependencies: 20 3246
-- Name: ft_procedimiento_gui_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_procedimiento_gui_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 CAPA:          MODELO
 FUNCION: 		segu.ft_procedimiento_gui_sel
 DESCRIPCIÓN: 	Permite la gestion de interfaces 
                 de usario con todas sus operaciones basicas
                
 AUTOR: 		KPLIAN(rac)
 FECHA:			16/10/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp                  varchar;
v_where varchar;



/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_procedimiento_gui_sel';

 /*******************************
 #TRANSACCION:  SEG_PROGUI_SEL
 #DESCRIPCION:	Lista procedimientos de una interfaz dada
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/

     if(par_transaccion='SEG_PROGUI_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select 
                            progui.id_procedimiento_gui,
                            progui.id_procedimiento,
                            progui.id_gui,
                            sub.codigo as codigo_sub,
                            fun.nombre as nombre_fun,
                            proced.codigo,
                            proced.descripcion as desc_procedimiento,                           
                            progui.boton,
                            progui.fecha_reg,
                            progui.estado_reg
                        from segu.tprocedimiento_gui progui
                        inner join segu.tprocedimiento proced
                        on proced.id_procedimiento=progui.id_procedimiento
                        inner join segu.tgui gui
                        on gui.id_gui=progui.id_gui 
                        inner join segu.tfuncion fun
                        on proced.id_funcion = fun.id_funcion
                        inner join segu.tsubsistema sub
                        on sub.id_subsistema = fun.id_subsistema 
                        where progui.estado_reg=''activo'' AND progui.id_gui ='|| v_parametros.id_gui||'  AND ';
                   
                   
                   v_consulta:=v_consulta||v_parametros.filtro;


               return v_consulta;


         END;

/*******************************
 #TRANSACCION:  SEG_PROGUI_CONT
 #DESCRIPCION:	Cuenta procedimientos de una interfaz dada
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_PROGUI_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(progui.id_procedimiento_gui)
                            from segu.tprocedimiento_gui progui
                            where progui.estado_reg=''activo'' AND progui.id_gui='||v_parametros.id_gui;
                            
               /* v_consulta:='select count(progui.id_procedimiento_gui)
                            from segu.tprocedimiento_gui progui'; */            
                            
            
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1800 (class 1255 OID 208341)
-- Dependencies: 20 3246
-- Name: ft_procedimiento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_procedimiento_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_procedimiento_ime
 DESCRIPCION:   modificaciones de procedimiento
 AUTOR: 	    KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/


DECLARE
v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_resp                  varchar;
v_id_procedimiento      integer;

BEGIN

     v_nombre_funcion:='segu.ft_procedimiento_ime';
     v_parametros:=f_get_record(par_tabla);
/*******************************
 #TRANSACCION:  SEG_PROCED_INS
 #DESCRIPCION:	Inserta Procedimiento
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_PROCED_INS')then

        
          BEGIN
               insert into segu.tprocedimiento(
                id_funcion,             codigo,             descripcion,
                habilita_log)
               values(
                v_parametros.id_funcion,v_parametros.codigo,v_parametros.descripcion,
                v_parametros.habilita_log) RETURNING id_procedimiento into v_id_procedimiento;

               v_resp = f_agrega_clave(v_resp,'mensaje','Procedimiento insertado con exito '||v_id_procedimiento);
               v_resp = f_agrega_clave(v_resp,'id_procedimiento',v_id_procedimiento::varchar);


         END;
/*******************************
 #TRANSACCION:  SEG_PROCED_MOD
 #DESCRIPCION:	Modifica Procedimiento
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_PROCED_MOD')then

          
          BEGIN
               
               update segu.tprocedimiento set
                      id_funcion=v_parametros.id_funcion,
                      codigo=v_parametros.codigo,
                      descripcion=v_parametros.descripcion,
                      habilita_log=v_parametros.habilita_log
                     

               where id_procedimiento=v_parametros.id_procedimiento;
                v_resp = f_agrega_clave(v_resp,'mensaje','Procedimiento modificado con exito '||v_parametros.id_procedimiento);
                v_resp = f_agrega_clave(v_resp,'id_procedimiento',v_parametros.id_procedimiento::varchar);

          END;
/*******************************
 #TRANSACCION:  SEG_PROCED_ELI
 #DESCRIPCION:	Elimina Procedimiento
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
    elsif(par_transaccion='SEG_PROCED_ELI')then

         
          BEGIN
               update segu.tprocedimiento set estado_reg='inactivo'
               where id_procedimiento=v_parametros.id_procedimiento;
               v_resp = f_agrega_clave(v_resp,'mensaje','Procedimiento eliminado con exito '||v_parametros.id_procedimiento);
                v_resp = f_agrega_clave(v_resp,'id_procedimiento',v_parametros.id_procedimiento::varchar);

         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     return v_resp;

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1812 (class 1255 OID 208342)
-- Dependencies: 20 3246
-- Name: ft_procedimiento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_procedimiento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_procedimiento_sel
 DESCRIPCIÓN: 	Realiza el listado de procedimientos (trasacciones)
 AUTOR: 		KPLIAN(rac)	
 FECHA:			17/10/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/


DECLARE


v_consulta    			varchar;
v_parametros  record;
v_nombre_funcion   		text;
v_mensaje_error    		text;
v_id_padre         		integer;
v_resp                  varchar;

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_procedimiento_sel';

 /*******************************
 #TRANSACCION:  SEG_PROCED_SEL
 #DESCRIPCION:	Selecciona Procedimientos para agregar al listado del arbol
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		08/01/11	
***********************************/

     if(par_transaccion='SEG_PROCED_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select
               
               progui.id_procedimiento_gui,
               proced.id_procedimiento,
               progui.id_gui,
                            proced.id_funcion,
                            proced.codigo,
                            proced.descripcion,
                            
                            proced.habilita_log,
                            (select distinct ''transaccion'') as tipo_meta
                        from segu.tprocedimiento proced
                        inner join segu.tfuncion funcio
                        on funcio.id_funcion=proced.id_funcion 
                        left join segu.tprocedimiento_gui progui on progui.id_procedimiento=proced.id_procedimiento
                        where proced.estado_reg=''activo'' and ';
              v_consulta:=v_consulta||v_parametros.filtro;
              if(v_parametros.id_padre = '%') then
                v_id_padre:=0;
              else
                v_id_padre:=v_parametros.id_padre;
              end if;
              v_consulta:=v_consulta|| ' and progui.id_gui='|| v_id_padre;
              v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;
 /*******************************
 #TRANSACCION:  SEG_PROCED_CONT
 #DESCRIPCION:	Cuenta Procedimientos para agregar al listado del arbol
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/

     elsif(par_transaccion='SEG_PROCED_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(proced.id_procedimiento)
                            FROM segu.tprocedimiento proced
                            INNER join segu.tfuncion funcio
                            on funcio.id_funcion=proced.id_funcion 
                            WHERE proced.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
            
               return v_consulta;
         END;
/*******************************
 #TRANSACCION:  SEG_PROCE_SEL
 #DESCRIPCION:	Listado de Procedimientos
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_PROCE_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select
                            proced.id_procedimiento,
                            proced.id_funcion,
                            proced.codigo,
                            proced.descripcion,
                            proced.habilita_log,
                            (select distinct ''transaccion'') as tipo_meta
                            from segu.tprocedimiento proced
                            inner join segu.tfuncion funcio
                            on funcio.id_funcion=proced.id_funcion
                            where proced.estado_reg=''activo'' and ';
              v_consulta:=v_consulta||v_parametros.filtro;
                 v_consulta:=v_consulta || ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
            
              /*if(v_parametros.id_padre = '%') then
                v_id_padre:=0;
              else
                v_id_padre:=v_parametros.id_padre;
              end if;*/

              return v_consulta;


         END;
/*******************************
 #TRANSACCION:  SEG_PROCE_CONT
 #DESCRIPCION:	Cuenta Procedimientos
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		08/01/11	
***********************************/

     elsif(par_transaccion='SEG_PROCE_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(proced.id_procedimiento)
                            from segu.tprocedimiento proced
                            inner join segu.tfuncion funcio
                            on funcio.id_funcion=proced.id_funcion where proced.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
              
               return v_consulta;
         END;
/*******************************
 #TRANSACCION:  SEG_PROCECMB_SEL
 #DESCRIPCION:	Selecciona Procedimientos para el listado
                del combo en la vista de procedimiento_gui
 #AUTOR:		KPLIAN(rac)		
 #FECHA:		08/01/11	
***********************************/
      
        elsif(par_transaccion='SEG_PROCECMB_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                                   pro.id_procedimiento,
                                   pro.id_funcion,
                                   sub.id_subsistema,
                                   sub.codigo as codigo_sub,
                                   fun.nombre as nombre_fun,
                                   pro.codigo,
                                   pro.descripcion,
                                   pro.habilita_log
                            FROM segu.tprocedimiento pro
                                 INNER JOIN segu.tfuncion fun on fun.id_funcion = pro.id_funcion
                                 INNER JOIN segu.tsubsistema sub on sub.id_subsistema = fun.id_subsistema

                            WHERE pro.estado_reg = ''activo'' and ';
                            
                            -- pro.id_funcion='|| v_parametros.id_funcion || ' and ';
              v_consulta:=v_consulta||v_parametros.filtro;
              v_consulta:=v_consulta || ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
            
         

              return v_consulta;


         END;

/*******************************
 #TRANSACCION:  SEG_PROCECMB_CONT
 #DESCRIPCION:	Cuenta Procedimientos para el listado
                del combo en la vista de procedimiento_gui
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_PROCECMB_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(pro.id_procedimiento)
         
                            FROM segu.tprocedimiento pro
                                 INNER JOIN segu.tfuncion fun 
                                 on fun.id_funcion = pro.id_funcion
                                 INNER JOIN segu.tsubsistema sub 
                                 on sub.id_subsistema = fun.id_subsistema

                            WHERE pro.estado_reg = ''activo'' and
                            ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;
         
         

     else
         raise exception 'No existe la opcion';

     end if;




EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1813 (class 1255 OID 208343)
-- Dependencies: 20 3246
-- Name: ft_programa_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_programa_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_programa_ime
 DESCRIPCION:   Funci?n que gestiona las operaciones b?sicas (inserciones, modificaciones, eliminaciones de la tabla 'segu.tprograma'
 AUTOR: 		 (w)
 FECHA:	        14-08-2011 15:36:44
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCI?N:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_programa	integer;
			
BEGIN

    v_nombre_funcion = 'segu.ft_programa_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************
 	#TRANSACCION:  'SG_PROGRA_INS'
 	#DESCRIPCION:	Inserci?n de registros
 	#AUTOR:		w	
 	#FECHA:		14-08-2011 15:36:44
	***********************************/

	if(p_transaccion='SG_PROGRA_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into segu.tprograma(
			codigo,
			descripcion,
			nombre,
			estado_reg,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			v_parametros.codigo,
			v_parametros.descripcion,
			v_parametros.nombre,
			'activo',
			now(),
			p_id_usuario,
			null,
			null
			)RETURNING id_programa into v_id_programa;

			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Programa almacenado(a) con exito (id_programa'||v_id_programa||')');
            v_resp = f_agrega_clave(v_resp,'id_programa',v_id_programa::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************
 	#TRANSACCION:  'SG_PROGRA_MOD'
 	#DESCRIPCION:	Modificaci?n de registros
 	#AUTOR:		w	
 	#FECHA:		14-08-2011 15:36:44
	***********************************/

	elsif(p_transaccion='SG_PROGRA_MOD')then

		begin
			--Sentencia de la modificacion
			update segu.tprograma set
			codigo= v_parametros.codigo,
			descripcion= v_parametros.descripcion,
			nombre= v_parametros.nombre,
			fecha_mod=now(),
			id_usuario_mod = p_id_usuario
			where id_programa=v_parametros.id_programa;

			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Programa modificado(a)');
            v_resp = f_agrega_clave(v_resp,'id_programa',v_parametros.id_programa::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************
 	#TRANSACCION:  'SG_PROGRA_ELI'
 	#DESCRIPCION:	Eliminaci?n de registros
 	#AUTOR:		w	
 	#FECHA:		14-08-2011 15:36:44
	***********************************/

	elsif(p_transaccion='SG_PROGRA_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from segu.tprograma
            where id_programa=v_parametros.id_programa;

            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Programa eliminado(a)');
            v_resp = f_agrega_clave(v_resp,'id_programa',v_parametros.id_programa::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	else

    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				
END;
$$;


--
-- TOC entry 1814 (class 1255 OID 208344)
-- Dependencies: 20 3246
-- Name: ft_programa_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_programa_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCI?N: 		segu.ft_programa_sel
 DESCRIPCI?N:   Funci?n que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'segu.tprograma'
 AUTOR: 		 (w)
 FECHA:	        13-08-2011 16:32:52
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCI?N:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			
BEGIN

	v_nombre_funcion = 'segu.ft_programa_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************
 	#TRANSACCION:  'SG_PROGRA_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		w	
 	#FECHA:		13-08-2011 16:32:52
	***********************************/

	if(p_transaccion='SG_PROGRA_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						progra.id_programa,
						progra.codigo,
						progra.descripcion,
						progra.estado_reg,
						progra.nombre,
						progra.fecha_reg,
						progra.id_usuario_reg,
						progra.fecha_mod,
						progra.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from segu.tprograma progra
						inner join segu.tusuario usu1 on usu1.id_usuario = progra.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = progra.id_usuario_mod
				        where  ';
			
			--Definici?n de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			
			if(f_existe_parametro(p_tabla,'estado_reg')) then
			  v_consulta:=v_consulta || ' and progra.estado_reg='''||v_parametros.estado_reg||'''';
			end if;
			
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************
 	#TRANSACCION:  'SG_PROGRA_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		w	
 	#FECHA:		13-08-2011 16:32:52
	***********************************/

	elsif(p_transaccion='SG_PROGRA_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_programa)
					    from segu.tprograma progra
					    inner join segu.tusuario usu1 on usu1.id_usuario = progra.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = progra.id_usuario_mod
					    where ';
			
			--Definici?n de la respuesta		
			v_consulta:=v_consulta||v_parametros.filtro;


            if(f_existe_parametro(p_tabla,'estado_reg')) then
			  v_consulta:=v_consulta || ' and progra.estado_reg='''||v_parametros.estado_reg||'''';
			end if;
			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					
		raise exception 'Transaccion inexistente';
					
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1815 (class 1255 OID 208345)
-- Dependencies: 20 3246
-- Name: ft_proyecto_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_proyecto_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_proyecto_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'segu.tproyecto'
 AUTOR: 		 (w)
 FECHA:	        17-10-2011 06:35:44
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_proyecto	integer;
			
BEGIN

    v_nombre_funcion = 'segu.ft_proyecto_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************
 	#TRANSACCION:  'SG_PROY_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:35:44
	***********************************/

	if(p_transaccion='SG_PROY_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into segu.tproyecto(
			codigo,
			descripcion,
			estado_reg,
			nombre,
			fecha_reg,
			id_usuario_reg,
			fecha_mod,
			id_usuario_mod
          	) values(
			v_parametros.codigo,
			v_parametros.descripcion,
			'activo',
			v_parametros.nombre,
			now(),
			p_id_usuario,
			null,
			null
			)RETURNING id_proyecto into v_id_proyecto;

			--Definici?n de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Proyecto almacenado(a) con exito (id_proyecto'||v_id_proyecto||')');
            v_resp = f_agrega_clave(v_resp,'id_proyecto',v_id_proyecto::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************
 	#TRANSACCION:  'SG_PROY_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:35:44
	***********************************/

	elsif(p_transaccion='SG_PROY_MOD')then

		begin
			--Sentencia de la modificacion
			update segu.tproyecto set
			codigo = v_parametros.codigo,
			descripcion = v_parametros.descripcion,
			nombre = v_parametros.nombre,
			fecha_mod = now(),
			id_usuario_mod = p_id_usuario
			where id_proyecto=v_parametros.id_proyecto;

			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proyecto modificado(a)');
            v_resp = f_agrega_clave(v_resp,'id_proyecto',v_parametros.id_proyecto::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************
 	#TRANSACCION:  'SG_PROY_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:35:44
	***********************************/

	elsif(p_transaccion='SG_PROY_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from segu.tproyecto
            where id_proyecto=v_parametros.id_proyecto;

            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Proyecto eliminado(a)');
            v_resp = f_agrega_clave(v_resp,'id_proyecto',v_parametros.id_proyecto::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	else

    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				
END;
$$;


--
-- TOC entry 1816 (class 1255 OID 208346)
-- Dependencies: 20 3246
-- Name: ft_proyecto_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_proyecto_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Seguridad
 FUNCION: 		segu.ft_proyecto_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'segu.tproyecto'
 AUTOR: 		 (w)
 FECHA:	        17-10-2011 06:35:44
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			
BEGIN

	v_nombre_funcion = 'segu.ft_proyecto_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************
 	#TRANSACCION:  'SG_PROY_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:35:44
	***********************************/

	if(p_transaccion='SG_PROY_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						proy.id_proyecto,
						proy.codigo,
						proy.descripcion,
						proy.estado_reg,
						proy.nombre,
						proy.fecha_reg,
						proy.id_usuario_reg,
						proy.fecha_mod,
						proy.id_usuario_mod,
						usu1.cuenta as usr_reg,
						usu2.cuenta as usr_mod	
						from segu.tproyecto proy
						inner join segu.tusuario usu1 on usu1.id_usuario = proy.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = proy.id_usuario_mod
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			
			if(f_existe_parametro(p_tabla,'estado_reg')) then
			  v_consulta:=v_consulta || ' and proy.estado_reg='''||v_parametros.estado_reg||'''';
			end if;
			
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************
 	#TRANSACCION:  'SG_PROY_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		w	
 	#FECHA:		17-10-2011 06:35:44
	***********************************/

	elsif(p_transaccion='SG_PROY_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_proyecto)
					    from segu.tproyecto proy
					    inner join segu.tusuario usu1 on usu1.id_usuario = proy.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = proy.id_usuario_mod
					    where ';
			
			--Definicion de la respuesta		
			v_consulta:=v_consulta||v_parametros.filtro;
			
            if(f_existe_parametro(p_tabla,'estado_reg')) then
			  v_consulta:=v_consulta || ' and proy.estado_reg='''||v_parametros.estado_reg||'''';
			end if;
			
			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					
		raise exception 'Transaccion inexistente';
					
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1817 (class 1255 OID 208347)
-- Dependencies: 20 3246
-- Name: ft_regional_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_regional_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_regional_ime
 DESCRIPCION:   modificaciones de regional
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)	
 FECHA:		08/01/11
***************************************************************************/

DECLARE

    v_nro_requerimiento    	integer;
    v_parametros           	record;
    v_id_requerimiento     	integer;
    v_resp		            varchar;
    v_nombre_funcion        text;
    v_mensaje_error         text;
    v_id_regional			integer;


/*

 id_proyecto
 denominacion 
 descripcion
 estado_reg 

*/

BEGIN

     v_nombre_funcion:='segu.ft_regional_ime';
     v_parametros:=f_get_record(p_tabla);
/*******************************
 #TRANSACCION:  SEG_REGION_INS
 #DESCRIPCION:	Inserta Regional
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     if(p_transaccion='SEG_REGION_INS')then

          BEGIN
               
               insert into segu.tregional(
		 nombre,
                 descripcion,
                 estado_reg
               ) values(
                v_parametros.nombre,
                v_parametros.descripcion,
                'activo'
               )RETURNING id_regional into v_id_regional;
               
               --v_mensaje_error = f1();

		v_resp = f_agrega_clave(v_resp,'mensaje','Regional almacenada con exito (id_regional'||v_id_regional||')'); 
               v_resp = f_agrega_clave(v_resp,'id_regional',v_id_regional::varchar);

               return v_resp;

         END;
/*******************************
 #TRANSACCION:  SEG_REGION_MOD
 #DESCRIPCION:	Modifica Regional
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     elsif(p_transaccion='SEG_REGION_MOD')then

          BEGIN

               update segu.tregional set
               nombre=v_parametros.nombre,
               descripcion=v_parametros.descripcion
               where id_regional=v_parametros.id_regional;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Regional modificada'); 
               v_resp = f_agrega_clave(v_resp,'id_regional',v_parametros.id_regional::varchar);
               
               return v_resp;
          END;
/*******************************
 #TRANSACCION:  SEG_REGION_ELI
 #DESCRIPCION:	Elimina Regional
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
    elsif(p_transaccion='SEG_REGION_ELI')then

          --consulta:=';
          BEGIN
               --raise exception 'Error al eliminar';
               delete from segu.tregional
               where id_regional=v_parametros.id_regional;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Regional eliminada'); 
               v_resp = f_agrega_clave(v_resp,'id_regional',v_parametros.id_regional::varchar);
              
               return v_resp;
         END;
         
     else
     
         raise exception 'Transacción inexistente: %',p_transaccion;

     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
        
END;
$$;


--
-- TOC entry 1818 (class 1255 OID 208348)
-- Dependencies: 20 3246
-- Name: ft_regional_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_regional_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_regional_sel
 DESCRIPCION:   consultas de regionales
 AUTOR: 		KPLIAN(jrr)	
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)		
 FECHA:		08/01/11
***************************************************************************/


DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
    v_resp				varchar;

BEGIN

    v_parametros:=f_get_record(p_tabla);
    v_nombre_funcion:='segu.ft_regional_sel';

 /*******************************
 #TRANSACCION:  SEG_REGION_SEL
 #DESCRIPCION:	Selecciona Regionales
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
    if p_transaccion = 'SEG_REGION_SEL' then

    	begin
        	v_consulta:='select
            			id_regional, fecha_reg, estado_reg,
                        nombre, descripcion
            			from segu.tregional
                        where  ';
            v_consulta:=v_consulta||v_parametros.filtro;
            v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;
            return v_consulta;
		end;

 /*******************************
 #TRANSACCION:  SEG_REGION_CONT
 #DESCRIPCION:	Cuenta Regionales
 #AUTOR:		KPLIAN(jrr)		
 #FECHA:		08/01/11	
***********************************/
    elsif p_transaccion = 'SEG_REGION_CONT' then

        begin
        	v_consulta:='select count(id_regional)
            			from segu.tregional
                        where ';
            v_consulta:=v_consulta||v_parametros.filtro;
            return v_consulta;
        end;

     else
     
         raise exception 'Transaccion inexistente';
         
     end if;

EXCEPTION

	WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1819 (class 1255 OID 208349)
-- Dependencies: 20 3246
-- Name: ft_rol_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_rol_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************

 FUNCION: 		segu.ft_rol_ime
 DESCRIPCIÓN: 	registro de roles
 AUTOR: 		KPLIAN(rac)	
 FECHA:			19/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE


v_parametros           record;
v_resp                  varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_id_rol 					integer;

BEGIN

     v_nombre_funcion:='segu.ft_rol_ime';
     v_parametros:=f_get_record(p_tabla);
/*******************************
 #TRANSACCION:  SEG_ROL_INS
 #DESCRIPCION:	Inserta Rol
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
     if(p_transaccion='SEG_ROL_INS')then

        
          BEGIN
               insert into segu.trol(descripcion,rol,id_subsistema)
               values(v_parametros.descripcion,v_parametros.rol,v_parametros.id_subsistema)
                RETURNING id_rol into v_id_rol;

                     
               v_resp = f_agrega_clave(v_resp,'mensaje','Rol insertado con exito '||v_id_rol); 
               v_resp = f_agrega_clave(v_resp,'id_rol',v_id_rol::varchar);


         END;
/*******************************
 #TRANSACCION:  SEG_ROL_MOD
 #DESCRIPCION:	Modifica Rol
 #AUTOR:		KPLIAN(rac)
 #FECHA:		08/01/11	
***********************************/
     elsif(p_transaccion='SEG_ROL_MOD')then

          
          BEGIN
               
               update segu.trol set
                      
                      descripcion=v_parametros.descripcion,
                     
                      rol=v_parametros.rol,
                      id_subsistema=v_parametros.id_subsistema
               where id_rol=v_parametros.id_rol;


           
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Rol modificado con exito '||v_parametros.id_rol); 
               v_resp = f_agrega_clave(v_resp,'id_rol',v_parametros.id_rol::varchar);

          END;
/*******************************
 #TRANSACCION:  SEG_ROL_ELI
 #DESCRIPCION:	Elimina Rol
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
    elsif(p_transaccion='SEG_ROL_ELI')then

         
          BEGIN
               update segu.trol set estado_reg='inactivo'
               where id_rol=v_parametros.id_rol;
               
                     
               v_resp = f_agrega_clave(v_resp,'mensaje','Rol eliminado con exito '||v_parametros.id_rol); 
               v_resp = f_agrega_clave(v_resp,'id_rol',v_parametros.id_rol::varchar);

               
         END;

     else

         raise exception 'No existe la transaccion: %',p_transaccion;
     end if;
 return v_resp;      
EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1820 (class 1255 OID 208350)
-- Dependencies: 20 3246
-- Name: ft_rol_procedimiento_gui_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_rol_procedimiento_gui_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_rol_procedimiento_gui_sel
 DESCRIPCIÓN: 	listado de procesimientos asignado 
                a una intarface segun el rol especificado
 AUTOR: 		KPLIAN(rac)
 FECHA:			26/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/


DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_id_padre         integer;

v_resp                  varchar;
v_where varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.f_t_rol_procedimiento_gui_sel';


 /*******************************
 #TRANSACCION:  SEG_ROLPROGUI_SEL
 #DESCRIPCION:	Selecciona Procesos por Gui y Rol
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_ROLPROGUI_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            pg.id_procedimiento_gui,
                            pg.id_gui,
                            pg.id_procedimiento,
                            p.codigo,
                            p.descripcion,
                            (case
                             when exists (  SELECT 1
                                            FROM segu.trol_procedimiento_gui rpg
                                            WHERE rpg.id_procedimiento_gui=pg.id_procedimiento_gui
                                            and rpg.estado_reg=''activo'' and rpg.id_rol='||v_parametros.id_rol||')then
                               ''true''
                             ELSE
                                ''false''
                             end)::varchar as checked,
                             (''transaccion'')::varchar as tipo_meta,
                             (pg.id_procedimiento_gui||''_transaccion'')::varchar  as id_nodo,
                            '||v_parametros.id_rol||'::integer as id_rol
                            
                        FROM segu.tprocedimiento_gui pg
                        INNER JOIN segu.tprocedimiento p
                            ON(p.id_procedimiento=pg.id_procedimiento)
                        
                        WHERE pg.estado_reg=''activo''' ;

                    if(v_parametros.id_padre = '%') then
                        v_id_padre:=0;
                
                    else
                        v_id_padre:=v_parametros.id_padre;
                    end if;

               v_consulta:=v_consulta|| ' and pg.id_gui= '|| v_id_padre;
               

                        
             
               return v_consulta;


         END;


 /*******************************
 #TRANSACCION:  SEG_ROLPRO_CONT
 #DESCRIPCION:	Cuenta Procesos por Gui y Rol
 #AUTOR:		KPLIAN(rac)
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_ROLPRO_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(rolpro.id_rol_procedimiento)
                            FROM segu.trol_procedimiento rolpro
                            WHERE rolpro.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;
EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1821 (class 1255 OID 208351)
-- Dependencies: 20 3246
-- Name: ft_rol_procedimiento_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_rol_procedimiento_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_rol_procedimiento_gui_ime
 DESCRIPCION:   modificaciones rol procedimiento
 AUTOR: 		KPLIAN(jrr)
 FECHA:	
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	actualizacion a nueva version xph
 AUTOR:		KPLIAN(jrr)	
 FECHA:		08/01/11
***************************************************************************/

DECLARE


v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_resp                 varchar;
v_id_rol_procedimiento  integer;

BEGIN

     v_nombre_funcion:='segu.ft_rol_procedimiento_gui_ime';
     v_parametros:=f_get_record(par_tabla);
/*******************************
 #TRANSACCION:  SEG_ROLPRO_INS
 #DESCRIPCION:	Inserta Rol Procedimiento gui
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     if(par_transaccion='SEG_ROLPRO_INS')then

        
          BEGIN
               insert into segu.trol_procedimiento_gui
               (id_procedimiento,                   id_rol)
               values(
               v_parametros.id_procedimiento,       v_parametros.id_rol
               )RETURNING id_rol_procedimiento into v_id_rol_procedimiento;


               v_resp = f_agrega_clave(v_resp,'mensaje','Rol Procedimiento gui insertado con exito '||v_id_rol_procedimiento);
               v_resp = f_agrega_clave(v_resp,'id_rol_procedimiento',v_id_rol_procedimiento::varchar);



         END;
/*******************************
 #TRANSACCION:  SEG_ROLPRO_MOD
 #DESCRIPCION:	modifica Rol Procedimiento gui
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		08/01/11	
***********************************/
     elsif(par_transaccion='SEG_ROLPRO_MOD')then

          
          BEGIN
               
               update segu.trol_procedimiento_gui set
                      
                      id_procedimiento=v_parametros.id_procedimiento,
                      id_rol=v_parametros.id_rol


               where id_rol_procedimiento=v_parametros.id_rol_procedimiento;

               v_resp = f_agrega_clave(v_resp,'mensaje','Rol Procedimiento gui modificado con exito '||v_parametros.id_rol_procedimiento);
               v_resp = f_agrega_clave(v_resp,'id_rol_procedimiento',v_parametros.id_rol_procedimiento::varchar);



          END;
/*******************************
 #TRANSACCION:  SEG_ROLPRO_ELI
 #DESCRIPCION:	elimina Rol Procedimiento gui
 #AUTOR:		KPLIAN(jrr)
 #FECHA:		08/01/11	
 *********************************
 #DESCRIPCION_MOD:	la eliminacion tiene que ser fisica no por estado
 					para permitir eliminar procedimientos_gui
 #AUTOR_MOD:		KPLIAN(rac)
 #FECHA_MOD:		08/02/12	
***********************************/
    elsif(par_transaccion='SEG_ROLPRO_ELI')then

         
          BEGIN
             /*
               update segu.trol_procedimiento_gui set estado_reg='inactivo'
               where id_rol_procedimiento=v_parametros.id_rol_procedimiento;
              */
              
              delete from segu.trol_procedimiento_gui 
              where id_rol_procedimiento=v_parametros.id_rol_procedimiento;
          
          
           v_resp = f_agrega_clave(v_resp,'mensaje','Rol Procedimiento gui eliminado con exito '||v_parametros.id_rol_procedimiento);
               v_resp = f_agrega_clave(v_resp,'id_rol_procedimiento',v_parametros.id_rol_procedimiento::varchar);


         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
    return v_resp;
EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1822 (class 1255 OID 208352)
-- Dependencies: 20 3246
-- Name: ft_rol_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_rol_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_rol_sel
 DESCRIPCION:   
 AUTOR: 		KPLIAN(jrr)
 FECHA:	
 COMENTARIOS:	
***************************************************************************/
DECLARE


v_consulta    varchar;
v_parametros  record;
v_resp                  varchar;
v_nombre_funcion   text;
v_mensaje_error    text;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(p_tabla);
     v_nombre_funcion:='segu.ft_rol_sel';


     if(p_transaccion='SEG_ROL_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            roll.id_rol,
                            roll.descripcion,
                            roll.fecha_reg,
                            roll.estado_reg,
                            roll.rol,
                            roll.id_subsistema,
                            coalesce(subsis.nombre,'' '') as desc_subsis
                        FROM segu.trol roll
                        LEFT join segu.tsubsistema subsis
                        on subsis.id_subsistema=roll.id_subsistema where roll.estado_reg = ''activo'' AND ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;


     elsif(p_transaccion='SEG_ROL_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(roll.id_rol)
                            FROM segu.trol roll
                        LEFT JOIN segu.tsubsistema subsis
                        on subsis.id_subsistema=roll.id_subsistema where roll.estado_reg = ''activo'' AND ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1823 (class 1255 OID 208353)
-- Dependencies: 20 3246
-- Name: ft_sesion_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_sesion_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_sesion_ime
 DESCRIPCIÓN: 	Permite registrar de sesiones activas e inectavas de un usuario
 AUTOR: 		KPLIAN(rac)
 FECHA:			19/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE


v_parametros       	record;
v_resp              varchar;
v_respuesta        	varchar;
v_nombre_funcion   	text;
v_mensaje_error    	text;
v_id_sesion			integer;

BEGIN

     v_nombre_funcion:='segu.ft_sesion_ime';
     v_parametros:=f_get_record(par_tabla);
     
 /*******************************    
 #TRANSACCION:  SEG_SESION_INS
 #DESCRIPCION:	registra sesiones  de un usuario
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		19/07/2010
***********************************/
     if(par_transaccion='SEG_SESION_INS')then

        
          BEGIN
                update segu.tsesion
                    set estado_reg='inactivo'
                where id_usuario=v_parametros.id_usuario
                    and estado_reg='activo';
               insert into segu.tsesion(
             	variable,
		        ip,
		        fecha_reg,
		        id_usuario,
		        estado_reg,
		        hora_act,
		        hora_des,
                datos,
                pid_web,
                inicio_proceso
		        ) VALUES (
		        v_parametros.variable,
		        v_parametros.ip,
		        now(),
		        v_parametros.id_usuario,
		        'activo',
		        now(),
		        NULL,
                v_parametros.datos,
                v_parametros.pid,
                now()
                		        
            )returning  id_sesion into v_id_sesion;                           
            
            v_resp = f_agrega_clave(v_resp,'mensaje','Sesion insertada con exito '||v_id_sesion); 
            v_resp = f_agrega_clave(v_resp,'id_funcion',v_id_sesion::varchar);
            return 'Sesion  insertada con exito';

         END; 
         
 /*******************************    
 #TRANSACCION:  SEG_SESION_MOD
 #DESCRIPCION:	Modifica la una variable de sesion
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		19/07/2010
***********************************/          
     elseif (par_transaccion='SEG_SESION_MOD')then      
        
          BEGIN
              UPDATE segu.tsesion
              SET datos = v_parametros.datos
              WHERE variable = v_parametros.variable
              and ip = v_parametros.ip;
              
              v_resp = f_agrega_clave(v_resp,'mensaje','Sesion modificada con exito, variable: '||v_parametros.variable); 
              v_resp = f_agrega_clave(v_resp,'variable',v_parametros.variable::varchar);  		        
           
            return 'Sesion  insertada con exito';

         END;         
         	v_resp = f_agrega_clave(v_resp,'mensaje','Sesion modificada con exito '||v_id_sesion); 
            v_resp = f_agrega_clave(v_resp,'id_funcion',v_id_sesion::varchar);
     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

EXCEPTION

       WHEN OTHERS THEN

         v_mensaje_error:=f_get_mensaje_err(SQLSTATE::varchar,SQLERRM::text,v_nombre_funcion,null,null);
         raise exception '%', v_mensaje_error;


END;
$$;


--
-- TOC entry 1846 (class 1255 OID 208354)
-- Dependencies: 20 3246
-- Name: ft_sesion_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_sesion_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************

 FUNCION: 		segu.ft_sesion_sel
 DESCRIPCIÓN: 	consultar la ultima sesion de un suario especificado
 AUTOR: 		KPLIAN(rac)
 FECHA:			19/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE                      

v_consulta    		varchar;
v_parametros  		record;
v_nombre_funcion   	text;
v_mensaje_error    	text;
v_resp 				varchar;
v_pid_web        integer;
v_id_sesion        integer;

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_sesion_sel';

/*******************************    
 #TRANSACCION:  SEG_SESION_SEL
 #DESCRIPCION:	Listado de las sesiones activas en el sistema
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		19/07/2010
***********************************/
     if(par_transaccion='SEG_SESION_SEL')then

          --consulta:=';
          BEGIN
                select pid_web,id_sesion
                into v_pid_web,v_id_sesion
                from segu.tsesion
                where id_usuario=v_parametros.id_usuario
                    and estado_reg='activo';
                    
                    raise notice 'v_pid_web: % v_id_sesion: %', v_pid_web, v_id_sesion;
                    
                --raise exception '%,%',v_pid_web,v_parametros.pid;
                if(v_pid_web!=v_parametros.pid)then
                    update segu.tsesion
                    set pid_web=v_parametros.pid,
                        inicio_proceso=now()
                    where id_sesion=v_id_sesion;
                end if;
               v_consulta:='select
                            id_usuario,
                            variable,
                            ip,
                            datos
                        from segu.tsesion 
                        where estado_reg=''activo'' 
                        and id_sesion= ';
               v_consulta:=v_consulta||v_id_sesion;
               v_consulta:=v_consulta||'  order by  id_sesion desc LIMIT 1 OFFSET 0';
	
               return v_consulta;


         END;

/*******************************    
 #TRANSACCION:  SEG_SESION_CONT
 #DESCRIPCION:	Contar  las sesiones activas en el sistema
 #AUTOR:		KPLIAN(rac)
 #FECHA:		19/07/2010
***********************************/
     elsif(par_transaccion='SEG_SESION_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(s.id_sesion)
                            from segu.tsesion s
                            where usuact.estado_reg=''activo'' and s.id_usuario = ';
               v_consulta:=v_consulta||v_parametros.id_usuario;
               return v_consulta;
         END;

     else
        
         
          raise exception 'No existe la transaccion: %',par_transaccion;

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1824 (class 1255 OID 208355)
-- Dependencies: 20 3246
-- Name: ft_subsistema_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_subsistema_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_subsistema
 DESCRIPCIÓN: 	gestion de subsistemas
 AUTOR: 		KPLIAN(rac)
 FECHA:			16/9/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/


DECLARE

v_consulta  				varchar;
v_parametros                record;
v_nombre_funcion            text;
v_mensaje_error             text;
v_id                        integer;
v_esquema                   varchar;
v_resp 						varchar;
v_id_gui  					varchar;

BEGIN

     v_nombre_funcion:='segu.ft_subsistema_ime';
     v_parametros:=f_get_record(par_tabla);

 /*******************************    
 #TRANSACCION:  SEG_SUBSIS_INS
 #DESCRIPCION:	Inserta Subsistemas
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		16/9/2010
***********************************/
     if(par_transaccion='SEG_SUBSIS_INS')then

        
          BEGIN
            INSERT INTO segu.tsubsistema(
                      codigo,
                      nombre,
                      prefijo,
                      nombre_carpeta
                   )
             values(
                      v_parametros.codigo,
                      v_parametros.nombre,
                      v_parametros.prefijo,
                      v_parametros.nombre_carpeta)
             RETURNING id_subsistema into v_id;

               -- crear el esquema para el subsistema creado
               v_esquema:=v_parametros.codigo;
               if not exists(SELECT 1 from pg_namespace 
                             WHERE lower(nspname)=lower(v_parametros.codigo)) THEN
                  
                  v_consulta:='CREATE SCHEMA '||v_esquema||' ';--AUTHORIZATION postgres;
                  
                  execute(v_consulta);
               end if;
               
               --crear el metaproceso para el subsistema
               if not exists(SELECT 1 from segu.tgui 
                             WHERE lower(codigo_gui)=v_parametros.codigo 
                             AND id_subsistema=v_id) THEN
                             
                  INSERT INTO segu.tgui(
                            codigo_gui,
                            descripcion,
                            id_subsistema, 
                            nombre,
                            nivel
                            )
                  VALUES(
                           v_parametros.codigo,
                            '',
                           v_id,
                           upper(v_parametros.nombre),
                           1) returning  id_gui into v_id_gui;
               end if;

               --return 'Subsistema insertado con exito';
               
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Subsistema insertado con exito '||v_id_gui); 
               v_resp = f_agrega_clave(v_resp,'id_subsistema',v_id_gui::varchar);

               
         END;

 /*******************************    
 #TRANSACCION:  SEG_SUBSIS_MOD
 #DESCRIPCION:	Modifica el subsistema seleccionada 
 #AUTOR:		KPLIAN(rac)	
 #FECHA:			
***********************************/
     elsif(par_transaccion='SEG_SUBSIS_MOD')then  
          
          BEGIN
               
               UPDATE segu.tsubsistema SET
                      
                      codigo=v_parametros.codigo,
                      prefijo=v_parametros.prefijo,
                      nombre=v_parametros.nombre,
                      nombre_carpeta=v_parametros.nombre_carpeta
               WHERE id_subsistema=v_parametros.id_subsistema;

               v_resp = f_agrega_clave(v_resp,'mensaje','Subsistema modificado con exito '||v_parametros.id_subsistema); 
               v_resp = f_agrega_clave(v_resp,'id_subsistema',v_parametros.id_subsistema::varchar);

               
          END;

/*******************************    
 #TRANSACCION:   SEG_SUBSIS_ELI
 #DESCRIPCION:	Inactiva el subsistema selecionado
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		
***********************************/
    elsif(par_transaccion='SEG_SUBSIS_ELI')then

         
          BEGIN
               UPDATE segu.tsubsistema 
               SET estado_reg='inactivo'
               WHERE id_subsistema=v_parametros.id_subsistema;
             
               v_resp = f_agrega_clave(v_resp,'mensaje','Subsistema eliminado con exito '||v_parametros.id_subsistema); 
               v_resp = f_agrega_clave(v_resp,'id_subsistema',v_parametros.id_subsistema::varchar);

         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
 
--retorna respuesta en formato JSON    
 return v_resp;      

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1825 (class 1255 OID 208356)
-- Dependencies: 20 3246
-- Name: ft_subsistema_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_subsistema_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.fvalidar_usuario
 DESCRIPCIÓN: 	verifica si el login y contgrasena proporcionados son correctos
                esta funcion es especial porque corre con el usario generico de conexion
                que solo tiene el privilegio de correr esta funcion
 AUTOR: 		KPLIAN (rac)
 FECHA:			26/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/
DECLARE


v_consulta    		varchar;
v_parametros  		record;
v_nombre_funcion   	text;
v_mensaje_error    	text;
v_resp 				varchar;


/*
PARAMETROS PREDEFINIDOS RECIBIDO PARA LA FUNCIONES TIPO SEL
'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN
     -- recupera datos pasados como parametros en el  servidor web
     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_subsistema_sel';

/*******************************    
 #TRANSACCION:  SEG_FUNCIO_SEL
 #DESCRIPCION:	Listado de los subsistemas registradas del sistema
 #AUTOR:		KPLIAN (rac)	
 #FECHA:		
***********************************/
     if(par_transaccion='SEG_SUBSIS_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                              subsis.id_subsistema,
                              subsis.codigo,
                              subsis.prefijo,
                              subsis.nombre,
                              subsis.fecha_reg,
                              subsis.estado_reg,
                              subsis.nombre_carpeta
                        FROM segu.tsubsistema subsis
                        WHERE subsis.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               --raise exception '%',v_consulta;

               return v_consulta;
              

         END;                          

/*******************************    
 #TRANSACCION:  SEG_SUBSIS_CONT
 #DESCRIPCION:	Contar  los subsistemas registrados del sistema
 #AUTOR:		KPLIAN (rac)	
 #FECHA:		
***********************************/
     elsif(par_transaccion='SEG_SUBSIS_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT
                                  count(subsis.id_subsistema)
                            FROM  segu.tsubsistema subsis
                            WHERE subsis.estado_reg=''activo'' and  ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;


EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1826 (class 1255 OID 208357)
-- Dependencies: 20 3246
-- Name: ft_tipo_documento_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_tipo_documento_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.fprocedimiento_sel
 DESCRIPCIÓN: 	Realiza el listado de procedimientos (trasacciones)
 AUTOR: 		KPLIAN (rac)
 FECHA:			17/10/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/DECLARE


v_consulta    		varchar;
v_parametros  		record;
v_nombre_funcion   	text;
v_mensaje_error    	text;
v_resp              varchar;



/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_tipo_documento_sel';

/*******************************    
 #TRANSACCION:  SEG_TIPDOC_SEL
 #DESCRIPCION:	Listado de los procedimientos de BD
 #AUTOR:		KPLIAN (rac)	
 #FECHA:		
***********************************/
     if(par_transaccion='SEG_TIPDOC_SEL')then
                        

          --consulta:=';
          BEGIN

               v_consulta:='select 
                            tipdoc.id_tipo_documento,
                            tipdoc.nombre,
                            tipdoc.fecha_reg,
                            tipdoc.estado_reg
                        from segu.ttipo_documento tipdoc
                        where tipdoc.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

/*******************************    
 #TRANSACCION:  SEG_FUNCIO_CONT
 #DESCRIPCION:	Contar  los procedimeintos de BD registradas del sistema
 #AUTOR:		KPLIAN (rac)
 #FECHA:		
***********************************/
     elsif(par_transaccion='SEG_TIPDOC_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(tipdoc.id_tipo_documento)
                            from segu.ttipo_documento tipdoc
                            where tipdoc.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1827 (class 1255 OID 208358)
-- Dependencies: 20 3246
-- Name: ft_usuario_actividad_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_usuario_actividad_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_usuario_actividad_ime
 DESCRIPCIÓN: 	gestiona las transaciones ime de usairio-actividad
 AUTOR: 		KPLIAN (jrr)
 FECHA:			28/02/2008
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/

DECLARE


v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_id_usuario_actividad		integer;
v_resp			varchar;

BEGIN

     v_nombre_funcion:='segu.f_t_usuario_actividad_ime';
     v_parametros:=f_get_record(par_tabla);

 /*******************************    
 #TRANSACCION:  SEG_USUACT_INS
 #DESCRIPCION:  Relaciona actividades con usuario
 #AUTOR:		KPLIAN (jrr)
 #FECHA:		28-02-2010	
***********************************/

     if(par_transaccion='SEG_USUACT_INS')then

        
          BEGIN
               insert into segu.tusuario_actividad(id_usuario,id_actividad)
               values(v_parametros.id_usuario,v_parametros.id_actividad)
               returning  id_usuario_actividad into v_id_usuario_actividad;

               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario actividad insertado con exito '||v_id_usuario_actividad); 
               v_resp = f_agrega_clave(v_resp,'id_usuario_actividad',v_id_usuario_actividad::varchar);


         END;
 /*******************************    
 #TRANSACCION:  SEG_USUACT_MOD
 #DESCRIPCION:  Modifica la relacion de  actividades con usuario
 #AUTOR:		KPLIAN (jrr)	
 #FECHA:		28-02-2010	
***********************************/
     elsif(par_transaccion='SEG_USUACT_MOD')then

          
          BEGIN
               
               update segu.tusuario_actividad set
                      id_usuario=v_parametros.id_usuario,
                      id_actividad=v_parametros.id_actividad
                     
               where id_usuario_actividad=v_parametros.id_usuario_actividad;

               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario actividad modificado con exito '||v_parametros.id_usuario_actividad); 
               v_resp = f_agrega_clave(v_resp,'id_usuario_actividad',v_parametros.id_usuario_actividad::varchar);

          END;
 /*******************************    
 #TRANSACCION:  SEG_USUACT_ELI
 #DESCRIPCION:  Inactivacion de la relacion de  actividades con usuario
 #AUTOR:		KPLIAN (jrr)	
 #FECHA:		28-02-2010	
***********************************/

    elsif(par_transaccion='SEG_USUACT_ELI')then

         
          BEGIN
               update segu.tusuario_actividad 
               set estado_reg='inactivo'
               where id_usuario_actividad=v_parametros.id_usuario_actividad;
            
          
               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario actividad inactivado con exito '||v_parametros.id_usuario_actividad); 
               v_resp = f_agrega_clave(v_resp,'id_usuario_actividad',v_parametros.id_usuario_actividad::varchar);

         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

return v_resp;

EXCEPTION

        WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1828 (class 1255 OID 208359)
-- Dependencies: 20 3246
-- Name: ft_usuario_actividad_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_usuario_actividad_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_usuario_actividad_sel
 DESCRIPCIÓN: 	manejo de actividades por usuario
 AUTOR: 		KPLIAN(jrr)
 FECHA:		    28/02/2008
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR: 		Rensi Arteaga Copari
 FECHA:			16/11/2010			
***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_usuario_actividad_sel';
     
     
 /*******************************    
 #TRANSACCION:  SEG_USUACT_SEL
 #DESCRIPCION:	lista las actividades por usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/

     if(par_transaccion='SEG_USUACT_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                            usuact.id_usuario_actividad,
                            usuact.id_usuario,
                            usuact.id_actividad,
                            usuact.fecha_reg,
                            usuact.estado_reg,
                            activi.nombre as desc_actividad,
                            person.nombre_completo2 as desc_person
                        FROM segu.tusuario_actividad usuact
                        INNER JOIN segu.tusuario usuari
                        on usuari.id_usuario=usuact.id_usuario 
                        INNER JOIN segu.tactividad activi
                        on activi.id_actividad=usuact.id_actividad and activi.estado_reg=''activo''
                        INNER JOIN segu.vpersona person
                        on person.id_persona=usuari.id_persona
                        WHERE usuact.estado_reg=''activo'' and ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

 /*******************************    
 #TRANSACCION:  SEG_USUACT_CONT
 #DESCRIPCION:	Contar  las actividades por usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/
     elsif(par_transaccion='SEG_USUACT_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(usuact.id_usuario_actividad)
                            FROM segu.tusuario_actividad usuact
                            INNER JOIN segu.tusuario usuari
                            ON usuari.id_usuario=usuact.id_usuario
                            INNER JOIN segu.tactividad activi
                            ON activi.id_actividad=usuact.id_actividad
                            where usuact.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


--
-- TOC entry 1829 (class 1255 OID 208360)
-- Dependencies: 20 3246
-- Name: ft_usuario_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_usuario_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************

 FUNCION: 		segu.ft_usuario_ime
 DESCRIPCIÓN: 	Permite registrar de de usuarios
 AUTOR: 		KPLIAN(rac)
 FECHA:			19/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			

***************************************************************************/

DECLARE


v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_id_usuario integer;
v_resp varchar;
v_id_roles varchar[];
v_i integer;
v_tamano integer;
--05-04-2012
v_respuesta_sinc       varchar;


v_sincronizar varchar;
v_sincronizar_user varchar;
v_sincronizar_password varchar;
v_sincronizar_base varchar;
v_sincronizar_ip varchar;
v_sincronizar_puerto varchar;





BEGIN

     v_nombre_funcion:='segu.ft_usuario_ime';
     v_parametros:=f_get_record(par_tabla);
     
     
     
     /*
     Obtener variables globales para definir la sincronizacion
     
     */
     
    v_sincronizar = f_get_variable_global('sincronizar');
	v_sincronizar_user= f_get_variable_global('sincronizar_user');
	v_sincronizar_password = f_get_variable_global('sincronizar_password');
	v_sincronizar_base= f_get_variable_global('sincronizar_base');
	v_sincronizar_ip= f_get_variable_global('sincronizar_ip');
	v_sincronizar_puerto=f_get_variable_global('sincronizar_puerto');
    
   
     
    
     
     
 /*******************************    
 #TRANSACCION: SEG_USUARI_INS
 #DESCRIPCION:	Inserta usuarios
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		19/07/2010
 ***************************************************************************
 HISTORIA DE MODIFICACIONES:
 #DESCRIPCION_MOD:	Aumenta campo de tipo de autentificacion
 #AUTOR_MOD: RAC	
 #FECHA_MOD: 01/03/2012		
***********************************/

     if(par_transaccion='SEG_USUARI_INS')then

        
          BEGIN
            
             INSERT  INTO segu.tusuario(
               				 id_clasificador,
                              cuenta,
                              contrasena,
                              fecha_caducidad,
                              estilo,
                              contrasena_anterior,
                              id_persona,
                              autentificacion)
                              
                       VALUES( 
                       
                        v_parametros.id_clasificador,
                        v_parametros.cuenta,
                        v_parametros.contrasena,
                        v_parametros.fecha_caducidad,
                        v_parametros.estilo,
                        NULL,
                        v_parametros.id_persona,
                        v_parametros.autentificacion)
                       RETURNING id_usuario into v_id_usuario;
            
             --05-04-2012:
             IF  v_sincronizar='true' THEN
                 v_respuesta_sinc:= segu.f_sincroniza_usuario_entre_bd(v_id_usuario,v_sincronizar_ip,v_sincronizar_puerto,v_sincronizar_user,v_sincronizar_password,v_sincronizar_base,'INSERT');
    	         if(v_respuesta_sinc!='si') then   
                     raise exception 'Sincronizacion de usuario en BD externa no realizada';
                 end if;  
             
             END IF;
             --fin 05-04-2012
             
             
             
             --insertamos los roles del usuario
             v_id_roles= string_to_array(v_parametros.id_roles,',');
             v_tamano = coalesce(array_length(v_id_roles, 1),0);
             

            
             FOR v_i IN 1..v_tamano LOOP
         
              --insertamos  registro si no esta presente como activo
                  insert into segu.tusuario_rol 
                     (id_usuario, 
                     id_rol, 
                     estado_reg) 
                  values(
                  v_id_usuario,
                  v_id_roles[v_i]::integer,
                  'activo'); 
             
             END LOOP;
                      
             v_resp = f_agrega_clave(v_resp,'mensaje','Usuario insertada con exito '||v_id_usuario); 
             v_resp = f_agrega_clave(v_resp,'id_usuario',v_id_usuario::varchar);

                            

         END;
         
 /*******************************    
 #TRANSACCION:  SEG_USUARI_MOD
 #DESCRIPCION:	Modifica datos de  usuario
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		19/07/2010
***********************************/

     elsif(par_transaccion='SEG_USUARI_MOD')then

          
          BEGIN
          
         -- raise exception '%',v_parametros.id_roles;
          
          IF v_parametros.contrasena_old != v_parametros.contrasena THEN
                         
             UPDATE segu.tusuario SET
                      id_clasificador=v_parametros.id_clasificador,
                      cuenta=v_parametros.cuenta,
                      contrasena=v_parametros.contrasena,
                      fecha_caducidad=v_parametros.fecha_caducidad,                      
                      estilo=v_parametros.estilo,
                      contrasena_anterior=v_parametros.contrasena_old,
                      id_persona=v_parametros.id_persona,
                      autentificacion=v_parametros.autentificacion
             WHERE id_usuario=v_parametros.id_usuario;
            
              --05-04-2012:
                IF  v_sincronizar= 'true' THEN
                
                
                 v_respuesta_sinc:= segu.f_sincroniza_usuario_entre_bd(v_id_usuario,v_sincronizar_ip,v_sincronizar_puerto,v_sincronizar_user,v_sincronizar_password,v_sincronizar_base,'UPDATE');
    	         if(v_respuesta_sinc!='si') then   
                      raise exception 'Sincronizacion de actualizacion de usuario en BD externa no realizada';
                 end if;  
             
                END IF;
             
             --fin 05-04-2012
             
             v_resp = f_agrega_clave(v_resp,'mensaje','Contraseña de usuario modificada con exito id_usuario='||v_parametros.id_usuario); 
                  
          ELSE
               
               
               UPDATE segu.tusuario SET
                      id_clasificador=v_parametros.id_clasificador,
                      cuenta=v_parametros.cuenta,                     
                      fecha_caducidad=v_parametros.fecha_caducidad,                      
                      estilo=v_parametros.estilo,                   
                      id_persona=v_parametros.id_persona,
                      autentificacion=v_parametros.autentificacion
                     
               WHERE id_usuario=v_parametros.id_usuario;
               
               --05-04-2012:
               
               
               IF  v_sincronizar= 'true' THEN
                
                 v_respuesta_sinc:= segu.f_sincroniza_usuario_entre_bd(v_id_usuario,v_sincronizar_ip,v_sincronizar_puerto,v_sincronizar_user,v_sincronizar_password,v_sincronizar_base,'UPDATE');
    	         if(v_respuesta_sinc!='si') then   
                      raise exception 'Sincronizacion de actualizacion de usuario en BD externa no realizada';
                 end if;  
             
                END IF;
               
                
               --fin 05-04-2012
                
                v_resp = f_agrega_clave(v_resp,'mensaje','Cuenta de usuario modificada con exito id_usuario= '||v_parametros.id_usuario); 
           
            END IF;

             v_resp = f_agrega_clave(v_resp,'id_usuario',v_parametros.id_usuario::varchar); 
             
             
             --modificamos lor roles relacionados al usuario
             --partimos los datos de id_roles en un vector
             
           
             v_id_roles= string_to_array(v_parametros.id_roles,',');
             v_tamano = coalesce(array_length(v_id_roles, 1),0);
             
             
             
             -- inactivamos todos los roles que no estan hay
             
             update segu.tusuario_rol 
             set estado_reg='inactivo'
             where 
             id_usuario = v_parametros.id_usuario
             and 
             (id_rol::varchar != ANY(v_id_roles) or v_tamano=0);
            --insertamos los que faltan
  
            
            FOR v_i IN 1..v_tamano LOOP
                         
              --preguntamos si el id_rol ya se encuentra asignado si no insertamos
            IF  (NOT EXISTS (select 1 from segu.tusuario_rol 
                        where id_usuario = v_parametros.id_usuario
                        and id_rol = v_id_roles[v_i]::integer 
                        and estado_reg='activo')) THEN
              --insertamos  registro si no esta presente como activo
                  insert into segu.tusuario_rol 
                     (id_usuario, 
                     id_rol, 
                     estado_reg) 
                  values(
                  v_parametros.id_usuario,
                  v_id_roles[v_i]::integer,
                  'activo'); 
              END IF;
            END LOOP;
             
          
          END;
          
/*******************************    
 #TRANSACCION: SEG_USUARI_ELI
 #DESCRIPCION:	Eliminar Usuarios
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		19/07/2010
***********************************/
 elsif(par_transaccion='SEG_USUARI_ELI')THEN
    

         
          BEGIN
               update segu.tusuario set estado_reg='inactivo'
               where id_usuario=v_parametros.id_usuario;
               
               --05-04-2012:
             
               
                IF  v_sincronizar= 'true' THEN
                 v_respuesta_sinc:= segu.f_sincroniza_usuario_entre_bd(v_id_usuario,v_sincronizar_ip,v_sincronizar_puerto,v_sincronizar_user,v_sincronizar_password,v_sincronizar_base,'DELETE');
    	         if(v_respuesta_sinc!='si') then   
                      raise exception 'Sincronizacion de actualizacion de usuario en BD externa no realizada';
                 end if;  
             
                END IF;
               
                
               --fin 05-04-2012
                
               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario inactivado con exito '||v_parametros.id_usuario); 
               v_resp = f_agrega_clave(v_resp,'id_usuario',v_parametros.id_usuario::varchar);
               
         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     
   return v_resp;   

EXCEPTION

       WHEN OTHERS THEN

       	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


--
-- TOC entry 1830 (class 1255 OID 208362)
-- Dependencies: 20 3246
-- Name: ft_usuario_proyecto_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_usuario_proyecto_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_usuario_proyecto_ime
 DESCRIPCIÓN: 	gestiona las transaciones ime de usairio-regional
 AUTOR: 		KPLIAN(jrr)
 FECHA:			28/02/2008
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/

DECLARE


v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_resp varchar;
v_id_usuario_proyecto integer;

BEGIN

     v_nombre_funcion:='segu.f_t_usuario_proyecto_ime';
     v_parametros:=f_get_record(par_tabla);
 /*******************************    
 #TRANSACCION: SEG_USUPRO_INS
 #DESCRIPCION:  Relaciona proyectos con usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/
     if(par_transaccion='SEG_USUPRO_INS')then

        
          BEGIN
               insert into segu.tusuario_proyecto(id_usuario,id_proyecto)
               values(v_parametros.id_usuario,v_parametros.id_proyecto)
               returning  id_usuario_proyecto into v_id_usuario_proyecto;

               v_resp = f_agrega_clave(v_resp,'mensaje','relacion proyecto-usuario insertado con exito '||v_id_usuario_proyecto); 
               v_resp = f_agrega_clave(v_resp,'id_usuario_proyecto',v_id_usuario_proyecto::varchar);



         END;
 /*******************************    
 #TRANSACCION:   SEG_USUPRO_MOD
 #DESCRIPCION:  Modifica la relacion de proyectos con usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/
     elsif(par_transaccion='SEG_USUPRO_MOD')then

          
          BEGIN
               
               update segu.tusuario_proyecto set
                      id_usuario=v_parametros.id_usuario,
                      id_proyecto=v_parametros.id_proyecto
                     
               where id_usuario_proyecto=v_parametros.id_usuario_proyecto;

             v_resp = f_agrega_clave(v_resp,'mensaje','Usuario proyecto modificado con exito '||v_parametros.id_usuario_proyecto); 
             v_resp = f_agrega_clave(v_resp,'id_usuario_proyecto',v_parametros.id_usuario_proyecto::varchar);
     
               
          END;
 /*******************************    
 #TRANSACCION:  SEG_USUPRO_ELI
 #DESCRIPCION:  Inactiva la relacion de proyectos con usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/
    elsif(par_transaccion='SEG_USUPRO_ELI')then

         
          BEGIN
               UPDATE segu.tusuario_proyecto 
               SET estado_reg='inactivo'
               WHERe id_usuario_proyecto=v_parametros.id_usuario_proyecto;
              
          
             v_resp = f_agrega_clave(v_resp,'mensaje','Usuario proyecto inactivado con exito '||v_parametros.id_usuario_proyecto); 
             v_resp = f_agrega_clave(v_resp,'id_usuario_proyecto',v_parametros.id_usuario_proyecto::varchar);
     
         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     
return v_resp;

EXCEPTION

        WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;

END;
$$;


--
-- TOC entry 1831 (class 1255 OID 208363)
-- Dependencies: 20 3246
-- Name: ft_usuario_proyecto_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_usuario_proyecto_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_usuario_proyecto_sel
 DESCRIPCIÓN: 	manejo de proyectos por usuario
 AUTOR: 		KPLIAN(jrr)	
 FECHA:		    28/02/2008
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR: 		Rensi Arteaga Copari
 FECHA:			16/11/2010			
***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_usuario_proyecto_sel';
 /*******************************    
 #TRANSACCION:  SEG_USUREG_SEL
 #DESCRIPCION:	lista las proyectos por usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/

     if(par_transaccion='SEG_USUPRO_SEL')then

       
          BEGIN

               v_consulta:='select 
                            usupro.id_usuario_proyecto,
                            usupro.id_usuario,
                            usupro.id_proyecto,
                            usupro.fecha_reg,
                            usupro.estado_reg,
                            proyec.nombre as desc_proyecto,
                            person.nombre_completo2 as desc_person
                        from segu.tusuario_proyecto usupro
                        inner join segu.tusuario usuari
                        on usuari.id_usuario=usupro.id_usuario
                        inner join segu.tproyecto proyec
                        on proyec.id_proyecto=usupro.id_proyecto
                        inner join segu.vpersona person
                        on person.id_persona=usuari.id_persona
                        where usupro.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;
         
 /*******************************    
 #TRANSACCION:  SEG_USUREG_SEL
 #DESCRIPCION:	contar proyectos por usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/

     elsif(par_transaccion='SEG_USUPRO_CONT')then

          --consulta:=';
          BEGIN

                 v_consulta:='SELECT 
                               count(usupro.id_usuario_proyecto)
                              FROM segu.tusuario_proyecto usupro
                              INNER JOIN segu.tusuario usuari
                                on usuari.id_usuario=usupro.id_usuario
                              INNER JOIN segu.tproyecto proyec
                                on proyec.id_proyecto=usupro.id_proyecto
                              WHERE usupro.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

       WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1832 (class 1255 OID 208364)
-- Dependencies: 20 3246
-- Name: ft_usuario_regional_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_usuario_regional_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_usuario_regional_ime
 DESCRIPCIÓN: 	manejo de regionales por usario
 AUTOR: 		KPLIAN(jrr)
 FECHA:			28/02/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/

DECLARE


v_parametros           record;
v_respuesta            varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_id_usuario_regional       integer;
v_resp                varchar;

BEGIN

     v_nombre_funcion:='segu.f_t_usuario_regional_ime';
     v_parametros:=f_get_record(par_tabla);

 /*******************************    
 #TRANSACCION:  SEG_USUREG_INS
 #DESCRIPCION:	Relaciona una regional al usuario
 #AUTOR:		KPLIAN(jrr)
 #FECHA:		28/02/2010
***********************************/

     if(par_transaccion='SEG_USUREG_INS')then

        
          BEGIN
               insert into segu.tusuario_regional(id_usuario,id_regional)
               values(v_parametros.id_usuario,v_parametros.id_regional)
               returning  id_usuario_regional into v_id_usuario_regional;

               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario-Regional  insertada con exito '||v_id_usuario_regional); 
               v_resp = f_agrega_clave(v_resp,'id_usario_regional',v_id_usuario_regional::varchar);

          END;
          
/*******************************    
 #TRANSACCION:  SEG_USUREG_MOD
 #DESCRIPCION:	Modifica la relacion una regional y un  usuario
 #AUTOR:		KPLIAN(jrr)
 #FECHA:		28/02/2010
***********************************/
     elsif(par_transaccion='SEG_USUREG_MOD')then

          
          BEGIN
               
               update segu.tusuario_regional set
                      id_usuario=v_parametros.id_usuario,
                      id_regional=v_parametros.id_regional
                      
               where id_usuario_regional=v_parametros.id_usuario_regional;

             v_resp = f_agrega_clave(v_resp,'mensaje','Usuario-Regional modificados con exito '||v_parametros.id_usuario_regional); 
             v_resp = f_agrega_clave(v_resp,'id_usuario_regional',v_parametros.id_usuario_regional::varchar);
   
          END;

/*******************************    
 #TRANSACCION:  SEG_USUREG_ELI
 #DESCRIPCION:	Inactiva la relacion de una regional y un  usuario
 #AUTOR:		KPLIAN(jrr)
 #FECHA:		28/02/2010
***********************************/

    elsif(par_transaccion='SEG_USUREG_ELI')then

         
          BEGIN
               update segu.tusuario_regional set estado_reg='inactivo'
               where id_usuario_regional=v_parametros.id_usuario_regional;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario regional eliminado con exito  '||v_parametros.id_usuario_regional); 
               v_resp = f_agrega_clave(v_resp,'id_usuario_regional',v_parametros.id_usuario_regional::varchar);
  
         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;

return v_resp;

EXCEPTION

        WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1833 (class 1255 OID 208365)
-- Dependencies: 20 3246
-- Name: ft_usuario_regional_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_usuario_regional_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_usuario_regional_sel
 DESCRIPCIÓN: 	gestiona las consulta de usario-regional
 AUTOR: 		KPLIAN(jrr)
 FECHA:			28/02/2008
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/

DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp varchar;


/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_usuario_regional_sel';

 /*******************************    
 #TRANSACCION:  SEG_USUREG_SEL
 #DESCRIPCION:	lista las regionales del usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/
     if(par_transaccion='SEG_USUREG_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='select 
                            usureg.id_usuario_regional,
                            usureg.id_usuario,
                            usureg.id_regional,
                            usureg.fecha_reg,
                            usureg.estado_reg,
                            region.nombre as desc_regional,
                            person.nombre_completo2 as desc_person
                        from segu.tusuario_regional usureg
                        inner join segu.tusuario usuari
                        on usuari.id_usuario=usureg.id_usuario
                        inner join segu.tregional region
                        on region.id_regional=usureg.id_regional
                        inner join segu.vpersona person
                        on person.id_persona=usuari.id_persona
                        where usureg.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;
         
 /*******************************    
 #TRANSACCION:  SEG_USUREG_CONT
 #DESCRIPCION:	cuenta las regionales del usuario
 #AUTOR:		KPLIAN(jrr)	
 #FECHA:		28-02-2010	
***********************************/

     elsif(par_transaccion='SEG_USUREG_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select count(usureg.id_usuario_regional)
                            from segu.tusuario_regional usureg
                        inner join segu.tusuario usuari
                        on usuari.id_usuario=usureg.id_usuario
                        inner join segu.tregional region
                        on region.id_regional=usureg.id_regional
                        where usureg.estado_reg=''activo'' and ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1834 (class 1255 OID 208366)
-- Dependencies: 20 3246
-- Name: ft_usuario_rol_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_usuario_rol_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_subsistema
 DESCRIPCIÓN: 	gestion de subsistemas
 AUTOR: 		
 FECHA:			
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	Actualizacion de version de XPH
 AUTOR: 		KPLIAN(rac)
 FECHA:			26/11/2010		
***************************************************************************/

DECLARE


v_parametros           record;
v_resp           varchar;
v_nombre_funcion            text;
v_mensaje_error             text;
v_id_usuario_rol integer;

BEGIN

     v_nombre_funcion:='segu.ft_usuario_rol_ime';
     v_parametros:=f_get_record(par_tabla);
     
 /*******************************    
 #TRANSACCION:  SEG_USUROL_INS
 #DESCRIPCION:	funcion para insertar usuario 
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		16-11-2010	
***********************************/

     if(par_transaccion='SEG_USUROL_INS')then
     
        BEGIN
         --revisa si el usuario ya tiene asignado ese rol
            if(exists(select 1
                      from segu.tusuario_rol
                      where id_rol=v_parametros.id_rol 
                        and id_usuario=v_parametros.id_usuario 
                        and estado_reg='activo'))then
               
               raise exception 'El usuario ya tiene asignado ese rol';
            
            end if;
               
              --insertar el rol si no lo tiene todavia   
               insert into segu.tusuario_rol(id_rol,id_usuario)
               values(v_parametros.id_rol,v_parametros.id_usuario)
               returning id_usuario_rol into v_id_usuario_rol;
               
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario rol insertado con exito '||v_id_usuario_rol); 
               v_resp = f_agrega_clave(v_resp,'id_usuaio_rol',v_id_usuario_rol::varchar);

              
         
         END;
 /*******************************    
 #TRANSACCION:  SEG_USUROL_MOD
 #DESCRIPCION:	modifica roles de usuario
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		16-11-2010	
***********************************/
     elsif(par_transaccion='SEG_USUROL_MOD')then

         --verifica que el nuevo rol que se quiere asignar no
         --no lo este previamente 
          BEGIN
            if(exists(select 1
                      from segu.tusuario_rol
                      where id_rol=v_parametros.id_rol 
                      and id_usuario=v_parametros.id_usuario 
                      and estado_reg='activo'))then
                
                raise exception 'El usuario ya tiene asignado ese rol';
                
            end if;
            
          --modifica el rol del usario  
               update segu.tusuario_rol set
                      id_rol=v_parametros.id_rol,
                      id_usuario=v_parametros.id_usuario
               where id_usuario_rol=v_parametros.id_usuario_rol;
               
               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario rol modificado con exito '||v_parametros.id_usuario_rol); 
               v_resp = f_agrega_clave(v_resp,'id_usuaio_rol',v_parametros.id_usuario_rol::varchar);


          END;
 /*******************************    
 #TRANSACCION:  SEG_USUROL_ELI
 #DESCRIPCION:	retira  el rol asignado a un uusario
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		16-11-2010	
***********************************/
    elsif(par_transaccion='SEG_USUROL_ELI')then

         
          BEGIN
               update segu.tusuario_rol set estado_reg='inactivo'
               where id_usuario_rol=v_parametros.id_usuario_rol;
               return 'Usuario rol inactivcado con exito';
               
          v_resp = f_agrega_clave(v_resp,'mensaje','Usuario rol eliminado con exito '||v_parametros.id_usuario_rol); 
          v_resp = f_agrega_clave(v_resp,'id_usuaio_rol',v_parametros.id_usuario_rol::varchar);

               
         END;

     else

         raise exception 'No existe la transaccion: %',par_transaccion;
     end if;
     
     
     return v_resp;


EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1835 (class 1255 OID 208367)
-- Dependencies: 20 3246
-- Name: ft_usuario_rol_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_usuario_rol_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.ft_usuario_rol_sel
 DESCRIPCIÓN: 	listado de roles por usuario
 AUTOR: 		KPLIAN(rac)
 FECHA:			
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR: 		KPLIAN(rac)
 FECHA:			16/11/2010			
***************************************************************************/


DECLARE


v_consulta    varchar;
v_parametros  record;
v_nombre_funcion   text;
v_mensaje_error    text;
v_resp varchar;

/*

'filtro'
'ordenacion'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN

     v_parametros:=f_get_record(par_tabla);
     v_nombre_funcion:='segu.ft_usuario_rol_sel';

 /*******************************    
 #TRANSACCION:  SEG_USUROL_SEL
 #DESCRIPCION:	Lista los roles activos que corresponden al usuario
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		16-11-2010	
***********************************/


     if(par_transaccion='SEG_USUROL_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT 
                                usurol.id_usuario_rol,
                                usurol.id_rol,
                                usurol.id_usuario,
                                usurol.fecha_reg,
                                usurol.estado_reg,
                                rol.rol,
                                person.nombre_completo2,
                                sub.nombre
                             FROM segu.tusuario_rol usurol
                             INNER JOIN segu.tusuario usuari
                                on usuari.id_usuario=usurol.id_usuario
                             INNER JOIN  segu.trol rol
                               on rol.id_rol=usurol.id_rol
                             LEFT JOIN  segu.tsubsistema sub
                               on sub.id_subsistema=rol.id_subsistema
                             INNER JOIN  segu.vpersona person
                               on person.id_persona=usuari.id_persona
                             WHERE usurol.estado_reg=''activo'' and 
                               usurol.id_usuario = '|| v_parametros.id_usuario || '  and ';
              v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;

               return v_consulta;


         END;

 /*******************************    
 #TRANSACCION:  SEG_USUROL_SEL
 #DESCRIPCION:	cuenta los roles activos que corresponden al usuario
 #AUTOR:		KPLIAN(rac)
 #FECHA:		16-11-2010	
***********************************/
     elsif(par_transaccion='SEG_USUROL_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='select 
                				count(usurol.id_usuario_rol)
                            from segu.tusuario_rol usurol
                            inner join segu.tusuario usuari
                            	on usuari.id_usuario=usurol.id_usuario
                            inner join segu.trol rol
                            	on rol.id_rol=usurol.id_rol
                            left join segu.tsubsistema sub
                            	on sub.id_subsistema=rol.id_subsistema
                            inner join segu.vpersona person
                            	on person.id_persona=usuari.id_persona
                            where usurol.estado_reg=''activo'' and  
                          usurol.id_usuario ='|| v_parametros.id_usuario || '  and ';
              
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1837 (class 1255 OID 208368)
-- Dependencies: 20 3246
-- Name: ft_usuario_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_usuario_sel(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 FUNCION: 		segu.fvalidar_usuario
 DESCRIPCIÓN: 	verifica si el login y contgrasena proporcionados son correctos
                esta funcion es especial porque corre con el usario generico de conexion
                que solo tiene el privilegio de correr esta funcion
 AUTOR: 		KPLIAN(rac)
 FECHA:			26/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/

DECLARE
 
v_consulta              varchar;
v_parametros            record;
v_mensaje_error         text;
v_nombre_funcion        text;
v_resp varchar;

/*

'login'
'password'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN
     v_nombre_funcion:='segu.ft_usuario_sel';
     v_parametros:=f_get_record(par_tabla);
     
/*******************************    
 #TRANSACCION:  SEG_VALUSU_SEL
 #DESCRIPCION:	consulta los datos del usario segun contrasena y login
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		26/07/2010	
***********************************/

     if(par_transaccion='SEG_VALUSU_SEL')then
          --consulta:=';
          BEGIN

               v_consulta:='SELECT u.id_usuario,
                                   u.cuenta,
                                   u.contrasena 
                            FROM segu.tusuario u  
                            WHERE u.cuenta='''||v_parametros.login || '''
                            and u.contrasena=''' || v_parametros.password || ''' 
                            and u.fecha_caducidad>=now()::date 
                            and u.estado_reg=''activo''';

               return v_consulta;
               
          END;
/*******************************    
 #TRANSACCION:  SEG_USUARI_SEL
 #DESCRIPCION:	Listar usuarios activos de sistema
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		26/07/2010	
***********************************/
          
     elsif(par_transaccion='SEG_USUARI_SEL')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT USUARI.id_usuario,
                                   USUARI.id_clasificador,
                                   USUARI.cuenta,
                                   USUARI.contrasena,
                                   USUARI.fecha_caducidad,
                                   USUARI.fecha_reg,
                                   USUARI.estado_reg,
                                   USUARI.estilo,
                                   USUARI.contrasena_anterior,
                                   USUARI.id_persona,
                                   PERSON.nombre_completo2 as desc_person,
                                   CLASIF.descripcion,
                                   text_concat(UR.id_rol::text) as id_roles,
                                   USUARI.autentificacion
                            FROM segu.tusuario USUARI
                                 INNER JOIN segu.vpersona PERSON on PERSON.id_persona = USUARI.id_persona
                                 LEFT JOIN segu.tclasificador CLASIF on CLASIF.id_clasificador =
                                 USUARI.id_clasificador 
                                 LEFT JOIN segu.tusuario_rol UR on ur.estado_reg= ''activo'' 
                                 and ur.id_usuario = usuari.id_usuario
                            WHERE USUARI.estado_reg = ''activo'' and ';
                           
               v_consulta:=v_consulta||v_parametros.filtro;
              
               v_consulta:=v_consulta||'      GROUP BY USUARI.id_usuario,
                                               USUARI.id_clasificador,
                                               USUARI.cuenta,
                                               USUARI.contrasena,
                                               USUARI.fecha_caducidad,
                                               USUARI.fecha_reg,
                                               USUARI.estado_reg,
                                               USUARI.estilo,
                                               USUARI.contrasena_anterior,
                                               USUARI.id_persona,
                                               PERSON.nombre_completo2,
                                               PERSON.nombre,
                                               CLASIF.descripcion,
                                               USUARI.autentificacion';
             v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;


               return v_consulta;


         END;

/*******************************    
 #TRANSACCION:  SEG_USUARI_CONT
 #DESCRIPCION:	Contar usuarios activos de sistema
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		26/07/2010	
***********************************/
     elsif(par_transaccion='SEG_USUARI_CONT')then

          --consulta:=';
          BEGIN

               v_consulta:='SELECT count(USUARI.id_usuario)
                            FROM segu.tusuario USUARI
                            INNER JOIN segu.vpersona PERSON
                              ON PERSON.id_persona=USUARI.id_persona
                            LEFT JOIN segu.tclasificador CLASIF
                              ON CLASIF.id_clasificador=USUARI.id_clasificador
                            WHERE USUARI.estado_reg=''activo'' AND ';
               v_consulta:=v_consulta||v_parametros.filtro;
               return v_consulta;
         END;

     else
         raise exception 'No existe la opcion';

     end if;
          
    

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


--
-- TOC entry 1838 (class 1255 OID 208369)
-- Dependencies: 20 3246
-- Name: ft_validar_usuario_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ft_validar_usuario_ime(par_administrador integer, par_id_usuario integer, par_tabla character varying, par_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/**************************************************************************
 FUNCION: 		segu.fvalidar_usuario
 DESCRIPCIÓN: 	verifica si el login y contgrasena proporcionados son correctos
                esta funcion es especial porque corre con el usario generico de conexion
                que solo tiene el privilegio de correr esta funcion
 AUTOR: 		KPLIAN(rac)
 FECHA:			26/07/2010
 COMENTARIOS:	
***************************************************************************
 HISTORIA DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:			
***************************************************************************/
DECLARE

v_count integer;
v_consulta    varchar;
v_parametros  record;
v_resp          varchar;
v_nombre_funcion   text;
v_mensaje_error    text;

v_id_usuario integer;
v_cuenta varchar;
v_nombre varchar;
v_apellido_paterno varchar;
v_apellido_materno varchar;
v_estilo varchar;
v_num_fallidos integer;
v_cont_alertas integer;
v_autentificacion varchar;
v_id_persona integer;
v_id_funcionario integer;
v_contrasena varchar;

/*

'login'
'password'
'dir_ordenacion'
'puntero'
'cantidad'

*/

BEGIN
     v_nombre_funcion:='segu.ft_validar_usuario_ime';
     v_parametros:=f_get_record(par_tabla);
     
 /*******************************    
 #TRANSACCION: SEG_VALUSU_SEG
 #DESCRIPCION:	verifica si el login y contgrasena proporcionados son correctos
                esta funcion es especial porque corre con el usario generico de conexion
                que solo tiene el privilegio de correr esta funcion
 #AUTOR:		KPLIAN(rac)	
 #FECHA:		16-11-2010	
 *******************************    

 #DESCRIPCION_MOD:	(1) se introduce el campo de tipo de autentificacion para 
  					autentificar con tra LDAP,
                    (2) se verifica si la contrasena es ldap
                    (3) se aumenta un contador que devuelve la cantidad de alarmas para mostrar al usuario
                    
                    
 #AUTOR_MOD:		KPLIAN(rac)	
 #FECHA_MOD:		22-11-2011	
***********************************/

     if(par_transaccion='SEG_VALUSU_SEG')then
          --consulta:=';
          BEGIN

          --verifica si el usuario y contrasena introducidos estan habilitados
          
           --     
            v_id_usuario=null;
            SELECT 
                  u.id_usuario,u.cuenta,p.nombre,p.apellido_paterno,
                  p.apellido_materno,u.estilo,u.autentificacion,p.id_persona,u.contrasena
            INTO
                  v_id_usuario,v_cuenta,v_nombre,v_apellido_paterno,
                  v_apellido_materno,v_estilo,v_autentificacion,v_id_persona,v_contrasena
            FROM segu.tusuario u 
            INNER JOIN segu.tpersona p  
                	ON  p.id_persona = u.id_persona
            WHERE u.cuenta=v_parametros.login
                   -- AND u.contrasena=v_parametros.password
            AND u.fecha_caducidad >= now()::date 
            AND u.estado_reg='activo'; 
            
            
             -- VERIFICA si LA autentificacion es local o por LDAP 
            IF(v_autentificacion='local') THEN
              --SI ES LOCAL VERIFICAMOS SI LA CONTRAENIA ES CORRECTA
               IF(v_contrasena!=v_parametros.password)THEN
                       v_id_usuario=null;
               END IF;
                
            END IF; 
            
              
                        
            IF(v_id_usuario is null) THEN
                RAISE EXCEPTION 'Credenciales de Usuario Invalidas';
           END IF;
  
              --verificamos si el usuario tiene alertas
              v_cont_alertas = 0;
              
              SELECT count(id_alarma) ,ala.id_funcionario
              into v_cont_alertas,v_id_funcionario
              FROM rhum.tfuncionario fun
              INNER JOIN param.talarma ala 
              on fun.id_funcionario = ala.id_funcionario 
              and ala.estado_reg = 'activo'
              WHERE fun.id_persona = v_id_persona
              GROUP BY ala.id_funcionario, id_alarma;
              
              --obtenemos el funcionario para el usuario
              --asumimos que una persona solo puede tener un funcionario
              --este este inactivo o activo
              
              IF(v_id_funcionario is null) THEN
                    SELECT id_funcionario into  v_id_funcionario
                    FROM rhum.tfuncionario fun 
                    WHERE fun.id_persona = v_id_persona;
              END IF;
              
              
              v_cont_alertas=COALESCE(v_cont_alertas,0);
              --raise exception '%',v_id_funcionario;
                    

               v_resp = f_agrega_clave(v_resp,'mensaje','Usuario autorizado'); 
               v_resp = f_agrega_clave(v_resp,'id_usuario',v_id_usuario::varchar);
               v_resp = f_agrega_clave(v_resp,'cuenta',v_cuenta);
               v_resp = f_agrega_clave(v_resp,'nombre',v_nombre);
               v_resp = f_agrega_clave(v_resp,'apellido_paterno',v_apellido_paterno);
               v_resp = f_agrega_clave(v_resp,'apellido_materno',v_apellido_materno);
               v_resp = f_agrega_clave(v_resp,'estilo',v_estilo);
               v_resp = f_agrega_clave(v_resp,'cont_alertas',v_cont_alertas::varchar);
               v_resp = f_agrega_clave(v_resp,'id_persona',v_id_persona::varchar);
               v_resp = f_agrega_clave(v_resp,'id_funcionario',v_id_funcionario::varchar);
               v_resp = f_agrega_clave(v_resp,'autentificacion',v_autentificacion::varchar);
               v_resp = f_agrega_clave(v_resp,'contrasena',v_contrasena::varchar);
              
              --raise exception '%',v_resp;
               return v_resp;
               
          END;
          
    
     else
         raise exception 'No existe la opcion';
      
      end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
	    v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  	    v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
  	    v_resp = f_agrega_clave(v_resp,'usuario',v_parametros.login);
	    raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1836 (class 1255 OID 208372)
-- Dependencies: 20 3246
-- Name: ftrig_log(); Type: FUNCTION; Schema: segu; Owner: -
--

CREATE FUNCTION ftrig_log() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
	nombre_tabla   varchar;
    consulta	   varchar;
    valores			varchar;
    fecha1			date;
    fecha2 			date;
    crear_tabla		text;
	v_rol 			varchar;
    	

BEGIN

/***************************************************************************
 XPHS - PARTICIONAMIENTO LOGS
***************************************************************************
 SCRITP: 		segu.ftrig_log
 DESCRIPCION: 	Ingreso de registro de logs		(tablas particionadas)
 AUTOR: 		KPLIAN(jrr)
 FECHA:			02/02/2011
 COMENTARIOS:	
***************************************************************************
	1) Se obtiene el nombre de tabla que corresponde para la fecha actual
    2) IF: existe la tabla
    	2.1) Se registra el evento en la tabla particionada correspondiente
    3) ELSE no existe la tabla
    	3.1) Se define el rango de fechas el que se creara la tabla
        3.2) Se crea la tabla con el nombre y el rango de fechas que corresponde
        3.3) Se inserta el evento en la tabla particionada correspondiente


*/
IF (TG_OP='INSERT')then
BEGIN
 nombre_tabla='tlog_'||to_char(NEW.fecha_reg,'YYYY_MM');

 if(not exists (select 1 from pg_class where relname like nombre_tabla))then
 	
 	fecha1:=to_char(NEW.fecha_reg,'YYYY-MM-01')::date;
    fecha2:= fecha1 + interval '1 month';

    crear_tabla:='CREATE TABLE "log"."'||nombre_tabla||'" (
      			  CHECK ((fecha_reg >= '''||fecha1||'''::date) AND (fecha_reg < '''||fecha2||'''::date)),
  				  CONSTRAINT "'||nombre_tabla||'_id_log_key" UNIQUE("id_log")
  				) INHERITS ("segu"."tlog");
                CREATE INDEX "'||nombre_tabla||'_idx" ON "log"."'||nombre_tabla||'"
  				USING btree ("fecha_reg")
                ';

    execute(crear_tabla);
    --RCM 24-03-2011: se vuelve dinámico el rol del grant
    v_rol = 'rol_usuario_' || current_database();
    --execute('GRANT SELECT ON log.'||nombre_tabla||' TO rol_usuario_bdweb');
    execute('GRANT SELECT ON log.'||nombre_tabla||' TO '||v_rol);
    --FIN RCM

 end if;

    --raise notice '%',NEW.fecha_reg;
 	valores:=NEW.id_log||','||
    coalesce(''''||(NEW.id_usuario::text)||'''','null')||','||
    coalesce(''''||(NEW.id_subsistema::text)||'''','null')||','||
    coalesce(''''||(NEW.mac_maquina::text)||'''','null')||','||
    coalesce(''''||NEW.ip_maquina||'''','null')||','''||
    NEW.tipo_log||''','||
    coalesce(''''||replace (NEW.descripcion,'''','''''')||'''','null')||','''||
    NEW.fecha_reg||''','''||
    NEW.estado_reg||''','||
    coalesce(''''||NEW.procedimientos||'''','null')||','||
    coalesce(''''||NEW.transaccion||'''','null')||','||
    coalesce(''''||replace (NEW.consulta,'''','''''')||'''','null')||','||
    coalesce(''''||(NEW.tiempo_ejecucion::text)||'''','null')||','||
    coalesce(''''||NEW.usuario_base||'''','null')||','||
    coalesce(''''||NEW.codigo_error||'''','null')||','||
    coalesce(''''||(NEW.dia_semana::text)||'''','null')||','||
    NEW.pid_db||','||
    NEW.pid_web||','''||
    NEW.sid_web||''','||
    coalesce(''''||NEW.cuenta_usuario||'''','null')||','||
    coalesce(''''||NEW.descripcion_transaccion||'''','null')||','||
    coalesce(''''||NEW.codigo_subsistema||'''','null')||','||
    NEW.si_log;

    valores=replace(valores,'\\','\\\\');
 	
    consulta='INSERT INTO log.'||nombre_tabla||' VALUES ('||valores||');';
    
    EXECUTE(consulta);

END;
end if;
 RETURN NULL;
END;
$$;


SET search_path = tesoro, pg_catalog;

--
-- TOC entry 1839 (class 1255 OID 208373)
-- Dependencies: 22 3246
-- Name: f_tts_corte_moneda_ime(integer, integer, character varying, character varying); Type: FUNCTION; Schema: tesoro; Owner: -
--

CREATE FUNCTION f_tts_corte_moneda_ime(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

/**************************************************************************
 SISTEMA:		Sistema de Tesoreria
 FUNCION: 		tesoro.f_tts_corte_moneda_ime
 DESCRIPCION:   Funcion que gestiona las operaciones basicas (inserciones, modificaciones, eliminaciones de la tabla 'tesoro.tts_corte_moneda'
 AUTOR: 		 (fprudencio)
 FECHA:	        29-09-2011 10:14:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_nro_requerimiento    	integer;
	v_parametros           	record;
	v_id_requerimiento     	integer;
	v_resp		            varchar;
	v_nombre_funcion        text;
	v_mensaje_error         text;
	v_id_corte	integer;
			    
BEGIN

    v_nombre_funcion = 'tesoro.f_tts_corte_moneda_ime';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'TS_CORMON_INS'
 	#DESCRIPCION:	Insercion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 10:14:30
	***********************************/

	if(p_transaccion='TS_CORMON_INS')then
					
        begin
        	--Sentencia de la insercion
        	insert into tesoro.tts_corte_moneda(
			importe_valor,
			id_moneda,
			tipo_corte,
			descri_corte
          	) values(
			v_parametros.importe_valor,
			v_parametros.id_moneda,
			v_parametros.tipo_corte,
			v_parametros.descri_corte
			)RETURNING id_corte into v_id_corte;
               
			--Definicion de la respuesta
			v_resp = f_agrega_clave(v_resp,'mensaje','Corte Moneda almacenado(a) con exito (id_corte'||v_id_corte||')'); 
            v_resp = f_agrega_clave(v_resp,'id_corte',v_id_corte::varchar);

            --Devuelve la respuesta
            return v_resp;

		end;

	/*********************************    
 	#TRANSACCION:  'TS_CORMON_MOD'
 	#DESCRIPCION:	Modificacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 10:14:30
	***********************************/

	elsif(p_transaccion='TS_CORMON_MOD')then

		begin
			--Sentencia de la modificacion
			update tesoro.tts_corte_moneda set
			importe_valor = v_parametros.importe_valor,
			id_moneda = v_parametros.id_moneda,
			tipo_corte = v_parametros.tipo_corte,
			descri_corte = v_parametros.descri_corte
			where id_corte=v_parametros.id_corte;
               
			--Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Corte Moneda modificado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_corte',v_parametros.id_corte::varchar);
               
            --Devuelve la respuesta
            return v_resp;
            
		end;

	/*********************************    
 	#TRANSACCION:  'TS_CORMON_ELI'
 	#DESCRIPCION:	Eliminacion de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 10:14:30
	***********************************/

	elsif(p_transaccion='TS_CORMON_ELI')then

		begin
			--Sentencia de la eliminacion
			delete from tesoro.tts_corte_moneda
            where id_corte=v_parametros.id_corte;
               
            --Definicion de la respuesta
            v_resp = f_agrega_clave(v_resp,'mensaje','Corte Moneda eliminado(a)'); 
            v_resp = f_agrega_clave(v_resp,'id_corte',v_parametros.id_corte::varchar);
              
            --Devuelve la respuesta
            return v_resp;

		end;
         
	else
     
    	raise exception 'Transaccion inexistente: %',p_transaccion;

	end if;

EXCEPTION
				
	WHEN OTHERS THEN
		v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
		v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;
				        
END;
$$;


--
-- TOC entry 1840 (class 1255 OID 208374)
-- Dependencies: 22 3246
-- Name: f_tts_corte_moneda_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: tesoro; Owner: -
--

CREATE FUNCTION f_tts_corte_moneda_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Sistema de Tesoreria
 FUNCION: 		tesoro.f_tts_corte_moneda_sel
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas relacionadas con la tabla 'tesoro.tts_corte_moneda'
 AUTOR: 		 (fprudencio)
 FECHA:	        29-09-2011 10:14:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE

	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'tesoro.f_tts_corte_moneda_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'TS_CORMON_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 10:14:30
	***********************************/

	if(p_transaccion='TS_CORMON_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						cormon.id_corte,
						cormon.importe_valor,
						cormon.id_moneda,
                        moneda.moneda,
						cormon.tipo_corte,
						cormon.descri_corte	
						from tesoro.tts_corte_moneda cormon
						inner join param.tmoneda moneda on moneda.id_moneda=cormon.id_moneda
				        where  ';
			
			--Definicion de la respuesta
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respuesta
			return v_consulta;
						
		end;

	/*********************************    
 	#TRANSACCION:  'TS_CORMON_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		fprudencio	
 	#FECHA:		29-09-2011 10:14:30
	***********************************/

	elsif(p_transaccion='TS_CORMON_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_corte)
					    from tesoro.tts_corte_moneda cormon
                        inner join param.tmoneda moneda on moneda.id_moneda=cormon.id_moneda
					    where ';
			
			--Definicion de la respuesta		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respuesta
			return v_consulta;

		end;
					
	else
					     
		raise exception 'Transaccion inexistente';
					         
	end if;
					
EXCEPTION
					
	WHEN OTHERS THEN
			v_resp='';
			v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
			v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
			v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
			raise exception '%',v_resp;
END;
$$;


--
-- TOC entry 1841 (class 1255 OID 208375)
-- Dependencies: 22 3246
-- Name: ft_requerimientos_sel(integer, integer, character varying, character varying); Type: FUNCTION; Schema: tesoro; Owner: -
--

CREATE FUNCTION ft_requerimientos_sel(p_administrador integer, p_id_usuario integer, p_tabla character varying, p_transaccion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/**************************************************************************
 SISTEMA:		Parametros Generales
 FUNCION: 		sast.treqado
 DESCRIPCION:   Funcion que devuelve conjuntos de registros de las consultas 
 				relacionadas con la tabla 'sast.trequerimientos'
 AUTOR: 		rortiz
 FECHA:	        22-11-2011 15:23:30
 COMENTARIOS:	
***************************************************************************
 HISTORIAL DE MODIFICACIONES:

 DESCRIPCION:	
 AUTOR:			
 FECHA:		
***************************************************************************/

DECLARE
	v_consulta    		varchar;
	v_parametros  		record;
	v_nombre_funcion   	text;
	v_resp				varchar;
			    
BEGIN

	v_nombre_funcion = 'sast.ft_requerimientos_sel';
    v_parametros = f_get_record(p_tabla);

	/*********************************    
 	#TRANSACCION:  'ST_REQ_SEL'
 	#DESCRIPCION:	Consulta de datos
 	#AUTOR:			rortiz	
 	#FECHA:			22-11-2011 15:23:30
	***********************************/

	if(p_transaccion='ST_REQ_SEL')then
     				
    	begin
    		--Sentencia de la consulta
			v_consulta:='select
						req.id_requerimiento,
                        req.id_funcionario,
                        req.id_tipo_requerimiento,
                        req.id_depto,
                        req.estado_actual,
                        req.estado_anterior,
                        req.descripcion,
                        req.version,
                        req.estado_reg,
                        req.id_usuario_reg,
                        req.fecha_reg,
						req.id_usuario_mod,						
						req.fecha_mod,
                        usu1.cuenta as usr_reg,
                        usu2.cuenta as usr_mod,
                        person.nombre_completo1
                        										
						from sast.trequerimientos req
                        inner join rhum.tfuncionario funcio on funcio.id_funcionario=req.id_funcionario   
                        inner join segu.vpersona person on person.id_persona=funcio.id_persona
                        inner join param.tdepto tdt on tdt.id_depto = req.id_depto
                        inner join sast.ttipo_requerimiento tipreq on tipreq.id_tipo_requerimiento = req.id_tipo_requerimiento
                        inner join segu.tusuario usu1 on usu1.id_usuario = req.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = req.id_usuario_mod                        					
				        where req.estado_reg = ''activo'' and ';
			
			--Definicion de la respureqa
			v_consulta:=v_consulta||v_parametros.filtro;
			v_consulta:=v_consulta||' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' offset ' || v_parametros.puntero;

			--Devuelve la respureqa
			return v_consulta;
						
		end;   

	/*********************************    
 	#TRANSACCION:  'ST_REQ_CONT'
 	#DESCRIPCION:	Conteo de registros
 	#AUTOR:		rortiz	
 	#FECHA:		18-11-2011 
	***********************************/

	elsif(p_transaccion='ST_REQ_CONT')then

		begin
			--Sentencia de la consulta de conteo de registros
			v_consulta:='select count(id_requerimiento)
						from sast.trequerimientos req
                        inner join rhum.tfuncionario funcio on funcio.id_funcionario=req.id_funcionario   
                        inner join segu.vpersona person on person.id_persona=funcio.id_persona
                        inner join param.tdepto tdt on tdt.id_depto = req.id_depto
                        inner join sast.ttipo_requerimiento tipreq on tipreq.id_tipo_requerimiento = req.id_tipo_requerimiento
                        inner join segu.tusuario usu1 on usu1.id_usuario = req.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = req.id_usuario_mod     
					    where ';
			
			--Definicion de la respureqa		    
			v_consulta:=v_consulta||v_parametros.filtro;

			--Devuelve la respureqa
			return v_consulta;

		end;
					
/*******************************
 #TRANSACCION:  ST_CAPTU_SEL
 #DESCRIPCION:	Selecciona requerimientos +
 #AUTOR:		RORTIZ	
 #FECHA:		29/11/11	
***********************************/
     elsif(p_transaccion='ST_CAPTU_SEL')then

          --  Se arma la consulta de requerimientos
          BEGIN
          
               v_consulta:='SELECT 
               				r.id_requerimiento,
               				r.id_funcionario,
                            r.id_tipo_requerimiento,
                            r.id_depto,
                            r.descripcion,
               				r.estado_reg,
                        	r.id_usuario_reg,
                        	r.fecha_reg,
							r.id_usuario_mod,						
							r.fecha_mod,
                        	usu1.cuenta as usr_reg,
                        	usu2.cuenta as usr_mod,                            
                            person.nombre_completo1 as funcionario,
       						tipreq.nombre as requerimiento,
       						depto.nombre as departamento, 
                            r.extension,                     
                            r.captura               			
                        FROM sast.trequerimientos r
                        inner join rhum.tfuncionario funcio on funcio.id_funcionario=r.id_funcionario   
                        inner join segu.vpersona person on person.id_persona=funcio.id_persona
                        inner join param.tdepto depto on depto.id_depto = r.id_depto                        
                        inner join sast.ttipo_requerimiento tipreq on tipreq.id_tipo_requerimiento = r.id_tipo_requerimiento
                        inner join segu.tusuario usu1 on usu1.id_usuario = r.id_usuario_reg
						left join segu.tusuario usu2 on usu2.id_usuario = r.id_usuario_mod                        					
				        where r.estado_reg = ''activo'' and ';
                          
                         
               v_consulta:=v_consulta||v_parametros.filtro;
               v_consulta:=v_consulta || ' order by ' ||v_parametros.ordenacion|| ' ' || v_parametros.dir_ordenacion || ' limit ' || v_parametros.cantidad || ' OFFSET ' || v_parametros.puntero;
               raise notice '%',v_consulta;
               return v_consulta;


         END;    


/*******************************
 #TRANSACCION:  ST_CAPTU_CONT
 #DESCRIPCION:	Cuenta requerimientos con foto
 #AUTOR:		RORTIZ		
 #FECHA:		29/11/11	
***********************************/

     elsif(p_transaccion='ST_CAPTU_CONT')then

          --se arma la sonsulta que cuenta requerimientos
          BEGIN
               
               	v_consulta:='select count(r.id_requerimiento)
                from sast.trequerimientos r
                inner join rhum.tfuncionario funcio on funcio.id_funcionario=r.id_funcionario   
                inner join segu.vpersona person on person.id_persona=funcio.id_persona
                inner join param.tdepto tdt on tdt.id_depto = r.id_depto
                inner join sast.ttipo_requerimiento tipreq on tipreq.id_tipo_requerimiento = r.id_tipo_requerimiento
                inner join segu.tusuario usu1 on usu1.id_usuario = r.id_usuario_reg
				left join segu.tusuario usu2 on usu2.id_usuario = r.id_usuario_mod       
				where';
               	v_consulta:=v_consulta||v_parametros.filtro;
               	return v_consulta;
         END;
         
     else
         raise exception 'No existe la opcion';

     end if;

EXCEPTION

      WHEN OTHERS THEN
    	v_resp='';
		v_resp = f_agrega_clave(v_resp,'mensaje',SQLERRM);
    	v_resp = f_agrega_clave(v_resp,'codigo_error',SQLSTATE);
  		v_resp = f_agrega_clave(v_resp,'procedimientos',v_nombre_funcion);
		raise exception '%',v_resp;


END;
$$;


SET search_path = public, pg_catalog;

--
-- TOC entry 3257 (class 1255 OID 208377)
-- Dependencies: 23 2191 2189 1074 1073
-- Name: accum(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE accum(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_accum_finalfn
);


--
-- TOC entry 3258 (class 1255 OID 208378)
-- Dependencies: 23 1015
-- Name: aggarray(anyelement); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE aggarray(anyelement) (
    SFUNC = aggregate_array,
    STYPE = anyarray
);


--
-- TOC entry 3259 (class 1255 OID 208379)
-- Dependencies: 23 1015
-- Name: aggarray1(anyelement); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE aggarray1(anyelement) (
    SFUNC = aggregate_array,
    STYPE = anyarray
);


--
-- TOC entry 3260 (class 1255 OID 208380)
-- Dependencies: 23 2189 2189 1074 1075
-- Name: collect(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE collect(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_collect_finalfn
);


--
-- TOC entry 3261 (class 1255 OID 208381)
-- Dependencies: 23 2168 2189 1387
-- Name: extent(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE extent(geometry) (
    SFUNC = public.st_combine_bbox,
    STYPE = box3d_extent
);


--
-- TOC entry 3262 (class 1255 OID 208382)
-- Dependencies: 23 2164 2189 767
-- Name: extent3d(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE extent3d(geometry) (
    SFUNC = public.combine_bbox,
    STYPE = box3d
);


--
-- TOC entry 3263 (class 1255 OID 208383)
-- Dependencies: 23 768
-- Name: list(text); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE list(text) (
    SFUNC = comma_cat,
    STYPE = text
);


--
-- TOC entry 3264 (class 1255 OID 208384)
-- Dependencies: 23 2189 2189 1074 1076
-- Name: makeline(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE makeline(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_makeline_finalfn
);


--
-- TOC entry 3265 (class 1255 OID 208385)
-- Dependencies: 23 2189 2189 1384
-- Name: memcollect(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE memcollect(geometry) (
    SFUNC = public.st_collect,
    STYPE = geometry
);


--
-- TOC entry 3266 (class 1255 OID 208386)
-- Dependencies: 23 2189 2189 864
-- Name: memgeomunion(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE memgeomunion(geometry) (
    SFUNC = geomunion,
    STYPE = geometry
);


--
-- TOC entry 3267 (class 1255 OID 208387)
-- Dependencies: 23 2189 2189 1074 1082
-- Name: polygonize(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE polygonize(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_polygonize_finalfn
);


--
-- TOC entry 3268 (class 1255 OID 208388)
-- Dependencies: 23 2191 2189 1074 1073
-- Name: st_accum(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE st_accum(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_accum_finalfn
);


--
-- TOC entry 3269 (class 1255 OID 208389)
-- Dependencies: 23 2189 2189 1074 1075
-- Name: st_collect(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE st_collect(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_collect_finalfn
);


--
-- TOC entry 3248 (class 1255 OID 208390)
-- Dependencies: 23 2168 2189 1387
-- Name: st_extent(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE st_extent(geometry) (
    SFUNC = public.st_combine_bbox,
    STYPE = box3d_extent
);


--
-- TOC entry 3249 (class 1255 OID 208391)
-- Dependencies: 2189 23 2164 1388
-- Name: st_extent3d(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE st_extent3d(geometry) (
    SFUNC = public.st_combine_bbox,
    STYPE = box3d
);


--
-- TOC entry 3250 (class 1255 OID 208392)
-- Dependencies: 2189 23 1076 1074 2189
-- Name: st_makeline(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE st_makeline(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_makeline_finalfn
);


--
-- TOC entry 3251 (class 1255 OID 208393)
-- Dependencies: 1384 2189 2189 23
-- Name: st_memcollect(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE st_memcollect(geometry) (
    SFUNC = public.st_collect,
    STYPE = geometry
);


--
-- TOC entry 3252 (class 1255 OID 208394)
-- Dependencies: 23 1644 2189 2189
-- Name: st_memunion(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE st_memunion(geometry) (
    SFUNC = public.st_union,
    STYPE = geometry
);


--
-- TOC entry 3253 (class 1255 OID 208395)
-- Dependencies: 23 1082 1074 2189 2189
-- Name: st_polygonize(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE st_polygonize(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_polygonize_finalfn
);


--
-- TOC entry 3254 (class 1255 OID 208396)
-- Dependencies: 1083 2189 2189 23 1074
-- Name: st_union(geometry); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE st_union(geometry) (
    SFUNC = pgis_geometry_accum_transfn,
    STYPE = pgis_abs,
    FINALFUNC = pgis_geometry_union_finalfn
);


--
-- TOC entry 3255 (class 1255 OID 208397)
-- Dependencies: 23 775
-- Name: text_concat(text); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE text_concat(text) (
    SFUNC = public.concat,
    STYPE = text
);


--
-- TOC entry 3256 (class 1255 OID 208398)
-- Dependencies: 23
-- Name: textcat_all(text); Type: AGGREGATE; Schema: public; Owner: -
--

CREATE AGGREGATE textcat_all(text) (
    SFUNC = textcat,
    STYPE = text
);


--
-- TOC entry 3976 (class 2617 OID 208399)
-- Dependencies: 23 877
-- Name: #; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR # (
    PROCEDURE = icount,
    RIGHTARG = integer[]
);


--
-- TOC entry 3977 (class 2617 OID 208400)
-- Dependencies: 23 878
-- Name: #; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR # (
    PROCEDURE = idx,
    LEFTARG = integer[],
    RIGHTARG = integer
);


--
-- TOC entry 3978 (class 2617 OID 208401)
-- Dependencies: 23 1005
-- Name: &; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR & (
    PROCEDURE = _int_inter,
    LEFTARG = integer[],
    RIGHTARG = integer[],
    COMMUTATOR = &
);


--
-- TOC entry 3979 (class 2617 OID 208402)
-- Dependencies: 2189 1143 2189 1135 23 1136
-- Name: &&; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR && (
    PROCEDURE = geometry_overlap,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = &&,
    RESTRICT = geometry_gist_sel,
    JOIN = geometry_gist_joinsel
);


--
-- TOC entry 3980 (class 2617 OID 208403)
-- Dependencies: 1102 1097 2185 1194 23 2185
-- Name: &&; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR && (
    PROCEDURE = geography_overlaps,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = &&,
    RESTRICT = geography_gist_selectivity,
    JOIN = geography_gist_join_selectivity
);


--
-- TOC entry 3981 (class 2617 OID 208404)
-- Dependencies: 1006 23
-- Name: &&; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR && (
    PROCEDURE = _int_overlap,
    LEFTARG = integer[],
    RIGHTARG = integer[],
    COMMUTATOR = &&,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 3982 (class 2617 OID 208406)
-- Dependencies: 2189 1144 23 2189
-- Name: &<; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR &< (
    PROCEDURE = geometry_overleft,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = &>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


--
-- TOC entry 3983 (class 2617 OID 208408)
-- Dependencies: 23 1142 2189 2189
-- Name: &<|; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR &<| (
    PROCEDURE = geometry_overbelow,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = |&>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


--
-- TOC entry 3984 (class 2617 OID 208405)
-- Dependencies: 23 2189 2189 1145
-- Name: &>; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR &> (
    PROCEDURE = geometry_overright,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = &<,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


--
-- TOC entry 3985 (class 2617 OID 208409)
-- Dependencies: 23 886
-- Name: +; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR + (
    PROCEDURE = intarray_push_elem,
    LEFTARG = integer[],
    RIGHTARG = integer
);


--
-- TOC entry 3986 (class 2617 OID 208410)
-- Dependencies: 23 880
-- Name: +; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR + (
    PROCEDURE = intarray_push_array,
    LEFTARG = integer[],
    RIGHTARG = integer[],
    COMMUTATOR = +
);


--
-- TOC entry 3987 (class 2617 OID 208411)
-- Dependencies: 879 23
-- Name: -; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR - (
    PROCEDURE = intarray_del_elem,
    LEFTARG = integer[],
    RIGHTARG = integer
);


--
-- TOC entry 3988 (class 2617 OID 208412)
-- Dependencies: 23 892
-- Name: -; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR - (
    PROCEDURE = intset_subtract,
    LEFTARG = integer[],
    RIGHTARG = integer[]
);


--
-- TOC entry 3989 (class 2617 OID 208415)
-- Dependencies: 2189 1140 23 2189
-- Name: <; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR < (
    PROCEDURE = geometry_lt,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 3992 (class 2617 OID 208418)
-- Dependencies: 2185 2185 23 1101
-- Name: <; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR < (
    PROCEDURE = geography_lt,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 3994 (class 2617 OID 208420)
-- Dependencies: 2189 23 2189 1139
-- Name: <<; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR << (
    PROCEDURE = geometry_left,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = >>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


--
-- TOC entry 3996 (class 2617 OID 208422)
-- Dependencies: 1129 23 2189 2189
-- Name: <<|; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR <<| (
    PROCEDURE = geometry_below,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = |>>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


--
-- TOC entry 3998 (class 2617 OID 208423)
-- Dependencies: 23 1138 2189 2189
-- Name: <=; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR <= (
    PROCEDURE = geometry_le,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 4000 (class 2617 OID 208424)
-- Dependencies: 2185 1100 23 2185
-- Name: <=; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR <= (
    PROCEDURE = geography_le,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 3990 (class 2617 OID 208426)
-- Dependencies: 1002 23
-- Name: <@; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR <@ (
    PROCEDURE = _int_contained,
    LEFTARG = integer[],
    RIGHTARG = integer[],
    COMMUTATOR = @>,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 3993 (class 2617 OID 208427)
-- Dependencies: 2189 23 1133 2189
-- Name: =; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR = (
    PROCEDURE = geometry_eq,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = =,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 4002 (class 2617 OID 208428)
-- Dependencies: 2185 1189 2185 23
-- Name: =; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR = (
    PROCEDURE = geography_eq,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = =,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 4003 (class 2617 OID 208413)
-- Dependencies: 23 1137 2189 2189
-- Name: >; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR > (
    PROCEDURE = geometry_gt,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 4004 (class 2617 OID 208416)
-- Dependencies: 23 1099 2185 2185
-- Name: >; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR > (
    PROCEDURE = geography_gt,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 4005 (class 2617 OID 208414)
-- Dependencies: 2189 1134 23 2189
-- Name: >=; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR >= (
    PROCEDURE = geometry_ge,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 4006 (class 2617 OID 208417)
-- Dependencies: 2185 2185 23 1190
-- Name: >=; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR >= (
    PROCEDURE = geography_ge,
    LEFTARG = geography,
    RIGHTARG = geography,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 4007 (class 2617 OID 208419)
-- Dependencies: 2189 1146 23 2189
-- Name: >>; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR >> (
    PROCEDURE = geometry_right,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = <<,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


--
-- TOC entry 4008 (class 2617 OID 208430)
-- Dependencies: 2189 23 2189 1132
-- Name: @; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR @ (
    PROCEDURE = geometry_contained,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = ~,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 4009 (class 2617 OID 208432)
-- Dependencies: 1003 23
-- Name: @; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR @ (
    PROCEDURE = _int_contains,
    LEFTARG = integer[],
    RIGHTARG = integer[],
    COMMUTATOR = ~,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 3999 (class 2617 OID 208425)
-- Dependencies: 1003 23
-- Name: @>; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR @> (
    PROCEDURE = _int_contains,
    LEFTARG = integer[],
    RIGHTARG = integer[],
    COMMUTATOR = <@,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 4001 (class 2617 OID 208434)
-- Dependencies: 23 2208 740
-- Name: @@; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR @@ (
    PROCEDURE = boolop,
    LEFTARG = integer[],
    RIGHTARG = query_int,
    COMMUTATOR = ~~,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 4010 (class 2617 OID 208435)
-- Dependencies: 23 893
-- Name: |; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR | (
    PROCEDURE = intset_union_elem,
    LEFTARG = integer[],
    RIGHTARG = integer
);


--
-- TOC entry 4011 (class 2617 OID 208436)
-- Dependencies: 1008 23
-- Name: |; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR | (
    PROCEDURE = _int_union,
    LEFTARG = integer[],
    RIGHTARG = integer[],
    COMMUTATOR = |
);


--
-- TOC entry 3991 (class 2617 OID 208407)
-- Dependencies: 1141 23 2189 2189
-- Name: |&>; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR |&> (
    PROCEDURE = geometry_overabove,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = &<|,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


--
-- TOC entry 4012 (class 2617 OID 208421)
-- Dependencies: 2189 23 1128 2189
-- Name: |>>; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR |>> (
    PROCEDURE = geometry_above,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = <<|,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


--
-- TOC entry 4013 (class 2617 OID 208429)
-- Dependencies: 1131 2189 2189 23
-- Name: ~; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR ~ (
    PROCEDURE = geometry_contain,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = @,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 4014 (class 2617 OID 208431)
-- Dependencies: 23 1002
-- Name: ~; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR ~ (
    PROCEDURE = _int_contained,
    LEFTARG = integer[],
    RIGHTARG = integer[],
    COMMUTATOR = @,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 3995 (class 2617 OID 208437)
-- Dependencies: 23 1148 2189 2189
-- Name: ~=; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR ~= (
    PROCEDURE = geometry_samebox,
    LEFTARG = geometry,
    RIGHTARG = geometry,
    COMMUTATOR = ~=,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


--
-- TOC entry 3997 (class 2617 OID 208433)
-- Dependencies: 23 1257 2208
-- Name: ~~; Type: OPERATOR; Schema: public; Owner: -
--

CREATE OPERATOR ~~ (
    PROCEDURE = rboolop,
    LEFTARG = query_int,
    RIGHTARG = integer[],
    COMMUTATOR = @@,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


--
-- TOC entry 4128 (class 2616 OID 208439)
-- Dependencies: 2185 4205 23
-- Name: btree_geography_ops; Type: OPERATOR CLASS; Schema: public; Owner: -
--

CREATE OPERATOR CLASS btree_geography_ops
    DEFAULT FOR TYPE geography USING btree AS
    OPERATOR 1 <(geography,geography) ,
    OPERATOR 2 <=(geography,geography) ,
    OPERATOR 3 =(geography,geography) ,
    OPERATOR 4 >=(geography,geography) ,
    OPERATOR 5 >(geography,geography) ,
    FUNCTION 1 geography_cmp(geography,geography);


--
-- TOC entry 4129 (class 2616 OID 208447)
-- Dependencies: 23 4206 2189
-- Name: btree_geometry_ops; Type: OPERATOR CLASS; Schema: public; Owner: -
--

CREATE OPERATOR CLASS btree_geometry_ops
    DEFAULT FOR TYPE geometry USING btree AS
    OPERATOR 1 <(geometry,geometry) ,
    OPERATOR 2 <=(geometry,geometry) ,
    OPERATOR 3 =(geometry,geometry) ,
    OPERATOR 4 >=(geometry,geometry) ,
    OPERATOR 5 >(geometry,geometry) ,
    FUNCTION 1 geometry_cmp(geometry,geometry);


--
-- TOC entry 4130 (class 2616 OID 208455)
-- Dependencies: 23 4207
-- Name: gin__int_ops; Type: OPERATOR CLASS; Schema: public; Owner: -
--

CREATE OPERATOR CLASS gin__int_ops
    FOR TYPE integer[] USING gin AS
    STORAGE integer ,
    OPERATOR 3 &&(integer[],integer[]) ,
    OPERATOR 6 =(anyarray,anyarray) ,
    OPERATOR 7 @>(integer[],integer[]) ,
    OPERATOR 8 <@(integer[],integer[]) ,
    OPERATOR 13 @(integer[],integer[]) ,
    OPERATOR 14 ~(integer[],integer[]) ,
    OPERATOR 20 @@(integer[],query_int) ,
    FUNCTION 1 btint4cmp(integer,integer) ,
    FUNCTION 2 ginarrayextract(anyarray,internal) ,
    FUNCTION 3 ginint4_queryextract(internal,internal,smallint,internal,internal) ,
    FUNCTION 4 ginint4_consistent(internal,smallint,internal,integer,internal,internal);


--
-- TOC entry 4131 (class 2616 OID 208468)
-- Dependencies: 23 4208
-- Name: gist__int_ops; Type: OPERATOR CLASS; Schema: public; Owner: -
--

CREATE OPERATOR CLASS gist__int_ops
    DEFAULT FOR TYPE integer[] USING gist AS
    OPERATOR 3 &&(integer[],integer[]) ,
    OPERATOR 6 =(anyarray,anyarray) ,
    OPERATOR 7 @>(integer[],integer[]) ,
    OPERATOR 8 <@(integer[],integer[]) ,
    OPERATOR 13 @(integer[],integer[]) ,
    OPERATOR 14 ~(integer[],integer[]) ,
    OPERATOR 20 @@(integer[],query_int) ,
    FUNCTION 1 g_int_consistent(internal,integer[],integer,oid,internal) ,
    FUNCTION 2 g_int_union(internal,internal) ,
    FUNCTION 3 g_int_compress(internal) ,
    FUNCTION 4 g_int_decompress(internal) ,
    FUNCTION 5 g_int_penalty(internal,internal,internal) ,
    FUNCTION 6 g_int_picksplit(internal,internal) ,
    FUNCTION 7 g_int_same(integer[],integer[],internal);


--
-- TOC entry 4132 (class 2616 OID 208484)
-- Dependencies: 4209 23 2200
-- Name: gist__intbig_ops; Type: OPERATOR CLASS; Schema: public; Owner: -
--

CREATE OPERATOR CLASS gist__intbig_ops
    FOR TYPE integer[] USING gist AS
    STORAGE intbig_gkey ,
    OPERATOR 3 &&(integer[],integer[]) ,
    OPERATOR 6 =(anyarray,anyarray) ,
    OPERATOR 7 @>(integer[],integer[]) ,
    OPERATOR 8 <@(integer[],integer[]) ,
    OPERATOR 13 @(integer[],integer[]) ,
    OPERATOR 14 ~(integer[],integer[]) ,
    OPERATOR 20 @@(integer[],query_int) ,
    FUNCTION 1 g_intbig_consistent(internal,internal,integer,oid,internal) ,
    FUNCTION 2 g_intbig_union(internal,internal) ,
    FUNCTION 3 g_intbig_compress(internal) ,
    FUNCTION 4 g_intbig_decompress(internal) ,
    FUNCTION 5 g_intbig_penalty(internal,internal,internal) ,
    FUNCTION 6 g_intbig_picksplit(internal,internal) ,
    FUNCTION 7 g_intbig_same(internal,internal,internal);


--
-- TOC entry 4133 (class 2616 OID 208500)
-- Dependencies: 4210 2196 23 2185
-- Name: gist_geography_ops; Type: OPERATOR CLASS; Schema: public; Owner: -
--

CREATE OPERATOR CLASS gist_geography_ops
    DEFAULT FOR TYPE geography USING gist AS
    STORAGE gidx ,
    OPERATOR 3 &&(geography,geography) ,
    FUNCTION 1 geography_gist_consistent(internal,geometry,integer) ,
    FUNCTION 2 geography_gist_union(bytea,internal) ,
    FUNCTION 3 geography_gist_compress(internal) ,
    FUNCTION 4 geography_gist_decompress(internal) ,
    FUNCTION 5 geography_gist_penalty(internal,internal,internal) ,
    FUNCTION 6 geography_gist_picksplit(internal,internal) ,
    FUNCTION 7 geography_gist_same(box2d,box2d,internal);


--
-- TOC entry 4134 (class 2616 OID 208510)
-- Dependencies: 2160 2189 23 4211
-- Name: gist_geometry_ops; Type: OPERATOR CLASS; Schema: public; Owner: -
--

CREATE OPERATOR CLASS gist_geometry_ops
    DEFAULT FOR TYPE geometry USING gist AS
    STORAGE box2d ,
    OPERATOR 1 <<(geometry,geometry) ,
    OPERATOR 2 &<(geometry,geometry) ,
    OPERATOR 3 &&(geometry,geometry) ,
    OPERATOR 4 &>(geometry,geometry) ,
    OPERATOR 5 >>(geometry,geometry) ,
    OPERATOR 6 ~=(geometry,geometry) ,
    OPERATOR 7 ~(geometry,geometry) ,
    OPERATOR 8 @(geometry,geometry) ,
    OPERATOR 9 &<|(geometry,geometry) ,
    OPERATOR 10 <<|(geometry,geometry) ,
    OPERATOR 11 |>>(geometry,geometry) ,
    OPERATOR 12 |&>(geometry,geometry) ,
    FUNCTION 1 lwgeom_gist_consistent(internal,geometry,integer) ,
    FUNCTION 2 lwgeom_gist_union(bytea,internal) ,
    FUNCTION 3 lwgeom_gist_compress(internal) ,
    FUNCTION 4 lwgeom_gist_decompress(internal) ,
    FUNCTION 5 lwgeom_gist_penalty(internal,internal,internal) ,
    FUNCTION 6 lwgeom_gist_picksplit(internal,internal) ,
    FUNCTION 7 lwgeom_gist_same(box2d,box2d,internal);


SET search_path = pg_catalog;

--
-- TOC entry 5367 (class 2605 OID 208530)
-- Dependencies: 748 2160 2164 748
-- Name: CAST (public.box2d AS public.box3d); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.box2d AS public.box3d) WITH FUNCTION public.box3d(public.box2d) AS IMPLICIT;


--
-- TOC entry 5368 (class 2605 OID 208531)
-- Dependencies: 1120 2189 1120 2160
-- Name: CAST (public.box2d AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.box2d AS public.geometry) WITH FUNCTION public.geometry(public.box2d) AS IMPLICIT;


--
-- TOC entry 5369 (class 2605 OID 208532)
-- Dependencies: 743 2164 743
-- Name: CAST (public.box3d AS box); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.box3d AS box) WITH FUNCTION public.box(public.box3d) AS IMPLICIT;


--
-- TOC entry 5370 (class 2605 OID 208533)
-- Dependencies: 746 2164 2160 746
-- Name: CAST (public.box3d AS public.box2d); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.box3d AS public.box2d) WITH FUNCTION public.box2d(public.box3d) AS IMPLICIT;


--
-- TOC entry 5371 (class 2605 OID 208534)
-- Dependencies: 1121 2164 1121 2189
-- Name: CAST (public.box3d AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.box3d AS public.geometry) WITH FUNCTION public.geometry(public.box3d) AS IMPLICIT;


--
-- TOC entry 5372 (class 2605 OID 208535)
-- Dependencies: 744 2160 2168 744
-- Name: CAST (public.box3d_extent AS public.box2d); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.box3d_extent AS public.box2d) WITH FUNCTION public.box2d(public.box3d_extent) AS IMPLICIT;


--
-- TOC entry 5373 (class 2605 OID 208536)
-- Dependencies: 749 749 2164 2168
-- Name: CAST (public.box3d_extent AS public.box3d); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.box3d_extent AS public.box3d) WITH FUNCTION public.box3d_extent(public.box3d_extent) AS IMPLICIT;


--
-- TOC entry 5374 (class 2605 OID 208537)
-- Dependencies: 1119 1119 2189 2168
-- Name: CAST (public.box3d_extent AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.box3d_extent AS public.geometry) WITH FUNCTION public.geometry(public.box3d_extent) AS IMPLICIT;


--
-- TOC entry 5173 (class 2605 OID 208538)
-- Dependencies: 1126 1126 2189
-- Name: CAST (bytea AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (bytea AS public.geometry) WITH FUNCTION public.geometry(bytea) AS IMPLICIT;


--
-- TOC entry 5375 (class 2605 OID 208539)
-- Dependencies: 1123 2189 1123 2172
-- Name: CAST (public.chip AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.chip AS public.geometry) WITH FUNCTION public.geometry(public.chip) AS IMPLICIT;


--
-- TOC entry 5376 (class 2605 OID 208540)
-- Dependencies: 1187 1187 2185 2185
-- Name: CAST (public.geography AS public.geography); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.geography AS public.geography) WITH FUNCTION public.geography(public.geography, integer, boolean) AS IMPLICIT;


--
-- TOC entry 5377 (class 2605 OID 208541)
-- Dependencies: 1127 2185 1127 2189
-- Name: CAST (public.geography AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.geography AS public.geometry) WITH FUNCTION public.geometry(public.geography);


--
-- TOC entry 5380 (class 2605 OID 208542)
-- Dependencies: 742 742 2189
-- Name: CAST (public.geometry AS box); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.geometry AS box) WITH FUNCTION public.box(public.geometry) AS IMPLICIT;


--
-- TOC entry 5381 (class 2605 OID 208543)
-- Dependencies: 745 2160 745 2189
-- Name: CAST (public.geometry AS public.box2d); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.geometry AS public.box2d) WITH FUNCTION public.box2d(public.geometry) AS IMPLICIT;


--
-- TOC entry 5382 (class 2605 OID 208544)
-- Dependencies: 747 2189 2164 747
-- Name: CAST (public.geometry AS public.box3d); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.geometry AS public.box3d) WITH FUNCTION public.box3d(public.geometry) AS IMPLICIT;


--
-- TOC entry 5378 (class 2605 OID 208545)
-- Dependencies: 754 2189 754
-- Name: CAST (public.geometry AS bytea); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.geometry AS bytea) WITH FUNCTION public.bytea(public.geometry) AS IMPLICIT;


--
-- TOC entry 5383 (class 2605 OID 208546)
-- Dependencies: 1186 1186 2189 2185
-- Name: CAST (public.geometry AS public.geography); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.geometry AS public.geography) WITH FUNCTION public.geography(public.geometry) AS IMPLICIT;


--
-- TOC entry 5379 (class 2605 OID 208547)
-- Dependencies: 1666 1666 2189
-- Name: CAST (public.geometry AS text); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (public.geometry AS text) WITH FUNCTION public.text(public.geometry) AS IMPLICIT;


--
-- TOC entry 5241 (class 2605 OID 208548)
-- Dependencies: 1122 1122 2189
-- Name: CAST (text AS public.geometry); Type: CAST; Schema: pg_catalog; Owner: -
--

CREATE CAST (text AS public.geometry) WITH FUNCTION public.geometry(text) AS IMPLICIT;


SET search_path = public, pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- TOC entry 203 (class 1259 OID 208549)
-- Dependencies: 5504 5505 5506 23
-- Name: tbase; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE tbase (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying
);


SET search_path = actif, pg_catalog;

--
-- TOC entry 204 (class 1259 OID 208555)
-- Dependencies: 5507 5508 5509 5510 5511 5512 5513 5514 5515 5516 5517 5519 5520 5521 5522 5523 6 203
-- Name: taf_activo_fijo; Type: TABLE; Schema: actif; Owner: -; Tablespace: 
--

CREATE TABLE taf_activo_fijo (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now() NOT NULL,
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT NULL::character varying,
    id_activo_fijo integer NOT NULL,
    codigo character varying,
    descripcion character varying(100) NOT NULL,
    descripcion_larga character varying(1000),
    vida_util_original integer NOT NULL,
    vida_util_restante integer NOT NULL,
    tasa_depreciacion numeric(10,4) DEFAULT 0 NOT NULL,
    fecha_ultima_deprec date,
    depreciacion_acum_ant numeric(18,6) NOT NULL,
    depreciacion_acum numeric(18,6) NOT NULL,
    depreciacion_periodo numeric(18,6) NOT NULL,
    flag_revaloriz character varying(2) DEFAULT 'no'::character varying NOT NULL,
    valor_rescate numeric(18,2) NOT NULL,
    fecha_compra date NOT NULL,
    monto_compra_mon_orig numeric(18,6) NOT NULL,
    monto_compra numeric(18,6) NOT NULL,
    monto_actual numeric(18,6) NOT NULL,
    con_garantia character varying(2) DEFAULT 'no'::character varying NOT NULL,
    num_poliza_garantia character varying(20),
    fecha_fin_gar date,
    foto_activo bytea,
    num_factura character varying(10),
    tipo_cambio numeric(10,5),
    estado character varying(20) DEFAULT 'registrado'::character varying NOT NULL,
    observaciones character varying(1000),
    id_sub_tipo_activo integer NOT NULL,
    id_moneda integer NOT NULL,
    id_moneda_original integer NOT NULL,
    id_unidad_constructiva integer,
    fecha_ini_dep date,
    ubicacion_fisica character varying(300),
    orden_compra character varying(20),
    id_estado_funcional integer,
    vida_util_2 integer,
    monto_actualiz numeric(18,2),
    id_depto integer,
    id_cotizacion integer,
    id_cotizacion_det integer,
    origen character varying,
    id_lugar integer,
    estado_anterior character varying,
    id_solicitud_compra integer,
    clonacion character varying(2) DEFAULT 'no'::character varying,
    id_clon_origen integer,
    proyecto character varying(2) DEFAULT 'no'::character varying,
    tipo_af_bien character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    id_usuario integer,
    monto_actualiz_2 numeric(18,2),
    id_deposito integer,
    codigo_ant character varying(40),
    id_sub_tipo_ant integer,
    tipo character varying(15) DEFAULT 'propio'::character varying,
    CONSTRAINT chk_taf_activo_fijo__tipo_af_bien CHECK ((((tipo_af_bien)::text = 'activo'::text) OR ((tipo_af_bien)::text = 'bien_resp'::text))),
    CONSTRAINT taf_activo_fijo_con_garantia_check CHECK ((((con_garantia)::text = 'si'::text) OR ((con_garantia)::text = 'no'::text))),
    CONSTRAINT taf_activo_fijo_estado_check CHECK ((((((((estado)::text = 'registrado'::text) OR ((estado)::text = 'alta'::text)) OR ((estado)::text = 'baja'::text)) OR ((estado)::text = 'eliminado'::text)) OR ((estado)::text = 'en_proceso'::text)) OR ((estado)::text = 'codificado'::text))),
    CONSTRAINT taf_activo_fijo_flag_revaloriz_check CHECK ((((flag_revaloriz)::text = 'si'::text) OR ((flag_revaloriz)::text = 'no'::text))),
    CONSTRAINT taf_activo_fijo_tasa_depreciacion_check CHECK ((((tasa_depreciacion)::double precision >= (0)::double precision) AND ((tasa_depreciacion)::double precision <= (100)::double precision)))
)
INHERITS (public.tbase);


--
-- TOC entry 7048 (class 0 OID 0)
-- Dependencies: 204
-- Name: TABLE taf_activo_fijo; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON TABLE taf_activo_fijo IS 'sistema=activos_fijos&codigo=ACTIF&prefijo=AF&titulo=Activo Fijo&desc=Activo Fijo&num_dt=2&dt_1=codigo&dt_2=descripcion';


--
-- TOC entry 7049 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.fecha_reg; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.fecha_reg IS 'nombre=fecha_reg&label=fecha_reg&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=fecha_reg';


--
-- TOC entry 7050 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.id_activo_fijo; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.id_activo_fijo IS 'nombre=id_activo_fijo&label=id_activo_fijo&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_activo_fijo';


--
-- TOC entry 7051 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.codigo; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.codigo IS 'nombre=codigo&label=Codigo&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=codigo';


--
-- TOC entry 7052 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.descripcion; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.descripcion IS 'nombre=descripcion&label=Descripcion&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=descripcion';


--
-- TOC entry 7053 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.descripcion_larga; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.descripcion_larga IS 'nombre=descripcion_larga&label=descripcion_larga&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=descripcion_larga';


--
-- TOC entry 7054 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.vida_util_original; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.vida_util_original IS 'nombre=vida_util_original&label=vida_util_original&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=vida_util_original';


--
-- TOC entry 7055 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.vida_util_restante; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.vida_util_restante IS 'nombre=vida_util_restante&label=vida_util_restante&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=vida_util_restante';


--
-- TOC entry 7056 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.tasa_depreciacion; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.tasa_depreciacion IS 'nombre=tasa_depreciacion&label=tasa_depreciacion&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=tasa_depreciacion';


--
-- TOC entry 7057 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.fecha_ultima_deprec; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.fecha_ultima_deprec IS 'nombre=fecha_ultima_deprec&label=fecha_ultima_deprec&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=fecha_ultima_deprec';


--
-- TOC entry 7058 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.depreciacion_acum_ant; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.depreciacion_acum_ant IS 'nombre=depreciacion_acum_ant&label=depreciacion_acum_ant&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=depreciacion_acum_ant';


--
-- TOC entry 7059 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.depreciacion_acum; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.depreciacion_acum IS 'nombre=depreciacion_acum&label=depreciacion_acum&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=depreciacion_acum';


--
-- TOC entry 7060 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.depreciacion_periodo; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.depreciacion_periodo IS 'nombre=depreciacion_periodo&label=depreciacion_periodo&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=depreciacion_periodo';


--
-- TOC entry 7061 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.flag_revaloriz; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.flag_revaloriz IS 'nombre=flag_revaloriz&label=flag_revaloriz&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=flag_revaloriz';


--
-- TOC entry 7062 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.valor_rescate; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.valor_rescate IS 'nombre=valor_rescate&label=valor_rescate&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=valor_rescate';


--
-- TOC entry 7063 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.fecha_compra; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.fecha_compra IS 'nombre=fecha_compra&label=fecha_compra&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=fecha_compra';


--
-- TOC entry 7064 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.monto_compra_mon_orig; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.monto_compra_mon_orig IS 'nombre=monto_compra_mon_orig&label=monto_compra_mon_orig&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=monto_compra_mon_orig';


--
-- TOC entry 7065 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.monto_compra; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.monto_compra IS 'nombre=monto_compra&label=monto_compra&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=monto_compra';


--
-- TOC entry 7066 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.monto_actual; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.monto_actual IS 'nombre=monto_actual&label=monto_actual&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=monto_actual';


--
-- TOC entry 7067 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.con_garantia; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.con_garantia IS 'nombre=con_garantia&label=con_garantia&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=con_garantia';


--
-- TOC entry 7068 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.num_poliza_garantia; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.num_poliza_garantia IS 'nombre=num_poliza_garantia&label=num_poliza_garantia&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=num_poliza_garantia';


--
-- TOC entry 7069 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.fecha_fin_gar; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.fecha_fin_gar IS 'nombre=fecha_fin_gar&label=fecha_fin_gar&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=fecha_fin_gar';


--
-- TOC entry 7070 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.foto_activo; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.foto_activo IS 'nombre=foto_activo&label=foto_activo&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=foto_activo';


--
-- TOC entry 7071 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.num_factura; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.num_factura IS 'nombre=num_factura&label=num_factura&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=num_factura';


--
-- TOC entry 7072 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.tipo_cambio; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.tipo_cambio IS 'nombre=tipo_cambio&label=tipo_cambio&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=tipo_cambio';


--
-- TOC entry 7073 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.estado; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.estado IS 'nombre=estado&label=estado&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=estado';


--
-- TOC entry 7074 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.observaciones; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.observaciones IS 'nombre=observaciones&label=observaciones&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=observaciones';


--
-- TOC entry 7075 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.id_sub_tipo_activo; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.id_sub_tipo_activo IS 'nombre=id_sub_tipo_activo&label=id_sub_tipo_activo&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_sub_tipo_activo';


--
-- TOC entry 7076 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.id_moneda; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.id_moneda IS 'nombre=id_moneda&label=id_moneda&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_moneda';


--
-- TOC entry 7077 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.id_moneda_original; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.id_moneda_original IS 'nombre=id_moneda_original&label=id_moneda_original&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_moneda_original';


--
-- TOC entry 7078 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.id_unidad_constructiva; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.id_unidad_constructiva IS 'nombre=id_unidad_constructiva&label=id_unidad_constructiva&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_unidad_constructiva';


--
-- TOC entry 7079 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.fecha_ini_dep; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.fecha_ini_dep IS 'nombre=fecha_ini_dep&label=fecha_ini_dep&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=fecha_ini_dep';


--
-- TOC entry 7080 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.ubicacion_fisica; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.ubicacion_fisica IS 'nombre=ubicacion_fisica&label=ubicacion_fisica&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=ubicacion_fisica';


--
-- TOC entry 7081 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.orden_compra; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.orden_compra IS 'nombre=orden_compra&label=orden_compra&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=orden_compra';


--
-- TOC entry 7082 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.id_estado_funcional; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.id_estado_funcional IS 'nombre=id_estado_funcional&label=id_estado_funcional&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_estado_funcional';


--
-- TOC entry 7083 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.vida_util_2; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.vida_util_2 IS 'nombre=vida_util_2&label=vida_util_2&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=Vida útil para la depreciación secundaria';


--
-- TOC entry 7084 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.monto_actualiz; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.monto_actualiz IS 'nombre=monto_actualiz&label=monto_actualiz&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=Monto Actualizado';


--
-- TOC entry 7085 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.id_depto; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.id_depto IS 'nombre=id_depto&label=id_depto&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_depto';


--
-- TOC entry 7086 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.id_cotizacion; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.id_cotizacion IS 'nombre=id_cotizacion&label=id_cotizacion&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_cotizacion';


--
-- TOC entry 7087 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.id_cotizacion_det; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.id_cotizacion_det IS 'nombre=id_cotizacion_det&label=id_cotizacion_det&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_cotizacion_det';


--
-- TOC entry 7088 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.origen; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.origen IS 'nombre=origen&label=origen&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=origen';


--
-- TOC entry 7089 (class 0 OID 0)
-- Dependencies: 204
-- Name: COLUMN taf_activo_fijo.id_lugar; Type: COMMENT; Schema: actif; Owner: -
--

COMMENT ON COLUMN taf_activo_fijo.id_lugar IS 'nombre=id_lugar&label=id_lugar&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_lugar';


--
-- TOC entry 205 (class 1259 OID 208577)
-- Dependencies: 6 204
-- Name: taf_activo_fijo_id_activo_fijo_seq; Type: SEQUENCE; Schema: actif; Owner: -
--

CREATE SEQUENCE taf_activo_fijo_id_activo_fijo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7090 (class 0 OID 0)
-- Dependencies: 205
-- Name: taf_activo_fijo_id_activo_fijo_seq; Type: SEQUENCE OWNED BY; Schema: actif; Owner: -
--

ALTER SEQUENCE taf_activo_fijo_id_activo_fijo_seq OWNED BY taf_activo_fijo.id_activo_fijo;


--
-- TOC entry 206 (class 1259 OID 208579)
-- Dependencies: 5524 5525 5526 5528 5529 6
-- Name: taf_sub_tipo_activo; Type: TABLE; Schema: actif; Owner: -; Tablespace: 
--

CREATE TABLE taf_sub_tipo_activo (
    id_sub_tipo_activo integer NOT NULL,
    codigo character varying(10) NOT NULL,
    descripcion character varying(100),
    vida_util integer,
    tasa_depreciacion real DEFAULT 0,
    ini_correlativo integer NOT NULL,
    correlativo_act integer NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    id_tipo_activo integer NOT NULL,
    CONSTRAINT taf_sub_tipo_activo_estado_check CHECK (((((estado)::text = 'activo'::text) OR ((estado)::text = 'inactivo'::text)) OR ((estado)::text = 'eliminado'::text))),
    CONSTRAINT taf_sub_tipo_activo_tasa_depreciacion_check CHECK (((tasa_depreciacion >= (0)::double precision) AND (tasa_depreciacion <= (100)::double precision)))
);


--
-- TOC entry 207 (class 1259 OID 208587)
-- Dependencies: 206 6
-- Name: taf_sub_tipo_activo_id_sub_tipo_activo_seq; Type: SEQUENCE; Schema: actif; Owner: -
--

CREATE SEQUENCE taf_sub_tipo_activo_id_sub_tipo_activo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7091 (class 0 OID 0)
-- Dependencies: 207
-- Name: taf_sub_tipo_activo_id_sub_tipo_activo_seq; Type: SEQUENCE OWNED BY; Schema: actif; Owner: -
--

ALTER SEQUENCE taf_sub_tipo_activo_id_sub_tipo_activo_seq OWNED BY taf_sub_tipo_activo.id_sub_tipo_activo;


--
-- TOC entry 208 (class 1259 OID 208589)
-- Dependencies: 5530 5531 5532 5533 5534 5535 6
-- Name: taf_tipo_activo; Type: TABLE; Schema: actif; Owner: -; Tablespace: 
--

CREATE TABLE taf_tipo_activo (
    id_tipo_activo integer DEFAULT nextval(('actif.taf_tipo_activo_fijo_id_tipo_activo_seq'::text)::regclass) NOT NULL,
    codigo character varying(10) NOT NULL,
    descripcion character varying(100),
    flag_depreciacion character varying(2) DEFAULT 'no'::character varying NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    id_metodo_depreciacion integer,
    CONSTRAINT taf_tipo_activo_fijo_estado_check CHECK (((((estado)::text = 'activo'::text) OR ((estado)::text = 'inactivo'::text)) OR ((estado)::text = 'eliminado'::text))),
    CONSTRAINT taf_tipo_activo_fijo_flag_depreciacion_check CHECK ((((flag_depreciacion)::text = 'si'::text) OR ((flag_depreciacion)::text = 'no'::text)))
);


SET search_path = cobra, pg_catalog;

--
-- TOC entry 209 (class 1259 OID 208598)
-- Dependencies: 8 203
-- Name: tcb_arqueo_estado; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_arqueo_estado (
    id_arqueo_estado integer NOT NULL,
    id_arqueo integer,
    estado_arqueo character varying
)
INHERITS (public.tbase);


--
-- TOC entry 210 (class 1259 OID 208607)
-- Dependencies: 209 8
-- Name: tarqueo_estado_id_arqueo_estado_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tarqueo_estado_id_arqueo_estado_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7092 (class 0 OID 0)
-- Dependencies: 210
-- Name: tarqueo_estado_id_arqueo_estado_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: -
--

ALTER SEQUENCE tarqueo_estado_id_arqueo_estado_seq OWNED BY tcb_arqueo_estado.id_arqueo_estado;


--
-- TOC entry 211 (class 1259 OID 208609)
-- Dependencies: 8 203
-- Name: tcb_agencia; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_agencia (
    id_agencia integer NOT NULL,
    id_enti_fin integer,
    codigo character varying(15),
    nombre character varying(100),
    observaciones character varying(500)
)
INHERITS (public.tbase);


--
-- TOC entry 212 (class 1259 OID 208618)
-- Dependencies: 211 8
-- Name: tcb_agencia_id_agencia_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_agencia_id_agencia_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7093 (class 0 OID 0)
-- Dependencies: 212
-- Name: tcb_agencia_id_agencia_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: -
--

ALTER SEQUENCE tcb_agencia_id_agencia_seq OWNED BY tcb_agencia.id_agencia;


--
-- TOC entry 213 (class 1259 OID 208620)
-- Dependencies: 203 8
-- Name: tcb_arqueo; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_arqueo (
    id_arqueo integer NOT NULL,
    id_caja integer,
    fecha date,
    estado character varying(15),
    observaciones character varying(1000)
)
INHERITS (public.tbase);


--
-- TOC entry 214 (class 1259 OID 208629)
-- Dependencies: 203 8
-- Name: tcb_arqueo_det; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_arqueo_det (
    id_arqueo_det integer NOT NULL,
    id_arqueo integer,
    id_corte integer,
    cantidad integer,
    importe numeric(18,2)
)
INHERITS (public.tbase);


--
-- TOC entry 7094 (class 0 OID 0)
-- Dependencies: 214
-- Name: COLUMN tcb_arqueo_det.cantidad; Type: COMMENT; Schema: cobra; Owner: -
--

COMMENT ON COLUMN tcb_arqueo_det.cantidad IS 'desc=cantidad que se tiene del id_corte seleccionado';


--
-- TOC entry 215 (class 1259 OID 208635)
-- Dependencies: 8 213
-- Name: tcb_arqueo_id_arqueo_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_arqueo_id_arqueo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7095 (class 0 OID 0)
-- Dependencies: 215
-- Name: tcb_arqueo_id_arqueo_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: -
--

ALTER SEQUENCE tcb_arqueo_id_arqueo_seq OWNED BY tcb_arqueo.id_arqueo;


--
-- TOC entry 216 (class 1259 OID 208637)
-- Dependencies: 8 203
-- Name: tcb_caja; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_caja (
    id_caja integer NOT NULL,
    id_agencia integer,
    codigo character varying(15),
    observaciones character varying(500),
    estado_caja character varying(10)
)
INHERITS (public.tbase);


--
-- TOC entry 217 (class 1259 OID 208646)
-- Dependencies: 5558 8 203
-- Name: tcb_caja_cajero; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_caja_cajero (
    id_caja_cajero integer DEFAULT nextval(('"cobra"."tcb_caja_cajero_id_caja_cajero_seq"'::text)::regclass) NOT NULL,
    id_cajero integer,
    estado_cajero character varying(15),
    id_caja integer
)
INHERITS (public.tbase);


--
-- TOC entry 218 (class 1259 OID 208653)
-- Dependencies: 8
-- Name: tcb_caja_cajero_id_caja_cajero_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_caja_cajero_id_caja_cajero_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 219 (class 1259 OID 208655)
-- Dependencies: 8 203
-- Name: tcb_caja_estado; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_caja_estado (
    id_caja_estado integer NOT NULL,
    id_caja integer,
    estado_ant character varying,
    estado_act character varying
)
INHERITS (public.tbase);


--
-- TOC entry 220 (class 1259 OID 208664)
-- Dependencies: 8 219
-- Name: tcb_caja_estado_id_caja_estado_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_caja_estado_id_caja_estado_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7096 (class 0 OID 0)
-- Dependencies: 220
-- Name: tcb_caja_estado_id_caja_estado_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: -
--

ALTER SEQUENCE tcb_caja_estado_id_caja_estado_seq OWNED BY tcb_caja_estado.id_caja_estado;


--
-- TOC entry 221 (class 1259 OID 208666)
-- Dependencies: 216 8
-- Name: tcb_caja_id_caja_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_caja_id_caja_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7097 (class 0 OID 0)
-- Dependencies: 221
-- Name: tcb_caja_id_caja_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: -
--

ALTER SEQUENCE tcb_caja_id_caja_seq OWNED BY tcb_caja.id_caja;


--
-- TOC entry 222 (class 1259 OID 208668)
-- Dependencies: 203 8
-- Name: tcb_cajero; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_cajero (
    id_cajero integer NOT NULL,
    id_caja integer,
    tipo_cajero character varying(15),
    estado_cajero character varying(10),
    id_usuario integer NOT NULL
)
INHERITS (public.tbase);


--
-- TOC entry 223 (class 1259 OID 208674)
-- Dependencies: 217 8
-- Name: tcb_cajero_estado_id_cajero_estado_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_cajero_estado_id_cajero_estado_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7098 (class 0 OID 0)
-- Dependencies: 223
-- Name: tcb_cajero_estado_id_cajero_estado_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: -
--

ALTER SEQUENCE tcb_cajero_estado_id_cajero_estado_seq OWNED BY tcb_caja_cajero.id_caja_cajero;


--
-- TOC entry 224 (class 1259 OID 208676)
-- Dependencies: 8 222
-- Name: tcb_cajero_id_cajero_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_cajero_id_cajero_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7099 (class 0 OID 0)
-- Dependencies: 224
-- Name: tcb_cajero_id_cajero_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: -
--

ALTER SEQUENCE tcb_cajero_id_cajero_seq OWNED BY tcb_cajero.id_cajero;


SET default_with_oids = true;

--
-- TOC entry 225 (class 1259 OID 208678)
-- Dependencies: 5570 8 203
-- Name: tcb_cliente; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_cliente (
    id_cliente integer DEFAULT nextval(('"cobra"."tcb_cliente_id_cliente_seq"'::text)::regclass) NOT NULL,
    id_sistema_dist integer NOT NULL,
    nro_cuenta character varying(20),
    nro_cuenta_ant character varying(20),
    nombre character varying(100),
    nro_nit numeric(12,0),
    id_cliente_dist integer NOT NULL,
    tipo_cliente character varying(10) NOT NULL,
    nroserie_med character varying(18)
)
INHERITS (public.tbase);


--
-- TOC entry 226 (class 1259 OID 208685)
-- Dependencies: 8
-- Name: tcb_cliente_id_cliente_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_cliente_id_cliente_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


SET default_with_oids = false;

--
-- TOC entry 227 (class 1259 OID 208687)
-- Dependencies: 203 8
-- Name: tcb_cobro; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_cobro (
    id_cobro integer NOT NULL,
    id_cajero integer,
    id_cliente integer,
    cant_facturas integer,
    importe_cobro numeric(20,2),
    importe_recibido numeric(20,2),
    importe_cambio numeric(20,2)
)
INHERITS (public.tbase);
ALTER TABLE ONLY tcb_cobro ALTER COLUMN id_cobro SET STATISTICS 0;
ALTER TABLE ONLY tcb_cobro ALTER COLUMN id_cajero SET STATISTICS 0;
ALTER TABLE ONLY tcb_cobro ALTER COLUMN id_cliente SET STATISTICS 0;
ALTER TABLE ONLY tcb_cobro ALTER COLUMN cant_facturas SET STATISTICS 0;
ALTER TABLE ONLY tcb_cobro ALTER COLUMN importe_cobro SET STATISTICS 0;
ALTER TABLE ONLY tcb_cobro ALTER COLUMN importe_recibido SET STATISTICS 0;
ALTER TABLE ONLY tcb_cobro ALTER COLUMN importe_cambio SET STATISTICS 0;


--
-- TOC entry 228 (class 1259 OID 208693)
-- Dependencies: 8 227
-- Name: tcb_cobro_id_cobro_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_cobro_id_cobro_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7100 (class 0 OID 0)
-- Dependencies: 228
-- Name: tcb_cobro_id_cobro_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: -
--

ALTER SEQUENCE tcb_cobro_id_cobro_seq OWNED BY tcb_cobro.id_cobro;


--
-- TOC entry 229 (class 1259 OID 208695)
-- Dependencies: 8 203
-- Name: tcb_enti_fin; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_enti_fin (
    id_enti_fin integer NOT NULL,
    id_institucion integer,
    nro_cuenta character varying(30),
    tipo_entidad character varying(30)
)
INHERITS (public.tbase);
ALTER TABLE ONLY tcb_enti_fin ALTER COLUMN id_enti_fin SET STATISTICS 0;
ALTER TABLE ONLY tcb_enti_fin ALTER COLUMN id_institucion SET STATISTICS 0;
ALTER TABLE ONLY tcb_enti_fin ALTER COLUMN nro_cuenta SET STATISTICS 0;
ALTER TABLE ONLY tcb_enti_fin ALTER COLUMN tipo_entidad SET STATISTICS 0;


--
-- TOC entry 230 (class 1259 OID 208701)
-- Dependencies: 229 8
-- Name: tcb_enti_fin2_id_enti_fin_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_enti_fin2_id_enti_fin_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7101 (class 0 OID 0)
-- Dependencies: 230
-- Name: tcb_enti_fin2_id_enti_fin_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: -
--

ALTER SEQUENCE tcb_enti_fin2_id_enti_fin_seq OWNED BY tcb_enti_fin.id_enti_fin;


SET default_with_oids = true;

--
-- TOC entry 231 (class 1259 OID 208703)
-- Dependencies: 203 8
-- Name: tcb_factura_cob; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_factura_cob (
    id_factura_cob integer NOT NULL,
    id_caja integer,
    id_cajero integer,
    id_cliente integer,
    id_moneda integer,
    periodo numeric(2,0),
    gestion numeric(4,0),
    fecha_pago timestamp without time zone,
    estado_fac character varying(10),
    tipo_lectura character varying(10),
    fecha_factura date,
    nro_factura character varying(20),
    cod_control character varying(15),
    nro_autorizacion character varying(15),
    nro_orden character varying(15),
    cod_alfanum character varying(15),
    importe_total numeric(18,2),
    fecha_vence date,
    fecha_ant date,
    fecha_act date,
    lectura_ant numeric(18,2),
    lectura_act numeric(18,2),
    consumo_cambio numeric(18,2),
    consumo_periodo numeric(18,2),
    consumo_total numeric(18,2),
    lectura_kw numeric(18,2),
    consumo_val numeric(18,2),
    conexion_val numeric(18,2),
    reconex_val numeric(18,2),
    importe_dev numeric(18,2),
    credito_pagado numeric(18,2),
    potencia_val numeric(18,2),
    importe_cred_fis numeric(18,2),
    multi_kwh numeric(18,2),
    fecha_prox_med date,
    consumo_libre numeric(18,2),
    num_formulario character varying(20),
    sw_deb_fis character varying(2),
    cod_ubica character varying(20),
    direccion character varying(100),
    nombre_fac character varying(100),
    nit_fact character varying(20),
    nro_medidor character varying(20),
    id_cobro integer,
    desc_categoria character varying(100),
    dias_morosidad integer,
    glosa character varying(1000),
    estado_fac_ant character varying(10)
)
INHERITS (public.tbase);


--
-- TOC entry 7102 (class 0 OID 0)
-- Dependencies: 231
-- Name: COLUMN tcb_factura_cob.importe_total; Type: COMMENT; Schema: cobra; Owner: -
--

COMMENT ON COLUMN tcb_factura_cob.importe_total IS 'desc=Importe total a pagar por el cliente (líquido pagable)';


--
-- TOC entry 7103 (class 0 OID 0)
-- Dependencies: 231
-- Name: COLUMN tcb_factura_cob.importe_cred_fis; Type: COMMENT; Schema: cobra; Owner: -
--

COMMENT ON COLUMN tcb_factura_cob.importe_cred_fis IS 'desc=Corresponde sólo al importe válido para el crédito fiscal';


--
-- TOC entry 7104 (class 0 OID 0)
-- Dependencies: 231
-- Name: COLUMN tcb_factura_cob.sw_deb_fis; Type: COMMENT; Schema: cobra; Owner: -
--

COMMENT ON COLUMN tcb_factura_cob.sw_deb_fis IS 'desc=Bandera que indica si se cobra o no Crédito Fiscal (caso de regiones como Cobija que no incluye Crédito Fiscal)';


--
-- TOC entry 7105 (class 0 OID 0)
-- Dependencies: 231
-- Name: COLUMN tcb_factura_cob.estado_fac_ant; Type: COMMENT; Schema: cobra; Owner: -
--

COMMENT ON COLUMN tcb_factura_cob.estado_fac_ant IS 'Estado anterior de la factura';


SET default_with_oids = false;

--
-- TOC entry 232 (class 1259 OID 208712)
-- Dependencies: 203 8
-- Name: tcb_factura_cob_anulado; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_factura_cob_anulado (
    id_factura_cob_anulado integer NOT NULL,
    id_factura_cob integer,
    id_caja integer,
    id_cajero integer,
    id_usuario integer,
    nro_formulario integer,
    motivo character varying(1000),
    estado_fac character varying(10),
    estado_fac_ant character varying(10),
    id_cobro integer
)
INHERITS (public.tbase);


--
-- TOC entry 7106 (class 0 OID 0)
-- Dependencies: 232
-- Name: COLUMN tcb_factura_cob_anulado.id_usuario; Type: COMMENT; Schema: cobra; Owner: -
--

COMMENT ON COLUMN tcb_factura_cob_anulado.id_usuario IS 'desc=Usuario que realiza la anulación que es diferente al cajero';


--
-- TOC entry 7107 (class 0 OID 0)
-- Dependencies: 232
-- Name: COLUMN tcb_factura_cob_anulado.estado_fac; Type: COMMENT; Schema: cobra; Owner: -
--

COMMENT ON COLUMN tcb_factura_cob_anulado.estado_fac IS 'Estado de la factura a la fecha de registro';


--
-- TOC entry 7108 (class 0 OID 0)
-- Dependencies: 232
-- Name: COLUMN tcb_factura_cob_anulado.estado_fac_ant; Type: COMMENT; Schema: cobra; Owner: -
--

COMMENT ON COLUMN tcb_factura_cob_anulado.estado_fac_ant IS 'Estado de la factura a la fecha de registro';


--
-- TOC entry 233 (class 1259 OID 208721)
-- Dependencies: 8 232
-- Name: tcb_factura_cob_anulado_id_factura_cob_anulado_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_factura_cob_anulado_id_factura_cob_anulado_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7109 (class 0 OID 0)
-- Dependencies: 233
-- Name: tcb_factura_cob_anulado_id_factura_cob_anulado_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: -
--

ALTER SEQUENCE tcb_factura_cob_anulado_id_factura_cob_anulado_seq OWNED BY tcb_factura_cob_anulado.id_factura_cob_anulado;


--
-- TOC entry 234 (class 1259 OID 208723)
-- Dependencies: 8 203
-- Name: tcb_factura_cob_det; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_factura_cob_det (
    id_factura_cob_det integer NOT NULL,
    id_factura_cob integer,
    id_tasa integer,
    id_descuento integer,
    importe numeric(18,2)
)
INHERITS (public.tbase);


--
-- TOC entry 235 (class 1259 OID 208729)
-- Dependencies: 234 8
-- Name: tcb_factura_cob_det_id_factura_cob_det_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_factura_cob_det_id_factura_cob_det_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7110 (class 0 OID 0)
-- Dependencies: 235
-- Name: tcb_factura_cob_det_id_factura_cob_det_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: -
--

ALTER SEQUENCE tcb_factura_cob_det_id_factura_cob_det_seq OWNED BY tcb_factura_cob_det.id_factura_cob_det;


--
-- TOC entry 236 (class 1259 OID 208731)
-- Dependencies: 8 231
-- Name: tcb_factura_cob_id_factura_cob_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_factura_cob_id_factura_cob_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7111 (class 0 OID 0)
-- Dependencies: 236
-- Name: tcb_factura_cob_id_factura_cob_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: -
--

ALTER SEQUENCE tcb_factura_cob_id_factura_cob_seq OWNED BY tcb_factura_cob.id_factura_cob;


--
-- TOC entry 237 (class 1259 OID 208733)
-- Dependencies: 5595 203 8
-- Name: tcb_prueba; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_prueba (
    id_prueba integer NOT NULL,
    nombre character varying(300),
    fecha date,
    estado character varying(10),
    sueldo numeric(18,2),
    empleado boolean,
    CONSTRAINT chk_tcb_prueba__estado CHECK (((estado)::text = ANY (ARRAY[('borrador'::character varying)::text, ('aprobado'::character varying)::text])))
)
INHERITS (public.tbase);


--
-- TOC entry 238 (class 1259 OID 208740)
-- Dependencies: 8 237
-- Name: tcb_prueba_id_prueba_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_prueba_id_prueba_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7112 (class 0 OID 0)
-- Dependencies: 238
-- Name: tcb_prueba_id_prueba_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: -
--

ALTER SEQUENCE tcb_prueba_id_prueba_seq OWNED BY tcb_prueba.id_prueba;


SET default_with_oids = true;

--
-- TOC entry 239 (class 1259 OID 208742)
-- Dependencies: 5599 8 203
-- Name: tcb_sistema_dist; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_sistema_dist (
    nombre character varying(100) NOT NULL,
    conexion character varying(100),
    id_sistema_dist integer DEFAULT nextval(('"cobra"."tcb_sistema_dist_id_sistema_dist_seq"'::text)::regclass) NOT NULL,
    codigo character varying(10) NOT NULL
)
INHERITS (public.tbase);


SET default_with_oids = false;

--
-- TOC entry 240 (class 1259 OID 208749)
-- Dependencies: 8 203
-- Name: tcb_sistema_dist_agencia; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_sistema_dist_agencia (
    id_sistema_dist_agencia integer NOT NULL,
    id_sistema_dist integer,
    id_agencia integer
)
INHERITS (public.tbase);


--
-- TOC entry 241 (class 1259 OID 208755)
-- Dependencies: 8 240
-- Name: tcb_sistema_dist_agencia_id_sistema_dist_agencia_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_sistema_dist_agencia_id_sistema_dist_agencia_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7113 (class 0 OID 0)
-- Dependencies: 241
-- Name: tcb_sistema_dist_agencia_id_sistema_dist_agencia_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: -
--

ALTER SEQUENCE tcb_sistema_dist_agencia_id_sistema_dist_agencia_seq OWNED BY tcb_sistema_dist_agencia.id_sistema_dist_agencia;


--
-- TOC entry 242 (class 1259 OID 208757)
-- Dependencies: 8
-- Name: tcb_sistema_dist_id_sistema_dist_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_sistema_dist_id_sistema_dist_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 243 (class 1259 OID 208759)
-- Dependencies: 203 8
-- Name: tcb_sistema_dist_usuario; Type: TABLE; Schema: cobra; Owner: -; Tablespace: 
--

CREATE TABLE tcb_sistema_dist_usuario (
    id_sistema_dist_usuario integer NOT NULL,
    id_sistema_dist integer,
    id_usuario integer
)
INHERITS (public.tbase);


--
-- TOC entry 244 (class 1259 OID 208765)
-- Dependencies: 8 243
-- Name: tcb_sistema_dist_usuario_id_sistema_dist_usuario_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_sistema_dist_usuario_id_sistema_dist_usuario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7114 (class 0 OID 0)
-- Dependencies: 244
-- Name: tcb_sistema_dist_usuario_id_sistema_dist_usuario_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: -
--

ALTER SEQUENCE tcb_sistema_dist_usuario_id_sistema_dist_usuario_seq OWNED BY tcb_sistema_dist_usuario.id_sistema_dist_usuario;


--
-- TOC entry 245 (class 1259 OID 208767)
-- Dependencies: 239 8
-- Name: tcb_sistema_distribucion_id_sistema_seq; Type: SEQUENCE; Schema: cobra; Owner: -
--

CREATE SEQUENCE tcb_sistema_distribucion_id_sistema_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7115 (class 0 OID 0)
-- Dependencies: 245
-- Name: tcb_sistema_distribucion_id_sistema_seq; Type: SEQUENCE OWNED BY; Schema: cobra; Owner: -
--

ALTER SEQUENCE tcb_sistema_distribucion_id_sistema_seq OWNED BY tcb_sistema_dist.id_sistema_dist;


SET search_path = conta, pg_catalog;

SET default_with_oids = true;

--
-- TOC entry 246 (class 1259 OID 208769)
-- Dependencies: 5608 5609 9
-- Name: tauxiliar; Type: TABLE; Schema: conta; Owner: -; Tablespace: 
--

CREATE TABLE tauxiliar (
    id_auxiliar integer NOT NULL,
    codigo character varying(50),
    nombre character varying(250),
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    fecha_reg date DEFAULT (now())::date NOT NULL
);


--
-- TOC entry 247 (class 1259 OID 208774)
-- Dependencies: 9 246
-- Name: tauxiliar_id_auxiliar_seq; Type: SEQUENCE; Schema: conta; Owner: -
--

CREATE SEQUENCE tauxiliar_id_auxiliar_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7116 (class 0 OID 0)
-- Dependencies: 247
-- Name: tauxiliar_id_auxiliar_seq; Type: SEQUENCE OWNED BY; Schema: conta; Owner: -
--

ALTER SEQUENCE tauxiliar_id_auxiliar_seq OWNED BY tauxiliar.id_auxiliar;


--
-- TOC entry 248 (class 1259 OID 208776)
-- Dependencies: 5611 5612 9
-- Name: tcuenta; Type: TABLE; Schema: conta; Owner: -; Tablespace: 
--

CREATE TABLE tcuenta (
    id_cuenta integer NOT NULL,
    codigo character varying(50),
    nombre character varying(250),
    estado_reg character varying DEFAULT 'activo'::character varying NOT NULL,
    fecha_reg date DEFAULT (now())::date NOT NULL
);


--
-- TOC entry 249 (class 1259 OID 208784)
-- Dependencies: 248 9
-- Name: tcuenta_id_cuenta_seq; Type: SEQUENCE; Schema: conta; Owner: -
--

CREATE SEQUENCE tcuenta_id_cuenta_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7117 (class 0 OID 0)
-- Dependencies: 249
-- Name: tcuenta_id_cuenta_seq; Type: SEQUENCE OWNED BY; Schema: conta; Owner: -
--

ALTER SEQUENCE tcuenta_id_cuenta_seq OWNED BY tcuenta.id_cuenta;


SET default_with_oids = false;

--
-- TOC entry 250 (class 1259 OID 208786)
-- Dependencies: 5617 5618 9 203
-- Name: tdocumento; Type: TABLE; Schema: conta; Owner: -; Tablespace: 
--

CREATE TABLE tdocumento (
    id_documento integer NOT NULL,
    id_documento_tipo integer NOT NULL,
    nit character varying(30),
    nro_autorizacion character varying(30),
    nro_orden character varying(30),
    codigo_control character varying(30),
    importe numeric(18,2) NOT NULL,
    importe_excento numeric(18,2) DEFAULT 0 NOT NULL,
    nro_documento character varying(20) NOT NULL,
    importe_ice numeric(18,2) DEFAULT 0 NOT NULL,
    id_moneda_base integer NOT NULL
)
INHERITS (public.tbase);


--
-- TOC entry 251 (class 1259 OID 208794)
-- Dependencies: 9 203
-- Name: tdocumento_tipo; Type: TABLE; Schema: conta; Owner: -; Tablespace: 
--

CREATE TABLE tdocumento_tipo (
    id_documento_tipo integer NOT NULL,
    nombre character varying(50)
)
INHERITS (public.tbase);


SET search_path = factur, pg_catalog;

--
-- TOC entry 252 (class 1259 OID 208800)
-- Dependencies: 5622 5623 5624 5626 5627 5628 10
-- Name: tfv_descuento; Type: TABLE; Schema: factur; Owner: -; Tablespace: 
--

CREATE TABLE tfv_descuento (
    id_descuento integer NOT NULL,
    id_cuenta integer,
    desc_descuento character varying(100) NOT NULL,
    porcentaje numeric(10,4) DEFAULT 0 NOT NULL,
    consumo numeric(18,0) NOT NULL,
    sw_maximo character varying(2) DEFAULT 'no'::character varying NOT NULL,
    sw_general character varying(2) DEFAULT 'no'::character varying NOT NULL,
    estado numeric(1,0) NOT NULL,
    CONSTRAINT tfv_descuento_porcentaje_check CHECK (((porcentaje >= (0)::numeric) AND (porcentaje <= (100)::numeric))),
    CONSTRAINT tfv_descuento_sw_general_check CHECK ((((sw_general)::text = 'si'::text) OR ((sw_general)::text = 'no'::text))),
    CONSTRAINT tfv_descuento_sw_maximo_check CHECK ((((sw_maximo)::text = 'si'::text) OR ((sw_maximo)::text = 'no'::text)))
);


--
-- TOC entry 7118 (class 0 OID 0)
-- Dependencies: 252
-- Name: TABLE tfv_descuento; Type: COMMENT; Schema: factur; Owner: -
--

COMMENT ON TABLE tfv_descuento IS 'Guarda los parametros de descuento por ley en las facturas del consumo electrico (descuento de vejes y descuento tarifa dignidad)';


--
-- TOC entry 253 (class 1259 OID 208809)
-- Dependencies: 252 10
-- Name: tfv_descuento_id_descuento_seq; Type: SEQUENCE; Schema: factur; Owner: -
--

CREATE SEQUENCE tfv_descuento_id_descuento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7119 (class 0 OID 0)
-- Dependencies: 253
-- Name: tfv_descuento_id_descuento_seq; Type: SEQUENCE OWNED BY; Schema: factur; Owner: -
--

ALTER SEQUENCE tfv_descuento_id_descuento_seq OWNED BY tfv_descuento.id_descuento;


SET default_with_oids = true;

--
-- TOC entry 254 (class 1259 OID 208811)
-- Dependencies: 10
-- Name: tfv_entidad_fin; Type: TABLE; Schema: factur; Owner: -; Tablespace: 
--

CREATE TABLE tfv_entidad_fin (
    id_enti_fin integer NOT NULL,
    doc_id character varying,
    tipo_doc_id character varying,
    nombre character varying,
    codigo integer,
    num_cta_dep character varying(25),
    estado character varying
);


--
-- TOC entry 255 (class 1259 OID 208817)
-- Dependencies: 254 10
-- Name: tfv_entidad_fin_id_enti_fin_seq; Type: SEQUENCE; Schema: factur; Owner: -
--

CREATE SEQUENCE tfv_entidad_fin_id_enti_fin_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7120 (class 0 OID 0)
-- Dependencies: 255
-- Name: tfv_entidad_fin_id_enti_fin_seq; Type: SEQUENCE OWNED BY; Schema: factur; Owner: -
--

ALTER SEQUENCE tfv_entidad_fin_id_enti_fin_seq OWNED BY tfv_entidad_fin.id_enti_fin;


SET default_with_oids = false;

--
-- TOC entry 256 (class 1259 OID 208819)
-- Dependencies: 5630 5632 10
-- Name: tfv_tasa; Type: TABLE; Schema: factur; Owner: -; Tablespace: 
--

CREATE TABLE tfv_tasa (
    id_tasa integer NOT NULL,
    id_param integer NOT NULL,
    id_cuenta integer,
    desc_tasa character varying(100) NOT NULL,
    tasa_porcen numeric(10,4) DEFAULT 0 NOT NULL,
    estado numeric(1,0) NOT NULL,
    CONSTRAINT tfv_tasa_tasa_porcen_check CHECK (((tasa_porcen >= (0)::numeric) AND (tasa_porcen <= (100)::numeric)))
);


--
-- TOC entry 7121 (class 0 OID 0)
-- Dependencies: 256
-- Name: TABLE tfv_tasa; Type: COMMENT; Schema: factur; Owner: -
--

COMMENT ON TABLE tfv_tasa IS 'Almacena la informacion referente a las tasas que se incluyen en la facturacion del servicio electrico';


--
-- TOC entry 257 (class 1259 OID 208824)
-- Dependencies: 256 10
-- Name: tfv_tasa_id_tasa_seq; Type: SEQUENCE; Schema: factur; Owner: -
--

CREATE SEQUENCE tfv_tasa_id_tasa_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7122 (class 0 OID 0)
-- Dependencies: 257
-- Name: tfv_tasa_id_tasa_seq; Type: SEQUENCE OWNED BY; Schema: factur; Owner: -
--

ALTER SEQUENCE tfv_tasa_id_tasa_seq OWNED BY tfv_tasa.id_tasa;


SET search_path = gem, pg_catalog;

SET default_with_oids = true;

--
-- TOC entry 625 (class 1259 OID 313632)
-- Dependencies: 203 42
-- Name: tlocalizacion; Type: TABLE; Schema: gem; Owner: -; Tablespace: 
--

CREATE TABLE tlocalizacion (
    id_localizacion integer NOT NULL,
    id_localizacion_fk integer,
    codigo character varying(30),
    nombre character varying(150),
    coordenadas character varying(200),
    ubicacion character varying(500),
    desc_ubicacion character varying(2000),
    latitud text,
    longitud text
)
INHERITS (public.tbase);


--
-- TOC entry 624 (class 1259 OID 313630)
-- Dependencies: 625 42
-- Name: tlocalizacion_id_localizacion_seq; Type: SEQUENCE; Schema: gem; Owner: -
--

CREATE SEQUENCE tlocalizacion_id_localizacion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7123 (class 0 OID 0)
-- Dependencies: 624
-- Name: tlocalizacion_id_localizacion_seq; Type: SEQUENCE OWNED BY; Schema: gem; Owner: -
--

ALTER SEQUENCE tlocalizacion_id_localizacion_seq OWNED BY tlocalizacion.id_localizacion;


SET search_path = gen, pg_catalog;

--
-- TOC entry 258 (class 1259 OID 208826)
-- Dependencies: 11
-- Name: tcolumna_id_columna_seq; Type: SEQUENCE; Schema: gen; Owner: -
--

CREATE SEQUENCE tcolumna_id_columna_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


SET default_with_oids = false;

--
-- TOC entry 259 (class 1259 OID 208828)
-- Dependencies: 5636 5637 5638 203 11
-- Name: tcolumna; Type: TABLE; Schema: gen; Owner: -; Tablespace: 
--

CREATE TABLE tcolumna (
    id_columna integer DEFAULT nextval('tcolumna_id_columna_seq'::regclass) NOT NULL,
    nombre character varying(50),
    descripcion character varying(500),
    id_tabla integer NOT NULL,
    etiqueta character varying(50),
    guardar character varying(2),
    tipo_dato character varying(25),
    longitud text,
    nulo character varying(10),
    checks character varying(20),
    valor_defecto character varying(200),
    grid_ancho integer,
    grid_mostrar character varying(2),
    form_ancho_porcen integer,
    orden smallint,
    grupo smallint,
    CONSTRAINT check_tcolumna__guardar CHECK ((((guardar)::text = 'si'::text) OR ((guardar)::text = 'no'::text))),
    CONSTRAINT chk_tcolumna__grid_mostrar CHECK (((grid_mostrar)::text = ANY (ARRAY[('si'::character varying)::text, ('no'::character varying)::text])))
)
INHERITS (public.tbase);


--
-- TOC entry 260 (class 1259 OID 208840)
-- Dependencies: 5641 11 203
-- Name: ttabla; Type: TABLE; Schema: gen; Owner: -; Tablespace: 
--

CREATE TABLE ttabla (
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    id_tabla integer NOT NULL,
    esquema character varying(20),
    nombre character varying(50),
    id_subsistema integer,
    alias character varying(10),
    reemplazar character varying(2),
    menu character varying(2),
    titulo character varying(150),
    direccion character varying(200),
    cant_grupos integer
)
INHERITS (public.tbase);


--
-- TOC entry 261 (class 1259 OID 208846)
-- Dependencies: 260 11
-- Name: ttabla_id_tabla_seq1; Type: SEQUENCE; Schema: gen; Owner: -
--

CREATE SEQUENCE ttabla_id_tabla_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7124 (class 0 OID 0)
-- Dependencies: 261
-- Name: ttabla_id_tabla_seq1; Type: SEQUENCE OWNED BY; Schema: gen; Owner: -
--

ALTER SEQUENCE ttabla_id_tabla_seq1 OWNED BY ttabla.id_tabla;


--
-- TOC entry 262 (class 1259 OID 208848)
-- Dependencies: 5485 2089 11 2089 2089
-- Name: vcolumna; Type: VIEW; Schema: gen; Owner: -
--

CREATE VIEW vcolumna AS
    SELECT col.table_schema AS esquema, col.table_name AS tabla, col.column_name AS columna, (col.ordinal_position)::integer AS posicion, (col.column_default)::character varying AS defecto, (col.is_nullable)::character varying AS blanco, (col.data_type)::character varying AS tipo, CASE WHEN ((col.data_type)::text = 'character varying'::text) THEN (col.character_maximum_length)::integer WHEN ((col.data_type)::text = 'numeric'::text) THEN (col.numeric_precision)::integer ELSE 0 END AS length, CASE WHEN ((col.data_type)::text = 'numeric'::text) THEN (col.numeric_scale)::integer ELSE 0 END AS "precision", (cons.conname)::character varying AS nombre_constraint, (cons.consrc)::character varying AS definicion_constraint FROM (((information_schema.columns col LEFT JOIN information_schema.constraint_column_usage colcon ON (((((col.table_schema)::text = (colcon.table_schema)::text) AND ((col.table_name)::text = (colcon.table_name)::text)) AND ((col.column_name)::text = (colcon.column_name)::text)))) LEFT JOIN pg_constraint cons ON (((cons.conname = (colcon.constraint_name)::name) AND (cons.contype = 'c'::"char")))) LEFT JOIN pg_class c ON (((cons.conrelid = c.oid) AND (c.relname = (col.table_name)::name)))) WHERE (((col.table_schema)::text <> 'pg_catalog'::text) AND ((col.table_schema)::text <> 'information_schema'::text));


SET search_path = gev, pg_catalog;

--
-- TOC entry 263 (class 1259 OID 208853)
-- Dependencies: 5643 5644 5645 5646 12 203
-- Name: tgv_activo_datos_tec; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_activo_datos_tec (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_activo_datos_tec integer DEFAULT nextval(('gev.tgv_activo_datos_tec_id_activo_datos_tec_seq'::text)::regclass) NOT NULL,
    id_activo_fijo integer,
    id_modelo integer,
    placa character varying NOT NULL,
    chasis character varying,
    soat character varying,
    num_motor character varying,
    cilindrada_cc numeric(18,2),
    rend_litro_km numeric(18,2),
    ult_kilometraje numeric,
    fecha_ult_km timestamp without time zone,
    modem_id character varying(50) NOT NULL
)
INHERITS (public.tbase);


--
-- TOC entry 264 (class 1259 OID 208863)
-- Dependencies: 12
-- Name: tgv_activo_datos_tec_id_activo_datos_tec_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_activo_datos_tec_id_activo_datos_tec_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


SET default_with_oids = true;

--
-- TOC entry 265 (class 1259 OID 208865)
-- Dependencies: 5647 5648 5649 12 203
-- Name: tgv_activo_fijo_grupo_evento; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_activo_fijo_grupo_evento (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_activo_fijo_grupo_evento integer NOT NULL,
    id_activo_fijo integer NOT NULL,
    id_agrupacion integer NOT NULL,
    estado character varying(10)
)
INHERITS (public.tbase);


--
-- TOC entry 266 (class 1259 OID 208871)
-- Dependencies: 265 12
-- Name: tgv_activo_fijo_grupo_evento_id_activo_fijo_grupo_evento_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_activo_fijo_grupo_evento_id_activo_fijo_grupo_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7125 (class 0 OID 0)
-- Dependencies: 266
-- Name: tgv_activo_fijo_grupo_evento_id_activo_fijo_grupo_evento_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_activo_fijo_grupo_evento_id_activo_fijo_grupo_evento_seq OWNED BY tgv_activo_fijo_grupo_evento.id_activo_fijo_grupo_evento;


--
-- TOC entry 267 (class 1259 OID 208873)
-- Dependencies: 265 12
-- Name: tgv_activo_fijo_grupo_evento_id_activo_fijo_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_activo_fijo_grupo_evento_id_activo_fijo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7126 (class 0 OID 0)
-- Dependencies: 267
-- Name: tgv_activo_fijo_grupo_evento_id_activo_fijo_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_activo_fijo_grupo_evento_id_activo_fijo_seq OWNED BY tgv_activo_fijo_grupo_evento.id_activo_fijo;


--
-- TOC entry 268 (class 1259 OID 208875)
-- Dependencies: 265 12
-- Name: tgv_activo_fijo_grupo_evento_id_agrupacion_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_activo_fijo_grupo_evento_id_agrupacion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7127 (class 0 OID 0)
-- Dependencies: 268
-- Name: tgv_activo_fijo_grupo_evento_id_agrupacion_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_activo_fijo_grupo_evento_id_agrupacion_seq OWNED BY tgv_activo_fijo_grupo_evento.id_agrupacion;


--
-- TOC entry 269 (class 1259 OID 208877)
-- Dependencies: 5653 5654 5655 203 12
-- Name: tgv_activo_fijo_rastreo; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_activo_fijo_rastreo (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_activo_fijo_rastreo integer NOT NULL,
    id_activo_fijo integer,
    dia integer,
    mes integer,
    anio integer,
    hora_gps numeric(19,10),
    fecha_hora integer,
    calle character varying(200),
    ciudad character varying(100),
    estado character varying(10),
    latitud numeric,
    longitud numeric,
    velocidad numeric,
    curso integer,
    altitud numeric,
    mensaje character varying(200),
    punto_cercano character varying(200),
    odometro numeric,
    numero_actualizado integer,
    fecha_servidor date,
    fecha_satelite timestamp without time zone,
    aux1 character varying(150),
    aux2 character varying(150),
    aux3 character varying(150),
    aux4 character varying(150),
    advisories character varying(30),
    events integer,
    id_funcionario integer
)
INHERITS (public.tbase);


--
-- TOC entry 270 (class 1259 OID 208886)
-- Dependencies: 269 12
-- Name: tgv_activo_fijo_rastreo_id_activo_fijo_rastreo_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_activo_fijo_rastreo_id_activo_fijo_rastreo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7128 (class 0 OID 0)
-- Dependencies: 270
-- Name: tgv_activo_fijo_rastreo_id_activo_fijo_rastreo_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_activo_fijo_rastreo_id_activo_fijo_rastreo_seq OWNED BY tgv_activo_fijo_rastreo.id_activo_fijo_rastreo;


SET default_with_oids = false;

--
-- TOC entry 271 (class 1259 OID 208888)
-- Dependencies: 5657 5658 5659 12 203
-- Name: tgv_activo_fijo_ultimo_registro; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_activo_fijo_ultimo_registro (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_ultimo_registro integer NOT NULL,
    fecha_satelite timestamp without time zone,
    latitud numeric,
    longitud numeric,
    velocidad numeric,
    curso integer,
    id_funcionario integer,
    chofer character varying(100),
    id_activo_fijo integer,
    aux1 character varying(150),
    aux2 character varying(150),
    aux3 character varying(150),
    aux4 character varying(150),
    punto_cercano character varying(100)
)
INHERITS (public.tbase);


--
-- TOC entry 272 (class 1259 OID 208897)
-- Dependencies: 271 12
-- Name: tgv_activo_fijo_ultimo_registro_id_ultimo_registro_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_activo_fijo_ultimo_registro_id_ultimo_registro_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7129 (class 0 OID 0)
-- Dependencies: 272
-- Name: tgv_activo_fijo_ultimo_registro_id_ultimo_registro_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_activo_fijo_ultimo_registro_id_ultimo_registro_seq OWNED BY tgv_activo_fijo_ultimo_registro.id_ultimo_registro;


SET default_with_oids = true;

--
-- TOC entry 273 (class 1259 OID 208899)
-- Dependencies: 5661 5662 5663 203 12
-- Name: tgv_agrupacion; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_agrupacion (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_agrupacion integer NOT NULL,
    nombre character varying(80)
)
INHERITS (public.tbase);


--
-- TOC entry 274 (class 1259 OID 208905)
-- Dependencies: 5665 5666 5667 12 203
-- Name: tgv_agrupacion_evento; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_agrupacion_evento (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_agrupacion_evento integer NOT NULL,
    id_evento integer NOT NULL,
    id_agrupacion integer NOT NULL
)
INHERITS (public.tbase);


--
-- TOC entry 275 (class 1259 OID 208911)
-- Dependencies: 12 274
-- Name: tgv_agrupacion_evento_id_agrupacion_evento_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_agrupacion_evento_id_agrupacion_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7130 (class 0 OID 0)
-- Dependencies: 275
-- Name: tgv_agrupacion_evento_id_agrupacion_evento_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_agrupacion_evento_id_agrupacion_evento_seq OWNED BY tgv_agrupacion_evento.id_agrupacion_evento;


--
-- TOC entry 276 (class 1259 OID 208913)
-- Dependencies: 12
-- Name: tgv_agrupacion_evento_id_evento_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_agrupacion_evento_id_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 277 (class 1259 OID 208915)
-- Dependencies: 12
-- Name: tgv_agrupacion_evento_id_grupo_evento_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_agrupacion_evento_id_grupo_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 278 (class 1259 OID 208917)
-- Dependencies: 12 273
-- Name: tgv_agrupacion_id_agrupacion_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_agrupacion_id_agrupacion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7131 (class 0 OID 0)
-- Dependencies: 278
-- Name: tgv_agrupacion_id_agrupacion_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_agrupacion_id_agrupacion_seq OWNED BY tgv_agrupacion.id_agrupacion;


--
-- TOC entry 279 (class 1259 OID 208919)
-- Dependencies: 5669 5670 5671 203 12
-- Name: tgv_bitacora; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_bitacora (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_bitacora integer NOT NULL,
    id_servicio_det integer NOT NULL,
    fecha date,
    combustible_lts numeric(18,2),
    combustible character varying(255),
    num_factura character varying(40),
    importe numeric(18,2),
    observaciones character varying(500),
    origen character varying(100),
    destino character varying(100)
)
INHERITS (public.tbase);


--
-- TOC entry 280 (class 1259 OID 208928)
-- Dependencies: 12 279
-- Name: tgv_bitacora_id_bitacora_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_bitacora_id_bitacora_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7132 (class 0 OID 0)
-- Dependencies: 280
-- Name: tgv_bitacora_id_bitacora_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_bitacora_id_bitacora_seq OWNED BY tgv_bitacora.id_bitacora;


--
-- TOC entry 281 (class 1259 OID 208930)
-- Dependencies: 12 279
-- Name: tgv_bitacora_id_servicio_det_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_bitacora_id_servicio_det_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7133 (class 0 OID 0)
-- Dependencies: 281
-- Name: tgv_bitacora_id_servicio_det_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_bitacora_id_servicio_det_seq OWNED BY tgv_bitacora.id_servicio_det;


--
-- TOC entry 282 (class 1259 OID 208932)
-- Dependencies: 5674 5675 5676 12 203
-- Name: tgv_datos_tec; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_datos_tec (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_datos_tec integer NOT NULL,
    id_activo_fijo integer NOT NULL,
    id_modelo integer,
    num_chasis character varying(50),
    soat character varying(30),
    num_motor character varying(50),
    cilindrada_cc numeric(18,2),
    rend_litro_km numeric(18,2),
    ult_kilometraje numeric(18,2),
    fecha_ult_km date,
    modem_id character varying(32)
)
INHERITS (public.tbase);


--
-- TOC entry 283 (class 1259 OID 208938)
-- Dependencies: 282 12
-- Name: tgv_datos_tec_id_datos_tec_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_datos_tec_id_datos_tec_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7134 (class 0 OID 0)
-- Dependencies: 283
-- Name: tgv_datos_tec_id_datos_tec_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_datos_tec_id_datos_tec_seq OWNED BY tgv_datos_tec.id_datos_tec;


--
-- TOC entry 284 (class 1259 OID 208940)
-- Dependencies: 5678 5679 5680 203 12
-- Name: tgv_evento; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_evento (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_evento integer NOT NULL,
    id_tipo_evento integer NOT NULL,
    nombre character varying(100) NOT NULL,
    descripcion character varying(500) NOT NULL
)
INHERITS (public.tbase);


--
-- TOC entry 285 (class 1259 OID 208949)
-- Dependencies: 284 12
-- Name: tgv_evento_id_evento_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_evento_id_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7135 (class 0 OID 0)
-- Dependencies: 285
-- Name: tgv_evento_id_evento_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_evento_id_evento_seq OWNED BY tgv_evento.id_evento;


--
-- TOC entry 286 (class 1259 OID 208951)
-- Dependencies: 12 284
-- Name: tgv_evento_id_tipo_evento_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_evento_id_tipo_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7136 (class 0 OID 0)
-- Dependencies: 286
-- Name: tgv_evento_id_tipo_evento_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_evento_id_tipo_evento_seq OWNED BY tgv_evento.id_tipo_evento;


SET default_with_oids = false;

--
-- TOC entry 287 (class 1259 OID 208953)
-- Dependencies: 5683 5684 5685 203 12
-- Name: tgv_iboton; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_iboton (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_iboton integer NOT NULL,
    codigo character varying(50) NOT NULL,
    id_funcionario integer NOT NULL
)
INHERITS (public.tbase);


--
-- TOC entry 288 (class 1259 OID 208959)
-- Dependencies: 12 287
-- Name: tgv_iboton_id_iboton_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_iboton_id_iboton_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7137 (class 0 OID 0)
-- Dependencies: 288
-- Name: tgv_iboton_id_iboton_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_iboton_id_iboton_seq OWNED BY tgv_iboton.id_iboton;


SET default_with_oids = true;

--
-- TOC entry 289 (class 1259 OID 208961)
-- Dependencies: 5687 5688 5689 203 12
-- Name: tgv_mantenimiento; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_mantenimiento (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_mantenimiento integer NOT NULL,
    id_proveedor integer NOT NULL,
    fecha_ini date NOT NULL,
    fecha_fin date NOT NULL,
    descripcion character varying(2000) NOT NULL,
    id_funcionario integer NOT NULL,
    id_tipo_evento integer NOT NULL
)
INHERITS (public.tbase);


--
-- TOC entry 290 (class 1259 OID 208970)
-- Dependencies: 5691 5692 5693 5694 5696 12 203
-- Name: tgv_mantenimiento_det; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_mantenimiento_det (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_mantenimiento_det integer NOT NULL,
    id_mantenimiento integer NOT NULL,
    id_activo_fijo integer NOT NULL,
    id_evento integer NOT NULL,
    descripcion character varying(1000) NOT NULL,
    estado character varying(15) DEFAULT 'pendiente'::character varying NOT NULL,
    CONSTRAINT chk_tgv_mantenimiento_det__estado CHECK (((estado)::text = ANY (ARRAY[('pendiente'::character varying)::text, ('concluido'::character varying)::text])))
)
INHERITS (public.tbase);


--
-- TOC entry 291 (class 1259 OID 208981)
-- Dependencies: 12
-- Name: tgv_mantenimiento_det_id_activo_fijo_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_mantenimiento_det_id_activo_fijo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 292 (class 1259 OID 208983)
-- Dependencies: 12
-- Name: tgv_mantenimiento_det_id_evento_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_mantenimiento_det_id_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 293 (class 1259 OID 208985)
-- Dependencies: 12 290
-- Name: tgv_mantenimiento_det_id_mantenimiento_det_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_mantenimiento_det_id_mantenimiento_det_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7138 (class 0 OID 0)
-- Dependencies: 293
-- Name: tgv_mantenimiento_det_id_mantenimiento_det_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_mantenimiento_det_id_mantenimiento_det_seq OWNED BY tgv_mantenimiento_det.id_mantenimiento_det;


--
-- TOC entry 294 (class 1259 OID 208987)
-- Dependencies: 12
-- Name: tgv_mantenimiento_det_id_mantenimiento_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_mantenimiento_det_id_mantenimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 295 (class 1259 OID 208989)
-- Dependencies: 12 289
-- Name: tgv_mantenimiento_id_mantenimiento_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_mantenimiento_id_mantenimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7139 (class 0 OID 0)
-- Dependencies: 295
-- Name: tgv_mantenimiento_id_mantenimiento_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_mantenimiento_id_mantenimiento_seq OWNED BY tgv_mantenimiento.id_mantenimiento;


--
-- TOC entry 296 (class 1259 OID 208991)
-- Dependencies: 12
-- Name: tgv_mantenimiento_id_movimiento_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_mantenimiento_id_movimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 297 (class 1259 OID 208993)
-- Dependencies: 12
-- Name: tgv_mantenimiento_id_proveedor_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_mantenimiento_id_proveedor_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 298 (class 1259 OID 208995)
-- Dependencies: 5697 5698 5699 12 203
-- Name: tgv_marca; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_marca (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_marca integer NOT NULL,
    marca character varying(80),
    procedencia character varying(100)
)
INHERITS (public.tbase);


--
-- TOC entry 299 (class 1259 OID 209001)
-- Dependencies: 12 298
-- Name: tgv_marca_id_marca_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_marca_id_marca_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7140 (class 0 OID 0)
-- Dependencies: 299
-- Name: tgv_marca_id_marca_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_marca_id_marca_seq OWNED BY tgv_marca.id_marca;


--
-- TOC entry 300 (class 1259 OID 209003)
-- Dependencies: 5701 5702 5703 12 203
-- Name: tgv_modelo; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_modelo (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_modelo integer NOT NULL,
    id_marca integer NOT NULL,
    modelo character varying(100),
    anio integer,
    descripcion character varying(500)
)
INHERITS (public.tbase);


--
-- TOC entry 301 (class 1259 OID 209012)
-- Dependencies: 12 300
-- Name: tgv_modelo_id_modelo_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_modelo_id_modelo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7141 (class 0 OID 0)
-- Dependencies: 301
-- Name: tgv_modelo_id_modelo_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_modelo_id_modelo_seq OWNED BY tgv_modelo.id_modelo;


--
-- TOC entry 302 (class 1259 OID 209014)
-- Dependencies: 5705 5706 5707 12 203
-- Name: tgv_servicio; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_servicio (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_servicio integer NOT NULL,
    id_lugar_origen integer NOT NULL,
    id_lugar_destino integer NOT NULL,
    estado character varying(10) NOT NULL,
    descripcion character varying(1000) NOT NULL,
    cant_personas integer NOT NULL,
    fecha_sol_ini date NOT NULL,
    fecha_sol_fin date NOT NULL,
    id_ep integer,
    fecha_asig_ini date,
    fecha_asig_fin date,
    id_funcionario integer,
    id_funcionario_autoriz integer NOT NULL,
    observaciones character varying(2000)
)
INHERITS (public.tbase);


--
-- TOC entry 303 (class 1259 OID 209023)
-- Dependencies: 5709 5710 5711 12 203
-- Name: tgv_servicio_det; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_servicio_det (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_servicio_det integer NOT NULL,
    id_activo_fijo integer NOT NULL,
    id_funcionario integer NOT NULL,
    id_servicio integer NOT NULL,
    kilometraje_ini numeric(18,2) NOT NULL,
    kilometraje_fin numeric(18,2) NOT NULL
)
INHERITS (public.tbase);


--
-- TOC entry 304 (class 1259 OID 209029)
-- Dependencies: 5713 5714 5715 12 203
-- Name: tgv_servicio_det_evento; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_servicio_det_evento (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_servicio_det_evento integer NOT NULL,
    id_evento integer NOT NULL,
    id_servicio_det integer NOT NULL,
    descripcion character varying(1000) NOT NULL
)
INHERITS (public.tbase);


--
-- TOC entry 305 (class 1259 OID 209038)
-- Dependencies: 12
-- Name: tgv_servicio_det_evento_id_evento_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_servicio_det_evento_id_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 306 (class 1259 OID 209040)
-- Dependencies: 12
-- Name: tgv_servicio_det_evento_id_servicio_det_event_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_servicio_det_evento_id_servicio_det_event_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 307 (class 1259 OID 209042)
-- Dependencies: 12 304
-- Name: tgv_servicio_det_evento_id_servicio_det_evento_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_servicio_det_evento_id_servicio_det_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7142 (class 0 OID 0)
-- Dependencies: 307
-- Name: tgv_servicio_det_evento_id_servicio_det_evento_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_servicio_det_evento_id_servicio_det_evento_seq OWNED BY tgv_servicio_det_evento.id_servicio_det_evento;


--
-- TOC entry 308 (class 1259 OID 209044)
-- Dependencies: 12
-- Name: tgv_servicio_det_evento_id_servicio_det_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_servicio_det_evento_id_servicio_det_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 309 (class 1259 OID 209046)
-- Dependencies: 12
-- Name: tgv_servicio_det_id_activo_fijo_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_servicio_det_id_activo_fijo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 310 (class 1259 OID 209048)
-- Dependencies: 12
-- Name: tgv_servicio_det_id_empleado_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_servicio_det_id_empleado_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 311 (class 1259 OID 209050)
-- Dependencies: 12 303
-- Name: tgv_servicio_det_id_servicio_det_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_servicio_det_id_servicio_det_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7143 (class 0 OID 0)
-- Dependencies: 311
-- Name: tgv_servicio_det_id_servicio_det_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_servicio_det_id_servicio_det_seq OWNED BY tgv_servicio_det.id_servicio_det;


--
-- TOC entry 312 (class 1259 OID 209052)
-- Dependencies: 12
-- Name: tgv_servicio_det_id_servicio_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_servicio_det_id_servicio_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 313 (class 1259 OID 209054)
-- Dependencies: 12 302
-- Name: tgv_servicio_id_servicio_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_servicio_id_servicio_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7144 (class 0 OID 0)
-- Dependencies: 313
-- Name: tgv_servicio_id_servicio_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_servicio_id_servicio_seq OWNED BY tgv_servicio.id_servicio;


--
-- TOC entry 314 (class 1259 OID 209056)
-- Dependencies: 5717 5718 5719 12 203
-- Name: tgv_tipo_evento; Type: TABLE; Schema: gev; Owner: -; Tablespace: 
--

CREATE TABLE tgv_tipo_evento (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_tipo_evento integer NOT NULL,
    codigo character varying(10),
    nombre character varying(50)
)
INHERITS (public.tbase);


--
-- TOC entry 315 (class 1259 OID 209062)
-- Dependencies: 12 314
-- Name: tgv_tipo_evento_id_tipo_evento_seq; Type: SEQUENCE; Schema: gev; Owner: -
--

CREATE SEQUENCE tgv_tipo_evento_id_tipo_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7145 (class 0 OID 0)
-- Dependencies: 315
-- Name: tgv_tipo_evento_id_tipo_evento_seq; Type: SEQUENCE OWNED BY; Schema: gev; Owner: -
--

ALTER SEQUENCE tgv_tipo_evento_id_tipo_evento_seq OWNED BY tgv_tipo_evento.id_tipo_evento;


SET search_path = segu, pg_catalog;

SET default_with_oids = false;

--
-- TOC entry 316 (class 1259 OID 209064)
-- Dependencies: 5721 5722 5723 5724 2182 20
-- Name: tusuario; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tusuario (
    id_usuario integer DEFAULT nextval(('"segu"."usuario_id_usuario_seq"'::text)::regclass) NOT NULL,
    id_clasificador integer,
    cuenta character varying(100) NOT NULL,
    contrasena character varying(100) NOT NULL,
    fecha_caducidad date,
    fecha_reg date DEFAULT now() NOT NULL,
    estilo character varying(100),
    contrasena_anterior character varying(100),
    id_persona integer NOT NULL,
    estado_reg public.estado_reg DEFAULT 'activo'::public.estado_reg,
    autentificacion character varying(20) DEFAULT 'local'::character varying
);


SET search_path = gev, pg_catalog;

--
-- TOC entry 317 (class 1259 OID 209071)
-- Dependencies: 5486 12
-- Name: vgv_activo_datos_tec; Type: VIEW; Schema: gev; Owner: -
--

CREATE VIEW vgv_activo_datos_tec AS
    SELECT vehic.id_activo_datos_tec, vehic.rend_litro_km, vehic.fecha_ult_km, vehic.estado_reg, vehic.id_activo_fijo, vehic.chasis, vehic.num_motor, vehic.ult_kilometraje, vehic.placa, vehic.cilindrada_cc, vehic.modem_id, vehic.soat, vehic.id_modelo, vehic.id_usuario_reg, vehic.fecha_reg, vehic.id_usuario_mod, vehic.fecha_mod, usu1.cuenta AS usr_reg, usu2.cuenta AS usr_mod, ((((actif.codigo)::text || ' - '::text) || (actif.descripcion)::text))::character varying AS desc_activo_fijo, model.modelo, marca.marca, marca.id_marca FROM (((((tgv_activo_datos_tec vehic JOIN actif.taf_activo_fijo actif ON ((actif.id_activo_fijo = vehic.id_activo_fijo))) JOIN tgv_modelo model ON ((model.id_modelo = vehic.id_modelo))) JOIN tgv_marca marca ON ((marca.id_marca = model.id_marca))) JOIN segu.tusuario usu1 ON ((usu1.id_usuario = vehic.id_usuario_reg))) LEFT JOIN segu.tusuario usu2 ON ((usu2.id_usuario = vehic.id_usuario_mod)));


SET search_path = hidro, pg_catalog;

--
-- TOC entry 318 (class 1259 OID 209076)
-- Dependencies: 13 203
-- Name: thd_administrador_hidro; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_administrador_hidro (
    id_administrador integer NOT NULL,
    codigo character varying(24) NOT NULL,
    nombre character varying NOT NULL,
    meteo boolean,
    hidro boolean
)
INHERITS (public.tbase);


--
-- TOC entry 319 (class 1259 OID 209085)
-- Dependencies: 318 13
-- Name: thd_administrador_hidro_id_administrador_hidro_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_administrador_hidro_id_administrador_hidro_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7146 (class 0 OID 0)
-- Dependencies: 319
-- Name: thd_administrador_hidro_id_administrador_hidro_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_administrador_hidro_id_administrador_hidro_seq OWNED BY thd_administrador_hidro.id_administrador;


--
-- TOC entry 320 (class 1259 OID 209087)
-- Dependencies: 5729 13 203
-- Name: thd_archivo; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_archivo (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT NULL,
    fecha_mod timestamp without time zone DEFAULT NULL,
    estado_reg character varying(10) DEFAULT NULL::character varying,
    id_archivo integer NOT NULL,
    id_operador integer NOT NULL,
    id_tipo_archivo integer NOT NULL,
    fecha date,
    nombre_archivo_real character varying(250),
    obs text,
    archivo_temp bytea
)
INHERITS (public.tbase);


--
-- TOC entry 321 (class 1259 OID 209094)
-- Dependencies: 13 320
-- Name: thd_archivo_id_archivo_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_archivo_id_archivo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7147 (class 0 OID 0)
-- Dependencies: 321
-- Name: thd_archivo_id_archivo_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_archivo_id_archivo_seq OWNED BY thd_archivo.id_archivo;


--
-- TOC entry 322 (class 1259 OID 209096)
-- Dependencies: 5731 203 13
-- Name: thd_archivo_sensor; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_archivo_sensor (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT NULL,
    fecha_mod timestamp without time zone DEFAULT NULL,
    estado_reg character varying(10) DEFAULT NULL::character varying,
    id_archivo_sensor integer NOT NULL,
    id_tipo_archivo integer NOT NULL,
    id_sensor integer NOT NULL,
    orden integer,
    nombre_col_file character varying(50),
    orden_col_fecha integer,
    nombre_col_fecha character varying(50),
    orden_col_hora integer,
    nombre_col_hora character varying(50)
)
INHERITS (public.tbase);


--
-- TOC entry 323 (class 1259 OID 209100)
-- Dependencies: 322 13
-- Name: thd_archivo_sensor_id_archivo_sensor_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_archivo_sensor_id_archivo_sensor_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7148 (class 0 OID 0)
-- Dependencies: 323
-- Name: thd_archivo_sensor_id_archivo_sensor_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_archivo_sensor_id_archivo_sensor_seq OWNED BY thd_archivo_sensor.id_archivo_sensor;


--
-- TOC entry 324 (class 1259 OID 209102)
-- Dependencies: 322 13
-- Name: thd_archivo_sensor_id_sensor_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_archivo_sensor_id_sensor_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7149 (class 0 OID 0)
-- Dependencies: 324
-- Name: thd_archivo_sensor_id_sensor_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_archivo_sensor_id_sensor_seq OWNED BY thd_archivo_sensor.id_sensor;


SET default_with_oids = true;

--
-- TOC entry 325 (class 1259 OID 209104)
-- Dependencies: 5736 13 203
-- Name: thd_cuenca; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_cuenca (
    id_cuenca integer DEFAULT nextval(('hidro.thd_cuenca_id_cuenca_seq'::text)::regclass) NOT NULL,
    id_cuenca_fk integer,
    tipo_cuenca character varying(255),
    nombre character varying(255),
    codigo character varying(255),
    codigo_largo character varying(255)
)
INHERITS (public.tbase);
ALTER TABLE ONLY thd_cuenca ALTER COLUMN id_cuenca SET STATISTICS 0;
ALTER TABLE ONLY thd_cuenca ALTER COLUMN id_cuenca_fk SET STATISTICS 0;
ALTER TABLE ONLY thd_cuenca ALTER COLUMN tipo_cuenca SET STATISTICS 0;
ALTER TABLE ONLY thd_cuenca ALTER COLUMN nombre SET STATISTICS 0;


--
-- TOC entry 326 (class 1259 OID 209114)
-- Dependencies: 13
-- Name: thd_cuenca_id_cuenca_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_cuenca_id_cuenca_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


SET default_with_oids = false;

--
-- TOC entry 327 (class 1259 OID 209116)
-- Dependencies: 5740 13 203
-- Name: thd_estacion; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_estacion (
    id_estacion integer DEFAULT nextval(('hidro.thd_estacion_id_estacion_seq'::text)::regclass) NOT NULL,
    codigo character varying(255),
    tipo character varying(255),
    id_cuenca integer NOT NULL,
    id_lugar integer NOT NULL,
    id_rio integer NOT NULL,
    fecha_ini timestamp(0) without time zone,
    fecha_fin timestamp(0) without time zone,
    latitud numeric,
    longitud numeric,
    altitud numeric,
    comentario character varying(10),
    id_administrador integer NOT NULL,
    superficie_cuenca integer,
    estado character varying(255),
    observador character varying(255),
    direccion character varying(10),
    teletransmision boolean,
    latitud_carto text,
    longitud_carto text,
    foto bytea,
    extension character varying(4)
)
INHERITS (public.tbase);


--
-- TOC entry 328 (class 1259 OID 209126)
-- Dependencies: 13
-- Name: thd_estacion_id_estacion_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_estacion_id_estacion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 329 (class 1259 OID 209128)
-- Dependencies: 13
-- Name: thd_estacion_proyecto; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_estacion_proyecto (
    id_estacion_proyecto integer NOT NULL,
    id_proyecto integer,
    id_estacion integer
);


--
-- TOC entry 330 (class 1259 OID 209131)
-- Dependencies: 13 329
-- Name: thd_estacion_proyecto_id_estacion_proyecto_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_estacion_proyecto_id_estacion_proyecto_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7150 (class 0 OID 0)
-- Dependencies: 330
-- Name: thd_estacion_proyecto_id_estacion_proyecto_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_estacion_proyecto_id_estacion_proyecto_seq OWNED BY thd_estacion_proyecto.id_estacion_proyecto;


--
-- TOC entry 331 (class 1259 OID 209133)
-- Dependencies: 13 203
-- Name: thd_medicion; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_medicion (
    id_medicion integer NOT NULL,
    id_sensor integer NOT NULL,
    id_operador integer,
    h integer,
    q integer,
    fecha_medida date,
    fecha_fin date,
    h_ini numeric(20,2),
    h_fin numeric(20,2),
    h_mini numeric(20,2),
    h_maxi numeric(20,2),
    h_original numeric(20,2),
    q_original numeric(20,2),
    hora_medida time without time zone,
    valor_numeric numeric(20,4),
    valor_varchar character varying(255),
    id_archivo integer
)
INHERITS (public.tbase);
ALTER TABLE ONLY thd_medicion ALTER COLUMN id_medicion SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN id_sensor SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN id_operador SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN h SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN q SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN fecha_medida SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN fecha_fin SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN h_ini SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN h_fin SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN h_mini SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN h_maxi SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN h_original SET STATISTICS 0;
ALTER TABLE ONLY thd_medicion ALTER COLUMN q_original SET STATISTICS 0;


--
-- TOC entry 332 (class 1259 OID 209139)
-- Dependencies: 13 331
-- Name: thd_medicion_id_medicion_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_medicion_id_medicion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7151 (class 0 OID 0)
-- Dependencies: 332
-- Name: thd_medicion_id_medicion_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_medicion_id_medicion_seq OWNED BY thd_medicion.id_medicion;


--
-- TOC entry 333 (class 1259 OID 209141)
-- Dependencies: 5749 13 203
-- Name: thd_operador; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_operador (
    id_operador integer DEFAULT nextval(('hidro.thd_operador_id_operador_seq'::text)::regclass) NOT NULL,
    id_persona integer NOT NULL,
    id_proyecto integer NOT NULL,
    fecha_presentacion date,
    codigo character varying(20)
)
INHERITS (public.tbase);


--
-- TOC entry 334 (class 1259 OID 209148)
-- Dependencies: 13
-- Name: thd_operador_id_operador_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_operador_id_operador_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 335 (class 1259 OID 209150)
-- Dependencies: 13 203
-- Name: thd_rio; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_rio (
    id_rio integer NOT NULL,
    codigo character varying(15) NOT NULL,
    nombre character varying(255) NOT NULL
)
INHERITS (public.tbase);


--
-- TOC entry 336 (class 1259 OID 209156)
-- Dependencies: 13 335
-- Name: thd_rio_id_rio_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_rio_id_rio_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7152 (class 0 OID 0)
-- Dependencies: 336
-- Name: thd_rio_id_rio_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_rio_id_rio_seq OWNED BY thd_rio.id_rio;


--
-- TOC entry 337 (class 1259 OID 209158)
-- Dependencies: 5758 13 203
-- Name: thd_sensor; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_sensor (
    id_sensor integer NOT NULL,
    id_estacion integer NOT NULL,
    fecha_ini date,
    fecha_fin date,
    ficticio boolean,
    estado character varying(20),
    id_tipo_sensor integer NOT NULL,
    id_tipo_muestra integer,
    codigo character varying(20),
    id_sensor_fk integer,
    CONSTRAINT thd_sensor_estado_chk CHECK ((((estado)::text = 'borrador'::text) OR ((estado)::text = 'validado'::text)))
)
INHERITS (public.tbase);
ALTER TABLE ONLY thd_sensor ALTER COLUMN id_sensor SET STATISTICS 0;
ALTER TABLE ONLY thd_sensor ALTER COLUMN id_estacion SET STATISTICS 0;
ALTER TABLE ONLY thd_sensor ALTER COLUMN fecha_ini SET STATISTICS 0;
ALTER TABLE ONLY thd_sensor ALTER COLUMN fecha_fin SET STATISTICS 0;
ALTER TABLE ONLY thd_sensor ALTER COLUMN ficticio SET STATISTICS 0;
ALTER TABLE ONLY thd_sensor ALTER COLUMN estado SET STATISTICS 0;


--
-- TOC entry 338 (class 1259 OID 209165)
-- Dependencies: 13 337
-- Name: thd_sensores_id_sensor_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_sensores_id_sensor_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7153 (class 0 OID 0)
-- Dependencies: 338
-- Name: thd_sensores_id_sensor_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_sensores_id_sensor_seq OWNED BY thd_sensor.id_sensor;


--
-- TOC entry 339 (class 1259 OID 209167)
-- Dependencies: 5759 13 203
-- Name: thd_tipo_archivo; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_tipo_archivo (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT NULL,
    fecha_mod timestamp without time zone DEFAULT NULL,
    estado_reg character varying(10) DEFAULT NULL::character varying,
    id_tipo_archivo integer NOT NULL,
    id_estacion integer NOT NULL,
    fecha_ini date,
    fecha_fin date,
    periodo character varying(40),
    patron_nombre_archivo character varying(500),
    num_file_ini integer
)
INHERITS (public.tbase);


--
-- TOC entry 340 (class 1259 OID 209174)
-- Dependencies: 339 13
-- Name: thd_tipo_archivo_id_tipo_archivo_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_tipo_archivo_id_tipo_archivo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7154 (class 0 OID 0)
-- Dependencies: 340
-- Name: thd_tipo_archivo_id_tipo_archivo_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_tipo_archivo_id_tipo_archivo_seq OWNED BY thd_tipo_archivo.id_tipo_archivo;


--
-- TOC entry 341 (class 1259 OID 209176)
-- Dependencies: 13 203
-- Name: thd_tipo_columna; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_tipo_columna (
    id_tipo_columna integer NOT NULL,
    codigo character varying(20) NOT NULL,
    tipo_dato character varying(50),
    tipo_columna character varying(50) NOT NULL,
    nombre_columna character varying(255)
)
INHERITS (public.tbase);


--
-- TOC entry 342 (class 1259 OID 209182)
-- Dependencies: 13 341
-- Name: thd_tipo_columna_id_tipo_columna_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_tipo_columna_id_tipo_columna_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7155 (class 0 OID 0)
-- Dependencies: 342
-- Name: thd_tipo_columna_id_tipo_columna_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_tipo_columna_id_tipo_columna_seq OWNED BY thd_tipo_columna.id_tipo_columna;


--
-- TOC entry 343 (class 1259 OID 209184)
-- Dependencies: 5768 13 203
-- Name: thd_tipo_columna_sensor; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_tipo_columna_sensor (
    id_tipo_columna_sensor integer NOT NULL,
    id_tipo_sensor integer NOT NULL,
    orden numeric,
    prioridad numeric,
    unidad_medida character varying(30),
    codigo_columna character varying(25) NOT NULL,
    nombre_columna character varying(200) NOT NULL,
    tipo_dato character varying(30) DEFAULT 'varchar'::character varying NOT NULL,
    mapeo_archivo character varying(400)
)
INHERITS (public.tbase);


--
-- TOC entry 344 (class 1259 OID 209194)
-- Dependencies: 13 343
-- Name: thd_tipo_columna_sensor_id_tipo_sensor_columna_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_tipo_columna_sensor_id_tipo_sensor_columna_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7156 (class 0 OID 0)
-- Dependencies: 344
-- Name: thd_tipo_columna_sensor_id_tipo_sensor_columna_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_tipo_columna_sensor_id_tipo_sensor_columna_seq OWNED BY thd_tipo_columna_sensor.id_tipo_columna_sensor;


--
-- TOC entry 345 (class 1259 OID 209196)
-- Dependencies: 13 203
-- Name: thd_tipo_dato; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_tipo_dato (
    id_tipo_dato integer NOT NULL,
    tipo_dato character varying(250) NOT NULL
)
INHERITS (public.tbase);


--
-- TOC entry 346 (class 1259 OID 209202)
-- Dependencies: 13 345
-- Name: thd_tipo_dato_id_tipo_dato_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_tipo_dato_id_tipo_dato_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7157 (class 0 OID 0)
-- Dependencies: 346
-- Name: thd_tipo_dato_id_tipo_dato_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_tipo_dato_id_tipo_dato_seq OWNED BY thd_tipo_dato.id_tipo_dato;


--
-- TOC entry 347 (class 1259 OID 209204)
-- Dependencies: 5777 2179 13 203
-- Name: thd_tipo_sensor; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_tipo_sensor (
    id_tipo_sensor integer NOT NULL,
    nombre_sensor character varying(255),
    descrip text,
    tipo_dato public.enum_tipo_dato,
    equivalente_hidra character varying(50),
    abreviacion character varying(20),
    codigo character varying(50) NOT NULL,
    estado_ts character varying(25) DEFAULT 'borrador'::character varying
)
INHERITS (public.tbase);


--
-- TOC entry 348 (class 1259 OID 209214)
-- Dependencies: 13 347
-- Name: thd_tipo_medicion_id_tipo_medicion_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_tipo_medicion_id_tipo_medicion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7158 (class 0 OID 0)
-- Dependencies: 348
-- Name: thd_tipo_medicion_id_tipo_medicion_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_tipo_medicion_id_tipo_medicion_seq OWNED BY thd_tipo_sensor.id_tipo_sensor;


--
-- TOC entry 349 (class 1259 OID 209216)
-- Dependencies: 13
-- Name: thd_tipo_muestra; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_tipo_muestra (
    id_tipo_muestra integer NOT NULL,
    nombre character varying(100),
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    estado_reg character varying(10)
);


--
-- TOC entry 350 (class 1259 OID 209219)
-- Dependencies: 349 13
-- Name: thd_tipo_muestra_id_tipo_muestra_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_tipo_muestra_id_tipo_muestra_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7159 (class 0 OID 0)
-- Dependencies: 350
-- Name: thd_tipo_muestra_id_tipo_muestra_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_tipo_muestra_id_tipo_muestra_seq OWNED BY thd_tipo_muestra.id_tipo_muestra;


--
-- TOC entry 351 (class 1259 OID 209221)
-- Dependencies: 13 203
-- Name: thd_tipo_sensor_22; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_22 (
    id_tipo_sensor_22 integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    aaaaa numeric,
    bbbbbbb character varying,
    cccccccccc timestamp without time zone,
    dddd character varying,
    fffffffffff character varying
)
INHERITS (public.tbase);


--
-- TOC entry 352 (class 1259 OID 209230)
-- Dependencies: 13 351
-- Name: thd_tipo_sensor_22_id_tipo_sensor_22_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_tipo_sensor_22_id_tipo_sensor_22_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7160 (class 0 OID 0)
-- Dependencies: 352
-- Name: thd_tipo_sensor_22_id_tipo_sensor_22_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_tipo_sensor_22_id_tipo_sensor_22_seq OWNED BY thd_tipo_sensor_22.id_tipo_sensor_22;


--
-- TOC entry 353 (class 1259 OID 209232)
-- Dependencies: 203 13
-- Name: thd_tipo_sensor_33; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_33 (
    id_tipo_sensor_33 integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    lectura numeric,
    lectura_pro numeric,
    fecha_lec timestamp without time zone,
    aaaaaaa character varying
)
INHERITS (public.tbase);


--
-- TOC entry 354 (class 1259 OID 209241)
-- Dependencies: 13 353
-- Name: thd_tipo_sensor_33_id_tipo_sensor_33_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_tipo_sensor_33_id_tipo_sensor_33_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7161 (class 0 OID 0)
-- Dependencies: 354
-- Name: thd_tipo_sensor_33_id_tipo_sensor_33_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_tipo_sensor_33_id_tipo_sensor_33_seq OWNED BY thd_tipo_sensor_33.id_tipo_sensor_33;


--
-- TOC entry 355 (class 1259 OID 209243)
-- Dependencies: 13 203
-- Name: thd_tipo_sensor_44; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_44 (
    id_tipo_sensor_44 integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    lectura_c numeric,
    lectura_2 character varying,
    lectura_3 timestamp without time zone
)
INHERITS (public.tbase);


--
-- TOC entry 356 (class 1259 OID 209252)
-- Dependencies: 355 13
-- Name: thd_tipo_sensor_44_id_tipo_sensor_44_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_tipo_sensor_44_id_tipo_sensor_44_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7162 (class 0 OID 0)
-- Dependencies: 356
-- Name: thd_tipo_sensor_44_id_tipo_sensor_44_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_tipo_sensor_44_id_tipo_sensor_44_seq OWNED BY thd_tipo_sensor_44.id_tipo_sensor_44;


--
-- TOC entry 357 (class 1259 OID 209254)
-- Dependencies: 203 13
-- Name: thd_tipo_sensor_anemometro; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_anemometro (
    id_tipo_sensor_anemometro integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    hora time without time zone,
    wind_v_hr_max numeric,
    cur_temp numeric,
    precip_hr_acu numeric,
    total_hrs_rad numeric,
    rad_hr_avg numeric,
    min_hr_temp numeric,
    max_hr_temp numeric,
    ob_time timestamp without time zone,
    press_hr_avg numeric,
    wind_u_10_avg numeric,
    wind_u_10_max numeric,
    wind_u_hr_max numeric,
    wind_v_10_avg numeric,
    wind_v_10_max numeric,
    wind_v_hr_avg numeric
)
INHERITS (public.tbase);


--
-- TOC entry 358 (class 1259 OID 209263)
-- Dependencies: 13 357
-- Name: thd_tipo_sensor_anemometro_id_tipo_sensor_anemometro_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_tipo_sensor_anemometro_id_tipo_sensor_anemometro_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7163 (class 0 OID 0)
-- Dependencies: 358
-- Name: thd_tipo_sensor_anemometro_id_tipo_sensor_anemometro_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_tipo_sensor_anemometro_id_tipo_sensor_anemometro_seq OWNED BY thd_tipo_sensor_anemometro.id_tipo_sensor_anemometro;


--
-- TOC entry 359 (class 1259 OID 209265)
-- Dependencies: 203 13
-- Name: thd_tipo_sensor_caudal; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_caudal (
    id_tipo_sensor_caudal integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    fecha timestamp without time zone,
    lectura_instantania numeric,
    caudal numeric,
    tipo character varying
)
INHERITS (public.tbase);


--
-- TOC entry 360 (class 1259 OID 209274)
-- Dependencies: 13 359
-- Name: thd_tipo_sensor_caudal_id_tipo_sensor_caudal_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_tipo_sensor_caudal_id_tipo_sensor_caudal_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7164 (class 0 OID 0)
-- Dependencies: 360
-- Name: thd_tipo_sensor_caudal_id_tipo_sensor_caudal_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_tipo_sensor_caudal_id_tipo_sensor_caudal_seq OWNED BY thd_tipo_sensor_caudal.id_tipo_sensor_caudal;


--
-- TOC entry 361 (class 1259 OID 209276)
-- Dependencies: 203 13
-- Name: thd_tipo_sensor_limnimetrica; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_limnimetrica (
    id_tipo_sensor_limnimetrica integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    lectura numeric,
    fecha timestamp without time zone
)
INHERITS (public.tbase);


--
-- TOC entry 362 (class 1259 OID 209285)
-- Dependencies: 13 361
-- Name: thd_tipo_sensor_limnimetrica_id_tipo_sensor_limnimetrica_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_tipo_sensor_limnimetrica_id_tipo_sensor_limnimetrica_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7165 (class 0 OID 0)
-- Dependencies: 362
-- Name: thd_tipo_sensor_limnimetrica_id_tipo_sensor_limnimetrica_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_tipo_sensor_limnimetrica_id_tipo_sensor_limnimetrica_seq OWNED BY thd_tipo_sensor_limnimetrica.id_tipo_sensor_limnimetrica;


--
-- TOC entry 363 (class 1259 OID 209287)
-- Dependencies: 13 203
-- Name: thd_tipo_sensor_presion; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_presion (
    id_tipo_sensor_presion integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    fecha_medida numeric,
    hora_medida timestamp without time zone,
    valor_medida numeric,
    operador character varying
)
INHERITS (public.tbase);


--
-- TOC entry 364 (class 1259 OID 209296)
-- Dependencies: 13 363
-- Name: thd_tipo_sensor_presion_id_tipo_sensor_presion_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_tipo_sensor_presion_id_tipo_sensor_presion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7166 (class 0 OID 0)
-- Dependencies: 364
-- Name: thd_tipo_sensor_presion_id_tipo_sensor_presion_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_tipo_sensor_presion_id_tipo_sensor_presion_seq OWNED BY thd_tipo_sensor_presion.id_tipo_sensor_presion;


--
-- TOC entry 365 (class 1259 OID 209298)
-- Dependencies: 13 203
-- Name: thd_tipo_sensor_pru; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_pru (
    id_tipo_sensor_pru integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    fecha2 timestamp without time zone,
    lectura numeric,
    fecha1 timestamp without time zone
)
INHERITS (public.tbase);


--
-- TOC entry 366 (class 1259 OID 209307)
-- Dependencies: 13 365
-- Name: thd_tipo_sensor_pru_id_tipo_sensor_pru_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_tipo_sensor_pru_id_tipo_sensor_pru_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7167 (class 0 OID 0)
-- Dependencies: 366
-- Name: thd_tipo_sensor_pru_id_tipo_sensor_pru_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_tipo_sensor_pru_id_tipo_sensor_pru_seq OWNED BY thd_tipo_sensor_pru.id_tipo_sensor_pru;


--
-- TOC entry 367 (class 1259 OID 209309)
-- Dependencies: 13 203
-- Name: thd_tipo_sensor_prue; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_prue (
    id_tipo_sensor_prue integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    fecha timestamp without time zone,
    lectura numeric
)
INHERITS (public.tbase);


--
-- TOC entry 368 (class 1259 OID 209318)
-- Dependencies: 13 367
-- Name: thd_tipo_sensor_prue_id_tipo_sensor_prue_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_tipo_sensor_prue_id_tipo_sensor_prue_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7168 (class 0 OID 0)
-- Dependencies: 368
-- Name: thd_tipo_sensor_prue_id_tipo_sensor_prue_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_tipo_sensor_prue_id_tipo_sensor_prue_seq OWNED BY thd_tipo_sensor_prue.id_tipo_sensor_prue;


--
-- TOC entry 369 (class 1259 OID 209320)
-- Dependencies: 203 13
-- Name: thd_tipo_sensor_termo; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_tipo_sensor_termo (
    id_tipo_sensor_termo integer NOT NULL,
    id_tipo_sensor integer,
    id_sensor integer,
    fecha1 timestamp without time zone,
    fecha2 timestamp without time zone,
    fecha3 timestamp without time zone,
    lecturas numeric
)
INHERITS (public.tbase);


--
-- TOC entry 370 (class 1259 OID 209329)
-- Dependencies: 369 13
-- Name: thd_tipo_sensor_termo_id_tipo_sensor_termo_seq; Type: SEQUENCE; Schema: hidro; Owner: -
--

CREATE SEQUENCE thd_tipo_sensor_termo_id_tipo_sensor_termo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7169 (class 0 OID 0)
-- Dependencies: 370
-- Name: thd_tipo_sensor_termo_id_tipo_sensor_termo_seq; Type: SEQUENCE OWNED BY; Schema: hidro; Owner: -
--

ALTER SEQUENCE thd_tipo_sensor_termo_id_tipo_sensor_termo_seq OWNED BY thd_tipo_sensor_termo.id_tipo_sensor_termo;


--
-- TOC entry 371 (class 1259 OID 209331)
-- Dependencies: 13 203
-- Name: thd_unidad_medida; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE thd_unidad_medida (
    unidad_medida character varying(250) NOT NULL,
    simbolo character varying(20) NOT NULL
)
INHERITS (public.tbase);


--
-- TOC entry 372 (class 1259 OID 209337)
-- Dependencies: 13
-- Name: tmp_aaaa; Type: TABLE; Schema: hidro; Owner: -; Tablespace: 
--

CREATE TABLE tmp_aaaa (
    fecha_medida date,
    valor_numeric numeric(20,4)
);


SET search_path = segu, pg_catalog;

--
-- TOC entry 373 (class 1259 OID 209340)
-- Dependencies: 5823 5824 5825 20 2216
-- Name: tlog; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tlog (
    id_log integer DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass) NOT NULL,
    id_usuario integer,
    id_subsistema integer,
    mac_maquina character varying(30),
    ip_maquina character varying(30),
    tipo_log character varying(30) NOT NULL,
    descripcion text,
    fecha_reg timestamp(0) without time zone DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL,
    procedimientos text NOT NULL,
    transaccion character varying(20),
    consulta character varying,
    tiempo_ejecucion integer,
    usuario_base character varying(100),
    codigo_error character varying,
    dia_semana integer NOT NULL,
    pid_db integer,
    pid_web integer,
    sid_web character varying(100),
    cuenta_usuario character varying,
    descripcion_transaccion text,
    codigo_subsistema character varying(30),
    si_log integer
);


SET search_path = log, pg_catalog;

--
-- TOC entry 374 (class 1259 OID 209349)
-- Dependencies: 5829 14 2216 373
-- Name: tlog_2011_02; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2011_02 (
    CONSTRAINT tlog_2011_02_fecha_reg_check CHECK (((fecha_reg >= '2011-02-01'::date) AND (fecha_reg < '2011-03-01'::date)))
)
INHERITS (segu.tlog);


--
-- TOC entry 375 (class 1259 OID 209359)
-- Dependencies: 5833 2216 373 14
-- Name: tlog_2011_04; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2011_04 (
    CONSTRAINT tlog_2011_04_fecha_reg_check CHECK (((fecha_reg >= '2011-04-01'::date) AND (fecha_reg < '2011-05-01'::date)))
)
INHERITS (segu.tlog);


--
-- TOC entry 376 (class 1259 OID 209369)
-- Dependencies: 5837 14 2216 373
-- Name: tlog_2011_05; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2011_05 (
    CONSTRAINT tlog_2011_05_fecha_reg_check CHECK (((fecha_reg >= '2011-05-01'::date) AND (fecha_reg < '2011-06-01'::date)))
)
INHERITS (segu.tlog);


--
-- TOC entry 377 (class 1259 OID 209379)
-- Dependencies: 5841 14 2216 373
-- Name: tlog_2011_06; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2011_06 (
    CONSTRAINT tlog_2011_06_fecha_reg_check CHECK (((fecha_reg >= '2011-06-01'::date) AND (fecha_reg < '2011-07-01'::date)))
)
INHERITS (segu.tlog);


--
-- TOC entry 378 (class 1259 OID 209389)
-- Dependencies: 5845 2216 14 373
-- Name: tlog_2011_07; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2011_07 (
    CONSTRAINT tlog_2011_07_fecha_reg_check CHECK (((fecha_reg >= '2011-07-01'::date) AND (fecha_reg < '2011-08-01'::date)))
)
INHERITS (segu.tlog);


--
-- TOC entry 379 (class 1259 OID 209399)
-- Dependencies: 5849 14 373 2216
-- Name: tlog_2011_08; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2011_08 (
    CONSTRAINT tlog_2011_08_fecha_reg_check CHECK (((fecha_reg >= '2011-08-01'::date) AND (fecha_reg < '2011-09-01'::date)))
)
INHERITS (segu.tlog);


--
-- TOC entry 380 (class 1259 OID 209409)
-- Dependencies: 5853 14 2216 373
-- Name: tlog_2011_09; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2011_09 (
    CONSTRAINT tlog_2011_09_fecha_reg_check CHECK (((fecha_reg >= '2011-09-01'::date) AND (fecha_reg < '2011-10-01'::date)))
)
INHERITS (segu.tlog);


--
-- TOC entry 381 (class 1259 OID 209419)
-- Dependencies: 5857 2216 14 373
-- Name: tlog_2011_10; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2011_10 (
    CONSTRAINT tlog_2011_10_fecha_reg_check CHECK (((fecha_reg >= '2011-10-01'::date) AND (fecha_reg < '2011-11-01'::date)))
)
INHERITS (segu.tlog);


--
-- TOC entry 382 (class 1259 OID 209429)
-- Dependencies: 5861 14 2216 373
-- Name: tlog_2011_11; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2011_11 (
    CONSTRAINT tlog_2011_11_fecha_reg_check CHECK (((fecha_reg >= '2011-11-01'::date) AND (fecha_reg < '2011-12-01'::date)))
)
INHERITS (segu.tlog);


--
-- TOC entry 383 (class 1259 OID 209439)
-- Dependencies: 5865 14 2216 373
-- Name: tlog_2011_12; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2011_12 (
    CONSTRAINT tlog_2011_12_fecha_reg_check CHECK (((fecha_reg >= '2011-12-01'::date) AND (fecha_reg < '2012-01-01'::date)))
)
INHERITS (segu.tlog);


--
-- TOC entry 384 (class 1259 OID 209449)
-- Dependencies: 5869 2216 14 373
-- Name: tlog_2012_01; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2012_01 (
    CONSTRAINT tlog_2012_01_fecha_reg_check CHECK (((fecha_reg >= '2012-01-01'::date) AND (fecha_reg < '2012-02-01'::date)))
)
INHERITS (segu.tlog);


--
-- TOC entry 385 (class 1259 OID 209459)
-- Dependencies: 5873 14 373 2216
-- Name: tlog_2012_02; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2012_02 (
    CONSTRAINT tlog_2012_02_fecha_reg_check CHECK (((fecha_reg >= '2012-02-01'::date) AND (fecha_reg < '2012-03-01'::date)))
)
INHERITS (segu.tlog);


--
-- TOC entry 386 (class 1259 OID 209469)
-- Dependencies: 5877 14 2216 373
-- Name: tlog_2012_03; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2012_03 (
    CONSTRAINT tlog_2012_03_fecha_reg_check CHECK (((fecha_reg >= '2012-03-01'::date) AND (fecha_reg < '2012-04-01'::date)))
)
INHERITS (segu.tlog);


--
-- TOC entry 387 (class 1259 OID 209479)
-- Dependencies: 5881 2216 14 373
-- Name: tlog_2012_04; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2012_04 (
    CONSTRAINT tlog_2012_04_fecha_reg_check CHECK (((fecha_reg >= '2012-04-01'::date) AND (fecha_reg < '2012-05-01'::date)))
)
INHERITS (segu.tlog);


--
-- TOC entry 388 (class 1259 OID 209489)
-- Dependencies: 5885 2216 373 14
-- Name: tlog_2012_05; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2012_05 (
    CONSTRAINT tlog_2012_05_fecha_reg_check CHECK (((fecha_reg >= '2012-05-01'::date) AND (fecha_reg < '2012-06-01'::date)))
)
INHERITS (segu.tlog);


--
-- TOC entry 389 (class 1259 OID 209499)
-- Dependencies: 5889 2216 14 373
-- Name: tlog_2012_06; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2012_06 (
    CONSTRAINT tlog_2012_06_fecha_reg_check CHECK (((fecha_reg >= '2012-06-01'::date) AND (fecha_reg < '2012-07-01'::date)))
)
INHERITS (segu.tlog);


--
-- TOC entry 626 (class 1259 OID 318931)
-- Dependencies: 6200 373 14 2216
-- Name: tlog_2012_08; Type: TABLE; Schema: log; Owner: -; Tablespace: 
--

CREATE TABLE tlog_2012_08 (
    CONSTRAINT tlog_2012_08_fecha_reg_check CHECK (((fecha_reg >= '2012-08-01'::date) AND (fecha_reg < '2012-09-01'::date)))
)
INHERITS (segu.tlog);


SET search_path = param, pg_catalog;

--
-- TOC entry 390 (class 1259 OID 209509)
-- Dependencies: 15 203
-- Name: table1; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE table1 (
    oid_depto integer,
    id_depto_usuario integer NOT NULL
)
INHERITS (public.tbase);


--
-- TOC entry 391 (class 1259 OID 209515)
-- Dependencies: 15 390
-- Name: table1_id_depto_usuario_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE table1_id_depto_usuario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7170 (class 0 OID 0)
-- Dependencies: 391
-- Name: table1_id_depto_usuario_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE table1_id_depto_usuario_seq OWNED BY table1.id_depto_usuario;


SET default_with_oids = true;

--
-- TOC entry 392 (class 1259 OID 209517)
-- Dependencies: 5894 5895 15
-- Name: talarma; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE talarma (
    id_alarma integer NOT NULL,
    descripcion character varying,
    acceso_directo character varying,
    fecha date,
    id_funcionario integer,
    estado_reg character varying(10),
    fecha_reg date,
    id_usuario_reg integer,
    fecha_mod date,
    id_usuario_mod integer,
    tipo character varying(50),
    obs character varying(300),
    clase character varying(150),
    parametros character varying DEFAULT '{}'::character varying NOT NULL,
    titulo character varying(200),
    sw_correo integer DEFAULT 0 NOT NULL
);


--
-- TOC entry 393 (class 1259 OID 209525)
-- Dependencies: 15 392
-- Name: talarma_id_alarma_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE talarma_id_alarma_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7171 (class 0 OID 0)
-- Dependencies: 393
-- Name: talarma_id_alarma_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE talarma_id_alarma_seq OWNED BY talarma.id_alarma;


--
-- TOC entry 394 (class 1259 OID 209527)
-- Dependencies: 15 203
-- Name: tconfig_alarma; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE tconfig_alarma (
    id_config_alarma integer NOT NULL,
    codigo character varying(50) NOT NULL,
    descripcion character varying(300),
    dias integer NOT NULL,
    id_subsistema integer NOT NULL
)
INHERITS (public.tbase);


--
-- TOC entry 395 (class 1259 OID 209533)
-- Dependencies: 15 394
-- Name: tconfig_alarma_id_config_alarma_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE tconfig_alarma_id_config_alarma_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7172 (class 0 OID 0)
-- Dependencies: 395
-- Name: tconfig_alarma_id_config_alarma_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE tconfig_alarma_id_config_alarma_seq OWNED BY tconfig_alarma.id_config_alarma;


--
-- TOC entry 396 (class 1259 OID 209535)
-- Dependencies: 15 203
-- Name: tcorrelativo; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE tcorrelativo (
    id_correlativo integer NOT NULL,
    num_actual integer NOT NULL,
    num_siguiente integer NOT NULL,
    id_periodo integer,
    id_gestion integer,
    id_documento integer,
    id_uo integer,
    id_depto integer
)
INHERITS (public.tbase);


--
-- TOC entry 397 (class 1259 OID 209541)
-- Dependencies: 15 396
-- Name: tcorrelativo_id_correlativo_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE tcorrelativo_id_correlativo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7173 (class 0 OID 0)
-- Dependencies: 397
-- Name: tcorrelativo_id_correlativo_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE tcorrelativo_id_correlativo_seq OWNED BY tcorrelativo.id_correlativo;


SET default_with_oids = false;

--
-- TOC entry 398 (class 1259 OID 209543)
-- Dependencies: 5907 15 203
-- Name: tdepto; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE tdepto (
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    id_depto integer NOT NULL,
    nombre character varying(200),
    nombre_corto character varying(100),
    id_subsistema integer,
    codigo character varying(15)
)
INHERITS (public.tbase);


--
-- TOC entry 399 (class 1259 OID 209549)
-- Dependencies: 15 398
-- Name: tdepto_id_depto_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE tdepto_id_depto_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7174 (class 0 OID 0)
-- Dependencies: 399
-- Name: tdepto_id_depto_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE tdepto_id_depto_seq OWNED BY tdepto.id_depto;


SET default_with_oids = true;

--
-- TOC entry 400 (class 1259 OID 209551)
-- Dependencies: 15 203
-- Name: tdepto_usuario; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE tdepto_usuario (
    id_depto_usuario integer NOT NULL,
    id_depto integer,
    id_usuario integer,
    cargo character varying(300)
)
INHERITS (public.tbase);


--
-- TOC entry 401 (class 1259 OID 209557)
-- Dependencies: 15 400
-- Name: tdepto_usuairo_id_depto_usuario_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE tdepto_usuairo_id_depto_usuario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7175 (class 0 OID 0)
-- Dependencies: 401
-- Name: tdepto_usuairo_id_depto_usuario_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE tdepto_usuairo_id_depto_usuario_seq OWNED BY tdepto_usuario.id_depto_usuario;


--
-- TOC entry 402 (class 1259 OID 209559)
-- Dependencies: 5916 15 203
-- Name: tdocumento; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE tdocumento (
    id_documento integer NOT NULL,
    id_subsistema integer,
    codigo character varying(10),
    descripcion character varying(200),
    periodo_gestion character varying(10) DEFAULT 'periodo'::character varying NOT NULL,
    tipo character varying(20),
    tipo_numeracion character varying(10) NOT NULL,
    formato character varying(300)
)
INHERITS (public.tbase);


--
-- TOC entry 403 (class 1259 OID 209569)
-- Dependencies: 15 402
-- Name: tdocumento_id_documento_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE tdocumento_id_documento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7176 (class 0 OID 0)
-- Dependencies: 403
-- Name: tdocumento_id_documento_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE tdocumento_id_documento_seq OWNED BY tdocumento.id_documento;


SET default_with_oids = false;

--
-- TOC entry 404 (class 1259 OID 209571)
-- Dependencies: 5918 5919 5920 15
-- Name: tgestion; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE tgestion (
    id_gestion integer NOT NULL,
    gestion integer,
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    fecha_reg timestamp(0) without time zone DEFAULT now(),
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_mod timestamp(0) without time zone DEFAULT now(),
    estado character varying(15)
);


--
-- TOC entry 405 (class 1259 OID 209577)
-- Dependencies: 15 404
-- Name: tgestion_id_gestion_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE tgestion_id_gestion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7177 (class 0 OID 0)
-- Dependencies: 405
-- Name: tgestion_id_gestion_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE tgestion_id_gestion_seq OWNED BY tgestion.id_gestion;


--
-- TOC entry 406 (class 1259 OID 209579)
-- Dependencies: 5925 5926 15 203
-- Name: tinstitucion; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE tinstitucion (
    id_institucion integer NOT NULL,
    doc_id character varying(50),
    nombre character varying(100) NOT NULL,
    casilla character varying(50),
    telefono1 character varying(50),
    telefono2 character varying(50),
    celular1 character varying(50),
    celular2 character varying(50),
    fax character varying(50),
    email1 character varying(100),
    email2 character varying(100),
    pag_web character varying(100),
    observaciones text,
    id_persona integer,
    direccion character varying(200),
    codigo_banco character varying(10),
    es_banco character varying(2) DEFAULT 'NO'::character varying NOT NULL,
    codigo character varying(25) NOT NULL,
    cargo_representante character varying DEFAULT 'Representante Legal'::character varying
)
INHERITS (public.tbase);


--
-- TOC entry 407 (class 1259 OID 209590)
-- Dependencies: 15 406
-- Name: tinstitucion_id_institucion_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE tinstitucion_id_institucion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7178 (class 0 OID 0)
-- Dependencies: 407
-- Name: tinstitucion_id_institucion_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE tinstitucion_id_institucion_seq OWNED BY tinstitucion.id_institucion;


--
-- TOC entry 408 (class 1259 OID 209592)
-- Dependencies: 5930 5931 5932 5933 5934 15 203
-- Name: tlugar; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE tlugar (
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    id_lugar integer DEFAULT nextval(('param.tlugar_id_lugar_seq'::text)::regclass) NOT NULL,
    id_lugar_fk integer,
    codigo character varying(25),
    nombre character varying(100),
    tipo character varying(25) DEFAULT 'pais'::character varying NOT NULL,
    sw_municipio character varying(2) DEFAULT 'no'::character varying NOT NULL,
    sw_impuesto character varying(2) DEFAULT 'si'::character varying NOT NULL,
    codigo_largo character varying(100)
)
INHERITS (public.tbase);


--
-- TOC entry 7179 (class 0 OID 0)
-- Dependencies: 408
-- Name: COLUMN tlugar.tipo; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tlugar.tipo IS 'El tipo puede ser : pais, departamento, provincia, localidad, zona';


--
-- TOC entry 409 (class 1259 OID 209602)
-- Dependencies: 15
-- Name: tlugar_id_lugar_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE tlugar_id_lugar_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 410 (class 1259 OID 209604)
-- Dependencies: 5937 15 203
-- Name: tmoneda; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE tmoneda (
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    moneda character varying(30),
    codigo character varying(5),
    id_moneda integer NOT NULL,
    tipo_moneda character varying(25)
)
INHERITS (public.tbase);


--
-- TOC entry 411 (class 1259 OID 209610)
-- Dependencies: 15 410
-- Name: tmoneda_id_moneda_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE tmoneda_id_moneda_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7180 (class 0 OID 0)
-- Dependencies: 411
-- Name: tmoneda_id_moneda_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE tmoneda_id_moneda_seq OWNED BY tmoneda.id_moneda;


--
-- TOC entry 412 (class 1259 OID 209612)
-- Dependencies: 5939 5940 5941 15
-- Name: tperiodo; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE tperiodo (
    id_periodo integer NOT NULL,
    periodo integer,
    id_gestion integer,
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    fecha_reg timestamp(0) without time zone DEFAULT now(),
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_mod timestamp(0) without time zone DEFAULT now(),
    fecha_ini date,
    fecha_fin date
);


--
-- TOC entry 413 (class 1259 OID 209618)
-- Dependencies: 412 15
-- Name: tperiodo_id_periodo_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE tperiodo_id_periodo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7181 (class 0 OID 0)
-- Dependencies: 413
-- Name: tperiodo_id_periodo_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE tperiodo_id_periodo_seq OWNED BY tperiodo.id_periodo;


--
-- TOC entry 414 (class 1259 OID 209620)
-- Dependencies: 5943 5944 5945 5946 15
-- Name: tpm_financiador; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE tpm_financiador (
    id_financiador integer NOT NULL,
    codigo_financiador character varying(10) NOT NULL,
    nombre_financiador character varying(100),
    descripcion_financiador text,
    fecha_registro date DEFAULT now() NOT NULL,
    hora_registro time without time zone DEFAULT now() NOT NULL,
    fecha_ultima_modificacion date DEFAULT now(),
    hora_ultima_modificacion time without time zone DEFAULT now(),
    id_usuario integer,
    id_financiador_actif integer
);


--
-- TOC entry 7182 (class 0 OID 0)
-- Dependencies: 414
-- Name: TABLE tpm_financiador; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON TABLE tpm_financiador IS 'sistema=parametros&codigo=FINANC&prefijo=PM&titulo=Financiadores&num_dt=2&dt_1=descripcion_financiador&dt_2=codigo_financiador&desc=Almacena los Financiadores';


--
-- TOC entry 7183 (class 0 OID 0)
-- Dependencies: 414
-- Name: COLUMN tpm_financiador.id_financiador; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_financiador.id_financiador IS 'label=Id Financiador&disable=no';


--
-- TOC entry 7184 (class 0 OID 0)
-- Dependencies: 414
-- Name: COLUMN tpm_financiador.codigo_financiador; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_financiador.codigo_financiador IS 'label=Codigo de Financiador&disable=no';


--
-- TOC entry 7185 (class 0 OID 0)
-- Dependencies: 414
-- Name: COLUMN tpm_financiador.nombre_financiador; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_financiador.nombre_financiador IS 'label=Financiador&disable=no';


--
-- TOC entry 7186 (class 0 OID 0)
-- Dependencies: 414
-- Name: COLUMN tpm_financiador.descripcion_financiador; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_financiador.descripcion_financiador IS 'label=Descripcion&disable=no';


--
-- TOC entry 7187 (class 0 OID 0)
-- Dependencies: 414
-- Name: COLUMN tpm_financiador.fecha_registro; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_financiador.fecha_registro IS 'label=Fecha de Registro&disable=no';


--
-- TOC entry 7188 (class 0 OID 0)
-- Dependencies: 414
-- Name: COLUMN tpm_financiador.hora_registro; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_financiador.hora_registro IS 'label=Hora de Registro&disable=no';


--
-- TOC entry 7189 (class 0 OID 0)
-- Dependencies: 414
-- Name: COLUMN tpm_financiador.fecha_ultima_modificacion; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_financiador.fecha_ultima_modificacion IS 'label=Fecha de Modificación&disable=no';


--
-- TOC entry 7190 (class 0 OID 0)
-- Dependencies: 414
-- Name: COLUMN tpm_financiador.hora_ultima_modificacion; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_financiador.hora_ultima_modificacion IS 'label=Hora de Modificación&disable=no';


--
-- TOC entry 7191 (class 0 OID 0)
-- Dependencies: 414
-- Name: COLUMN tpm_financiador.id_financiador_actif; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_financiador.id_financiador_actif IS 'para actualización de activos fijos';


--
-- TOC entry 415 (class 1259 OID 209630)
-- Dependencies: 15 414
-- Name: tpm_financiador_id_financiador_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE tpm_financiador_id_financiador_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7192 (class 0 OID 0)
-- Dependencies: 415
-- Name: tpm_financiador_id_financiador_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE tpm_financiador_id_financiador_seq OWNED BY tpm_financiador.id_financiador;


--
-- TOC entry 416 (class 1259 OID 209632)
-- Dependencies: 5948 5949 15
-- Name: tpm_programa; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE tpm_programa (
    id_programa integer NOT NULL,
    codigo_programa character varying(10) NOT NULL,
    nombre_programa character varying(100),
    descripcion_programa text,
    fecha_registro date DEFAULT now() NOT NULL,
    hora_registro time without time zone DEFAULT now() NOT NULL,
    fecha_ultima_modificacion date,
    hora_ultima_modificacion time without time zone,
    id_usuario integer,
    id_programa_actif integer
);


--
-- TOC entry 7193 (class 0 OID 0)
-- Dependencies: 416
-- Name: TABLE tpm_programa; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON TABLE tpm_programa IS 'sistema=parametros&codigo=PROGRA&prefijo=PM&titulo=Programas&num_dt=2&dt_1=descripcion_programa&dt_2=codigo_programa&desc=Almacena los Programas';


--
-- TOC entry 7194 (class 0 OID 0)
-- Dependencies: 416
-- Name: COLUMN tpm_programa.id_programa; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_programa.id_programa IS 'label=Id Programa&disable=no';


--
-- TOC entry 7195 (class 0 OID 0)
-- Dependencies: 416
-- Name: COLUMN tpm_programa.codigo_programa; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_programa.codigo_programa IS 'label=Código&disable=no';


--
-- TOC entry 7196 (class 0 OID 0)
-- Dependencies: 416
-- Name: COLUMN tpm_programa.nombre_programa; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_programa.nombre_programa IS 'label=Nombre&disable=no';


--
-- TOC entry 7197 (class 0 OID 0)
-- Dependencies: 416
-- Name: COLUMN tpm_programa.descripcion_programa; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_programa.descripcion_programa IS 'label=Descripción&disable=no';


--
-- TOC entry 7198 (class 0 OID 0)
-- Dependencies: 416
-- Name: COLUMN tpm_programa.fecha_registro; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_programa.fecha_registro IS 'label=Fecha de Registro&disable=no';


--
-- TOC entry 7199 (class 0 OID 0)
-- Dependencies: 416
-- Name: COLUMN tpm_programa.hora_registro; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_programa.hora_registro IS 'label=Hora de Registro&disable=no';


--
-- TOC entry 7200 (class 0 OID 0)
-- Dependencies: 416
-- Name: COLUMN tpm_programa.fecha_ultima_modificacion; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_programa.fecha_ultima_modificacion IS 'label=Fecha de Modificación&disable=no';


--
-- TOC entry 7201 (class 0 OID 0)
-- Dependencies: 416
-- Name: COLUMN tpm_programa.hora_ultima_modificacion; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_programa.hora_ultima_modificacion IS 'label=Hora de Modificación&disable=no';


--
-- TOC entry 7202 (class 0 OID 0)
-- Dependencies: 416
-- Name: COLUMN tpm_programa.id_programa_actif; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_programa.id_programa_actif IS 'para actualización de activos fijos';


--
-- TOC entry 417 (class 1259 OID 209640)
-- Dependencies: 15 416
-- Name: tpm_programa_id_programa_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE tpm_programa_id_programa_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7203 (class 0 OID 0)
-- Dependencies: 417
-- Name: tpm_programa_id_programa_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE tpm_programa_id_programa_seq OWNED BY tpm_programa.id_programa;


--
-- TOC entry 418 (class 1259 OID 209642)
-- Dependencies: 5951 5952 5953 15
-- Name: tpm_proyecto; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE tpm_proyecto (
    id_proyecto integer NOT NULL,
    codigo_proyecto character varying(10) NOT NULL,
    nombre_proyecto character varying(100),
    descripcion_proyecto text,
    fecha_registro date DEFAULT now() NOT NULL,
    hora_registro time without time zone DEFAULT now() NOT NULL,
    fecha_ultima_modificacion date,
    hora_ultima_modificacion time without time zone,
    id_usuario integer,
    id_proyecto_actif integer,
    nombre_corto character varying(100),
    codigo_sisin bigint,
    hidro character varying(2) DEFAULT 'no'::character varying NOT NULL
);


--
-- TOC entry 7204 (class 0 OID 0)
-- Dependencies: 418
-- Name: TABLE tpm_proyecto; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON TABLE tpm_proyecto IS 'sistema=parametros&codigo=PROYEC&prefijo=PM&titulo=Proyectos&num_dt=2&dt_1=descripcion_proyecto&dt_2=codigo_proyecto&desc=Almacena los Proyectos';


--
-- TOC entry 7205 (class 0 OID 0)
-- Dependencies: 418
-- Name: COLUMN tpm_proyecto.id_proyecto; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_proyecto.id_proyecto IS 'label=Id Proyecto&disable=no';


--
-- TOC entry 7206 (class 0 OID 0)
-- Dependencies: 418
-- Name: COLUMN tpm_proyecto.codigo_proyecto; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_proyecto.codigo_proyecto IS 'label=Código&disable=no';


--
-- TOC entry 7207 (class 0 OID 0)
-- Dependencies: 418
-- Name: COLUMN tpm_proyecto.nombre_proyecto; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_proyecto.nombre_proyecto IS 'label=Proyecto&disable=no';


--
-- TOC entry 7208 (class 0 OID 0)
-- Dependencies: 418
-- Name: COLUMN tpm_proyecto.descripcion_proyecto; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_proyecto.descripcion_proyecto IS 'label=Descripción&disable=no';


--
-- TOC entry 7209 (class 0 OID 0)
-- Dependencies: 418
-- Name: COLUMN tpm_proyecto.fecha_registro; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_proyecto.fecha_registro IS 'label=Fecha de Registro&disable=no';


--
-- TOC entry 7210 (class 0 OID 0)
-- Dependencies: 418
-- Name: COLUMN tpm_proyecto.hora_registro; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_proyecto.hora_registro IS 'label=Hora de Registro&disable=no';


--
-- TOC entry 7211 (class 0 OID 0)
-- Dependencies: 418
-- Name: COLUMN tpm_proyecto.fecha_ultima_modificacion; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_proyecto.fecha_ultima_modificacion IS 'label=Fecha de Modificación&disable=no';


--
-- TOC entry 7212 (class 0 OID 0)
-- Dependencies: 418
-- Name: COLUMN tpm_proyecto.hora_ultima_modificacion; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_proyecto.hora_ultima_modificacion IS 'label=Hora de Modificación&disable=no';


--
-- TOC entry 7213 (class 0 OID 0)
-- Dependencies: 418
-- Name: COLUMN tpm_proyecto.id_proyecto_actif; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_proyecto.id_proyecto_actif IS 'para actualización de activos fijos';


--
-- TOC entry 419 (class 1259 OID 209651)
-- Dependencies: 15 418
-- Name: tpm_proyecto_id_proyecto_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE tpm_proyecto_id_proyecto_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7214 (class 0 OID 0)
-- Dependencies: 419
-- Name: tpm_proyecto_id_proyecto_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE tpm_proyecto_id_proyecto_seq OWNED BY tpm_proyecto.id_proyecto;


--
-- TOC entry 420 (class 1259 OID 209653)
-- Dependencies: 5955 5956 15
-- Name: tpm_regional; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE tpm_regional (
    id_regional integer NOT NULL,
    codigo_regional character varying(10) NOT NULL,
    nombre_regional character varying(100),
    descripcion_regional text,
    fecha_registro date DEFAULT now() NOT NULL,
    hora_registro time without time zone DEFAULT now() NOT NULL,
    fecha_ultima_modificacion date,
    hora_ultima_modificacion time without time zone,
    id_usuario integer,
    id_regional_actif integer
);


--
-- TOC entry 7215 (class 0 OID 0)
-- Dependencies: 420
-- Name: TABLE tpm_regional; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON TABLE tpm_regional IS 'sistema=parametros&codigo=REGION&prefijo=PM&titulo=Regional&num_dt=2&dt_1=codigo_regional&dt_2=nombre_regional&desc=Almacena informacion referente a las Regionales';


--
-- TOC entry 7216 (class 0 OID 0)
-- Dependencies: 420
-- Name: COLUMN tpm_regional.id_regional; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_regional.id_regional IS 'label=Id Regional&disable=no';


--
-- TOC entry 7217 (class 0 OID 0)
-- Dependencies: 420
-- Name: COLUMN tpm_regional.codigo_regional; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_regional.codigo_regional IS 'label=Código Regional&disable=no';


--
-- TOC entry 7218 (class 0 OID 0)
-- Dependencies: 420
-- Name: COLUMN tpm_regional.nombre_regional; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_regional.nombre_regional IS 'label=Nombre Regional&disable=no';


--
-- TOC entry 7219 (class 0 OID 0)
-- Dependencies: 420
-- Name: COLUMN tpm_regional.descripcion_regional; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_regional.descripcion_regional IS 'label=Descripción Regional&disable=no';


--
-- TOC entry 7220 (class 0 OID 0)
-- Dependencies: 420
-- Name: COLUMN tpm_regional.fecha_registro; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_regional.fecha_registro IS 'label=Fecha Registro&disable=no';


--
-- TOC entry 7221 (class 0 OID 0)
-- Dependencies: 420
-- Name: COLUMN tpm_regional.hora_registro; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_regional.hora_registro IS 'label=Hora Registro&disable=no';


--
-- TOC entry 7222 (class 0 OID 0)
-- Dependencies: 420
-- Name: COLUMN tpm_regional.fecha_ultima_modificacion; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_regional.fecha_ultima_modificacion IS 'label=Fecha Ultima Mod&disable=no';


--
-- TOC entry 7223 (class 0 OID 0)
-- Dependencies: 420
-- Name: COLUMN tpm_regional.hora_ultima_modificacion; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_regional.hora_ultima_modificacion IS 'label=Hora Ultima Mod&disable=no';


--
-- TOC entry 7224 (class 0 OID 0)
-- Dependencies: 420
-- Name: COLUMN tpm_regional.id_regional_actif; Type: COMMENT; Schema: param; Owner: -
--

COMMENT ON COLUMN tpm_regional.id_regional_actif IS 'para actualización de activos fijos';


--
-- TOC entry 421 (class 1259 OID 209661)
-- Dependencies: 15 420
-- Name: tpm_regional_id_regional_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE tpm_regional_id_regional_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7225 (class 0 OID 0)
-- Dependencies: 421
-- Name: tpm_regional_id_regional_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE tpm_regional_id_regional_seq OWNED BY tpm_regional.id_regional;


SET default_with_oids = true;

--
-- TOC entry 422 (class 1259 OID 209663)
-- Dependencies: 5958 5959 15
-- Name: tproveedor; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE tproveedor (
    id_proveedor integer NOT NULL,
    id_institucion integer,
    id_persona integer,
    tipo character varying,
    numero_sigma character varying,
    codigo character varying,
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer,
    fecha_mod date,
    id_usuario_mod integer,
    nit character varying(100)
);


--
-- TOC entry 423 (class 1259 OID 209671)
-- Dependencies: 422 15
-- Name: tproveedor_id_proveedor_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE tproveedor_id_proveedor_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7226 (class 0 OID 0)
-- Dependencies: 423
-- Name: tproveedor_id_proveedor_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE tproveedor_id_proveedor_seq OWNED BY tproveedor.id_proveedor;


SET default_with_oids = false;

--
-- TOC entry 424 (class 1259 OID 209673)
-- Dependencies: 15 203
-- Name: tusuario_uo; Type: TABLE; Schema: param; Owner: -; Tablespace: 
--

CREATE TABLE tusuario_uo (
    id_usuario_uo integer NOT NULL,
    id_usuario integer,
    id_uo integer
)
INHERITS (public.tbase);


--
-- TOC entry 425 (class 1259 OID 209679)
-- Dependencies: 15 424
-- Name: tusuario_uo_id_usuario_uo_seq; Type: SEQUENCE; Schema: param; Owner: -
--

CREATE SEQUENCE tusuario_uo_id_usuario_uo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7227 (class 0 OID 0)
-- Dependencies: 425
-- Name: tusuario_uo_id_usuario_uo_seq; Type: SEQUENCE OWNED BY; Schema: param; Owner: -
--

ALTER SEQUENCE tusuario_uo_id_usuario_uo_seq OWNED BY tusuario_uo.id_usuario_uo;


SET search_path = segu, pg_catalog;

--
-- TOC entry 426 (class 1259 OID 209681)
-- Dependencies: 5965 5966 5967 20 203
-- Name: tpersona; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tpersona (
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_reg timestamp without time zone DEFAULT now(),
    fecha_mod timestamp without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    id_persona integer NOT NULL,
    nombre character varying(150),
    apellido_paterno character varying(100),
    apellido_materno character varying(100),
    ci character varying(20),
    correo character varying(50),
    celular1 character varying(15),
    num_documento integer,
    telefono1 character varying(15),
    telefono2 character varying(15),
    celular2 character varying(15),
    foto bytea,
    extension character varying(5),
    genero character varying(1),
    fecha_nacimiento date,
    direccion character varying
)
INHERITS (public.tbase);


--
-- TOC entry 427 (class 1259 OID 209690)
-- Dependencies: 5487 20
-- Name: vpersona; Type: VIEW; Schema: segu; Owner: -
--

CREATE VIEW vpersona AS
    SELECT p.id_persona, p.apellido_materno AS ap_materno, p.apellido_paterno AS ap_paterno, p.nombre, (((((COALESCE(p.nombre, ''::character varying))::text || ' '::text) || (COALESCE(p.apellido_paterno, ''::character varying))::text) || ' '::text) || (COALESCE(p.apellido_materno, ''::character varying))::text) AS nombre_completo1, (((((COALESCE(p.apellido_paterno, ''::character varying))::text || ' '::text) || (COALESCE(p.apellido_materno, ''::character varying))::text) || ' '::text) || (COALESCE(p.nombre, ''::character varying))::text) AS nombre_completo2, p.ci, p.correo, p.celular1, p.num_documento, p.telefono1, p.telefono2, p.celular2 FROM tpersona p;


SET search_path = param, pg_catalog;

--
-- TOC entry 428 (class 1259 OID 209694)
-- Dependencies: 5488 15
-- Name: vproveedor; Type: VIEW; Schema: param; Owner: -
--

CREATE VIEW vproveedor AS
    SELECT provee.id_proveedor, provee.id_persona, provee.codigo, provee.numero_sigma, provee.tipo, provee.id_institucion, public.f_iif((provee.id_persona IS NOT NULL), (person.nombre_completo1)::character varying, ((((instit.codigo)::text || '-'::text) || (instit.nombre)::text))::character varying) AS desc_proveedor, provee.nit FROM ((tproveedor provee LEFT JOIN segu.vpersona person ON ((person.id_persona = provee.id_persona))) LEFT JOIN tinstitucion instit ON ((instit.id_institucion = provee.id_institucion))) WHERE ((provee.estado_reg)::text = 'activo'::text);


SET search_path = public, pg_catalog;

--
-- TOC entry 429 (class 1259 OID 209699)
-- Dependencies: 23
-- Name: file_store; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE file_store (
    id integer NOT NULL,
    data text
);


--
-- TOC entry 430 (class 1259 OID 209705)
-- Dependencies: 23 429
-- Name: file_store_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE file_store_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7228 (class 0 OID 0)
-- Dependencies: 430
-- Name: file_store_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE file_store_id_seq OWNED BY file_store.id;


--
-- TOC entry 431 (class 1259 OID 209707)
-- Dependencies: 5489 23
-- Name: geography_columns; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW geography_columns AS
    SELECT current_database() AS f_table_catalog, n.nspname AS f_table_schema, c.relname AS f_table_name, a.attname AS f_geography_column, geography_typmod_dims(a.atttypmod) AS coord_dimension, geography_typmod_srid(a.atttypmod) AS srid, geography_typmod_type(a.atttypmod) AS type FROM pg_class c, pg_attribute a, pg_type t, pg_namespace n WHERE ((((((t.typname = 'geography'::name) AND (a.attisdropped = false)) AND (a.atttypid = t.oid)) AND (a.attrelid = c.oid)) AND (c.relnamespace = n.oid)) AND (NOT pg_is_other_temp_schema(c.relnamespace)));


SET default_with_oids = true;

--
-- TOC entry 432 (class 1259 OID 209712)
-- Dependencies: 23
-- Name: geometry_columns; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE geometry_columns (
    f_table_catalog character varying(256) NOT NULL,
    f_table_schema character varying(256) NOT NULL,
    f_table_name character varying(256) NOT NULL,
    f_geometry_column character varying(256) NOT NULL,
    coord_dimension integer NOT NULL,
    srid integer NOT NULL,
    type character varying(30) NOT NULL
);


--
-- TOC entry 433 (class 1259 OID 209718)
-- Dependencies: 23
-- Name: monitor; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE monitor (
    pid character varying(30),
    comando character varying(200),
    usuario character varying(100),
    por_procesador character varying(5),
    por_memoria character varying(5),
    memoria_virtual character varying(50)
);
ALTER TABLE ONLY monitor ALTER COLUMN pid SET STATISTICS 0;


--
-- TOC entry 434 (class 1259 OID 209721)
-- Dependencies: 23
-- Name: monitor2; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE monitor2 (
    pid integer,
    comando character varying(200),
    usuario character varying(100),
    por_procesador character varying,
    por_memoria character varying,
    memoria_virtual character varying(50)
);


--
-- TOC entry 435 (class 1259 OID 209727)
-- Dependencies: 23
-- Name: monitor3; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE monitor3 (
    pid integer,
    comando character varying(200),
    usuario character varying(100),
    por_procesador numeric(5,2),
    por_memoria numeric(5,2),
    memoria_virtual numeric(40,2)
);


--
-- TOC entry 436 (class 1259 OID 209730)
-- Dependencies: 23
-- Name: parametro; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE parametro
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


SET default_with_oids = false;

--
-- TOC entry 437 (class 1259 OID 209732)
-- Dependencies: 23
-- Name: pempleado; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE pempleado (
    "?column?" text
);


--
-- TOC entry 438 (class 1259 OID 209738)
-- Dependencies: 23
-- Name: prueba_sast; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE prueba_sast (
    id_estado_requerimiento integer,
    id_requerimiento integer,
    observaciones text,
    fecha_ini date,
    responsable text,
    fecha_fin date,
    vigente character varying(100),
    estado_reg character varying(10),
    fecha_reg timestamp without time zone,
    id_usuario_reg integer,
    fecha_mod timestamp without time zone,
    id_usuario_mod integer,
    usr_reg character varying(100),
    usr_mod character varying(100)
);


--
-- TOC entry 439 (class 1259 OID 209744)
-- Dependencies: 23
-- Name: resum; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE resum (
    periodo numeric(2,0),
    gestion numeric(4,0),
    cant_clientes bigint,
    importe_total numeric
);


--
-- TOC entry 440 (class 1259 OID 209750)
-- Dependencies: 23
-- Name: spatial_ref_sys; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE spatial_ref_sys (
    srid integer NOT NULL,
    auth_name character varying(256),
    auth_srid integer,
    srtext character varying(2048),
    proj4text character varying(2048)
);


--
-- TOC entry 441 (class 1259 OID 209756)
-- Dependencies: 2089 2089 23
-- Name: sssss; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE sssss (
    table_schema information_schema.sql_identifier,
    table_name information_schema.sql_identifier
);


--
-- TOC entry 442 (class 1259 OID 209762)
-- Dependencies: 23
-- Name: temporal_gvc; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE temporal_gvc (
    id_cajero integer,
    cajero text,
    cantidad_facturas bigint,
    sum numeric
);


--
-- TOC entry 443 (class 1259 OID 209768)
-- Dependencies: 23
-- Name: ttttttt; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE ttttttt (
    id_config_alarma integer,
    codigo character varying(50),
    descripcion character varying(300),
    dias integer,
    id_subsistema integer,
    desc_subsis text,
    id_usuario_reg integer,
    estado_reg character varying(10),
    fecha_reg timestamp without time zone,
    fecha_mod timestamp without time zone,
    id_usuario_mod integer,
    desc_usuario_reg text,
    desc_usuario_mod text
);


--
-- TOC entry 444 (class 1259 OID 209774)
-- Dependencies: 23
-- Name: v_num_fallidos; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE v_num_fallidos (
    count bigint
);


--
-- TOC entry 445 (class 1259 OID 209777)
-- Dependencies: 23
-- Name: v_orden_logico; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE v_orden_logico (
    orden_logico integer
);


SET default_with_oids = true;

--
-- TOC entry 446 (class 1259 OID 209780)
-- Dependencies: 23
-- Name: variable_global; Type: TABLE; Schema: public; Owner: -; Tablespace: 
--

CREATE TABLE variable_global (
    id_variable_global integer NOT NULL,
    variable character varying NOT NULL,
    valor character varying(200) NOT NULL,
    descripcion character varying
);
ALTER TABLE ONLY variable_global ALTER COLUMN id_variable_global SET STATISTICS 0;
ALTER TABLE ONLY variable_global ALTER COLUMN valor SET STATISTICS 0;


--
-- TOC entry 447 (class 1259 OID 209786)
-- Dependencies: 23 446
-- Name: variable_global_id_variable_global_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE variable_global_id_variable_global_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7229 (class 0 OID 0)
-- Dependencies: 447
-- Name: variable_global_id_variable_global_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE variable_global_id_variable_global_seq OWNED BY variable_global.id_variable_global;


SET search_path = rhum, pg_catalog;

SET default_with_oids = false;

--
-- TOC entry 448 (class 1259 OID 209788)
-- Dependencies: 5971 5972 5973 5974 5976 5977 16
-- Name: tcolumna; Type: TABLE; Schema: rhum; Owner: -; Tablespace: 
--

CREATE TABLE tcolumna (
    id_columna integer NOT NULL,
    codigo character varying(30),
    formula character varying(200),
    valor_defecto numeric(18,2),
    formula_original character varying(200),
    en_reporte character varying DEFAULT 'si'::character varying,
    orden_reporte integer,
    total character varying(2) DEFAULT 'no'::character varying,
    auxiliar character varying(2) DEFAULT 'no'::character varying,
    id_tipo_planilla integer,
    id_tipo_columna integer,
    estado_reg character varying(15) NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer NOT NULL,
    CONSTRAINT chk_tcolumna__estado_reg CHECK ((((estado_reg)::text = 'activo'::text) OR ((estado_reg)::text = 'inactivo'::text))),
    CONSTRAINT chk_tcolumna__valor_defecto__formula CHECK (((((valor_defecto IS NOT NULL) AND (formula IS NULL)) OR ((valor_defecto IS NULL) AND (formula IS NOT NULL))) OR ((valor_defecto IS NULL) AND (formula IS NULL))))
);


--
-- TOC entry 449 (class 1259 OID 209800)
-- Dependencies: 16 448
-- Name: tcolumna_id_columna_seq; Type: SEQUENCE; Schema: rhum; Owner: -
--

CREATE SEQUENCE tcolumna_id_columna_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7230 (class 0 OID 0)
-- Dependencies: 449
-- Name: tcolumna_id_columna_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: -
--

ALTER SEQUENCE tcolumna_id_columna_seq OWNED BY tcolumna.id_columna;


SET default_with_oids = true;

--
-- TOC entry 450 (class 1259 OID 209802)
-- Dependencies: 5980 16 203
-- Name: testructura_uo; Type: TABLE; Schema: rhum; Owner: -; Tablespace: 
--

CREATE TABLE testructura_uo (
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    id_estructura_uo integer NOT NULL,
    id_uo_padre integer,
    id_uo_hijo integer
)
INHERITS (public.tbase);


--
-- TOC entry 451 (class 1259 OID 209808)
-- Dependencies: 16 450
-- Name: testructura_uo_id_estructura_uo_seq; Type: SEQUENCE; Schema: rhum; Owner: -
--

CREATE SEQUENCE testructura_uo_id_estructura_uo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7231 (class 0 OID 0)
-- Dependencies: 451
-- Name: testructura_uo_id_estructura_uo_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: -
--

ALTER SEQUENCE testructura_uo_id_estructura_uo_seq OWNED BY testructura_uo.id_estructura_uo;


SET default_with_oids = false;

--
-- TOC entry 452 (class 1259 OID 209810)
-- Dependencies: 5982 5983 5984 5985 16
-- Name: tfuncionario; Type: TABLE; Schema: rhum; Owner: -; Tablespace: 
--

CREATE TABLE tfuncionario (
    id_persona integer NOT NULL,
    codigo character varying(20),
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    fecha_reg date DEFAULT (now())::date NOT NULL,
    id_usuario_reg integer,
    fecha_mod date DEFAULT (now())::date,
    id_usuario_mod integer,
    id_funcionario integer NOT NULL,
    email_empresa character varying(40),
    interno character varying(9),
    fecha_ingreso date DEFAULT now() NOT NULL
);


--
-- TOC entry 7232 (class 0 OID 0)
-- Dependencies: 452
-- Name: COLUMN tfuncionario.email_empresa; Type: COMMENT; Schema: rhum; Owner: -
--

COMMENT ON COLUMN tfuncionario.email_empresa IS 'correo corporativo  asignado por la empresa';


--
-- TOC entry 7233 (class 0 OID 0)
-- Dependencies: 452
-- Name: COLUMN tfuncionario.interno; Type: COMMENT; Schema: rhum; Owner: -
--

COMMENT ON COLUMN tfuncionario.interno IS 'numero telefonico interno de la empresa';


--
-- TOC entry 453 (class 1259 OID 209817)
-- Dependencies: 16
-- Name: tfuncionario_horario; Type: TABLE; Schema: rhum; Owner: -; Tablespace: 
--

CREATE TABLE tfuncionario_horario (
    id_funcionario_horario integer NOT NULL,
    id_funcionario integer,
    id_horario integer,
    estado_reg character varying(255),
    id_usuario_reg integer,
    fecha_reg date
);


--
-- TOC entry 454 (class 1259 OID 209820)
-- Dependencies: 16 453
-- Name: tfuncionario_horario_id_funcionario_horario_seq; Type: SEQUENCE; Schema: rhum; Owner: -
--

CREATE SEQUENCE tfuncionario_horario_id_funcionario_horario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7234 (class 0 OID 0)
-- Dependencies: 454
-- Name: tfuncionario_horario_id_funcionario_horario_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: -
--

ALTER SEQUENCE tfuncionario_horario_id_funcionario_horario_seq OWNED BY tfuncionario_horario.id_funcionario_horario;


--
-- TOC entry 455 (class 1259 OID 209822)
-- Dependencies: 16 452
-- Name: tfuncionario_id_funcionario_seq; Type: SEQUENCE; Schema: rhum; Owner: -
--

CREATE SEQUENCE tfuncionario_id_funcionario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7235 (class 0 OID 0)
-- Dependencies: 455
-- Name: tfuncionario_id_funcionario_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: -
--

ALTER SEQUENCE tfuncionario_id_funcionario_seq OWNED BY tfuncionario.id_funcionario;


--
-- TOC entry 456 (class 1259 OID 209824)
-- Dependencies: 16
-- Name: thorario; Type: TABLE; Schema: rhum; Owner: -; Tablespace: 
--

CREATE TABLE thorario (
    id_horario integer NOT NULL,
    numero_periodo integer,
    fecha_inicio date NOT NULL,
    fecha_fin date,
    horas_por_dia numeric(2,0),
    hora_ini_p1 time(6) without time zone,
    hora_fin_p1 time(6) without time zone,
    hora_ini_p2 time(6) without time zone,
    hora_fin_p2 time(6) without time zone,
    tipo_periodo character varying(255),
    observaciones character varying(255),
    repite_anualmente character varying(255),
    estado_reg character varying(255),
    id_tipo_horario integer,
    id_vacacion integer,
    id_usuario_reg integer,
    fecha_reg date,
    id_usuario_mod integer,
    fecha_mod date
);


--
-- TOC entry 457 (class 1259 OID 209830)
-- Dependencies: 16 456
-- Name: thorario_id_horario_seq; Type: SEQUENCE; Schema: rhum; Owner: -
--

CREATE SEQUENCE thorario_id_horario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7236 (class 0 OID 0)
-- Dependencies: 457
-- Name: thorario_id_horario_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: -
--

ALTER SEQUENCE thorario_id_horario_seq OWNED BY thorario.id_horario;


--
-- TOC entry 458 (class 1259 OID 209832)
-- Dependencies: 16 203
-- Name: tnivel_organizacional; Type: TABLE; Schema: rhum; Owner: -; Tablespace: 
--

CREATE TABLE tnivel_organizacional (
    id_nivel_organizacional integer NOT NULL,
    nombre_nivel character varying(50) NOT NULL,
    numero_nivel integer NOT NULL
)
INHERITS (public.tbase);


--
-- TOC entry 459 (class 1259 OID 209838)
-- Dependencies: 458 16
-- Name: tnivel_organizacional_id_nivel_organizacional_seq; Type: SEQUENCE; Schema: rhum; Owner: -
--

CREATE SEQUENCE tnivel_organizacional_id_nivel_organizacional_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7237 (class 0 OID 0)
-- Dependencies: 459
-- Name: tnivel_organizacional_id_nivel_organizacional_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: -
--

ALTER SEQUENCE tnivel_organizacional_id_nivel_organizacional_seq OWNED BY tnivel_organizacional.id_nivel_organizacional;


--
-- TOC entry 460 (class 1259 OID 209840)
-- Dependencies: 5993 5994 5996 16
-- Name: tobligacion; Type: TABLE; Schema: rhum; Owner: -; Tablespace: 
--

CREATE TABLE tobligacion (
    id_obligacion integer NOT NULL,
    observaciones text,
    monto numeric,
    tipo_pago character varying,
    estado_reg character varying,
    id_tipo_obligacion integer,
    id_planilla integer,
    id_usuario_reg integer,
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_mod integer,
    fecha_mod date DEFAULT now(),
    CONSTRAINT tkp_obligacion__tipo_pago__check CHECK ((((tipo_pago)::text = 'cheque'::text) OR ((tipo_pago)::text = 'transferencia'::text)))
);


--
-- TOC entry 461 (class 1259 OID 209849)
-- Dependencies: 16 460
-- Name: tobligacion_id_obligacion_seq; Type: SEQUENCE; Schema: rhum; Owner: -
--

CREATE SEQUENCE tobligacion_id_obligacion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7238 (class 0 OID 0)
-- Dependencies: 461
-- Name: tobligacion_id_obligacion_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: -
--

ALTER SEQUENCE tobligacion_id_obligacion_seq OWNED BY tobligacion.id_obligacion;


SET default_with_oids = true;

--
-- TOC entry 462 (class 1259 OID 209851)
-- Dependencies: 5997 16
-- Name: tparametro_rhum; Type: TABLE; Schema: rhum; Owner: -; Tablespace: 
--

CREATE TABLE tparametro_rhum (
    id_parametro integer NOT NULL,
    id_gestion integer,
    salario_min_nal numeric,
    id_moneda_sal_min_nal integer,
    estado_reg character varying,
    fecha_reg date,
    id_usuario_reg integer,
    id_usuario_mod integer,
    fecha_mod date DEFAULT now()
);


--
-- TOC entry 463 (class 1259 OID 209858)
-- Dependencies: 16 462
-- Name: tparametro_rhum_id_parametro_seq; Type: SEQUENCE; Schema: rhum; Owner: -
--

CREATE SEQUENCE tparametro_rhum_id_parametro_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7239 (class 0 OID 0)
-- Dependencies: 463
-- Name: tparametro_rhum_id_parametro_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: -
--

ALTER SEQUENCE tparametro_rhum_id_parametro_seq OWNED BY tparametro_rhum.id_parametro;


--
-- TOC entry 464 (class 1259 OID 209860)
-- Dependencies: 16
-- Name: tplanilla; Type: TABLE; Schema: rhum; Owner: -; Tablespace: 
--

CREATE TABLE tplanilla (
    id_planilla integer NOT NULL
);


--
-- TOC entry 465 (class 1259 OID 209863)
-- Dependencies: 16 464
-- Name: tplanilla_id_planilla_seq; Type: SEQUENCE; Schema: rhum; Owner: -
--

CREATE SEQUENCE tplanilla_id_planilla_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7240 (class 0 OID 0)
-- Dependencies: 465
-- Name: tplanilla_id_planilla_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: -
--

ALTER SEQUENCE tplanilla_id_planilla_seq OWNED BY tplanilla.id_planilla;


SET default_with_oids = false;

--
-- TOC entry 466 (class 1259 OID 209865)
-- Dependencies: 6000 6001 6002 6003 6004 6006 16
-- Name: ttipo_columna; Type: TABLE; Schema: rhum; Owner: -; Tablespace: 
--

CREATE TABLE ttipo_columna (
    id_tipo_columna integer NOT NULL,
    codigo character varying(15),
    nombre character varying(255),
    descripcion character varying(255),
    valor numeric(20,6),
    tipo_dato character varying(255),
    compromete character varying(5) DEFAULT 'no'::character varying NOT NULL,
    tipo_aporte character varying(255),
    descuento_incremento character varying(20),
    observacion character varying(255),
    formula character varying(500),
    movimiento_contable character varying DEFAULT 'haber'::character varying NOT NULL,
    prorratea character varying(2) DEFAULT 'no'::character varying NOT NULL,
    estado_reg character varying(255) DEFAULT 'activo'::character varying,
    fecha_reg date DEFAULT (now())::date,
    id_parametro_rhum integer,
    id_moneda integer,
    id_tipo_descuento_bono integer,
    id_cuenta_pasivo integer,
    id_auxiliar_pasivo integer,
    id_tipo_obligacion integer,
    id_usuario_reg integer,
    CONSTRAINT ttipo_columna__descuento_incremento__chk CHECK (((((descuento_incremento)::text = 'aumentar'::text) OR ((descuento_incremento)::text = 'descontar'::text)) OR ((descuento_incremento)::text = 'ninguno'::text)))
);


--
-- TOC entry 467 (class 1259 OID 209877)
-- Dependencies: 16 466
-- Name: ttipo_columna_id_tipo_columna_seq; Type: SEQUENCE; Schema: rhum; Owner: -
--

CREATE SEQUENCE ttipo_columna_id_tipo_columna_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7241 (class 0 OID 0)
-- Dependencies: 467
-- Name: ttipo_columna_id_tipo_columna_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: -
--

ALTER SEQUENCE ttipo_columna_id_tipo_columna_seq OWNED BY ttipo_columna.id_tipo_columna;


--
-- TOC entry 468 (class 1259 OID 209879)
-- Dependencies: 6007 6008 16
-- Name: ttipo_horario; Type: TABLE; Schema: rhum; Owner: -; Tablespace: 
--

CREATE TABLE ttipo_horario (
    id_tipo_horario integer NOT NULL,
    codigo character varying(255),
    nombre character varying(255),
    estado_reg character varying(10),
    id_usuario_reg integer,
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_mod integer,
    fecha_mod date DEFAULT now()
);


--
-- TOC entry 469 (class 1259 OID 209887)
-- Dependencies: 468 16
-- Name: ttipo_horario_id_tipo_horario_seq; Type: SEQUENCE; Schema: rhum; Owner: -
--

CREATE SEQUENCE ttipo_horario_id_tipo_horario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7242 (class 0 OID 0)
-- Dependencies: 469
-- Name: ttipo_horario_id_tipo_horario_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: -
--

ALTER SEQUENCE ttipo_horario_id_tipo_horario_seq OWNED BY ttipo_horario.id_tipo_horario;


--
-- TOC entry 470 (class 1259 OID 209889)
-- Dependencies: 6010 6011 16
-- Name: ttipo_obligacion; Type: TABLE; Schema: rhum; Owner: -; Tablespace: 
--

CREATE TABLE ttipo_obligacion (
    id_tipo_obligacion integer NOT NULL,
    codigo character varying(20) NOT NULL,
    nombre character varying(150) NOT NULL,
    estado_reg character varying(20),
    id_usuario_reg integer,
    fecha_reg date DEFAULT now(),
    id_usuario_mod integer,
    fecha_mod date DEFAULT now()
);


--
-- TOC entry 471 (class 1259 OID 209894)
-- Dependencies: 16 470
-- Name: ttipo_obligacion_id_tipo_obligacion_seq; Type: SEQUENCE; Schema: rhum; Owner: -
--

CREATE SEQUENCE ttipo_obligacion_id_tipo_obligacion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7243 (class 0 OID 0)
-- Dependencies: 471
-- Name: ttipo_obligacion_id_tipo_obligacion_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: -
--

ALTER SEQUENCE ttipo_obligacion_id_tipo_obligacion_seq OWNED BY ttipo_obligacion.id_tipo_obligacion;


SET default_with_oids = true;

--
-- TOC entry 472 (class 1259 OID 209896)
-- Dependencies: 6013 6014 6015 6016 6017 16
-- Name: ttipo_planilla; Type: TABLE; Schema: rhum; Owner: -; Tablespace: 
--

CREATE TABLE ttipo_planilla (
    id_tipo_planilla integer NOT NULL,
    nombre character varying(50),
    descripcion character varying(300),
    tipo character varying(10) DEFAULT 'sueldo'::character varying,
    basica character varying(2) DEFAULT 'no'::character varying,
    estado_reg character varying DEFAULT 'activo'::character varying,
    id_moneda integer NOT NULL,
    id_usuario_reg integer,
    fecha_reg date DEFAULT (now())::date,
    id_usuario_mod integer,
    fecha_mod date DEFAULT (now())::date
);


--
-- TOC entry 473 (class 1259 OID 209907)
-- Dependencies: 16 472
-- Name: ttipo_planilla_id_tipo_planilla_seq; Type: SEQUENCE; Schema: rhum; Owner: -
--

CREATE SEQUENCE ttipo_planilla_id_tipo_planilla_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7244 (class 0 OID 0)
-- Dependencies: 473
-- Name: ttipo_planilla_id_tipo_planilla_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: -
--

ALTER SEQUENCE ttipo_planilla_id_tipo_planilla_seq OWNED BY ttipo_planilla.id_tipo_planilla;


--
-- TOC entry 474 (class 1259 OID 209909)
-- Dependencies: 6022 16 203
-- Name: tuo; Type: TABLE; Schema: rhum; Owner: -; Tablespace: 
--

CREATE TABLE tuo (
    id_uo integer NOT NULL,
    nombre_unidad character varying(100),
    nombre_cargo character varying(50),
    cargo_individual character varying(2),
    descripcion character varying(100),
    presupuesta character varying(2),
    codigo character varying(15),
    nodo_base character varying(2) DEFAULT 'no'::character varying NOT NULL,
    gerencia character varying(2),
    correspondencia character varying(2)
)
INHERITS (public.tbase)
WITH (fillfactor=10);


--
-- TOC entry 7245 (class 0 OID 0)
-- Dependencies: 474
-- Name: COLUMN tuo.nodo_base; Type: COMMENT; Schema: rhum; Owner: -
--

COMMENT ON COLUMN tuo.nodo_base IS 'Identifica la raiz del organigrama';


--
-- TOC entry 475 (class 1259 OID 209916)
-- Dependencies: 6026 16 203
-- Name: tuo_funcionario; Type: TABLE; Schema: rhum; Owner: -; Tablespace: 
--

CREATE TABLE tuo_funcionario (
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    id_uo_funcionario integer NOT NULL,
    id_uo integer,
    id_funcionario integer,
    fecha_asignacion date,
    fecha_finalizacion date
)
INHERITS (public.tbase)
WITH (fillfactor=10);
ALTER TABLE ONLY tuo_funcionario ALTER COLUMN id_uo SET STATISTICS 0;


--
-- TOC entry 7246 (class 0 OID 0)
-- Dependencies: 475
-- Name: COLUMN tuo_funcionario.estado_reg; Type: COMMENT; Schema: rhum; Owner: -
--

COMMENT ON COLUMN tuo_funcionario.estado_reg IS 'activo :  relacion vigente
eliminado: relacion eliminada no se tiene que considerar 
finalizada: el funcionario se le cambiio el cargo, se tiene que considerar como historico 
finalizado:';


--
-- TOC entry 476 (class 1259 OID 209922)
-- Dependencies: 16 475
-- Name: tuo_funcionario_id_uo_funcionario_seq; Type: SEQUENCE; Schema: rhum; Owner: -
--

CREATE SEQUENCE tuo_funcionario_id_uo_funcionario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7247 (class 0 OID 0)
-- Dependencies: 476
-- Name: tuo_funcionario_id_uo_funcionario_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: -
--

ALTER SEQUENCE tuo_funcionario_id_uo_funcionario_seq OWNED BY tuo_funcionario.id_uo_funcionario;


--
-- TOC entry 477 (class 1259 OID 209924)
-- Dependencies: 16 474
-- Name: tuo_id_uo_seq; Type: SEQUENCE; Schema: rhum; Owner: -
--

CREATE SEQUENCE tuo_id_uo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7248 (class 0 OID 0)
-- Dependencies: 477
-- Name: tuo_id_uo_seq; Type: SEQUENCE OWNED BY; Schema: rhum; Owner: -
--

ALTER SEQUENCE tuo_id_uo_seq OWNED BY tuo.id_uo;


--
-- TOC entry 478 (class 1259 OID 209926)
-- Dependencies: 5490 16
-- Name: vfuncionario; Type: VIEW; Schema: rhum; Owner: -
--

CREATE VIEW vfuncionario AS
    SELECT funcio.id_funcionario, person.nombre_completo1 AS desc_funcionario1, person.nombre_completo2 AS desc_funcionario2, person.num_documento AS num_doc, person.ci, funcio.codigo, funcio.estado_reg FROM (tfuncionario funcio JOIN segu.vpersona person ON ((funcio.id_persona = person.id_persona)));


--
-- TOC entry 479 (class 1259 OID 209930)
-- Dependencies: 5491 16
-- Name: vfuncionario_cargo; Type: VIEW; Schema: rhum; Owner: -
--

CREATE VIEW vfuncionario_cargo AS
    SELECT uof.id_uo_funcionario, funcio.id_funcionario, person.nombre_completo1 AS desc_funcionario1, person.nombre_completo2 AS desc_funcionario2, uo.id_uo, uo.nombre_cargo, uof.fecha_asignacion, uof.fecha_finalizacion, person.num_documento AS num_doc, person.ci, funcio.codigo, funcio.email_empresa, funcio.estado_reg AS estado_reg_fun, uof.estado_reg AS estado_reg_asi FROM (((tfuncionario funcio JOIN segu.vpersona person ON ((funcio.id_persona = person.id_persona))) JOIN tuo_funcionario uof ON ((uof.id_funcionario = funcio.id_funcionario))) JOIN tuo uo ON ((uo.id_uo = uof.id_funcionario)));


SET search_path = saj, pg_catalog;

--
-- TOC entry 480 (class 1259 OID 209935)
-- Dependencies: 6028 6029 17
-- Name: tboleta; Type: TABLE; Schema: saj; Owner: -; Tablespace: 
--

CREATE TABLE tboleta (
    id_boleta integer NOT NULL,
    id_proceso_contrato integer,
    id_moneda integer,
    id_institucion_banco integer,
    doc_garantia character varying,
    extension character varying,
    version integer DEFAULT 0 NOT NULL,
    tipo character varying,
    fecha_ini date,
    fecha_fin date,
    estado character varying,
    numero character varying(40),
    monto numeric(18,2),
    fecha_suscripcion date,
    fecha_vencimiento date,
    observaciones character varying,
    orden integer,
    estado_reg character varying(10),
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer,
    fecha_mod date,
    id_usuario_mod integer,
    id_alarma integer[],
    id_boleta_fk integer,
    "aA" bigint
);
ALTER TABLE ONLY tboleta ALTER COLUMN id_moneda SET STATISTICS 0;


--
-- TOC entry 481 (class 1259 OID 209943)
-- Dependencies: 17 480
-- Name: tboleta_id_boleta_seq; Type: SEQUENCE; Schema: saj; Owner: -
--

CREATE SEQUENCE tboleta_id_boleta_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7249 (class 0 OID 0)
-- Dependencies: 481
-- Name: tboleta_id_boleta_seq; Type: SEQUENCE OWNED BY; Schema: saj; Owner: -
--

ALTER SEQUENCE tboleta_id_boleta_seq OWNED BY tboleta.id_boleta;


--
-- TOC entry 482 (class 1259 OID 209945)
-- Dependencies: 17
-- Name: tconfig_alerta_id_config_alerta_seq; Type: SEQUENCE; Schema: saj; Owner: -
--

CREATE SEQUENCE tconfig_alerta_id_config_alerta_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 483 (class 1259 OID 209947)
-- Dependencies: 6031 17
-- Name: tdocumento_anexo; Type: TABLE; Schema: saj; Owner: -; Tablespace: 
--

CREATE TABLE tdocumento_anexo (
    id_documento_anexo integer NOT NULL,
    id_proceso_contrato integer,
    estado_reg character varying(10),
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer,
    fecha_mod date,
    id_usuario_mod integer
);
ALTER TABLE ONLY tdocumento_anexo ALTER COLUMN id_proceso_contrato SET STATISTICS 0;


--
-- TOC entry 484 (class 1259 OID 209951)
-- Dependencies: 17 483
-- Name: tdocumento_anexo_id_documento_anexo_seq; Type: SEQUENCE; Schema: saj; Owner: -
--

CREATE SEQUENCE tdocumento_anexo_id_documento_anexo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7250 (class 0 OID 0)
-- Dependencies: 484
-- Name: tdocumento_anexo_id_documento_anexo_seq; Type: SEQUENCE OWNED BY; Schema: saj; Owner: -
--

ALTER SEQUENCE tdocumento_anexo_id_documento_anexo_seq OWNED BY tdocumento_anexo.id_documento_anexo;


--
-- TOC entry 485 (class 1259 OID 209953)
-- Dependencies: 6033 6034 17
-- Name: testado; Type: TABLE; Schema: saj; Owner: -; Tablespace: 
--

CREATE TABLE testado (
    id_estado integer NOT NULL,
    codigo character varying(20) NOT NULL,
    nombre character varying(255) NOT NULL,
    orden integer NOT NULL,
    dias numeric(18,2),
    admite_boleta character varying(2),
    admite_anexo character varying(2),
    estado_reg character varying(10),
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer NOT NULL,
    id_usuario_mod integer,
    fecha_mod date DEFAULT now()
);


--
-- TOC entry 486 (class 1259 OID 209958)
-- Dependencies: 17 485
-- Name: testado_id_estado_seq; Type: SEQUENCE; Schema: saj; Owner: -
--

CREATE SEQUENCE testado_id_estado_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7251 (class 0 OID 0)
-- Dependencies: 486
-- Name: testado_id_estado_seq; Type: SEQUENCE OWNED BY; Schema: saj; Owner: -
--

ALTER SEQUENCE testado_id_estado_seq OWNED BY testado.id_estado;


--
-- TOC entry 487 (class 1259 OID 209960)
-- Dependencies: 6036 6037 6038 6039 17
-- Name: testado_proceso; Type: TABLE; Schema: saj; Owner: -; Tablespace: 
--

CREATE TABLE testado_proceso (
    id_estado_proceso integer NOT NULL,
    id_proceso_contrato integer,
    observaciones character varying,
    fecha_ini date DEFAULT now(),
    id_responsable_proceso integer,
    fecha_fin date,
    estado_vigente character varying(30),
    estado_anterior character varying(30),
    estado_reg character varying(10) DEFAULT 'activo'::character varying,
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer,
    fecha_mod date,
    id_usuario_mod integer,
    hora time(0) without time zone DEFAULT now() NOT NULL
);


--
-- TOC entry 488 (class 1259 OID 209970)
-- Dependencies: 17 487
-- Name: testado_proceso_id_estado_proceso_seq; Type: SEQUENCE; Schema: saj; Owner: -
--

CREATE SEQUENCE testado_proceso_id_estado_proceso_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7252 (class 0 OID 0)
-- Dependencies: 488
-- Name: testado_proceso_id_estado_proceso_seq; Type: SEQUENCE OWNED BY; Schema: saj; Owner: -
--

ALTER SEQUENCE testado_proceso_id_estado_proceso_seq OWNED BY testado_proceso.id_estado_proceso;


--
-- TOC entry 489 (class 1259 OID 209972)
-- Dependencies: 6041 6042 17
-- Name: ttipo_contrato; Type: TABLE; Schema: saj; Owner: -; Tablespace: 
--

CREATE TABLE ttipo_contrato (
    id_tipo_contrato integer NOT NULL,
    nombre character varying,
    estado_reg character varying(10),
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer,
    fecha_mod date DEFAULT now(),
    id_usuario_mod integer
);
ALTER TABLE ONLY ttipo_contrato ALTER COLUMN id_tipo_contrato SET STATISTICS 0;


--
-- TOC entry 490 (class 1259 OID 209980)
-- Dependencies: 489 17
-- Name: tipo_contrato_id_tipo_contrato_seq; Type: SEQUENCE; Schema: saj; Owner: -
--

CREATE SEQUENCE tipo_contrato_id_tipo_contrato_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7253 (class 0 OID 0)
-- Dependencies: 490
-- Name: tipo_contrato_id_tipo_contrato_seq; Type: SEQUENCE OWNED BY; Schema: saj; Owner: -
--

ALTER SEQUENCE tipo_contrato_id_tipo_contrato_seq OWNED BY ttipo_contrato.id_tipo_contrato;


--
-- TOC entry 491 (class 1259 OID 209982)
-- Dependencies: 6044 6045 6046 17
-- Name: tmodalidad; Type: TABLE; Schema: saj; Owner: -; Tablespace: 
--

CREATE TABLE tmodalidad (
    id_modalidad integer NOT NULL,
    nombre character varying,
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer,
    fecha_mod date DEFAULT now(),
    id_usuario_mod integer
);


--
-- TOC entry 492 (class 1259 OID 209991)
-- Dependencies: 491 17
-- Name: tmodalidad_id_modalidad_seq; Type: SEQUENCE; Schema: saj; Owner: -
--

CREATE SEQUENCE tmodalidad_id_modalidad_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7254 (class 0 OID 0)
-- Dependencies: 492
-- Name: tmodalidad_id_modalidad_seq; Type: SEQUENCE OWNED BY; Schema: saj; Owner: -
--

ALTER SEQUENCE tmodalidad_id_modalidad_seq OWNED BY tmodalidad.id_modalidad;


--
-- TOC entry 493 (class 1259 OID 209993)
-- Dependencies: 6048 6049 6050 17
-- Name: tproceso_contrato; Type: TABLE; Schema: saj; Owner: -; Tablespace: 
--

CREATE TABLE tproceso_contrato (
    id_proceso_contrato integer NOT NULL,
    id_funcionario integer,
    id_uo integer,
    id_proyecto integer,
    id_modalidad integer,
    id_proveedor integer,
    id_rpc integer,
    id_supervisor integer,
    id_representante_legal integer,
    id_moneda integer,
    id_gestion integer,
    id_depto integer,
    id_lugar_suscripcion integer,
    id_tipo_contrato integer,
    doc_contrato character varying(500),
    extension character varying(100),
    version integer DEFAULT 0 NOT NULL,
    numero_contrato character varying,
    numero_cuce character varying(300),
    numero_licitacion character varying,
    numero_oc character varying(50),
    id_oc integer,
    beneficiario character varying,
    fecha_ini date,
    fecha_fin date,
    fecha_suscripcion date,
    objeto_contrato character varying,
    numero_requerimiento character varying,
    multas character varying,
    plazo character varying,
    testimonio character varying,
    fecha_testimonio date,
    origen_recursos character varying,
    forma_pago character varying,
    notario character varying,
    fecha_convocatoria date,
    fecha_aprobacion date,
    fecha_ap_acta date,
    observaciones character varying,
    id_usuario_reg integer,
    fecha_reg date DEFAULT (now())::date NOT NULL,
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    id_usuario_mod integer,
    fecha_mod date,
    estado_proceso character varying(30),
    monto_contrato numeric(18,2),
    id_alarma integer[]
);
ALTER TABLE ONLY tproceso_contrato ALTER COLUMN id_funcionario SET STATISTICS 0;


--
-- TOC entry 7255 (class 0 OID 0)
-- Dependencies: 493
-- Name: COLUMN tproceso_contrato.doc_contrato; Type: COMMENT; Schema: saj; Owner: -
--

COMMENT ON COLUMN tproceso_contrato.doc_contrato IS 'ruta url del archivo';


--
-- TOC entry 494 (class 1259 OID 210002)
-- Dependencies: 17 493
-- Name: tproceso_contrato_id_proceso_contrato_seq; Type: SEQUENCE; Schema: saj; Owner: -
--

CREATE SEQUENCE tproceso_contrato_id_proceso_contrato_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7256 (class 0 OID 0)
-- Dependencies: 494
-- Name: tproceso_contrato_id_proceso_contrato_seq; Type: SEQUENCE OWNED BY; Schema: saj; Owner: -
--

ALTER SEQUENCE tproceso_contrato_id_proceso_contrato_seq OWNED BY tproceso_contrato.id_proceso_contrato;


--
-- TOC entry 495 (class 1259 OID 210004)
-- Dependencies: 6052 6053 6054 17
-- Name: tresponsable_proceso; Type: TABLE; Schema: saj; Owner: -; Tablespace: 
--

CREATE TABLE tresponsable_proceso (
    id_responsable_proceso integer NOT NULL,
    tipo character varying(30),
    id_funcionario integer,
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario_reg integer,
    fecha_mod date DEFAULT now(),
    id_usuario_mod integer,
    id_responsable_proceso_anterior integer
);


--
-- TOC entry 496 (class 1259 OID 210010)
-- Dependencies: 17 495
-- Name: tresponsable_proceso_id_responsable_proceso_seq; Type: SEQUENCE; Schema: saj; Owner: -
--

CREATE SEQUENCE tresponsable_proceso_id_responsable_proceso_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7257 (class 0 OID 0)
-- Dependencies: 496
-- Name: tresponsable_proceso_id_responsable_proceso_seq; Type: SEQUENCE OWNED BY; Schema: saj; Owner: -
--

ALTER SEQUENCE tresponsable_proceso_id_responsable_proceso_seq OWNED BY tresponsable_proceso.id_responsable_proceso;


--
-- TOC entry 497 (class 1259 OID 210012)
-- Dependencies: 5492 17
-- Name: vresponsable_proceso; Type: VIEW; Schema: saj; Owner: -
--

CREATE VIEW vresponsable_proceso AS
    SELECT respro.id_responsable_proceso, respro.tipo, respro.id_funcionario, person.nombre_completo1 AS desc_responsable_proceso FROM ((tresponsable_proceso respro JOIN rhum.tfuncionario funcio ON ((funcio.id_funcionario = respro.id_funcionario))) JOIN segu.vpersona person ON ((person.id_persona = funcio.id_persona)));


SET search_path = sast, pg_catalog;

SET default_with_oids = false;

--
-- TOC entry 498 (class 1259 OID 210017)
-- Dependencies: 203 18
-- Name: testado; Type: TABLE; Schema: sast; Owner: -; Tablespace: 
--

CREATE TABLE testado (
    id_estado integer NOT NULL,
    nombre character varying(100) NOT NULL,
    orden integer NOT NULL,
    codigo character varying(20) NOT NULL
)
INHERITS (public.tbase);


--
-- TOC entry 499 (class 1259 OID 210023)
-- Dependencies: 498 18
-- Name: testado_id_estado_seq; Type: SEQUENCE; Schema: sast; Owner: -
--

CREATE SEQUENCE testado_id_estado_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7258 (class 0 OID 0)
-- Dependencies: 499
-- Name: testado_id_estado_seq; Type: SEQUENCE OWNED BY; Schema: sast; Owner: -
--

ALTER SEQUENCE testado_id_estado_seq OWNED BY testado.id_estado;


--
-- TOC entry 500 (class 1259 OID 210025)
-- Dependencies: 6063 18 203
-- Name: testado_requerimiento; Type: TABLE; Schema: sast; Owner: -; Tablespace: 
--

CREATE TABLE testado_requerimiento (
    id_estado_requerimiento integer NOT NULL,
    id_requerimiento integer NOT NULL,
    id_depto_usuario integer,
    fecha_ini date,
    hora time(0) without time zone DEFAULT now() NOT NULL,
    observaciones text,
    estado_vigente character varying(100),
    estado_anterior character varying(100),
    fecha_fin date
)
INHERITS (public.tbase);


--
-- TOC entry 501 (class 1259 OID 210035)
-- Dependencies: 18 500
-- Name: testado_requerimiento_id_estado_requerimiento_seq; Type: SEQUENCE; Schema: sast; Owner: -
--

CREATE SEQUENCE testado_requerimiento_id_estado_requerimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7259 (class 0 OID 0)
-- Dependencies: 501
-- Name: testado_requerimiento_id_estado_requerimiento_seq; Type: SEQUENCE OWNED BY; Schema: sast; Owner: -
--

ALTER SEQUENCE testado_requerimiento_id_estado_requerimiento_seq OWNED BY testado_requerimiento.id_estado_requerimiento;


--
-- TOC entry 502 (class 1259 OID 210037)
-- Dependencies: 18 203
-- Name: ttipo_requerimiento; Type: TABLE; Schema: sast; Owner: -; Tablespace: 
--

CREATE TABLE ttipo_requerimiento (
    id_tipo_requerimiento integer NOT NULL,
    nombre character varying(100)
)
INHERITS (public.tbase);


--
-- TOC entry 503 (class 1259 OID 210043)
-- Dependencies: 502 18
-- Name: tipo_requerimiento_id_tipo_requerimiento_seq; Type: SEQUENCE; Schema: sast; Owner: -
--

CREATE SEQUENCE tipo_requerimiento_id_tipo_requerimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7260 (class 0 OID 0)
-- Dependencies: 503
-- Name: tipo_requerimiento_id_tipo_requerimiento_seq; Type: SEQUENCE OWNED BY; Schema: sast; Owner: -
--

ALTER SEQUENCE tipo_requerimiento_id_tipo_requerimiento_seq OWNED BY ttipo_requerimiento.id_tipo_requerimiento;


--
-- TOC entry 504 (class 1259 OID 210045)
-- Dependencies: 18
-- Name: trequerimiento_id_requerimiento_seq; Type: SEQUENCE; Schema: sast; Owner: -
--

CREATE SEQUENCE trequerimiento_id_requerimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 505 (class 1259 OID 210047)
-- Dependencies: 6072 6073 6074 18 203
-- Name: trequerimientos; Type: TABLE; Schema: sast; Owner: -; Tablespace: 
--

CREATE TABLE trequerimientos (
    id_requerimiento integer NOT NULL,
    id_funcionario integer NOT NULL,
    id_tipo_requerimiento integer NOT NULL,
    id_depto integer NOT NULL,
    estado_requerimiento character varying(30),
    descripcion text,
    extension character varying(3),
    version integer DEFAULT 0 NOT NULL,
    id_gestion integer,
    numero_requerimiento character varying,
    solucion character varying(5000),
    hora_requer time(0) without time zone DEFAULT now(),
    fecha_requer date DEFAULT now(),
    captura1 character varying(5000)
)
INHERITS (public.tbase);


--
-- TOC entry 7261 (class 0 OID 0)
-- Dependencies: 505
-- Name: COLUMN trequerimientos.captura1; Type: COMMENT; Schema: sast; Owner: -
--

COMMENT ON COLUMN trequerimientos.captura1 IS 'ruta url del archivo';


--
-- TOC entry 506 (class 1259 OID 210059)
-- Dependencies: 18 505
-- Name: trequerimientos_id_requerimiento_seq; Type: SEQUENCE; Schema: sast; Owner: -
--

CREATE SEQUENCE trequerimientos_id_requerimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7262 (class 0 OID 0)
-- Dependencies: 506
-- Name: trequerimientos_id_requerimiento_seq; Type: SEQUENCE OWNED BY; Schema: sast; Owner: -
--

ALTER SEQUENCE trequerimientos_id_requerimiento_seq OWNED BY trequerimientos.id_requerimiento;


--
-- TOC entry 507 (class 1259 OID 210061)
-- Dependencies: 5493 18
-- Name: vdepto_usuario; Type: VIEW; Schema: sast; Owner: -
--

CREATE VIEW vdepto_usuario AS
    SELECT depusu.id_depto_usuario, depusu.cargo AS funcion, depusu.id_usuario, person.nombre_completo1 AS desc_depto_usuario FROM ((param.tdepto_usuario depusu JOIN segu.tusuario usuario ON ((usuario.id_usuario = depusu.id_usuario))) JOIN segu.vpersona person ON ((person.id_persona = usuario.id_persona)));


SET search_path = secont, pg_catalog;

--
-- TOC entry 508 (class 1259 OID 210066)
-- Dependencies: 19
-- Name: alarma; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE alarma (
    id_alarma integer NOT NULL,
    id_proyecto integer,
    alarma_contrato boolean,
    alarma_garantia boolean,
    dias_contrato integer,
    dias_garantia integer,
    dias_proceso integer,
    fecha_reg date,
    estado_reg character varying(15),
    fecha_cambio date
);


--
-- TOC entry 509 (class 1259 OID 210069)
-- Dependencies: 19
-- Name: contratista; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE contratista (
    id_contratista integer NOT NULL,
    id_persona_juridica integer,
    id_persona integer,
    nit character varying(20),
    tipo text,
    obs text,
    estado_reg character varying(15)
);


--
-- TOC entry 510 (class 1259 OID 210075)
-- Dependencies: 19 509
-- Name: contratista_id_contratista_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE contratista_id_contratista_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7263 (class 0 OID 0)
-- Dependencies: 510
-- Name: contratista_id_contratista_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE contratista_id_contratista_seq OWNED BY contratista.id_contratista;


--
-- TOC entry 511 (class 1259 OID 210077)
-- Dependencies: 19
-- Name: contrato; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE contrato (
    id_contrato integer NOT NULL,
    id_representante integer,
    id_empleado integer,
    id_proyecto integer,
    emp_id_empleado integer,
    numero character varying(10),
    objeto text,
    gerencia text,
    moneda character varying(50),
    monto_cifra double precision,
    multas double precision,
    forma_pago text,
    origen_recursos text,
    fecha_ini date,
    fecha_fin date,
    forma_contratacion text,
    tipo_contrato text,
    doc_contrato text,
    numero_licitacion character varying(50),
    numero_cuce character varying(50),
    lugar_sus text,
    fecha_sus date,
    obs text,
    intermediario text,
    estado_reg character varying(15),
    beneficiario text,
    id_requerimiento integer NOT NULL
);


--
-- TOC entry 512 (class 1259 OID 210083)
-- Dependencies: 19 511
-- Name: contrato_id_contrato_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE contrato_id_contrato_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7264 (class 0 OID 0)
-- Dependencies: 512
-- Name: contrato_id_contrato_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE contrato_id_contrato_seq OWNED BY contrato.id_contrato;


--
-- TOC entry 513 (class 1259 OID 210085)
-- Dependencies: 19
-- Name: correspondencia; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE correspondencia (
    id_correspondencia integer NOT NULL,
    id_contrato integer,
    cite character varying(50),
    tipo_correspondencia text,
    remite text,
    recibe text,
    fecha_emision date,
    fecha_recepcion date,
    lugar_archivo text,
    doc_correspondencia text,
    contenido text,
    estado_reg character varying(15),
    obs text
);


--
-- TOC entry 514 (class 1259 OID 210091)
-- Dependencies: 513 19
-- Name: correspondencia_id_correspondencia_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE correspondencia_id_correspondencia_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7265 (class 0 OID 0)
-- Dependencies: 514
-- Name: correspondencia_id_correspondencia_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE correspondencia_id_correspondencia_seq OWNED BY correspondencia.id_correspondencia;


--
-- TOC entry 515 (class 1259 OID 210093)
-- Dependencies: 19
-- Name: doc_anexo; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE doc_anexo (
    id_documento integer NOT NULL,
    id_contrato integer,
    denominacion_doc text,
    desc_archivo text,
    doc_archivo text,
    obs text,
    estado_reg character varying(15)
);


--
-- TOC entry 516 (class 1259 OID 210099)
-- Dependencies: 515 19
-- Name: doc_anexo_id_documento_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE doc_anexo_id_documento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7266 (class 0 OID 0)
-- Dependencies: 516
-- Name: doc_anexo_id_documento_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE doc_anexo_id_documento_seq OWNED BY doc_anexo.id_documento;


--
-- TOC entry 517 (class 1259 OID 210101)
-- Dependencies: 19
-- Name: empleado; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE empleado (
    id_personal integer NOT NULL,
    id_persona integer NOT NULL,
    id_unidad integer,
    cod_empleado character varying(150),
    oficina text,
    regional text,
    gerencia text,
    cargo text,
    obs text,
    estado_reg character varying(15)
);


--
-- TOC entry 518 (class 1259 OID 210107)
-- Dependencies: 517 19
-- Name: empleado_id_personal_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE empleado_id_personal_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7267 (class 0 OID 0)
-- Dependencies: 518
-- Name: empleado_id_personal_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE empleado_id_personal_seq OWNED BY empleado.id_personal;


--
-- TOC entry 519 (class 1259 OID 210109)
-- Dependencies: 6082 19
-- Name: estado; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE estado (
    id_estado integer NOT NULL,
    nombre_estado character varying(100) NOT NULL,
    desc_estado character varying NOT NULL,
    orden integer NOT NULL,
    rango_inf integer NOT NULL,
    rango_sup integer NOT NULL,
    estado_reg character varying(15) DEFAULT 'activo'::character varying NOT NULL
);


--
-- TOC entry 520 (class 1259 OID 210116)
-- Dependencies: 19 519
-- Name: estado_id_estado_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE estado_id_estado_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7268 (class 0 OID 0)
-- Dependencies: 520
-- Name: estado_id_estado_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE estado_id_estado_seq OWNED BY estado.id_estado;


--
-- TOC entry 521 (class 1259 OID 210118)
-- Dependencies: 19
-- Name: estado_requerimiento; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE estado_requerimiento (
    id_estado_requerimiento integer NOT NULL,
    id_requerimiento integer,
    id_estado integer,
    fecha_ini date,
    fecha_fin date,
    estado_reg character varying(15),
    observaciones text
);


--
-- TOC entry 522 (class 1259 OID 210124)
-- Dependencies: 19 521
-- Name: estado_requerimiento_id_estado_requerimiento_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE estado_requerimiento_id_estado_requerimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7269 (class 0 OID 0)
-- Dependencies: 522
-- Name: estado_requerimiento_id_estado_requerimiento_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE estado_requerimiento_id_estado_requerimiento_seq OWNED BY estado_requerimiento.id_estado_requerimiento;


--
-- TOC entry 523 (class 1259 OID 210126)
-- Dependencies: 19
-- Name: garantia; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE garantia (
    id_garantia integer NOT NULL,
    id_contrato integer,
    tipo text,
    numero character varying(10),
    orden character varying(20),
    moneda character varying(50),
    monto_cifra double precision,
    fecha_vencimiento date,
    banco text,
    fecha_sus date,
    lugar_suc text,
    obs text,
    doc_garantia text,
    estado_reg character varying(15)
);


--
-- TOC entry 524 (class 1259 OID 210132)
-- Dependencies: 19 523
-- Name: garantia_id_garantia_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE garantia_id_garantia_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7270 (class 0 OID 0)
-- Dependencies: 524
-- Name: garantia_id_garantia_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE garantia_id_garantia_seq OWNED BY garantia.id_garantia;


--
-- TOC entry 525 (class 1259 OID 210134)
-- Dependencies: 19
-- Name: informe; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE informe (
    id_informe integer NOT NULL,
    id_contrato integer,
    contenido text,
    cod_informe character varying(50),
    remite text,
    recibido_por text,
    fecha_emision date,
    fecha_recepcion date,
    lugar_archivo text,
    doc_informe text,
    obs text,
    tipo_informe text,
    estado_reg character varying(15)
);


--
-- TOC entry 526 (class 1259 OID 210140)
-- Dependencies: 19 525
-- Name: informe_id_informe_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE informe_id_informe_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7271 (class 0 OID 0)
-- Dependencies: 526
-- Name: informe_id_informe_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE informe_id_informe_seq OWNED BY informe.id_informe;


--
-- TOC entry 527 (class 1259 OID 210142)
-- Dependencies: 19 508
-- Name: leg_alarma_id_alarma_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE leg_alarma_id_alarma_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7272 (class 0 OID 0)
-- Dependencies: 527
-- Name: leg_alarma_id_alarma_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE leg_alarma_id_alarma_seq OWNED BY alarma.id_alarma;


--
-- TOC entry 528 (class 1259 OID 210144)
-- Dependencies: 19
-- Name: oferta; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE oferta (
    id_oferta integer NOT NULL,
    id_contrato integer,
    nombre_ofertante text,
    descripcion_oferta text,
    fecha_emision date,
    lugar_archivo text,
    doc_oferta text,
    tomos integer,
    obs text,
    estado_reg character varying(15)
);


--
-- TOC entry 529 (class 1259 OID 210150)
-- Dependencies: 19 528
-- Name: oferta_id_oferta_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE oferta_id_oferta_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7273 (class 0 OID 0)
-- Dependencies: 529
-- Name: oferta_id_oferta_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE oferta_id_oferta_seq OWNED BY oferta.id_oferta;


--
-- TOC entry 530 (class 1259 OID 210152)
-- Dependencies: 19
-- Name: persona_juridica; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE persona_juridica (
    id_persona_juridica integer NOT NULL,
    nombre character varying(150),
    domicilio character varying(300),
    telefono character varying(100),
    correo character varying(100),
    pag_web character varying(150),
    obs text,
    estado_reg character varying(15)
);


--
-- TOC entry 531 (class 1259 OID 210158)
-- Dependencies: 530 19
-- Name: persona_juridica_id_persona_juridica_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE persona_juridica_id_persona_juridica_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7274 (class 0 OID 0)
-- Dependencies: 531
-- Name: persona_juridica_id_persona_juridica_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE persona_juridica_id_persona_juridica_seq OWNED BY persona_juridica.id_persona_juridica;


--
-- TOC entry 532 (class 1259 OID 210160)
-- Dependencies: 19
-- Name: proyecto; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE proyecto (
    id_proyecto integer NOT NULL,
    denominacion text,
    descripcion text,
    estado_reg character varying(15)
);


--
-- TOC entry 533 (class 1259 OID 210166)
-- Dependencies: 19 532
-- Name: proyecto_id_proyecto_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE proyecto_id_proyecto_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7275 (class 0 OID 0)
-- Dependencies: 533
-- Name: proyecto_id_proyecto_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE proyecto_id_proyecto_seq OWNED BY proyecto.id_proyecto;


--
-- TOC entry 534 (class 1259 OID 210168)
-- Dependencies: 19
-- Name: representante; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE representante (
    id_representante integer NOT NULL,
    id_contratista integer NOT NULL,
    cargo text,
    respaldo text,
    estado_reg character varying(15),
    obs text,
    id_persona integer NOT NULL
);


--
-- TOC entry 535 (class 1259 OID 210174)
-- Dependencies: 534 19
-- Name: representante_id_representante_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE representante_id_representante_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7276 (class 0 OID 0)
-- Dependencies: 535
-- Name: representante_id_representante_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE representante_id_representante_seq OWNED BY representante.id_representante;


--
-- TOC entry 536 (class 1259 OID 210176)
-- Dependencies: 19
-- Name: requerimiento; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE requerimiento (
    id_requerimiento integer NOT NULL,
    id_personal integer NOT NULL,
    emp_id_personal integer,
    fecha_requerimiento date NOT NULL,
    hora_requerimiento time without time zone NOT NULL,
    descripcion text NOT NULL,
    estado_reg character varying(15) NOT NULL,
    num_contrato numeric(10,0),
    id_unidad integer NOT NULL,
    nro_requerimiento integer NOT NULL
);


--
-- TOC entry 7277 (class 0 OID 0)
-- Dependencies: 536
-- Name: COLUMN requerimiento.id_personal; Type: COMMENT; Schema: secont; Owner: -
--

COMMENT ON COLUMN requerimiento.id_personal IS 'solicitante';


--
-- TOC entry 7278 (class 0 OID 0)
-- Dependencies: 536
-- Name: COLUMN requerimiento.emp_id_personal; Type: COMMENT; Schema: secont; Owner: -
--

COMMENT ON COLUMN requerimiento.emp_id_personal IS 'abogado';


--
-- TOC entry 537 (class 1259 OID 210182)
-- Dependencies: 19 536
-- Name: requerimiento_id_requerimiento_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE requerimiento_id_requerimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7279 (class 0 OID 0)
-- Dependencies: 537
-- Name: requerimiento_id_requerimiento_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE requerimiento_id_requerimiento_seq OWNED BY requerimiento.id_requerimiento;


--
-- TOC entry 538 (class 1259 OID 210184)
-- Dependencies: 19
-- Name: resolucion; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE resolucion (
    id_resolucion integer NOT NULL,
    id_contrato integer,
    numero_resolucion character varying(20),
    fecha_emision date,
    lugar_archivo text,
    doc_resolucion text,
    contenido text,
    obs text,
    tipo_resolucion text,
    estado_reg character varying(15)
);


--
-- TOC entry 539 (class 1259 OID 210190)
-- Dependencies: 538 19
-- Name: resolucion_id_resolucion_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE resolucion_id_resolucion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7280 (class 0 OID 0)
-- Dependencies: 539
-- Name: resolucion_id_resolucion_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE resolucion_id_resolucion_seq OWNED BY resolucion.id_resolucion;


--
-- TOC entry 540 (class 1259 OID 210192)
-- Dependencies: 19
-- Name: unidad; Type: TABLE; Schema: secont; Owner: -; Tablespace: 
--

CREATE TABLE unidad (
    id_unidad integer NOT NULL,
    cod_unidad character varying(50),
    nombre_unidad text,
    gerencia_unidad text,
    estado_reg character varying(15)
);


--
-- TOC entry 541 (class 1259 OID 210198)
-- Dependencies: 19 540
-- Name: unidad_id_unidad_seq; Type: SEQUENCE; Schema: secont; Owner: -
--

CREATE SEQUENCE unidad_id_unidad_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7281 (class 0 OID 0)
-- Dependencies: 541
-- Name: unidad_id_unidad_seq; Type: SEQUENCE OWNED BY; Schema: secont; Owner: -
--

ALTER SEQUENCE unidad_id_unidad_seq OWNED BY unidad.id_unidad;


--
-- TOC entry 542 (class 1259 OID 210200)
-- Dependencies: 5494 19
-- Name: v_contratista; Type: VIEW; Schema: secont; Owner: -
--

CREATE VIEW v_contratista AS
    SELECT c.id_contratista, c.id_persona_juridica, c.id_persona, c.nit, c.tipo, c.obs, c.estado_reg, (CASE WHEN (c.tipo = 'Persona Natural'::text) THEN (p.nombre_completo1)::character varying ELSE pj.nombre END)::text AS nombre, pj.nombre AS nombre_institucion, p.nombre_completo1 AS nombre_persona FROM ((contratista c LEFT JOIN persona_juridica pj ON ((pj.id_persona_juridica = c.id_persona_juridica))) LEFT JOIN segu.vpersona p ON ((c.id_persona = p.id_persona)));


--
-- TOC entry 543 (class 1259 OID 210205)
-- Dependencies: 5495 19
-- Name: v_empleado; Type: VIEW; Schema: secont; Owner: -
--

CREATE VIEW v_empleado AS
    SELECT p.id_persona, p.apellido_materno AS ap_materno, p.apellido_paterno AS ap_paterno, p.nombre, p.ci, e.id_personal, e.cod_empleado, e.cargo, e.estado_reg, e.gerencia, e.oficina, e.regional, e.obs, (((((COALESCE(p.nombre, ''::character varying))::text || ' '::text) || (COALESCE(p.apellido_paterno, ''::character varying))::text) || ' '::text) || (COALESCE(p.apellido_materno, ''::character varying))::text) AS nombre_completo1, (((((COALESCE(p.apellido_paterno, ''::character varying))::text || ' '::text) || (COALESCE(p.apellido_materno, ''::character varying))::text) || ' '::text) || (COALESCE(p.nombre, ''::character varying))::text) AS nombre_completo2, e.id_unidad, u.nombre_unidad FROM ((empleado e JOIN segu.tpersona p ON ((p.id_persona = e.id_persona))) LEFT JOIN unidad u ON ((e.id_unidad = u.id_unidad)));


--
-- TOC entry 544 (class 1259 OID 210210)
-- Dependencies: 5496 19
-- Name: v_estado_requerimiento; Type: VIEW; Schema: secont; Owner: -
--

CREATE VIEW v_estado_requerimiento AS
    SELECT er.id_estado_requerimiento, er.id_requerimiento, e.nombre_estado, er.fecha_ini, er.fecha_fin, er.observaciones, er.estado_reg FROM (estado_requerimiento er JOIN estado e ON ((er.id_estado = e.id_estado))) ORDER BY er.id_requerimiento, er.id_estado_requerimiento DESC;


--
-- TOC entry 545 (class 1259 OID 210214)
-- Dependencies: 5497 19
-- Name: v_requerimiento; Type: VIEW; Schema: secont; Owner: -
--

CREATE VIEW v_requerimiento AS
    SELECT req.id_requerimiento, req.fecha_requerimiento, req.estado_reg, req.descripcion, req.num_contrato, abo.id_personal AS id_personal_abo, abo.id_persona AS id_persona_abo, abo.nombre_completo2 AS nombre_completo_abo, sol.id_personal AS id_personal_sol, sol.id_persona AS id_persona_sol, sol.nombre_completo2 AS nombre_completo_sol, uni.id_unidad, uni.nombre_unidad, er.fecha_ini, er.id_estado, e.nombre_estado, e.orden, er.observaciones, req.nro_requerimiento FROM (((((requerimiento req JOIN v_empleado sol ON ((sol.id_personal = req.id_personal))) LEFT JOIN v_empleado abo ON ((abo.id_personal = req.id_personal))) JOIN unidad uni ON ((uni.id_unidad = req.id_unidad))) JOIN estado_requerimiento er ON (((er.id_requerimiento = req.id_requerimiento) AND ((er.estado_reg)::text = 'activo'::text)))) JOIN estado e ON ((e.id_estado = er.id_estado)));


SET search_path = segu, pg_catalog;

--
-- TOC entry 546 (class 1259 OID 210219)
-- Dependencies: 6094 6095 2216 20
-- Name: tactividad; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tactividad (
    id_actividad integer NOT NULL,
    nombre character varying(150) NOT NULL,
    descripcion character varying(500),
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL,
    codigo character varying
);


--
-- TOC entry 547 (class 1259 OID 210227)
-- Dependencies: 546 20
-- Name: actividad_id_actividad_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE actividad_id_actividad_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7282 (class 0 OID 0)
-- Dependencies: 547
-- Name: actividad_id_actividad_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE actividad_id_actividad_seq OWNED BY tactividad.id_actividad;


--
-- TOC entry 548 (class 1259 OID 210229)
-- Dependencies: 20
-- Name: clasificador_id_clasificador_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE clasificador_id_clasificador_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 549 (class 1259 OID 210231)
-- Dependencies: 6097 6098 2221 20 2216 2221
-- Name: testructura_dato; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE testructura_dato (
    id_estructura_dato integer NOT NULL,
    id_subsistema integer NOT NULL,
    nombre character varying(50),
    descripcion text,
    encripta si_no,
    log si_no,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL,
    tipo character varying(30) NOT NULL
);


--
-- TOC entry 550 (class 1259 OID 210239)
-- Dependencies: 549 20
-- Name: estructura_dato_id_estructura_dato_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE estructura_dato_id_estructura_dato_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7283 (class 0 OID 0)
-- Dependencies: 550
-- Name: estructura_dato_id_estructura_dato_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE estructura_dato_id_estructura_dato_seq OWNED BY testructura_dato.id_estructura_dato;


--
-- TOC entry 551 (class 1259 OID 210241)
-- Dependencies: 6100 6101 20 2216
-- Name: testructura_gui; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE testructura_gui (
    id_estructura_gui integer NOT NULL,
    id_gui integer NOT NULL,
    fk_id_gui integer NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL
);


--
-- TOC entry 552 (class 1259 OID 210249)
-- Dependencies: 551 20
-- Name: estructura_gui_id_estructura_gui_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE estructura_gui_id_estructura_gui_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7284 (class 0 OID 0)
-- Dependencies: 552
-- Name: estructura_gui_id_estructura_gui_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE estructura_gui_id_estructura_gui_seq OWNED BY testructura_gui.id_estructura_gui;


--
-- TOC entry 553 (class 1259 OID 210251)
-- Dependencies: 20
-- Name: funcion_id_funcion_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE funcion_id_funcion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 554 (class 1259 OID 210253)
-- Dependencies: 6103 2216 20
-- Name: tgui_rol; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tgui_rol (
    id_gui_rol integer NOT NULL,
    id_rol integer NOT NULL,
    id_gui integer NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo NOT NULL
);


--
-- TOC entry 555 (class 1259 OID 210260)
-- Dependencies: 20 554
-- Name: gui_rol_id_gui_rol_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE gui_rol_id_gui_rol_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7285 (class 0 OID 0)
-- Dependencies: 555
-- Name: gui_rol_id_gui_rol_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE gui_rol_id_gui_rol_seq OWNED BY tgui_rol.id_gui_rol;


--
-- TOC entry 556 (class 1259 OID 210262)
-- Dependencies: 20
-- Name: libreta; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE libreta (
    id_libreta integer NOT NULL,
    nombre character varying(15),
    telefono integer,
    obs text
);


--
-- TOC entry 557 (class 1259 OID 210268)
-- Dependencies: 203 20
-- Name: libreta_her; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE libreta_her (
    id_libreta_her integer NOT NULL,
    nombre character varying(12),
    telefono integer,
    obs text
)
INHERITS (public.tbase);


--
-- TOC entry 558 (class 1259 OID 210277)
-- Dependencies: 557 20
-- Name: libreta_her_id_libreta_her_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE libreta_her_id_libreta_her_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7286 (class 0 OID 0)
-- Dependencies: 558
-- Name: libreta_her_id_libreta_her_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE libreta_her_id_libreta_her_seq OWNED BY libreta_her.id_libreta_her;


--
-- TOC entry 559 (class 1259 OID 210279)
-- Dependencies: 556 20
-- Name: libreta_id_libreta_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE libreta_id_libreta_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7287 (class 0 OID 0)
-- Dependencies: 559
-- Name: libreta_id_libreta_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE libreta_id_libreta_seq OWNED BY libreta.id_libreta;


--
-- TOC entry 560 (class 1259 OID 210281)
-- Dependencies: 20
-- Name: log_id_log_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE log_id_log_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 561 (class 1259 OID 210283)
-- Dependencies: 6110 6111 2221 2216 20
-- Name: tpermiso; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tpermiso (
    id_permiso integer NOT NULL,
    id_procedimiento integer NOT NULL,
    id_estructura integer NOT NULL,
    permiso character varying(30),
    acceso si_no DEFAULT 'no'::character varying,
    descripcion text,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo NOT NULL
);


--
-- TOC entry 562 (class 1259 OID 210291)
-- Dependencies: 20 561
-- Name: permiso_id_permiso_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE permiso_id_permiso_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7288 (class 0 OID 0)
-- Dependencies: 562
-- Name: permiso_id_permiso_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE permiso_id_permiso_seq OWNED BY tpermiso.id_permiso;


--
-- TOC entry 563 (class 1259 OID 210293)
-- Dependencies: 20
-- Name: primo_id_primo_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE primo_id_primo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 564 (class 1259 OID 210295)
-- Dependencies: 6113 6114 2221 20 2182
-- Name: tprocedimiento_gui; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tprocedimiento_gui (
    id_procedimiento_gui integer NOT NULL,
    id_procedimiento integer NOT NULL,
    id_gui integer NOT NULL,
    boton si_no NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg public.estado_reg DEFAULT 'activo'::public.estado_reg NOT NULL
);


--
-- TOC entry 565 (class 1259 OID 210303)
-- Dependencies: 564 20
-- Name: procedimiento_gui_id_procedimiento_gui_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE procedimiento_gui_id_procedimiento_gui_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7289 (class 0 OID 0)
-- Dependencies: 565
-- Name: procedimiento_gui_id_procedimiento_gui_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE procedimiento_gui_id_procedimiento_gui_seq OWNED BY tprocedimiento_gui.id_procedimiento_gui;


--
-- TOC entry 566 (class 1259 OID 210305)
-- Dependencies: 20
-- Name: procedimiento_id_procedimiento_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE procedimiento_id_procedimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 567 (class 1259 OID 210307)
-- Dependencies: 6116 6117 6118 20
-- Name: tproyecto; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tproyecto (
    id_proyecto integer NOT NULL,
    nombre character varying(150) NOT NULL,
    descripcion character varying(500),
    fecha_reg timestamp(0) without time zone DEFAULT now(),
    estado_reg character varying(10) DEFAULT 'activo'::character varying NOT NULL,
    codigo character varying(20),
    id_usuario_reg integer,
    fecha_mod timestamp(0) without time zone DEFAULT now(),
    id_usuario_mod integer
);


--
-- TOC entry 568 (class 1259 OID 210316)
-- Dependencies: 20 567
-- Name: proyecto_id_proyecto_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE proyecto_id_proyecto_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7290 (class 0 OID 0)
-- Dependencies: 568
-- Name: proyecto_id_proyecto_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE proyecto_id_proyecto_seq OWNED BY tproyecto.id_proyecto;


--
-- TOC entry 569 (class 1259 OID 210318)
-- Dependencies: 5498 20
-- Name: prueba; Type: VIEW; Schema: segu; Owner: -
--

CREATE VIEW prueba AS
    SELECT pg_stat_activity.datid, pg_stat_activity.datname, pg_stat_activity.procpid, pg_stat_activity.usesysid, pg_stat_activity.usename, pg_stat_activity.application_name, pg_stat_activity.client_addr, pg_stat_activity.client_port, pg_stat_activity.backend_start, pg_stat_activity.xact_start, pg_stat_activity.query_start, pg_stat_activity.waiting, pg_stat_activity.current_query FROM pg_stat_activity;


--
-- TOC entry 570 (class 1259 OID 210322)
-- Dependencies: 6120 20 2216
-- Name: trecurso; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE trecurso (
    id_recurso integer NOT NULL,
    nombre character varying(50),
    valor character varying(50) NOT NULL,
    observaciones text,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo NOT NULL
);


--
-- TOC entry 571 (class 1259 OID 210329)
-- Dependencies: 20 570
-- Name: recurso_id_recurso_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE recurso_id_recurso_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7291 (class 0 OID 0)
-- Dependencies: 571
-- Name: recurso_id_recurso_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE recurso_id_recurso_seq OWNED BY trecurso.id_recurso;


--
-- TOC entry 572 (class 1259 OID 210331)
-- Dependencies: 20
-- Name: regional_id_regional_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE regional_id_regional_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 573 (class 1259 OID 210333)
-- Dependencies: 20
-- Name: rol_id_rol_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE rol_id_rol_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 574 (class 1259 OID 210335)
-- Dependencies: 6122 2216 20
-- Name: trol_procedimiento_gui; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE trol_procedimiento_gui (
    id_rol_procedimiento integer NOT NULL,
    id_procedimiento_gui integer NOT NULL,
    id_rol integer,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo NOT NULL
);


--
-- TOC entry 575 (class 1259 OID 210342)
-- Dependencies: 20 574
-- Name: rol_procedimiento_id_rol_procedimiento_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE rol_procedimiento_id_rol_procedimiento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7292 (class 0 OID 0)
-- Dependencies: 575
-- Name: rol_procedimiento_id_rol_procedimiento_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE rol_procedimiento_id_rol_procedimiento_seq OWNED BY trol_procedimiento_gui.id_rol_procedimiento;


--
-- TOC entry 576 (class 1259 OID 210344)
-- Dependencies: 20
-- Name: subsistema_id_subsistema_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE subsistema_id_subsistema_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


SET default_with_oids = true;

--
-- TOC entry 577 (class 1259 OID 210346)
-- Dependencies: 20
-- Name: tbloqueo_notificacion; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tbloqueo_notificacion (
    id_bloqueo_notificacion integer NOT NULL,
    id_patron_evento integer NOT NULL,
    nombre_patron character varying(100) NOT NULL,
    fecha_hora_ini timestamp(0) without time zone NOT NULL,
    fecha_hora_fin timestamp(0) without time zone NOT NULL,
    estado_reg character varying(10) NOT NULL,
    id_usuario integer,
    usuario character varying(50),
    ip character varying(50) NOT NULL,
    tipo character varying(15) NOT NULL,
    aplicacion character varying(15) NOT NULL,
    tipo_evento character varying(35)
);
ALTER TABLE ONLY tbloqueo_notificacion ALTER COLUMN id_bloqueo_notificacion SET STATISTICS 0;


--
-- TOC entry 578 (class 1259 OID 210349)
-- Dependencies: 577 20
-- Name: tbloqueo_notificacion_id_bloqueo_notificacion_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE tbloqueo_notificacion_id_bloqueo_notificacion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7293 (class 0 OID 0)
-- Dependencies: 578
-- Name: tbloqueo_notificacion_id_bloqueo_notificacion_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE tbloqueo_notificacion_id_bloqueo_notificacion_seq OWNED BY tbloqueo_notificacion.id_bloqueo_notificacion;


SET default_with_oids = false;

--
-- TOC entry 579 (class 1259 OID 210351)
-- Dependencies: 6125 6126 6127 20 2216
-- Name: tclasificador; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tclasificador (
    id_clasificador integer DEFAULT nextval(('"segu"."clasificador_id_clasificador_seq"'::text)::regclass) NOT NULL,
    codigo character varying(20),
    descripcion text,
    prioridad integer,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL
);


--
-- TOC entry 580 (class 1259 OID 210360)
-- Dependencies: 20
-- Name: temp_menu_prueba; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE temp_menu_prueba (
    id_gui integer,
    nombre character varying(50),
    descripcion text,
    nivel integer,
    orden_logico integer,
    ruta_archivo text,
    clase_vista character varying(100),
    "case" character varying
);


--
-- TOC entry 581 (class 1259 OID 210366)
-- Dependencies: 6128 6129 6130 6131 20 2216
-- Name: tfuncion; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tfuncion (
    id_funcion integer DEFAULT nextval(('"segu"."funcion_id_funcion_seq"'::text)::regclass) NOT NULL,
    nombre character varying(50),
    descripcion text,
    fecha_reg date DEFAULT now() NOT NULL,
    id_subsistema integer NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::public.estado_reg NOT NULL,
    CONSTRAINT chk_id_subsistema CHECK ((id_subsistema > 0))
);


--
-- TOC entry 582 (class 1259 OID 210376)
-- Dependencies: 6132 6133 6134 2182 20 2221
-- Name: tgui; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tgui (
    id_gui integer DEFAULT nextval(('"segu"."tgui_id_gui_seq"'::text)::regclass) NOT NULL,
    nombre character varying(50),
    descripcion text,
    fecha_reg date DEFAULT now() NOT NULL,
    codigo_gui character varying(30),
    visible si_no,
    orden_logico integer,
    ruta_archivo text,
    nivel integer,
    icono character varying(50),
    id_subsistema integer,
    clase_vista character varying(100),
    estado_reg public.estado_reg DEFAULT 'activo'::public.estado_reg NOT NULL
);


--
-- TOC entry 7294 (class 0 OID 0)
-- Dependencies: 582
-- Name: COLUMN tgui.clase_vista; Type: COMMENT; Schema: segu; Owner: -
--

COMMENT ON COLUMN tgui.clase_vista IS 'para las interfaces de nivel 2, que corren llamadas directamente por el menu, se necesita el nombre de la clase de la interface en la capa de vista';


--
-- TOC entry 583 (class 1259 OID 210385)
-- Dependencies: 20
-- Name: tgui_id_gui_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE tgui_id_gui_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


SET default_with_oids = true;

--
-- TOC entry 584 (class 1259 OID 210387)
-- Dependencies: 20
-- Name: thorario_trabajo; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE thorario_trabajo (
    id_horario_trabajo integer NOT NULL,
    dia_semana integer,
    hora_ini time(0) without time zone,
    hora_fin time(0) without time zone
);
ALTER TABLE ONLY thorario_trabajo ALTER COLUMN dia_semana SET STATISTICS 0;


--
-- TOC entry 585 (class 1259 OID 210390)
-- Dependencies: 584 20
-- Name: thorario_trabajo_id_horario_trabajo_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE thorario_trabajo_id_horario_trabajo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7295 (class 0 OID 0)
-- Dependencies: 585
-- Name: thorario_trabajo_id_horario_trabajo_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE thorario_trabajo_id_horario_trabajo_seq OWNED BY thorario_trabajo.id_horario_trabajo;


SET default_with_oids = false;

--
-- TOC entry 586 (class 1259 OID 210392)
-- Dependencies: 6136 6137 20 2182
-- Name: ttipo_documento; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE ttipo_documento (
    id_tipo_documento integer NOT NULL,
    nombre character varying(15) NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg public.estado_reg DEFAULT 'activo'::public.estado_reg NOT NULL
);


--
-- TOC entry 587 (class 1259 OID 210397)
-- Dependencies: 20 586
-- Name: tipo_documento_id_tipo_documento_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE tipo_documento_id_tipo_documento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7296 (class 0 OID 0)
-- Dependencies: 587
-- Name: tipo_documento_id_tipo_documento_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE tipo_documento_id_tipo_documento_seq OWNED BY ttipo_documento.id_tipo_documento;


--
-- TOC entry 588 (class 1259 OID 210399)
-- Dependencies: 6139 6140 6141 2217 20 2216
-- Name: tlog_; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tlog_ (
    id_log integer DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass) NOT NULL,
    id_usuario integer,
    id_subsistema integer,
    id_procedimiento integer,
    mac_maquina character varying(30),
    ip_maquina character varying(30) NOT NULL,
    tipo_log error_advertencia_informativo,
    descripcion text,
    fecha_reg timestamp(0) without time zone DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL,
    procedimientos text NOT NULL,
    transaccion character varying(20) NOT NULL,
    consulta character varying
);


SET default_with_oids = true;

--
-- TOC entry 589 (class 1259 OID 210408)
-- Dependencies: 6143 6144 20
-- Name: tpatron_evento; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tpatron_evento (
    id_patron_evento integer NOT NULL,
    tipo_evento character varying(20) NOT NULL,
    operacion character varying,
    aplicacion character varying,
    cantidad_intentos integer,
    periodo_intentos numeric,
    tiempo_bloqueo numeric,
    email character varying,
    nombre_patron character varying(100),
    estado_reg character varying(20),
    CONSTRAINT tpatron_evento__aplicacion__chk CHECK ((((aplicacion)::text = 'usuario'::text) OR ((aplicacion)::text = 'ip'::text))),
    CONSTRAINT tpatron_evento__operacion__chk CHECK ((((operacion)::text = 'bloqueo'::text) OR ((operacion)::text = 'notificacion'::text)))
);


--
-- TOC entry 590 (class 1259 OID 210416)
-- Dependencies: 589 20
-- Name: tpatron_evento_id_patron_evento_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE tpatron_evento_id_patron_evento_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7297 (class 0 OID 0)
-- Dependencies: 590
-- Name: tpatron_evento_id_patron_evento_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE tpatron_evento_id_patron_evento_seq OWNED BY tpatron_evento.id_patron_evento;


SET default_with_oids = false;

--
-- TOC entry 591 (class 1259 OID 210418)
-- Dependencies: 6145 6146 6147 2216 20 2221
-- Name: tperfil; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tperfil (
    id_perfil integer NOT NULL,
    perfil character varying(30),
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL,
    defecto si_no DEFAULT 'si'::character varying NOT NULL,
    id_recurso integer
);


--
-- TOC entry 592 (class 1259 OID 210427)
-- Dependencies: 20 426
-- Name: tpersona_id_persona_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE tpersona_id_persona_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7298 (class 0 OID 0)
-- Dependencies: 592
-- Name: tpersona_id_persona_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE tpersona_id_persona_seq OWNED BY tpersona.id_persona;


--
-- TOC entry 593 (class 1259 OID 210429)
-- Dependencies: 6148 20
-- Name: tprimo; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tprimo (
    id_primo integer DEFAULT nextval(('"segu"."primo_id_primo_seq"'::text)::regclass) NOT NULL,
    numero integer
);


--
-- TOC entry 594 (class 1259 OID 210433)
-- Dependencies: 6149 6150 6151 6152 2221 20 2182
-- Name: tprocedimiento; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tprocedimiento (
    id_procedimiento integer DEFAULT nextval(('"segu"."procedimiento_id_procedimiento_seq"'::text)::regclass) NOT NULL,
    id_funcion integer,
    codigo character varying(20) NOT NULL,
    descripcion text NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    habilita_log si_no DEFAULT 'si'::character varying NOT NULL,
    estado_reg public.estado_reg DEFAULT 'activo'::public.estado_reg NOT NULL,
    autor character varying(100),
    fecha_creacion character varying(40)
);


--
-- TOC entry 595 (class 1259 OID 210443)
-- Dependencies: 6153 6154 20 2182
-- Name: tregional; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tregional (
    id_regional integer DEFAULT nextval(('"segu"."regional_id_regional_seq"'::text)::regclass) NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    nombre character varying(150) NOT NULL,
    descripcion character varying(500),
    estado_reg public.estado_reg
);


--
-- TOC entry 596 (class 1259 OID 210451)
-- Dependencies: 6155 6156 6157 2216 20
-- Name: trol; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE trol (
    id_rol integer DEFAULT nextval(('"segu"."rol_id_rol_seq"'::text)::regclass) NOT NULL,
    descripcion text,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL,
    rol character varying(150),
    id_subsistema integer
);


SET default_with_oids = true;

--
-- TOC entry 597 (class 1259 OID 210460)
-- Dependencies: 6158 2182 20
-- Name: tsesion; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tsesion (
    id_sesion bigint NOT NULL,
    variable text NOT NULL,
    ip character varying(20) NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    id_usuario integer,
    estado_reg public.estado_reg,
    hora_act time(0) without time zone NOT NULL,
    hora_des time(0) without time zone,
    datos text,
    pid_web integer,
    pid_bd integer,
    transaccion_actual character varying,
    funcion_actual character varying,
    inicio_proceso timestamp(0) without time zone
);
ALTER TABLE ONLY tsesion ALTER COLUMN fecha_reg SET STATISTICS 0;


--
-- TOC entry 598 (class 1259 OID 210467)
-- Dependencies: 597 20
-- Name: tsesion_id_sesion_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE tsesion_id_sesion_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7299 (class 0 OID 0)
-- Dependencies: 598
-- Name: tsesion_id_sesion_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE tsesion_id_sesion_seq OWNED BY tsesion.id_sesion;


SET default_with_oids = false;

--
-- TOC entry 599 (class 1259 OID 210469)
-- Dependencies: 6160 6161 6162 20 2182
-- Name: tsubsistema; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tsubsistema (
    id_subsistema integer DEFAULT nextval(('"segu"."tsubsistema_id_subsistema_seq"'::text)::regclass) NOT NULL,
    codigo character varying(20) NOT NULL,
    nombre character varying(50) NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    prefijo character varying(10) NOT NULL,
    estado_reg public.estado_reg DEFAULT 'activo'::public.estado_reg NOT NULL,
    nombre_carpeta character varying(50),
    id_subsis_orig integer
);


--
-- TOC entry 600 (class 1259 OID 210475)
-- Dependencies: 20
-- Name: tsubsistema_id_subsistema_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE tsubsistema_id_subsistema_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 601 (class 1259 OID 210477)
-- Dependencies: 6163 2216 20
-- Name: tusuario_actividad; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tusuario_actividad (
    id_usuario_actividad integer NOT NULL,
    id_usuario integer NOT NULL,
    id_actividad integer NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo NOT NULL
);


--
-- TOC entry 602 (class 1259 OID 210484)
-- Dependencies: 6165 6166 20 2216
-- Name: tusuario_perfil; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tusuario_perfil (
    id_usuario_perfil integer NOT NULL,
    id_usuario integer,
    id_perfil integer,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL
);


--
-- TOC entry 603 (class 1259 OID 210492)
-- Dependencies: 6167 2216 20
-- Name: tusuario_proyecto; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tusuario_proyecto (
    id_usuario_proyecto integer NOT NULL,
    id_usuario integer NOT NULL,
    id_proyecto integer NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo NOT NULL
);


--
-- TOC entry 604 (class 1259 OID 210499)
-- Dependencies: 6169 6170 6171 2216 20
-- Name: tusuario_regional; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tusuario_regional (
    id_usuario_regional integer DEFAULT nextval(('"segu"."usuario_regional_id_usuario_regional_seq"'::text)::regclass) NOT NULL,
    id_regional integer NOT NULL,
    id_usuario integer NOT NULL,
    fecha_reg date DEFAULT now() NOT NULL,
    estado_reg activo_inactivo DEFAULT 'activo'::character varying NOT NULL
);


--
-- TOC entry 605 (class 1259 OID 210508)
-- Dependencies: 6172 6173 20 2182
-- Name: tusuario_rol; Type: TABLE; Schema: segu; Owner: -; Tablespace: 
--

CREATE TABLE tusuario_rol (
    id_usuario_rol integer DEFAULT nextval(('"segu"."usuario_rol_id_usuario_rol_seq"'::text)::regclass) NOT NULL,
    id_rol integer NOT NULL,
    id_usuario integer NOT NULL,
    fecha_reg date,
    estado_reg public.estado_reg DEFAULT 'activo'::public.estado_reg NOT NULL
);


--
-- TOC entry 606 (class 1259 OID 210513)
-- Dependencies: 601 20
-- Name: usuario_actividad_id_usuario_actividad_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE usuario_actividad_id_usuario_actividad_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7300 (class 0 OID 0)
-- Dependencies: 606
-- Name: usuario_actividad_id_usuario_actividad_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE usuario_actividad_id_usuario_actividad_seq OWNED BY tusuario_actividad.id_usuario_actividad;


--
-- TOC entry 607 (class 1259 OID 210515)
-- Dependencies: 20
-- Name: usuario_id_usuario_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE usuario_id_usuario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 608 (class 1259 OID 210517)
-- Dependencies: 603 20
-- Name: usuario_proyecto_id_usuario_proyecto_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE usuario_proyecto_id_usuario_proyecto_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7301 (class 0 OID 0)
-- Dependencies: 608
-- Name: usuario_proyecto_id_usuario_proyecto_seq; Type: SEQUENCE OWNED BY; Schema: segu; Owner: -
--

ALTER SEQUENCE usuario_proyecto_id_usuario_proyecto_seq OWNED BY tusuario_proyecto.id_usuario_proyecto;


--
-- TOC entry 609 (class 1259 OID 210519)
-- Dependencies: 20
-- Name: usuario_regional_id_usuario_regional_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE usuario_regional_id_usuario_regional_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 610 (class 1259 OID 210521)
-- Dependencies: 20
-- Name: usuario_rol_id_usuario_rol_seq; Type: SEQUENCE; Schema: segu; Owner: -
--

CREATE SEQUENCE usuario_rol_id_usuario_rol_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 611 (class 1259 OID 210523)
-- Dependencies: 5499 20 2216
-- Name: vlog; Type: VIEW; Schema: segu; Owner: -
--

CREATE VIEW vlog AS
    SELECT tlog.id_log, tlog.id_usuario, tlog.id_subsistema, tlog.mac_maquina, tlog.ip_maquina, tlog.tipo_log, tlog.descripcion, tlog.fecha_reg, tlog.estado_reg, tlog.procedimientos, tlog.transaccion, tlog.consulta, tlog.tiempo_ejecucion, tlog.usuario_base, tlog.codigo_error, tlog.dia_semana, tlog.pid_db, tlog.pid_web, tlog.sid_web, tlog.cuenta_usuario, tlog.descripcion_transaccion, tlog.codigo_subsistema FROM tlog WHERE ((tlog.fecha_reg >= (now() - '24:00:00'::interval)) AND (tlog.fecha_reg <= now()));


--
-- TOC entry 612 (class 1259 OID 210528)
-- Dependencies: 5500 20
-- Name: vmonitor_bd_esquema; Type: VIEW; Schema: segu; Owner: -
--

CREATE VIEW vmonitor_bd_esquema AS
    SELECT (n.oid)::integer AS nspoid, (ut.schemaname)::character varying AS schemaname, (u.usename)::character varying AS usename, (SELECT count(pg_class.oid) AS count FROM pg_class WHERE ((pg_class.relnamespace = n.oid) AND (pg_class.relkind = 'r'::"char"))) AS cantidad_tablas, count(i.indexrelid) AS cantidad_indices, sum(ut.seq_scan) AS scaneos_secuenciales, sum(ut.seq_tup_read) AS tuplas_seq_leidas, sum(ut.idx_scan) AS indices_scaneados, sum(ut.idx_tup_fetch) AS tuplas_idx_leidas, sum(ut.n_tup_ins) AS tuplas_insertadas, sum(ut.n_tup_upd) AS tuplas_actualizadas, sum(ut.n_tup_del) AS tuplas_borradas, sum(ut.n_tup_hot_upd) AS tuplas_actualizadas_hot, sum(ut.n_live_tup) AS tuplas_vivas, sum(ut.n_dead_tup) AS tuplas_muertas, sum(uiot.heap_blks_read) AS bloques_leidos_disco_tabla, sum(uiot.heap_blks_hit) AS bloques_leidos_buffer_tabla, sum(uiot.idx_blks_read) AS bloques_leidos_disco_indice, sum(uiot.idx_blks_hit) AS bloques_leidos_buffer_indice, sum(uiot.toast_blks_read) AS bloques_leidos_disco_toast, sum(uiot.toast_blks_hit) AS bloques_leidos_buffer_toast, sum(uiot.tidx_blks_read) AS bloques_leidos_disco_toast_indice, sum(uiot.tidx_blks_hit) AS bloques_leidos_buffer_toast_indice, sum((c.relpages * 8)) AS kb_tablas, sum((ci.relpages * 8)) AS kb_indices FROM ((((((pg_stat_user_tables ut JOIN pg_statio_user_tables uiot ON ((ut.relid = uiot.relid))) JOIN pg_class c ON ((c.oid = ut.relid))) JOIN pg_namespace n ON ((n.oid = c.relnamespace))) JOIN pg_user u ON ((n.nspowner = u.usesysid))) LEFT JOIN pg_index i ON ((i.indrelid = c.oid))) LEFT JOIN pg_class ci ON ((ci.oid = i.indexrelid))) WHERE (ut.schemaname !~~ 'pg_temp%'::text) GROUP BY n.oid, ut.schemaname, u.usename;


--
-- TOC entry 613 (class 1259 OID 210533)
-- Dependencies: 5501 20
-- Name: vmonitor_bd_funcion; Type: VIEW; Schema: segu; Owner: -
--

CREATE VIEW vmonitor_bd_funcion AS
    SELECT (pro.oid)::integer AS oid, (pro.pronamespace)::integer AS pronamespace, (pro.proname)::character varying AS proname, (CASE WHEN pro.prosecdef THEN 'si'::text ELSE 'no'::text END)::character varying AS setuid, (u.usename)::character varying AS usename FROM (pg_proc pro JOIN pg_user u ON ((pro.proowner = u.usesysid)));


--
-- TOC entry 614 (class 1259 OID 210538)
-- Dependencies: 5502 20
-- Name: vmonitor_bd_indice; Type: VIEW; Schema: segu; Owner: -
--

CREATE VIEW vmonitor_bd_indice AS
    SELECT (ui.relid)::integer AS relid, (ui.indexrelid)::integer AS indexrelid, (ui.indexrelname)::character varying AS indexrelname, ui.idx_scan AS numero_index_scan, ui.idx_tup_read AS numero_indices_devueltos, ui.idx_tup_fetch AS numero_tuplas_vivas, ioi.idx_blks_read AS bloques_disco_leidos, ioi.idx_blks_hit AS bloques_buffer_leidos FROM (pg_stat_user_indexes ui JOIN pg_statio_user_indexes ioi ON ((ui.indexrelid = ioi.indexrelid)));


--
-- TOC entry 615 (class 1259 OID 210542)
-- Dependencies: 5503 20
-- Name: vmonitor_bd_tabla; Type: VIEW; Schema: segu; Owner: -
--

CREATE VIEW vmonitor_bd_tabla AS
    SELECT (c.oid)::integer AS oid, (c.relnamespace)::integer AS relnamespace, (c.relname)::character varying AS relname, (u.usename)::character varying AS usename, to_char(ut.last_vacuum, 'DD/MM/YYYY HH24:MI'::text) AS last_vacuum, to_char(ut.last_autovacuum, 'DD/MM/YYYY HH24:MI'::text) AS last_autovacuum, to_char(ut.last_analyze, 'DD/MM/YYYY HH24:MI'::text) AS last_analyze, to_char(ut.last_autoanalyze, 'DD/MM/YYYY HH24:MI'::text) AS last_autoanalyze, count(i.indexrelid) AS cantidad_indices, (SELECT count(*) AS count FROM pg_trigger WHERE ((pg_trigger.tgrelid = c.oid) AND (pg_trigger.tgisinternal = false))) AS cantidad_triggers, (ut.seq_scan)::numeric AS scaneos_secuenciales, (ut.seq_tup_read)::numeric AS tuplas_seq_leidas, (ut.idx_scan)::numeric AS indices_scaneados, (ut.idx_tup_fetch)::numeric AS tuplas_idx_leidas, (ut.n_tup_ins)::numeric AS tuplas_insertadas, (ut.n_tup_upd)::numeric AS tuplas_actualizadas, (ut.n_tup_del)::numeric AS tuplas_borradas, (ut.n_tup_hot_upd)::numeric AS tuplas_actualizadas_hot, (ut.n_live_tup)::numeric AS tuplas_vivas, (ut.n_dead_tup)::numeric AS tuplas_muertas, (uiot.heap_blks_read)::numeric AS bloques_leidos_disco_tabla, (uiot.heap_blks_hit)::numeric AS bloques_leidos_buffer_tabla, (uiot.idx_blks_read)::numeric AS bloques_leidos_disco_indice, (uiot.idx_blks_hit)::numeric AS bloques_leidos_buffer_indice, (uiot.toast_blks_read)::numeric AS bloques_leidos_disco_toast, (uiot.toast_blks_hit)::numeric AS bloques_leidos_buffer_toast, (uiot.tidx_blks_read)::numeric AS bloques_leidos_disco_toast_indice, (uiot.tidx_blks_hit)::numeric AS bloques_leidos_buffer_toast_indice, ((c.relpages * 8))::numeric AS kb_tabla, (sum((ci.relpages * 8)))::numeric AS kb_indices FROM (((((pg_stat_user_tables ut JOIN pg_statio_user_tables uiot ON ((ut.relid = uiot.relid))) JOIN pg_class c ON ((c.oid = ut.relid))) JOIN pg_user u ON ((c.relowner = u.usesysid))) LEFT JOIN pg_index i ON ((i.indrelid = c.oid))) LEFT JOIN pg_class ci ON ((ci.oid = i.indexrelid))) GROUP BY c.oid, c.relnamespace, c.relname, u.usename, c.relhastriggers, ut.last_vacuum, ut.last_autovacuum, ut.last_analyze, ut.last_autoanalyze, ut.seq_scan, ut.seq_tup_read, ut.idx_scan, ut.idx_tup_fetch, ut.n_tup_ins, ut.n_tup_upd, ut.n_tup_del, ut.n_tup_hot_upd, ut.n_live_tup, ut.n_dead_tup, uiot.heap_blks_read, uiot.heap_blks_hit, uiot.idx_blks_read, uiot.idx_blks_hit, uiot.toast_blks_read, uiot.toast_blks_hit, uiot.tidx_blks_read, uiot.tidx_blks_hit, (c.relpages * 8);


SET search_path = tesor, pg_catalog;

--
-- TOC entry 616 (class 1259 OID 210547)
-- Dependencies: 21 203
-- Name: tcaja; Type: TABLE; Schema: tesor; Owner: -; Tablespace: 
--

CREATE TABLE tcaja (
    id_caja integer NOT NULL,
    codigo character varying(20) NOT NULL,
    descripcion character varying(200) NOT NULL,
    estado_caja character varying(15)
)
INHERITS (public.tbase);


--
-- TOC entry 617 (class 1259 OID 210553)
-- Dependencies: 21 203
-- Name: tcaja_mov; Type: TABLE; Schema: tesor; Owner: -; Tablespace: 
--

CREATE TABLE tcaja_mov (
    id_caja_mov integer NOT NULL,
    tipo_mov character varying(15),
    estado_mov character varying(15),
    importe numeric,
    id_caja integer
)
INHERITS (public.tbase);


--
-- TOC entry 618 (class 1259 OID 210562)
-- Dependencies: 6183 21 203
-- Name: tcajero; Type: TABLE; Schema: tesor; Owner: -; Tablespace: 
--

CREATE TABLE tcajero (
    id_cajero integer DEFAULT nextval(('"tesor"."tcajero_id_cajero_seq"'::text)::regclass) NOT NULL,
    id_caja integer,
    id_funcionario integer,
    estado_cajero character varying
)
INHERITS (public.tbase);


--
-- TOC entry 619 (class 1259 OID 210572)
-- Dependencies: 21
-- Name: tcajero_id_cajero_seq; Type: SEQUENCE; Schema: tesor; Owner: -
--

CREATE SEQUENCE tcajero_id_cajero_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


--
-- TOC entry 620 (class 1259 OID 210574)
-- Dependencies: 6187 6188 21 203
-- Name: trecibo; Type: TABLE; Schema: tesor; Owner: -; Tablespace: 
--

CREATE TABLE trecibo (
    id_recibo integer NOT NULL,
    id_cajero integer,
    tipo_recibo character varying(20),
    importe numeric(18,2) NOT NULL,
    id_moneda integer,
    descripcion character varying(500),
    id_funcionario integer,
    codigo character varying(20),
    estado_recibo character varying(15) NOT NULL,
    tipo_ingreso_salida character varying(25) NOT NULL,
    nombre_recibo character varying(150) NOT NULL,
    CONSTRAINT chk__trecibo__tipo_ingreso_salida CHECK ((((((((tipo_ingreso_salida)::text = 'repocision'::text) OR ((tipo_ingreso_salida)::text = 'venta'::text)) OR ((tipo_ingreso_salida)::text = 'reposicion_recibo'::text)) OR ((tipo_ingreso_salida)::text = 'recibo_provisorio'::text)) OR ((tipo_ingreso_salida)::text = 'recibo_pago'::text)) OR ((tipo_ingreso_salida)::text = 'recibo_pago_cliente'::text))),
    CONSTRAINT chk__trecibo__tipo_recibo CHECK ((((tipo_recibo)::text = 'ingreso'::text) OR ((tipo_recibo)::text = 'salida'::text)))
)
INHERITS (public.tbase);


--
-- TOC entry 621 (class 1259 OID 210585)
-- Dependencies: 21 203
-- Name: trendicion; Type: TABLE; Schema: tesor; Owner: -; Tablespace: 
--

CREATE TABLE trendicion (
    id_rendicion integer NOT NULL,
    id_recibo integer NOT NULL,
    id_documento integer NOT NULL
)
INHERITS (public.tbase);


SET search_path = tesoro, pg_catalog;

--
-- TOC entry 622 (class 1259 OID 210591)
-- Dependencies: 22
-- Name: tts_corte_moneda; Type: TABLE; Schema: tesoro; Owner: -; Tablespace: 
--

CREATE TABLE tts_corte_moneda (
    id_corte integer NOT NULL,
    id_moneda integer NOT NULL,
    descri_corte character varying(50) NOT NULL,
    importe_valor numeric(18,2) NOT NULL,
    tipo_corte numeric(1,0) NOT NULL
);


--
-- TOC entry 7302 (class 0 OID 0)
-- Dependencies: 622
-- Name: TABLE tts_corte_moneda; Type: COMMENT; Schema: tesoro; Owner: -
--

COMMENT ON TABLE tts_corte_moneda IS 'sistema=Tesoreria&codigo=CORMON&prefijo=TS&titulo=Corte Moneda&desc=Corte Moneda&num_dt=3&dt_1=id_moneda&dt_2=importe_valor&dt_3=tipo_corte';


--
-- TOC entry 7303 (class 0 OID 0)
-- Dependencies: 622
-- Name: COLUMN tts_corte_moneda.id_corte; Type: COMMENT; Schema: tesoro; Owner: -
--

COMMENT ON COLUMN tts_corte_moneda.id_corte IS 'nombre=id_corte&label=id_corte&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=id_corte';


--
-- TOC entry 7304 (class 0 OID 0)
-- Dependencies: 622
-- Name: COLUMN tts_corte_moneda.id_moneda; Type: COMMENT; Schema: tesoro; Owner: -
--

COMMENT ON COLUMN tts_corte_moneda.id_moneda IS 'nombre=id_moneda&label=Moneda&grid_visible=si&grid_editable=no&disabled=no&width_grid=90&width=100%&filtro=si&defecto=&desc=id_moneda';


--
-- TOC entry 7305 (class 0 OID 0)
-- Dependencies: 622
-- Name: COLUMN tts_corte_moneda.descri_corte; Type: COMMENT; Schema: tesoro; Owner: -
--

COMMENT ON COLUMN tts_corte_moneda.descri_corte IS 'nombre=descri_corte&label=Descripción&grid_visible=si&grid_editable=no&disabled=no&width_grid=150&width=100%&filtro=si&defecto=&desc=descri_corte';


--
-- TOC entry 7306 (class 0 OID 0)
-- Dependencies: 622
-- Name: COLUMN tts_corte_moneda.importe_valor; Type: COMMENT; Schema: tesoro; Owner: -
--

COMMENT ON COLUMN tts_corte_moneda.importe_valor IS 'nombre=importe_valor&label=Valor&grid_visible=si&grid_editable=no&disabled=no&width_grid=100&width=100%&filtro=si&defecto=&desc=importe_valor';


--
-- TOC entry 7307 (class 0 OID 0)
-- Dependencies: 622
-- Name: COLUMN tts_corte_moneda.tipo_corte; Type: COMMENT; Schema: tesoro; Owner: -
--

COMMENT ON COLUMN tts_corte_moneda.tipo_corte IS 'nombre=tipo_corte&label=Tipo&grid_visible=si&grid_editable=no&disabled=no&width_grid=120&width=100%&filtro=si&defecto=&desc=tipo_corte';


--
-- TOC entry 623 (class 1259 OID 210594)
-- Dependencies: 22 622
-- Name: tts_corte_moneda_id_corte_seq; Type: SEQUENCE; Schema: tesoro; Owner: -
--

CREATE SEQUENCE tts_corte_moneda_id_corte_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- TOC entry 7308 (class 0 OID 0)
-- Dependencies: 623
-- Name: tts_corte_moneda_id_corte_seq; Type: SEQUENCE OWNED BY; Schema: tesoro; Owner: -
--

ALTER SEQUENCE tts_corte_moneda_id_corte_seq OWNED BY tts_corte_moneda.id_corte;


SET search_path = actif, pg_catalog;

--
-- TOC entry 5518 (class 2604 OID 210596)
-- Dependencies: 205 204
-- Name: id_activo_fijo; Type: DEFAULT; Schema: actif; Owner: -
--

ALTER TABLE ONLY taf_activo_fijo ALTER COLUMN id_activo_fijo SET DEFAULT nextval('taf_activo_fijo_id_activo_fijo_seq'::regclass);


--
-- TOC entry 5527 (class 2604 OID 210597)
-- Dependencies: 207 206
-- Name: id_sub_tipo_activo; Type: DEFAULT; Schema: actif; Owner: -
--

ALTER TABLE ONLY taf_sub_tipo_activo ALTER COLUMN id_sub_tipo_activo SET DEFAULT nextval('taf_sub_tipo_activo_id_sub_tipo_activo_seq'::regclass);


SET search_path = cobra, pg_catalog;

--
-- TOC entry 5540 (class 2604 OID 208612)
-- Dependencies: 211 211
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_agencia ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5541 (class 2604 OID 208613)
-- Dependencies: 211 211
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_agencia ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5542 (class 2604 OID 208614)
-- Dependencies: 211 211
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_agencia ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5543 (class 2604 OID 210598)
-- Dependencies: 212 211
-- Name: id_agencia; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_agencia ALTER COLUMN id_agencia SET DEFAULT nextval('tcb_agencia_id_agencia_seq'::regclass);


--
-- TOC entry 5544 (class 2604 OID 208623)
-- Dependencies: 213 213
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_arqueo ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5545 (class 2604 OID 208624)
-- Dependencies: 213 213
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_arqueo ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5546 (class 2604 OID 208625)
-- Dependencies: 213 213
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_arqueo ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5547 (class 2604 OID 210599)
-- Dependencies: 215 213
-- Name: id_arqueo; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_arqueo ALTER COLUMN id_arqueo SET DEFAULT nextval('tcb_arqueo_id_arqueo_seq'::regclass);


--
-- TOC entry 5548 (class 2604 OID 208632)
-- Dependencies: 214 214
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_arqueo_det ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5549 (class 2604 OID 208633)
-- Dependencies: 214 214
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_arqueo_det ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5550 (class 2604 OID 208634)
-- Dependencies: 214 214
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_arqueo_det ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5536 (class 2604 OID 208601)
-- Dependencies: 209 209
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_arqueo_estado ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5537 (class 2604 OID 208602)
-- Dependencies: 209 209
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_arqueo_estado ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5538 (class 2604 OID 208603)
-- Dependencies: 209 209
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_arqueo_estado ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5539 (class 2604 OID 210600)
-- Dependencies: 210 209
-- Name: id_arqueo_estado; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_arqueo_estado ALTER COLUMN id_arqueo_estado SET DEFAULT nextval('tarqueo_estado_id_arqueo_estado_seq'::regclass);


--
-- TOC entry 5551 (class 2604 OID 208640)
-- Dependencies: 216 216
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_caja ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5552 (class 2604 OID 208641)
-- Dependencies: 216 216
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_caja ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5553 (class 2604 OID 208642)
-- Dependencies: 216 216
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_caja ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5554 (class 2604 OID 210601)
-- Dependencies: 221 216
-- Name: id_caja; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_caja ALTER COLUMN id_caja SET DEFAULT nextval('tcb_caja_id_caja_seq'::regclass);


--
-- TOC entry 5555 (class 2604 OID 208649)
-- Dependencies: 217 217
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_caja_cajero ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5556 (class 2604 OID 208650)
-- Dependencies: 217 217
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_caja_cajero ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5557 (class 2604 OID 208651)
-- Dependencies: 217 217
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_caja_cajero ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5559 (class 2604 OID 208658)
-- Dependencies: 219 219
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_caja_estado ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5560 (class 2604 OID 208659)
-- Dependencies: 219 219
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_caja_estado ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5561 (class 2604 OID 208660)
-- Dependencies: 219 219
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_caja_estado ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5562 (class 2604 OID 210602)
-- Dependencies: 220 219
-- Name: id_caja_estado; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_caja_estado ALTER COLUMN id_caja_estado SET DEFAULT nextval('tcb_caja_estado_id_caja_estado_seq'::regclass);


--
-- TOC entry 5563 (class 2604 OID 208671)
-- Dependencies: 222 222
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_cajero ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5564 (class 2604 OID 208672)
-- Dependencies: 222 222
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_cajero ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5565 (class 2604 OID 208673)
-- Dependencies: 222 222
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_cajero ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5566 (class 2604 OID 210603)
-- Dependencies: 224 222
-- Name: id_cajero; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_cajero ALTER COLUMN id_cajero SET DEFAULT nextval('tcb_cajero_id_cajero_seq'::regclass);


--
-- TOC entry 5567 (class 2604 OID 208681)
-- Dependencies: 225 225
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_cliente ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5568 (class 2604 OID 208682)
-- Dependencies: 225 225
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_cliente ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5569 (class 2604 OID 208683)
-- Dependencies: 225 225
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_cliente ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5571 (class 2604 OID 208690)
-- Dependencies: 227 227
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_cobro ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5572 (class 2604 OID 208691)
-- Dependencies: 227 227
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_cobro ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5573 (class 2604 OID 208692)
-- Dependencies: 227 227
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_cobro ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5574 (class 2604 OID 210604)
-- Dependencies: 228 227
-- Name: id_cobro; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_cobro ALTER COLUMN id_cobro SET DEFAULT nextval('tcb_cobro_id_cobro_seq'::regclass);


--
-- TOC entry 5575 (class 2604 OID 208698)
-- Dependencies: 229 229
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_enti_fin ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5576 (class 2604 OID 208699)
-- Dependencies: 229 229
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_enti_fin ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5577 (class 2604 OID 208700)
-- Dependencies: 229 229
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_enti_fin ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5578 (class 2604 OID 210605)
-- Dependencies: 230 229
-- Name: id_enti_fin; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_enti_fin ALTER COLUMN id_enti_fin SET DEFAULT nextval('tcb_enti_fin2_id_enti_fin_seq'::regclass);


--
-- TOC entry 5579 (class 2604 OID 208706)
-- Dependencies: 231 231
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5580 (class 2604 OID 208707)
-- Dependencies: 231 231
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5581 (class 2604 OID 208708)
-- Dependencies: 231 231
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5582 (class 2604 OID 210606)
-- Dependencies: 236 231
-- Name: id_factura_cob; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob ALTER COLUMN id_factura_cob SET DEFAULT nextval('tcb_factura_cob_id_factura_cob_seq'::regclass);


--
-- TOC entry 5583 (class 2604 OID 208715)
-- Dependencies: 232 232
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob_anulado ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5584 (class 2604 OID 208716)
-- Dependencies: 232 232
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob_anulado ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5585 (class 2604 OID 208717)
-- Dependencies: 232 232
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob_anulado ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5586 (class 2604 OID 210607)
-- Dependencies: 233 232
-- Name: id_factura_cob_anulado; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob_anulado ALTER COLUMN id_factura_cob_anulado SET DEFAULT nextval('tcb_factura_cob_anulado_id_factura_cob_anulado_seq'::regclass);


--
-- TOC entry 5587 (class 2604 OID 208726)
-- Dependencies: 234 234
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob_det ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5588 (class 2604 OID 208727)
-- Dependencies: 234 234
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob_det ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5589 (class 2604 OID 208728)
-- Dependencies: 234 234
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob_det ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5590 (class 2604 OID 210608)
-- Dependencies: 235 234
-- Name: id_factura_cob_det; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob_det ALTER COLUMN id_factura_cob_det SET DEFAULT nextval('tcb_factura_cob_det_id_factura_cob_det_seq'::regclass);


--
-- TOC entry 5591 (class 2604 OID 208736)
-- Dependencies: 237 237
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_prueba ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5592 (class 2604 OID 208737)
-- Dependencies: 237 237
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_prueba ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5593 (class 2604 OID 208738)
-- Dependencies: 237 237
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_prueba ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5594 (class 2604 OID 210609)
-- Dependencies: 238 237
-- Name: id_prueba; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_prueba ALTER COLUMN id_prueba SET DEFAULT nextval('tcb_prueba_id_prueba_seq'::regclass);


--
-- TOC entry 5596 (class 2604 OID 208745)
-- Dependencies: 239 239
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_sistema_dist ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5597 (class 2604 OID 208746)
-- Dependencies: 239 239
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_sistema_dist ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5598 (class 2604 OID 208747)
-- Dependencies: 239 239
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_sistema_dist ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5600 (class 2604 OID 208752)
-- Dependencies: 240 240
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_sistema_dist_agencia ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5601 (class 2604 OID 208753)
-- Dependencies: 240 240
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_sistema_dist_agencia ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5602 (class 2604 OID 208754)
-- Dependencies: 240 240
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_sistema_dist_agencia ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5603 (class 2604 OID 210610)
-- Dependencies: 241 240
-- Name: id_sistema_dist_agencia; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_sistema_dist_agencia ALTER COLUMN id_sistema_dist_agencia SET DEFAULT nextval('tcb_sistema_dist_agencia_id_sistema_dist_agencia_seq'::regclass);


--
-- TOC entry 5604 (class 2604 OID 208762)
-- Dependencies: 243 243
-- Name: fecha_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_sistema_dist_usuario ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5605 (class 2604 OID 208763)
-- Dependencies: 243 243
-- Name: fecha_mod; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_sistema_dist_usuario ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5606 (class 2604 OID 208764)
-- Dependencies: 243 243
-- Name: estado_reg; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_sistema_dist_usuario ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5607 (class 2604 OID 210611)
-- Dependencies: 244 243
-- Name: id_sistema_dist_usuario; Type: DEFAULT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_sistema_dist_usuario ALTER COLUMN id_sistema_dist_usuario SET DEFAULT nextval('tcb_sistema_dist_usuario_id_sistema_dist_usuario_seq'::regclass);


SET search_path = conta, pg_catalog;

--
-- TOC entry 5610 (class 2604 OID 210612)
-- Dependencies: 247 246
-- Name: id_auxiliar; Type: DEFAULT; Schema: conta; Owner: -
--

ALTER TABLE ONLY tauxiliar ALTER COLUMN id_auxiliar SET DEFAULT nextval('tauxiliar_id_auxiliar_seq'::regclass);


--
-- TOC entry 5613 (class 2604 OID 210613)
-- Dependencies: 249 248
-- Name: id_cuenta; Type: DEFAULT; Schema: conta; Owner: -
--

ALTER TABLE ONLY tcuenta ALTER COLUMN id_cuenta SET DEFAULT nextval('tcuenta_id_cuenta_seq'::regclass);


--
-- TOC entry 5614 (class 2604 OID 208789)
-- Dependencies: 250 250
-- Name: fecha_reg; Type: DEFAULT; Schema: conta; Owner: -
--

ALTER TABLE ONLY tdocumento ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5615 (class 2604 OID 208790)
-- Dependencies: 250 250
-- Name: fecha_mod; Type: DEFAULT; Schema: conta; Owner: -
--

ALTER TABLE ONLY tdocumento ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5616 (class 2604 OID 208791)
-- Dependencies: 250 250
-- Name: estado_reg; Type: DEFAULT; Schema: conta; Owner: -
--

ALTER TABLE ONLY tdocumento ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5619 (class 2604 OID 208797)
-- Dependencies: 251 251
-- Name: fecha_reg; Type: DEFAULT; Schema: conta; Owner: -
--

ALTER TABLE ONLY tdocumento_tipo ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5620 (class 2604 OID 208798)
-- Dependencies: 251 251
-- Name: fecha_mod; Type: DEFAULT; Schema: conta; Owner: -
--

ALTER TABLE ONLY tdocumento_tipo ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5621 (class 2604 OID 208799)
-- Dependencies: 251 251
-- Name: estado_reg; Type: DEFAULT; Schema: conta; Owner: -
--

ALTER TABLE ONLY tdocumento_tipo ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


SET search_path = factur, pg_catalog;

--
-- TOC entry 5625 (class 2604 OID 210614)
-- Dependencies: 253 252
-- Name: id_descuento; Type: DEFAULT; Schema: factur; Owner: -
--

ALTER TABLE ONLY tfv_descuento ALTER COLUMN id_descuento SET DEFAULT nextval('tfv_descuento_id_descuento_seq'::regclass);


--
-- TOC entry 5629 (class 2604 OID 210615)
-- Dependencies: 255 254
-- Name: id_enti_fin; Type: DEFAULT; Schema: factur; Owner: -
--

ALTER TABLE ONLY tfv_entidad_fin ALTER COLUMN id_enti_fin SET DEFAULT nextval('tfv_entidad_fin_id_enti_fin_seq'::regclass);


--
-- TOC entry 5631 (class 2604 OID 210616)
-- Dependencies: 257 256
-- Name: id_tasa; Type: DEFAULT; Schema: factur; Owner: -
--

ALTER TABLE ONLY tfv_tasa ALTER COLUMN id_tasa SET DEFAULT nextval('tfv_tasa_id_tasa_seq'::regclass);


SET search_path = gem, pg_catalog;

--
-- TOC entry 6193 (class 2604 OID 313635)
-- Dependencies: 625 625
-- Name: fecha_reg; Type: DEFAULT; Schema: gem; Owner: -
--

ALTER TABLE ONLY tlocalizacion ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 6194 (class 2604 OID 313636)
-- Dependencies: 625 625
-- Name: fecha_mod; Type: DEFAULT; Schema: gem; Owner: -
--

ALTER TABLE ONLY tlocalizacion ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 6195 (class 2604 OID 313637)
-- Dependencies: 625 625
-- Name: estado_reg; Type: DEFAULT; Schema: gem; Owner: -
--

ALTER TABLE ONLY tlocalizacion ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 6196 (class 2604 OID 313638)
-- Dependencies: 624 625 625
-- Name: id_localizacion; Type: DEFAULT; Schema: gem; Owner: -
--

ALTER TABLE ONLY tlocalizacion ALTER COLUMN id_localizacion SET DEFAULT nextval('tlocalizacion_id_localizacion_seq'::regclass);


SET search_path = gen, pg_catalog;

--
-- TOC entry 5633 (class 2604 OID 208831)
-- Dependencies: 259 259
-- Name: fecha_reg; Type: DEFAULT; Schema: gen; Owner: -
--

ALTER TABLE ONLY tcolumna ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5634 (class 2604 OID 208832)
-- Dependencies: 259 259
-- Name: fecha_mod; Type: DEFAULT; Schema: gen; Owner: -
--

ALTER TABLE ONLY tcolumna ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5635 (class 2604 OID 208833)
-- Dependencies: 259 259
-- Name: estado_reg; Type: DEFAULT; Schema: gen; Owner: -
--

ALTER TABLE ONLY tcolumna ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5639 (class 2604 OID 208843)
-- Dependencies: 260 260
-- Name: fecha_reg; Type: DEFAULT; Schema: gen; Owner: -
--

ALTER TABLE ONLY ttabla ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5640 (class 2604 OID 208844)
-- Dependencies: 260 260
-- Name: fecha_mod; Type: DEFAULT; Schema: gen; Owner: -
--

ALTER TABLE ONLY ttabla ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5642 (class 2604 OID 210617)
-- Dependencies: 261 260
-- Name: id_tabla; Type: DEFAULT; Schema: gen; Owner: -
--

ALTER TABLE ONLY ttabla ALTER COLUMN id_tabla SET DEFAULT nextval('ttabla_id_tabla_seq1'::regclass);


SET search_path = gev, pg_catalog;

--
-- TOC entry 5650 (class 2604 OID 210618)
-- Dependencies: 266 265
-- Name: id_activo_fijo_grupo_evento; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_activo_fijo_grupo_evento ALTER COLUMN id_activo_fijo_grupo_evento SET DEFAULT nextval('tgv_activo_fijo_grupo_evento_id_activo_fijo_grupo_evento_seq'::regclass);


--
-- TOC entry 5651 (class 2604 OID 210619)
-- Dependencies: 267 265
-- Name: id_activo_fijo; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_activo_fijo_grupo_evento ALTER COLUMN id_activo_fijo SET DEFAULT nextval('tgv_activo_fijo_grupo_evento_id_activo_fijo_seq'::regclass);


--
-- TOC entry 5652 (class 2604 OID 210620)
-- Dependencies: 268 265
-- Name: id_agrupacion; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_activo_fijo_grupo_evento ALTER COLUMN id_agrupacion SET DEFAULT nextval('tgv_activo_fijo_grupo_evento_id_agrupacion_seq'::regclass);


--
-- TOC entry 5656 (class 2604 OID 210621)
-- Dependencies: 270 269
-- Name: id_activo_fijo_rastreo; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_activo_fijo_rastreo ALTER COLUMN id_activo_fijo_rastreo SET DEFAULT nextval('tgv_activo_fijo_rastreo_id_activo_fijo_rastreo_seq'::regclass);


--
-- TOC entry 5660 (class 2604 OID 210622)
-- Dependencies: 272 271
-- Name: id_ultimo_registro; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_activo_fijo_ultimo_registro ALTER COLUMN id_ultimo_registro SET DEFAULT nextval('tgv_activo_fijo_ultimo_registro_id_ultimo_registro_seq'::regclass);


--
-- TOC entry 5664 (class 2604 OID 210623)
-- Dependencies: 278 273
-- Name: id_agrupacion; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_agrupacion ALTER COLUMN id_agrupacion SET DEFAULT nextval('tgv_agrupacion_id_agrupacion_seq'::regclass);


--
-- TOC entry 5668 (class 2604 OID 210624)
-- Dependencies: 275 274
-- Name: id_agrupacion_evento; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_agrupacion_evento ALTER COLUMN id_agrupacion_evento SET DEFAULT nextval('tgv_agrupacion_evento_id_agrupacion_evento_seq'::regclass);


--
-- TOC entry 5672 (class 2604 OID 210625)
-- Dependencies: 280 279
-- Name: id_bitacora; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_bitacora ALTER COLUMN id_bitacora SET DEFAULT nextval('tgv_bitacora_id_bitacora_seq'::regclass);


--
-- TOC entry 5673 (class 2604 OID 210626)
-- Dependencies: 281 279
-- Name: id_servicio_det; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_bitacora ALTER COLUMN id_servicio_det SET DEFAULT nextval('tgv_bitacora_id_servicio_det_seq'::regclass);


--
-- TOC entry 5677 (class 2604 OID 210627)
-- Dependencies: 283 282
-- Name: id_datos_tec; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_datos_tec ALTER COLUMN id_datos_tec SET DEFAULT nextval('tgv_datos_tec_id_datos_tec_seq'::regclass);


--
-- TOC entry 5681 (class 2604 OID 210628)
-- Dependencies: 285 284
-- Name: id_evento; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_evento ALTER COLUMN id_evento SET DEFAULT nextval('tgv_evento_id_evento_seq'::regclass);


--
-- TOC entry 5682 (class 2604 OID 210629)
-- Dependencies: 286 284
-- Name: id_tipo_evento; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_evento ALTER COLUMN id_tipo_evento SET DEFAULT nextval('tgv_evento_id_tipo_evento_seq'::regclass);


--
-- TOC entry 5686 (class 2604 OID 210630)
-- Dependencies: 288 287
-- Name: id_iboton; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_iboton ALTER COLUMN id_iboton SET DEFAULT nextval('tgv_iboton_id_iboton_seq'::regclass);


--
-- TOC entry 5690 (class 2604 OID 210631)
-- Dependencies: 295 289
-- Name: id_mantenimiento; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_mantenimiento ALTER COLUMN id_mantenimiento SET DEFAULT nextval('tgv_mantenimiento_id_mantenimiento_seq'::regclass);


--
-- TOC entry 5695 (class 2604 OID 210632)
-- Dependencies: 293 290
-- Name: id_mantenimiento_det; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_mantenimiento_det ALTER COLUMN id_mantenimiento_det SET DEFAULT nextval('tgv_mantenimiento_det_id_mantenimiento_det_seq'::regclass);


--
-- TOC entry 5700 (class 2604 OID 210633)
-- Dependencies: 299 298
-- Name: id_marca; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_marca ALTER COLUMN id_marca SET DEFAULT nextval('tgv_marca_id_marca_seq'::regclass);


--
-- TOC entry 5704 (class 2604 OID 210634)
-- Dependencies: 301 300
-- Name: id_modelo; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_modelo ALTER COLUMN id_modelo SET DEFAULT nextval('tgv_modelo_id_modelo_seq'::regclass);


--
-- TOC entry 5708 (class 2604 OID 210635)
-- Dependencies: 313 302
-- Name: id_servicio; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_servicio ALTER COLUMN id_servicio SET DEFAULT nextval('tgv_servicio_id_servicio_seq'::regclass);


--
-- TOC entry 5712 (class 2604 OID 210636)
-- Dependencies: 311 303
-- Name: id_servicio_det; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_servicio_det ALTER COLUMN id_servicio_det SET DEFAULT nextval('tgv_servicio_det_id_servicio_det_seq'::regclass);


--
-- TOC entry 5716 (class 2604 OID 210637)
-- Dependencies: 307 304
-- Name: id_servicio_det_evento; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_servicio_det_evento ALTER COLUMN id_servicio_det_evento SET DEFAULT nextval('tgv_servicio_det_evento_id_servicio_det_evento_seq'::regclass);


--
-- TOC entry 5720 (class 2604 OID 210638)
-- Dependencies: 315 314
-- Name: id_tipo_evento; Type: DEFAULT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_tipo_evento ALTER COLUMN id_tipo_evento SET DEFAULT nextval('tgv_tipo_evento_id_tipo_evento_seq'::regclass);


SET search_path = hidro, pg_catalog;

--
-- TOC entry 5725 (class 2604 OID 209079)
-- Dependencies: 318 318
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_administrador_hidro ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5726 (class 2604 OID 209080)
-- Dependencies: 318 318
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_administrador_hidro ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5727 (class 2604 OID 209081)
-- Dependencies: 318 318
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_administrador_hidro ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5728 (class 2604 OID 210639)
-- Dependencies: 319 318
-- Name: id_administrador; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_administrador_hidro ALTER COLUMN id_administrador SET DEFAULT nextval('thd_administrador_hidro_id_administrador_hidro_seq'::regclass);


--
-- TOC entry 5730 (class 2604 OID 210640)
-- Dependencies: 321 320
-- Name: id_archivo; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_archivo ALTER COLUMN id_archivo SET DEFAULT nextval('thd_archivo_id_archivo_seq'::regclass);


--
-- TOC entry 5732 (class 2604 OID 210641)
-- Dependencies: 323 322
-- Name: id_archivo_sensor; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_archivo_sensor ALTER COLUMN id_archivo_sensor SET DEFAULT nextval('thd_archivo_sensor_id_archivo_sensor_seq'::regclass);


--
-- TOC entry 5733 (class 2604 OID 209107)
-- Dependencies: 325 325
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_cuenca ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5734 (class 2604 OID 209108)
-- Dependencies: 325 325
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_cuenca ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5735 (class 2604 OID 209109)
-- Dependencies: 325 325
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_cuenca ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5737 (class 2604 OID 209119)
-- Dependencies: 327 327
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_estacion ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5738 (class 2604 OID 209120)
-- Dependencies: 327 327
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_estacion ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5739 (class 2604 OID 209121)
-- Dependencies: 327 327
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_estacion ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5741 (class 2604 OID 210642)
-- Dependencies: 330 329
-- Name: id_estacion_proyecto; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_estacion_proyecto ALTER COLUMN id_estacion_proyecto SET DEFAULT nextval('thd_estacion_proyecto_id_estacion_proyecto_seq'::regclass);


--
-- TOC entry 5742 (class 2604 OID 209136)
-- Dependencies: 331 331
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_medicion ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5743 (class 2604 OID 209137)
-- Dependencies: 331 331
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_medicion ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5744 (class 2604 OID 209138)
-- Dependencies: 331 331
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_medicion ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5745 (class 2604 OID 210643)
-- Dependencies: 332 331
-- Name: id_medicion; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_medicion ALTER COLUMN id_medicion SET DEFAULT nextval('thd_medicion_id_medicion_seq'::regclass);


--
-- TOC entry 5746 (class 2604 OID 209144)
-- Dependencies: 333 333
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_operador ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5747 (class 2604 OID 209145)
-- Dependencies: 333 333
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_operador ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5748 (class 2604 OID 209146)
-- Dependencies: 333 333
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_operador ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5750 (class 2604 OID 209153)
-- Dependencies: 335 335
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_rio ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5751 (class 2604 OID 209154)
-- Dependencies: 335 335
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_rio ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5752 (class 2604 OID 209155)
-- Dependencies: 335 335
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_rio ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5753 (class 2604 OID 210644)
-- Dependencies: 336 335
-- Name: id_rio; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_rio ALTER COLUMN id_rio SET DEFAULT nextval('thd_rio_id_rio_seq'::regclass);


--
-- TOC entry 5754 (class 2604 OID 209161)
-- Dependencies: 337 337
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_sensor ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5755 (class 2604 OID 209162)
-- Dependencies: 337 337
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_sensor ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5756 (class 2604 OID 209163)
-- Dependencies: 337 337
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_sensor ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5757 (class 2604 OID 210645)
-- Dependencies: 338 337
-- Name: id_sensor; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_sensor ALTER COLUMN id_sensor SET DEFAULT nextval('thd_sensores_id_sensor_seq'::regclass);


--
-- TOC entry 5760 (class 2604 OID 210646)
-- Dependencies: 340 339
-- Name: id_tipo_archivo; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_archivo ALTER COLUMN id_tipo_archivo SET DEFAULT nextval('thd_tipo_archivo_id_tipo_archivo_seq'::regclass);


--
-- TOC entry 5761 (class 2604 OID 209179)
-- Dependencies: 341 341
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_columna ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5762 (class 2604 OID 209180)
-- Dependencies: 341 341
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_columna ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5763 (class 2604 OID 209181)
-- Dependencies: 341 341
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_columna ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5764 (class 2604 OID 210647)
-- Dependencies: 342 341
-- Name: id_tipo_columna; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_columna ALTER COLUMN id_tipo_columna SET DEFAULT nextval('thd_tipo_columna_id_tipo_columna_seq'::regclass);


--
-- TOC entry 5765 (class 2604 OID 209187)
-- Dependencies: 343 343
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_columna_sensor ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5766 (class 2604 OID 209188)
-- Dependencies: 343 343
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_columna_sensor ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5767 (class 2604 OID 209189)
-- Dependencies: 343 343
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_columna_sensor ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5769 (class 2604 OID 210648)
-- Dependencies: 344 343
-- Name: id_tipo_columna_sensor; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_columna_sensor ALTER COLUMN id_tipo_columna_sensor SET DEFAULT nextval('thd_tipo_columna_sensor_id_tipo_sensor_columna_seq'::regclass);


--
-- TOC entry 5770 (class 2604 OID 209199)
-- Dependencies: 345 345
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_dato ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5771 (class 2604 OID 209200)
-- Dependencies: 345 345
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_dato ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5772 (class 2604 OID 209201)
-- Dependencies: 345 345
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_dato ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5773 (class 2604 OID 210649)
-- Dependencies: 346 345
-- Name: id_tipo_dato; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_dato ALTER COLUMN id_tipo_dato SET DEFAULT nextval('thd_tipo_dato_id_tipo_dato_seq'::regclass);


--
-- TOC entry 5779 (class 2604 OID 210650)
-- Dependencies: 350 349
-- Name: id_tipo_muestra; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_muestra ALTER COLUMN id_tipo_muestra SET DEFAULT nextval('thd_tipo_muestra_id_tipo_muestra_seq'::regclass);


--
-- TOC entry 5774 (class 2604 OID 209207)
-- Dependencies: 347 347
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5775 (class 2604 OID 209208)
-- Dependencies: 347 347
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5776 (class 2604 OID 209209)
-- Dependencies: 347 347
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5778 (class 2604 OID 210651)
-- Dependencies: 348 347
-- Name: id_tipo_sensor; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor ALTER COLUMN id_tipo_sensor SET DEFAULT nextval('thd_tipo_medicion_id_tipo_medicion_seq'::regclass);


--
-- TOC entry 5780 (class 2604 OID 209224)
-- Dependencies: 351 351
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_22 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5781 (class 2604 OID 209225)
-- Dependencies: 351 351
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_22 ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5782 (class 2604 OID 209226)
-- Dependencies: 351 351
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_22 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5783 (class 2604 OID 210652)
-- Dependencies: 352 351
-- Name: id_tipo_sensor_22; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_22 ALTER COLUMN id_tipo_sensor_22 SET DEFAULT nextval('thd_tipo_sensor_22_id_tipo_sensor_22_seq'::regclass);


--
-- TOC entry 5784 (class 2604 OID 209235)
-- Dependencies: 353 353
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_33 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5785 (class 2604 OID 209236)
-- Dependencies: 353 353
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_33 ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5786 (class 2604 OID 209237)
-- Dependencies: 353 353
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_33 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5787 (class 2604 OID 210653)
-- Dependencies: 354 353
-- Name: id_tipo_sensor_33; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_33 ALTER COLUMN id_tipo_sensor_33 SET DEFAULT nextval('thd_tipo_sensor_33_id_tipo_sensor_33_seq'::regclass);


--
-- TOC entry 5788 (class 2604 OID 209246)
-- Dependencies: 355 355
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_44 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5789 (class 2604 OID 209247)
-- Dependencies: 355 355
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_44 ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5790 (class 2604 OID 209248)
-- Dependencies: 355 355
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_44 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5791 (class 2604 OID 210654)
-- Dependencies: 356 355
-- Name: id_tipo_sensor_44; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_44 ALTER COLUMN id_tipo_sensor_44 SET DEFAULT nextval('thd_tipo_sensor_44_id_tipo_sensor_44_seq'::regclass);


--
-- TOC entry 5792 (class 2604 OID 209257)
-- Dependencies: 357 357
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_anemometro ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5793 (class 2604 OID 209258)
-- Dependencies: 357 357
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_anemometro ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5794 (class 2604 OID 209259)
-- Dependencies: 357 357
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_anemometro ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5795 (class 2604 OID 210655)
-- Dependencies: 358 357
-- Name: id_tipo_sensor_anemometro; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_anemometro ALTER COLUMN id_tipo_sensor_anemometro SET DEFAULT nextval('thd_tipo_sensor_anemometro_id_tipo_sensor_anemometro_seq'::regclass);


--
-- TOC entry 5796 (class 2604 OID 209268)
-- Dependencies: 359 359
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_caudal ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5797 (class 2604 OID 209269)
-- Dependencies: 359 359
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_caudal ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5798 (class 2604 OID 209270)
-- Dependencies: 359 359
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_caudal ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5799 (class 2604 OID 210656)
-- Dependencies: 360 359
-- Name: id_tipo_sensor_caudal; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_caudal ALTER COLUMN id_tipo_sensor_caudal SET DEFAULT nextval('thd_tipo_sensor_caudal_id_tipo_sensor_caudal_seq'::regclass);


--
-- TOC entry 5800 (class 2604 OID 209279)
-- Dependencies: 361 361
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_limnimetrica ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5801 (class 2604 OID 209280)
-- Dependencies: 361 361
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_limnimetrica ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5802 (class 2604 OID 209281)
-- Dependencies: 361 361
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_limnimetrica ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5803 (class 2604 OID 210657)
-- Dependencies: 362 361
-- Name: id_tipo_sensor_limnimetrica; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_limnimetrica ALTER COLUMN id_tipo_sensor_limnimetrica SET DEFAULT nextval('thd_tipo_sensor_limnimetrica_id_tipo_sensor_limnimetrica_seq'::regclass);


--
-- TOC entry 5804 (class 2604 OID 209290)
-- Dependencies: 363 363
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_presion ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5805 (class 2604 OID 209291)
-- Dependencies: 363 363
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_presion ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5806 (class 2604 OID 209292)
-- Dependencies: 363 363
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_presion ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5807 (class 2604 OID 210658)
-- Dependencies: 364 363
-- Name: id_tipo_sensor_presion; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_presion ALTER COLUMN id_tipo_sensor_presion SET DEFAULT nextval('thd_tipo_sensor_presion_id_tipo_sensor_presion_seq'::regclass);


--
-- TOC entry 5808 (class 2604 OID 209301)
-- Dependencies: 365 365
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_pru ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5809 (class 2604 OID 209302)
-- Dependencies: 365 365
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_pru ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5810 (class 2604 OID 209303)
-- Dependencies: 365 365
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_pru ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5811 (class 2604 OID 210659)
-- Dependencies: 366 365
-- Name: id_tipo_sensor_pru; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_pru ALTER COLUMN id_tipo_sensor_pru SET DEFAULT nextval('thd_tipo_sensor_pru_id_tipo_sensor_pru_seq'::regclass);


--
-- TOC entry 5812 (class 2604 OID 209312)
-- Dependencies: 367 367
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_prue ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5813 (class 2604 OID 209313)
-- Dependencies: 367 367
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_prue ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5814 (class 2604 OID 209314)
-- Dependencies: 367 367
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_prue ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5815 (class 2604 OID 210660)
-- Dependencies: 368 367
-- Name: id_tipo_sensor_prue; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_prue ALTER COLUMN id_tipo_sensor_prue SET DEFAULT nextval('thd_tipo_sensor_prue_id_tipo_sensor_prue_seq'::regclass);


--
-- TOC entry 5816 (class 2604 OID 209323)
-- Dependencies: 369 369
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_termo ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5817 (class 2604 OID 209324)
-- Dependencies: 369 369
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_termo ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5818 (class 2604 OID 209325)
-- Dependencies: 369 369
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_termo ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5819 (class 2604 OID 210661)
-- Dependencies: 370 369
-- Name: id_tipo_sensor_termo; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_termo ALTER COLUMN id_tipo_sensor_termo SET DEFAULT nextval('thd_tipo_sensor_termo_id_tipo_sensor_termo_seq'::regclass);


--
-- TOC entry 5820 (class 2604 OID 209334)
-- Dependencies: 371 371
-- Name: fecha_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_unidad_medida ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5821 (class 2604 OID 209335)
-- Dependencies: 371 371
-- Name: fecha_mod; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_unidad_medida ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5822 (class 2604 OID 209336)
-- Dependencies: 371 371
-- Name: estado_reg; Type: DEFAULT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_unidad_medida ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


SET search_path = log, pg_catalog;

--
-- TOC entry 5826 (class 2604 OID 209352)
-- Dependencies: 374 374
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_02 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 5827 (class 2604 OID 209353)
-- Dependencies: 374 374
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_02 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5828 (class 2604 OID 209354)
-- Dependencies: 374 2216 374
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_02 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5831 (class 2604 OID 209362)
-- Dependencies: 375 375
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_04 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 5830 (class 2604 OID 209363)
-- Dependencies: 375 375
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_04 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5832 (class 2604 OID 209364)
-- Dependencies: 375 2216 375
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_04 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5834 (class 2604 OID 209372)
-- Dependencies: 376 376
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_05 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 5835 (class 2604 OID 209373)
-- Dependencies: 376 376
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_05 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5836 (class 2604 OID 209374)
-- Dependencies: 376 376 2216
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_05 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5838 (class 2604 OID 209382)
-- Dependencies: 377 377
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_06 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 5839 (class 2604 OID 209383)
-- Dependencies: 377 377
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_06 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5840 (class 2604 OID 209384)
-- Dependencies: 377 377 2216
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_06 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5842 (class 2604 OID 209392)
-- Dependencies: 378 378
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_07 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 5843 (class 2604 OID 209393)
-- Dependencies: 378 378
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_07 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5844 (class 2604 OID 209394)
-- Dependencies: 378 2216 378
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_07 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5846 (class 2604 OID 209402)
-- Dependencies: 379 379
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_08 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 5847 (class 2604 OID 209403)
-- Dependencies: 379 379
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_08 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5848 (class 2604 OID 209404)
-- Dependencies: 379 379 2216
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_08 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5850 (class 2604 OID 209412)
-- Dependencies: 380 380
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_09 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 5851 (class 2604 OID 209413)
-- Dependencies: 380 380
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_09 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5852 (class 2604 OID 209414)
-- Dependencies: 380 2216 380
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_09 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5854 (class 2604 OID 209422)
-- Dependencies: 381 381
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_10 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 5855 (class 2604 OID 209423)
-- Dependencies: 381 381
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_10 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5856 (class 2604 OID 209424)
-- Dependencies: 381 2216 381
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_10 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5858 (class 2604 OID 209432)
-- Dependencies: 382 382
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_11 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 5859 (class 2604 OID 209433)
-- Dependencies: 382 382
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_11 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5860 (class 2604 OID 209434)
-- Dependencies: 382 382 2216
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_11 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5862 (class 2604 OID 209442)
-- Dependencies: 383 383
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_12 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 5863 (class 2604 OID 209443)
-- Dependencies: 383 383
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_12 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5864 (class 2604 OID 209444)
-- Dependencies: 383 383 2216
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2011_12 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5866 (class 2604 OID 209452)
-- Dependencies: 384 384
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_01 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 5867 (class 2604 OID 209453)
-- Dependencies: 384 384
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_01 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5868 (class 2604 OID 209454)
-- Dependencies: 384 2216 384
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_01 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5870 (class 2604 OID 209462)
-- Dependencies: 385 385
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_02 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 5871 (class 2604 OID 209463)
-- Dependencies: 385 385
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_02 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5872 (class 2604 OID 209464)
-- Dependencies: 385 2216 385
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_02 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5874 (class 2604 OID 209472)
-- Dependencies: 386 386
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_03 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 5875 (class 2604 OID 209473)
-- Dependencies: 386 386
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_03 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5876 (class 2604 OID 209474)
-- Dependencies: 386 386 2216
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_03 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5878 (class 2604 OID 209482)
-- Dependencies: 387 387
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_04 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 5879 (class 2604 OID 209483)
-- Dependencies: 387 387
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_04 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5880 (class 2604 OID 209484)
-- Dependencies: 387 387 2216
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_04 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5882 (class 2604 OID 209492)
-- Dependencies: 388 388
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_05 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 5883 (class 2604 OID 209493)
-- Dependencies: 388 388
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_05 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5884 (class 2604 OID 209494)
-- Dependencies: 388 2216 388
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_05 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5886 (class 2604 OID 209502)
-- Dependencies: 389 389
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_06 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 5887 (class 2604 OID 209503)
-- Dependencies: 389 389
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_06 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5888 (class 2604 OID 209504)
-- Dependencies: 389 389 2216
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_06 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 6197 (class 2604 OID 318934)
-- Dependencies: 626 626
-- Name: id_log; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_08 ALTER COLUMN id_log SET DEFAULT nextval(('"segu"."log_id_log_seq"'::text)::regclass);


--
-- TOC entry 6198 (class 2604 OID 318935)
-- Dependencies: 626 626
-- Name: fecha_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_08 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 6199 (class 2604 OID 318936)
-- Dependencies: 626 2216 626
-- Name: estado_reg; Type: DEFAULT; Schema: log; Owner: -
--

ALTER TABLE ONLY tlog_2012_08 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


SET search_path = param, pg_catalog;

--
-- TOC entry 5890 (class 2604 OID 209512)
-- Dependencies: 390 390
-- Name: fecha_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY table1 ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5891 (class 2604 OID 209513)
-- Dependencies: 390 390
-- Name: fecha_mod; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY table1 ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5892 (class 2604 OID 209514)
-- Dependencies: 390 390
-- Name: estado_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY table1 ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5893 (class 2604 OID 210662)
-- Dependencies: 391 390
-- Name: id_depto_usuario; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY table1 ALTER COLUMN id_depto_usuario SET DEFAULT nextval('table1_id_depto_usuario_seq'::regclass);


--
-- TOC entry 5896 (class 2604 OID 210663)
-- Dependencies: 393 392
-- Name: id_alarma; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY talarma ALTER COLUMN id_alarma SET DEFAULT nextval('talarma_id_alarma_seq'::regclass);


--
-- TOC entry 5897 (class 2604 OID 209530)
-- Dependencies: 394 394
-- Name: fecha_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tconfig_alarma ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5898 (class 2604 OID 209531)
-- Dependencies: 394 394
-- Name: fecha_mod; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tconfig_alarma ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5899 (class 2604 OID 209532)
-- Dependencies: 394 394
-- Name: estado_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tconfig_alarma ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5900 (class 2604 OID 210664)
-- Dependencies: 395 394
-- Name: id_config_alarma; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tconfig_alarma ALTER COLUMN id_config_alarma SET DEFAULT nextval('tconfig_alarma_id_config_alarma_seq'::regclass);


--
-- TOC entry 5902 (class 2604 OID 209538)
-- Dependencies: 396 396
-- Name: fecha_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tcorrelativo ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5901 (class 2604 OID 209539)
-- Dependencies: 396 396
-- Name: fecha_mod; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tcorrelativo ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5903 (class 2604 OID 209540)
-- Dependencies: 396 396
-- Name: estado_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tcorrelativo ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5904 (class 2604 OID 210665)
-- Dependencies: 397 396
-- Name: id_correlativo; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tcorrelativo ALTER COLUMN id_correlativo SET DEFAULT nextval('tcorrelativo_id_correlativo_seq'::regclass);


--
-- TOC entry 5905 (class 2604 OID 209546)
-- Dependencies: 398 398
-- Name: fecha_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tdepto ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5906 (class 2604 OID 209547)
-- Dependencies: 398 398
-- Name: fecha_mod; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tdepto ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5908 (class 2604 OID 210666)
-- Dependencies: 399 398
-- Name: id_depto; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tdepto ALTER COLUMN id_depto SET DEFAULT nextval('tdepto_id_depto_seq'::regclass);


--
-- TOC entry 5909 (class 2604 OID 209554)
-- Dependencies: 400 400
-- Name: fecha_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tdepto_usuario ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5910 (class 2604 OID 209555)
-- Dependencies: 400 400
-- Name: fecha_mod; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tdepto_usuario ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5911 (class 2604 OID 209556)
-- Dependencies: 400 400
-- Name: estado_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tdepto_usuario ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5912 (class 2604 OID 210667)
-- Dependencies: 401 400
-- Name: id_depto_usuario; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tdepto_usuario ALTER COLUMN id_depto_usuario SET DEFAULT nextval('tdepto_usuairo_id_depto_usuario_seq'::regclass);


--
-- TOC entry 5913 (class 2604 OID 209562)
-- Dependencies: 402 402
-- Name: fecha_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tdocumento ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5914 (class 2604 OID 209563)
-- Dependencies: 402 402
-- Name: fecha_mod; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tdocumento ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5915 (class 2604 OID 209564)
-- Dependencies: 402 402
-- Name: estado_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tdocumento ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5917 (class 2604 OID 210668)
-- Dependencies: 403 402
-- Name: id_documento; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tdocumento ALTER COLUMN id_documento SET DEFAULT nextval('tdocumento_id_documento_seq'::regclass);


--
-- TOC entry 5921 (class 2604 OID 210669)
-- Dependencies: 405 404
-- Name: id_gestion; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tgestion ALTER COLUMN id_gestion SET DEFAULT nextval('tgestion_id_gestion_seq'::regclass);


--
-- TOC entry 5922 (class 2604 OID 209582)
-- Dependencies: 406 406
-- Name: fecha_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tinstitucion ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5923 (class 2604 OID 209583)
-- Dependencies: 406 406
-- Name: fecha_mod; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tinstitucion ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5924 (class 2604 OID 209584)
-- Dependencies: 406 406
-- Name: estado_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tinstitucion ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5927 (class 2604 OID 210670)
-- Dependencies: 407 406
-- Name: id_institucion; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tinstitucion ALTER COLUMN id_institucion SET DEFAULT nextval('tinstitucion_id_institucion_seq'::regclass);


--
-- TOC entry 5928 (class 2604 OID 209595)
-- Dependencies: 408 408
-- Name: fecha_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tlugar ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5929 (class 2604 OID 209596)
-- Dependencies: 408 408
-- Name: fecha_mod; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tlugar ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5935 (class 2604 OID 209607)
-- Dependencies: 410 410
-- Name: fecha_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tmoneda ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5936 (class 2604 OID 209608)
-- Dependencies: 410 410
-- Name: fecha_mod; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tmoneda ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5938 (class 2604 OID 210671)
-- Dependencies: 411 410
-- Name: id_moneda; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tmoneda ALTER COLUMN id_moneda SET DEFAULT nextval('tmoneda_id_moneda_seq'::regclass);


--
-- TOC entry 5942 (class 2604 OID 210672)
-- Dependencies: 413 412
-- Name: id_periodo; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tperiodo ALTER COLUMN id_periodo SET DEFAULT nextval('tperiodo_id_periodo_seq'::regclass);


--
-- TOC entry 5947 (class 2604 OID 210673)
-- Dependencies: 415 414
-- Name: id_financiador; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tpm_financiador ALTER COLUMN id_financiador SET DEFAULT nextval('tpm_financiador_id_financiador_seq'::regclass);


--
-- TOC entry 5950 (class 2604 OID 210674)
-- Dependencies: 417 416
-- Name: id_programa; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tpm_programa ALTER COLUMN id_programa SET DEFAULT nextval('tpm_programa_id_programa_seq'::regclass);


--
-- TOC entry 5954 (class 2604 OID 210675)
-- Dependencies: 419 418
-- Name: id_proyecto; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tpm_proyecto ALTER COLUMN id_proyecto SET DEFAULT nextval('tpm_proyecto_id_proyecto_seq'::regclass);


--
-- TOC entry 5957 (class 2604 OID 210676)
-- Dependencies: 421 420
-- Name: id_regional; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tpm_regional ALTER COLUMN id_regional SET DEFAULT nextval('tpm_regional_id_regional_seq'::regclass);


--
-- TOC entry 5960 (class 2604 OID 210677)
-- Dependencies: 423 422
-- Name: id_proveedor; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tproveedor ALTER COLUMN id_proveedor SET DEFAULT nextval('tproveedor_id_proveedor_seq'::regclass);


--
-- TOC entry 5961 (class 2604 OID 209676)
-- Dependencies: 424 424
-- Name: fecha_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tusuario_uo ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5962 (class 2604 OID 209677)
-- Dependencies: 424 424
-- Name: fecha_mod; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tusuario_uo ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5963 (class 2604 OID 209678)
-- Dependencies: 424 424
-- Name: estado_reg; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tusuario_uo ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5964 (class 2604 OID 210678)
-- Dependencies: 425 424
-- Name: id_usuario_uo; Type: DEFAULT; Schema: param; Owner: -
--

ALTER TABLE ONLY tusuario_uo ALTER COLUMN id_usuario_uo SET DEFAULT nextval('tusuario_uo_id_usuario_uo_seq'::regclass);


SET search_path = public, pg_catalog;

--
-- TOC entry 5969 (class 2604 OID 210679)
-- Dependencies: 430 429
-- Name: id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY file_store ALTER COLUMN id SET DEFAULT nextval('file_store_id_seq'::regclass);


--
-- TOC entry 5970 (class 2604 OID 210680)
-- Dependencies: 447 446
-- Name: id_variable_global; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY variable_global ALTER COLUMN id_variable_global SET DEFAULT nextval('variable_global_id_variable_global_seq'::regclass);


SET search_path = rhum, pg_catalog;

--
-- TOC entry 5975 (class 2604 OID 210681)
-- Dependencies: 449 448
-- Name: id_columna; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tcolumna ALTER COLUMN id_columna SET DEFAULT nextval('tcolumna_id_columna_seq'::regclass);


--
-- TOC entry 5978 (class 2604 OID 209805)
-- Dependencies: 450 450
-- Name: fecha_reg; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY testructura_uo ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5979 (class 2604 OID 209806)
-- Dependencies: 450 450
-- Name: fecha_mod; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY testructura_uo ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5981 (class 2604 OID 210682)
-- Dependencies: 451 450
-- Name: id_estructura_uo; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY testructura_uo ALTER COLUMN id_estructura_uo SET DEFAULT nextval('testructura_uo_id_estructura_uo_seq'::regclass);


--
-- TOC entry 5986 (class 2604 OID 210683)
-- Dependencies: 455 452
-- Name: id_funcionario; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tfuncionario ALTER COLUMN id_funcionario SET DEFAULT nextval('tfuncionario_id_funcionario_seq'::regclass);


--
-- TOC entry 5987 (class 2604 OID 210684)
-- Dependencies: 454 453
-- Name: id_funcionario_horario; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tfuncionario_horario ALTER COLUMN id_funcionario_horario SET DEFAULT nextval('tfuncionario_horario_id_funcionario_horario_seq'::regclass);


--
-- TOC entry 5988 (class 2604 OID 210685)
-- Dependencies: 457 456
-- Name: id_horario; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY thorario ALTER COLUMN id_horario SET DEFAULT nextval('thorario_id_horario_seq'::regclass);


--
-- TOC entry 5989 (class 2604 OID 209835)
-- Dependencies: 458 458
-- Name: fecha_reg; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tnivel_organizacional ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 5990 (class 2604 OID 209836)
-- Dependencies: 458 458
-- Name: fecha_mod; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tnivel_organizacional ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 5991 (class 2604 OID 209837)
-- Dependencies: 458 458
-- Name: estado_reg; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tnivel_organizacional ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 5992 (class 2604 OID 210686)
-- Dependencies: 459 458
-- Name: id_nivel_organizacional; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tnivel_organizacional ALTER COLUMN id_nivel_organizacional SET DEFAULT nextval('tnivel_organizacional_id_nivel_organizacional_seq'::regclass);


--
-- TOC entry 5995 (class 2604 OID 210687)
-- Dependencies: 461 460
-- Name: id_obligacion; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tobligacion ALTER COLUMN id_obligacion SET DEFAULT nextval('tobligacion_id_obligacion_seq'::regclass);


--
-- TOC entry 5998 (class 2604 OID 210688)
-- Dependencies: 463 462
-- Name: id_parametro; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tparametro_rhum ALTER COLUMN id_parametro SET DEFAULT nextval('tparametro_rhum_id_parametro_seq'::regclass);


--
-- TOC entry 5999 (class 2604 OID 210689)
-- Dependencies: 465 464
-- Name: id_planilla; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tplanilla ALTER COLUMN id_planilla SET DEFAULT nextval('tplanilla_id_planilla_seq'::regclass);


--
-- TOC entry 6005 (class 2604 OID 210690)
-- Dependencies: 467 466
-- Name: id_tipo_columna; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY ttipo_columna ALTER COLUMN id_tipo_columna SET DEFAULT nextval('ttipo_columna_id_tipo_columna_seq'::regclass);


--
-- TOC entry 6009 (class 2604 OID 210691)
-- Dependencies: 469 468
-- Name: id_tipo_horario; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY ttipo_horario ALTER COLUMN id_tipo_horario SET DEFAULT nextval('ttipo_horario_id_tipo_horario_seq'::regclass);


--
-- TOC entry 6012 (class 2604 OID 210692)
-- Dependencies: 471 470
-- Name: id_tipo_obligacion; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY ttipo_obligacion ALTER COLUMN id_tipo_obligacion SET DEFAULT nextval('ttipo_obligacion_id_tipo_obligacion_seq'::regclass);


--
-- TOC entry 6018 (class 2604 OID 210693)
-- Dependencies: 473 472
-- Name: id_tipo_planilla; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY ttipo_planilla ALTER COLUMN id_tipo_planilla SET DEFAULT nextval('ttipo_planilla_id_tipo_planilla_seq'::regclass);


--
-- TOC entry 6019 (class 2604 OID 209912)
-- Dependencies: 474 474
-- Name: fecha_reg; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tuo ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 6020 (class 2604 OID 209913)
-- Dependencies: 474 474
-- Name: fecha_mod; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tuo ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 6021 (class 2604 OID 209914)
-- Dependencies: 474 474
-- Name: estado_reg; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tuo ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 6023 (class 2604 OID 210694)
-- Dependencies: 477 474
-- Name: id_uo; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tuo ALTER COLUMN id_uo SET DEFAULT nextval('tuo_id_uo_seq'::regclass);


--
-- TOC entry 6024 (class 2604 OID 209919)
-- Dependencies: 475 475
-- Name: fecha_reg; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tuo_funcionario ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 6025 (class 2604 OID 209920)
-- Dependencies: 475 475
-- Name: fecha_mod; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tuo_funcionario ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 6027 (class 2604 OID 210695)
-- Dependencies: 476 475
-- Name: id_uo_funcionario; Type: DEFAULT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tuo_funcionario ALTER COLUMN id_uo_funcionario SET DEFAULT nextval('tuo_funcionario_id_uo_funcionario_seq'::regclass);


SET search_path = saj, pg_catalog;

--
-- TOC entry 6030 (class 2604 OID 210696)
-- Dependencies: 481 480
-- Name: id_boleta; Type: DEFAULT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tboleta ALTER COLUMN id_boleta SET DEFAULT nextval('tboleta_id_boleta_seq'::regclass);


--
-- TOC entry 6032 (class 2604 OID 210697)
-- Dependencies: 484 483
-- Name: id_documento_anexo; Type: DEFAULT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tdocumento_anexo ALTER COLUMN id_documento_anexo SET DEFAULT nextval('tdocumento_anexo_id_documento_anexo_seq'::regclass);


--
-- TOC entry 6035 (class 2604 OID 210698)
-- Dependencies: 486 485
-- Name: id_estado; Type: DEFAULT; Schema: saj; Owner: -
--

ALTER TABLE ONLY testado ALTER COLUMN id_estado SET DEFAULT nextval('testado_id_estado_seq'::regclass);


--
-- TOC entry 6040 (class 2604 OID 210699)
-- Dependencies: 488 487
-- Name: id_estado_proceso; Type: DEFAULT; Schema: saj; Owner: -
--

ALTER TABLE ONLY testado_proceso ALTER COLUMN id_estado_proceso SET DEFAULT nextval('testado_proceso_id_estado_proceso_seq'::regclass);


--
-- TOC entry 6047 (class 2604 OID 210700)
-- Dependencies: 492 491
-- Name: id_modalidad; Type: DEFAULT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tmodalidad ALTER COLUMN id_modalidad SET DEFAULT nextval('tmodalidad_id_modalidad_seq'::regclass);


--
-- TOC entry 6051 (class 2604 OID 210701)
-- Dependencies: 494 493
-- Name: id_proceso_contrato; Type: DEFAULT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tproceso_contrato ALTER COLUMN id_proceso_contrato SET DEFAULT nextval('tproceso_contrato_id_proceso_contrato_seq'::regclass);


--
-- TOC entry 6055 (class 2604 OID 210702)
-- Dependencies: 496 495
-- Name: id_responsable_proceso; Type: DEFAULT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tresponsable_proceso ALTER COLUMN id_responsable_proceso SET DEFAULT nextval('tresponsable_proceso_id_responsable_proceso_seq'::regclass);


--
-- TOC entry 6043 (class 2604 OID 210703)
-- Dependencies: 490 489
-- Name: id_tipo_contrato; Type: DEFAULT; Schema: saj; Owner: -
--

ALTER TABLE ONLY ttipo_contrato ALTER COLUMN id_tipo_contrato SET DEFAULT nextval('tipo_contrato_id_tipo_contrato_seq'::regclass);


SET search_path = sast, pg_catalog;

--
-- TOC entry 6056 (class 2604 OID 210020)
-- Dependencies: 498 498
-- Name: fecha_reg; Type: DEFAULT; Schema: sast; Owner: -
--

ALTER TABLE ONLY testado ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 6057 (class 2604 OID 210021)
-- Dependencies: 498 498
-- Name: fecha_mod; Type: DEFAULT; Schema: sast; Owner: -
--

ALTER TABLE ONLY testado ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 6058 (class 2604 OID 210022)
-- Dependencies: 498 498
-- Name: estado_reg; Type: DEFAULT; Schema: sast; Owner: -
--

ALTER TABLE ONLY testado ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 6059 (class 2604 OID 210704)
-- Dependencies: 499 498
-- Name: id_estado; Type: DEFAULT; Schema: sast; Owner: -
--

ALTER TABLE ONLY testado ALTER COLUMN id_estado SET DEFAULT nextval('testado_id_estado_seq'::regclass);


--
-- TOC entry 6060 (class 2604 OID 210028)
-- Dependencies: 500 500
-- Name: fecha_reg; Type: DEFAULT; Schema: sast; Owner: -
--

ALTER TABLE ONLY testado_requerimiento ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 6061 (class 2604 OID 210029)
-- Dependencies: 500 500
-- Name: fecha_mod; Type: DEFAULT; Schema: sast; Owner: -
--

ALTER TABLE ONLY testado_requerimiento ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 6062 (class 2604 OID 210030)
-- Dependencies: 500 500
-- Name: estado_reg; Type: DEFAULT; Schema: sast; Owner: -
--

ALTER TABLE ONLY testado_requerimiento ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 6064 (class 2604 OID 210705)
-- Dependencies: 501 500
-- Name: id_estado_requerimiento; Type: DEFAULT; Schema: sast; Owner: -
--

ALTER TABLE ONLY testado_requerimiento ALTER COLUMN id_estado_requerimiento SET DEFAULT nextval('testado_requerimiento_id_estado_requerimiento_seq'::regclass);


--
-- TOC entry 6069 (class 2604 OID 210050)
-- Dependencies: 505 505
-- Name: fecha_reg; Type: DEFAULT; Schema: sast; Owner: -
--

ALTER TABLE ONLY trequerimientos ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 6070 (class 2604 OID 210051)
-- Dependencies: 505 505
-- Name: fecha_mod; Type: DEFAULT; Schema: sast; Owner: -
--

ALTER TABLE ONLY trequerimientos ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 6071 (class 2604 OID 210052)
-- Dependencies: 505 505
-- Name: estado_reg; Type: DEFAULT; Schema: sast; Owner: -
--

ALTER TABLE ONLY trequerimientos ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 6075 (class 2604 OID 210706)
-- Dependencies: 506 505
-- Name: id_requerimiento; Type: DEFAULT; Schema: sast; Owner: -
--

ALTER TABLE ONLY trequerimientos ALTER COLUMN id_requerimiento SET DEFAULT nextval('trequerimientos_id_requerimiento_seq'::regclass);


--
-- TOC entry 6065 (class 2604 OID 210040)
-- Dependencies: 502 502
-- Name: fecha_reg; Type: DEFAULT; Schema: sast; Owner: -
--

ALTER TABLE ONLY ttipo_requerimiento ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 6066 (class 2604 OID 210041)
-- Dependencies: 502 502
-- Name: fecha_mod; Type: DEFAULT; Schema: sast; Owner: -
--

ALTER TABLE ONLY ttipo_requerimiento ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 6067 (class 2604 OID 210042)
-- Dependencies: 502 502
-- Name: estado_reg; Type: DEFAULT; Schema: sast; Owner: -
--

ALTER TABLE ONLY ttipo_requerimiento ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 6068 (class 2604 OID 210707)
-- Dependencies: 503 502
-- Name: id_tipo_requerimiento; Type: DEFAULT; Schema: sast; Owner: -
--

ALTER TABLE ONLY ttipo_requerimiento ALTER COLUMN id_tipo_requerimiento SET DEFAULT nextval('tipo_requerimiento_id_tipo_requerimiento_seq'::regclass);


SET search_path = secont, pg_catalog;

--
-- TOC entry 6076 (class 2604 OID 210708)
-- Dependencies: 527 508
-- Name: id_alarma; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY alarma ALTER COLUMN id_alarma SET DEFAULT nextval('leg_alarma_id_alarma_seq'::regclass);


--
-- TOC entry 6077 (class 2604 OID 210709)
-- Dependencies: 510 509
-- Name: id_contratista; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY contratista ALTER COLUMN id_contratista SET DEFAULT nextval('contratista_id_contratista_seq'::regclass);


--
-- TOC entry 6078 (class 2604 OID 210710)
-- Dependencies: 512 511
-- Name: id_contrato; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY contrato ALTER COLUMN id_contrato SET DEFAULT nextval('contrato_id_contrato_seq'::regclass);


--
-- TOC entry 6079 (class 2604 OID 210711)
-- Dependencies: 514 513
-- Name: id_correspondencia; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY correspondencia ALTER COLUMN id_correspondencia SET DEFAULT nextval('correspondencia_id_correspondencia_seq'::regclass);


--
-- TOC entry 6080 (class 2604 OID 210712)
-- Dependencies: 516 515
-- Name: id_documento; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY doc_anexo ALTER COLUMN id_documento SET DEFAULT nextval('doc_anexo_id_documento_seq'::regclass);


--
-- TOC entry 6081 (class 2604 OID 210713)
-- Dependencies: 518 517
-- Name: id_personal; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY empleado ALTER COLUMN id_personal SET DEFAULT nextval('empleado_id_personal_seq'::regclass);


--
-- TOC entry 6083 (class 2604 OID 210714)
-- Dependencies: 520 519
-- Name: id_estado; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY estado ALTER COLUMN id_estado SET DEFAULT nextval('estado_id_estado_seq'::regclass);


--
-- TOC entry 6084 (class 2604 OID 210715)
-- Dependencies: 522 521
-- Name: id_estado_requerimiento; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY estado_requerimiento ALTER COLUMN id_estado_requerimiento SET DEFAULT nextval('estado_requerimiento_id_estado_requerimiento_seq'::regclass);


--
-- TOC entry 6085 (class 2604 OID 210716)
-- Dependencies: 524 523
-- Name: id_garantia; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY garantia ALTER COLUMN id_garantia SET DEFAULT nextval('garantia_id_garantia_seq'::regclass);


--
-- TOC entry 6086 (class 2604 OID 210717)
-- Dependencies: 526 525
-- Name: id_informe; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY informe ALTER COLUMN id_informe SET DEFAULT nextval('informe_id_informe_seq'::regclass);


--
-- TOC entry 6087 (class 2604 OID 210718)
-- Dependencies: 529 528
-- Name: id_oferta; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY oferta ALTER COLUMN id_oferta SET DEFAULT nextval('oferta_id_oferta_seq'::regclass);


--
-- TOC entry 6088 (class 2604 OID 210719)
-- Dependencies: 531 530
-- Name: id_persona_juridica; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY persona_juridica ALTER COLUMN id_persona_juridica SET DEFAULT nextval('persona_juridica_id_persona_juridica_seq'::regclass);


--
-- TOC entry 6089 (class 2604 OID 210720)
-- Dependencies: 533 532
-- Name: id_proyecto; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY proyecto ALTER COLUMN id_proyecto SET DEFAULT nextval('proyecto_id_proyecto_seq'::regclass);


--
-- TOC entry 6090 (class 2604 OID 210721)
-- Dependencies: 535 534
-- Name: id_representante; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY representante ALTER COLUMN id_representante SET DEFAULT nextval('representante_id_representante_seq'::regclass);


--
-- TOC entry 6091 (class 2604 OID 210722)
-- Dependencies: 537 536
-- Name: id_requerimiento; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY requerimiento ALTER COLUMN id_requerimiento SET DEFAULT nextval('requerimiento_id_requerimiento_seq'::regclass);


--
-- TOC entry 6092 (class 2604 OID 210723)
-- Dependencies: 539 538
-- Name: id_resolucion; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY resolucion ALTER COLUMN id_resolucion SET DEFAULT nextval('resolucion_id_resolucion_seq'::regclass);


--
-- TOC entry 6093 (class 2604 OID 210724)
-- Dependencies: 541 540
-- Name: id_unidad; Type: DEFAULT; Schema: secont; Owner: -
--

ALTER TABLE ONLY unidad ALTER COLUMN id_unidad SET DEFAULT nextval('unidad_id_unidad_seq'::regclass);


SET search_path = segu, pg_catalog;

--
-- TOC entry 6105 (class 2604 OID 210725)
-- Dependencies: 559 556
-- Name: id_libreta; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY libreta ALTER COLUMN id_libreta SET DEFAULT nextval('libreta_id_libreta_seq'::regclass);


--
-- TOC entry 6106 (class 2604 OID 210271)
-- Dependencies: 557 557
-- Name: fecha_reg; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY libreta_her ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 6107 (class 2604 OID 210272)
-- Dependencies: 557 557
-- Name: fecha_mod; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY libreta_her ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 6108 (class 2604 OID 210273)
-- Dependencies: 557 557
-- Name: estado_reg; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY libreta_her ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 6109 (class 2604 OID 210726)
-- Dependencies: 558 557
-- Name: id_libreta_her; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY libreta_her ALTER COLUMN id_libreta_her SET DEFAULT nextval('libreta_her_id_libreta_her_seq'::regclass);


--
-- TOC entry 6096 (class 2604 OID 210727)
-- Dependencies: 547 546
-- Name: id_actividad; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tactividad ALTER COLUMN id_actividad SET DEFAULT nextval('actividad_id_actividad_seq'::regclass);


--
-- TOC entry 6124 (class 2604 OID 210728)
-- Dependencies: 578 577
-- Name: id_bloqueo_notificacion; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tbloqueo_notificacion ALTER COLUMN id_bloqueo_notificacion SET DEFAULT nextval('tbloqueo_notificacion_id_bloqueo_notificacion_seq'::regclass);


--
-- TOC entry 6099 (class 2604 OID 210729)
-- Dependencies: 550 549
-- Name: id_estructura_dato; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY testructura_dato ALTER COLUMN id_estructura_dato SET DEFAULT nextval('estructura_dato_id_estructura_dato_seq'::regclass);


--
-- TOC entry 6102 (class 2604 OID 210730)
-- Dependencies: 552 551
-- Name: id_estructura_gui; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY testructura_gui ALTER COLUMN id_estructura_gui SET DEFAULT nextval('estructura_gui_id_estructura_gui_seq'::regclass);


--
-- TOC entry 6104 (class 2604 OID 210731)
-- Dependencies: 555 554
-- Name: id_gui_rol; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tgui_rol ALTER COLUMN id_gui_rol SET DEFAULT nextval('gui_rol_id_gui_rol_seq'::regclass);


--
-- TOC entry 6135 (class 2604 OID 210732)
-- Dependencies: 585 584
-- Name: id_horario_trabajo; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY thorario_trabajo ALTER COLUMN id_horario_trabajo SET DEFAULT nextval('thorario_trabajo_id_horario_trabajo_seq'::regclass);


--
-- TOC entry 6142 (class 2604 OID 210733)
-- Dependencies: 590 589
-- Name: id_patron_evento; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tpatron_evento ALTER COLUMN id_patron_evento SET DEFAULT nextval('tpatron_evento_id_patron_evento_seq'::regclass);


--
-- TOC entry 6112 (class 2604 OID 210734)
-- Dependencies: 562 561
-- Name: id_permiso; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tpermiso ALTER COLUMN id_permiso SET DEFAULT nextval('permiso_id_permiso_seq'::regclass);


--
-- TOC entry 5968 (class 2604 OID 210735)
-- Dependencies: 592 426
-- Name: id_persona; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tpersona ALTER COLUMN id_persona SET DEFAULT nextval('tpersona_id_persona_seq'::regclass);


--
-- TOC entry 6115 (class 2604 OID 210736)
-- Dependencies: 565 564
-- Name: id_procedimiento_gui; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tprocedimiento_gui ALTER COLUMN id_procedimiento_gui SET DEFAULT nextval('procedimiento_gui_id_procedimiento_gui_seq'::regclass);


--
-- TOC entry 6119 (class 2604 OID 210737)
-- Dependencies: 568 567
-- Name: id_proyecto; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tproyecto ALTER COLUMN id_proyecto SET DEFAULT nextval('proyecto_id_proyecto_seq'::regclass);


--
-- TOC entry 6121 (class 2604 OID 210738)
-- Dependencies: 571 570
-- Name: id_recurso; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY trecurso ALTER COLUMN id_recurso SET DEFAULT nextval('recurso_id_recurso_seq'::regclass);


--
-- TOC entry 6123 (class 2604 OID 210739)
-- Dependencies: 575 574
-- Name: id_rol_procedimiento; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY trol_procedimiento_gui ALTER COLUMN id_rol_procedimiento SET DEFAULT nextval('rol_procedimiento_id_rol_procedimiento_seq'::regclass);


--
-- TOC entry 6159 (class 2604 OID 210740)
-- Dependencies: 598 597
-- Name: id_sesion; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tsesion ALTER COLUMN id_sesion SET DEFAULT nextval('tsesion_id_sesion_seq'::regclass);


--
-- TOC entry 6138 (class 2604 OID 210741)
-- Dependencies: 587 586
-- Name: id_tipo_documento; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY ttipo_documento ALTER COLUMN id_tipo_documento SET DEFAULT nextval('tipo_documento_id_tipo_documento_seq'::regclass);


--
-- TOC entry 6164 (class 2604 OID 210742)
-- Dependencies: 606 601
-- Name: id_usuario_actividad; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tusuario_actividad ALTER COLUMN id_usuario_actividad SET DEFAULT nextval('usuario_actividad_id_usuario_actividad_seq'::regclass);


--
-- TOC entry 6168 (class 2604 OID 210743)
-- Dependencies: 608 603
-- Name: id_usuario_proyecto; Type: DEFAULT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tusuario_proyecto ALTER COLUMN id_usuario_proyecto SET DEFAULT nextval('usuario_proyecto_id_usuario_proyecto_seq'::regclass);


SET search_path = tesor, pg_catalog;

--
-- TOC entry 6174 (class 2604 OID 210550)
-- Dependencies: 616 616
-- Name: fecha_reg; Type: DEFAULT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY tcaja ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 6175 (class 2604 OID 210551)
-- Dependencies: 616 616
-- Name: fecha_mod; Type: DEFAULT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY tcaja ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 6176 (class 2604 OID 210552)
-- Dependencies: 616 616
-- Name: estado_reg; Type: DEFAULT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY tcaja ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 6177 (class 2604 OID 210556)
-- Dependencies: 617 617
-- Name: fecha_reg; Type: DEFAULT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY tcaja_mov ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 6178 (class 2604 OID 210557)
-- Dependencies: 617 617
-- Name: fecha_mod; Type: DEFAULT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY tcaja_mov ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 6179 (class 2604 OID 210558)
-- Dependencies: 617 617
-- Name: estado_reg; Type: DEFAULT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY tcaja_mov ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 6180 (class 2604 OID 210565)
-- Dependencies: 618 618
-- Name: fecha_reg; Type: DEFAULT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY tcajero ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 6181 (class 2604 OID 210566)
-- Dependencies: 618 618
-- Name: fecha_mod; Type: DEFAULT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY tcajero ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 6182 (class 2604 OID 210567)
-- Dependencies: 618 618
-- Name: estado_reg; Type: DEFAULT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY tcajero ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 6184 (class 2604 OID 210577)
-- Dependencies: 620 620
-- Name: fecha_reg; Type: DEFAULT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY trecibo ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 6185 (class 2604 OID 210578)
-- Dependencies: 620 620
-- Name: fecha_mod; Type: DEFAULT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY trecibo ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 6186 (class 2604 OID 210579)
-- Dependencies: 620 620
-- Name: estado_reg; Type: DEFAULT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY trecibo ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


--
-- TOC entry 6189 (class 2604 OID 210588)
-- Dependencies: 621 621
-- Name: fecha_reg; Type: DEFAULT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY trendicion ALTER COLUMN fecha_reg SET DEFAULT now();


--
-- TOC entry 6190 (class 2604 OID 210589)
-- Dependencies: 621 621
-- Name: fecha_mod; Type: DEFAULT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY trendicion ALTER COLUMN fecha_mod SET DEFAULT now();


--
-- TOC entry 6191 (class 2604 OID 210590)
-- Dependencies: 621 621
-- Name: estado_reg; Type: DEFAULT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY trendicion ALTER COLUMN estado_reg SET DEFAULT 'activo'::character varying;


SET search_path = tesoro, pg_catalog;

--
-- TOC entry 6192 (class 2604 OID 210744)
-- Dependencies: 623 622
-- Name: id_corte; Type: DEFAULT; Schema: tesoro; Owner: -
--

ALTER TABLE ONLY tts_corte_moneda ALTER COLUMN id_corte SET DEFAULT nextval('tts_corte_moneda_id_corte_seq'::regclass);


SET search_path = actif, pg_catalog;

--
-- TOC entry 6208 (class 2606 OID 210746)
-- Dependencies: 204 204
-- Name: taf_activo_fijo_codigo_key; Type: CONSTRAINT; Schema: actif; Owner: -; Tablespace: 
--

ALTER TABLE ONLY taf_activo_fijo
    ADD CONSTRAINT taf_activo_fijo_codigo_key UNIQUE (codigo);


--
-- TOC entry 6214 (class 2606 OID 210748)
-- Dependencies: 204 204
-- Name: taf_activo_fijo_pkey; Type: CONSTRAINT; Schema: actif; Owner: -; Tablespace: 
--

ALTER TABLE ONLY taf_activo_fijo
    ADD CONSTRAINT taf_activo_fijo_pkey PRIMARY KEY (id_activo_fijo);


--
-- TOC entry 6218 (class 2606 OID 210750)
-- Dependencies: 206 206
-- Name: taf_sub_tipo_activo_pkey; Type: CONSTRAINT; Schema: actif; Owner: -; Tablespace: 
--

ALTER TABLE ONLY taf_sub_tipo_activo
    ADD CONSTRAINT taf_sub_tipo_activo_pkey PRIMARY KEY (id_sub_tipo_activo);


--
-- TOC entry 6220 (class 2606 OID 210752)
-- Dependencies: 208 208
-- Name: taf_tipo_activo_codigo_key; Type: CONSTRAINT; Schema: actif; Owner: -; Tablespace: 
--

ALTER TABLE ONLY taf_tipo_activo
    ADD CONSTRAINT taf_tipo_activo_codigo_key UNIQUE (codigo);


--
-- TOC entry 6223 (class 2606 OID 210754)
-- Dependencies: 208 208
-- Name: taf_tipo_activo_pkey; Type: CONSTRAINT; Schema: actif; Owner: -; Tablespace: 
--

ALTER TABLE ONLY taf_tipo_activo
    ADD CONSTRAINT taf_tipo_activo_pkey PRIMARY KEY (id_tipo_activo);


SET search_path = cobra, pg_catalog;

--
-- TOC entry 6226 (class 2606 OID 210756)
-- Dependencies: 209 209
-- Name: tarqueo_estado_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_arqueo_estado
    ADD CONSTRAINT tarqueo_estado_pkey PRIMARY KEY (id_arqueo_estado);


--
-- TOC entry 6228 (class 2606 OID 210758)
-- Dependencies: 211 211
-- Name: tcb_agencia_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_agencia
    ADD CONSTRAINT tcb_agencia_pkey PRIMARY KEY (id_agencia);


--
-- TOC entry 6232 (class 2606 OID 210760)
-- Dependencies: 214 214
-- Name: tcb_arqueo_det_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_arqueo_det
    ADD CONSTRAINT tcb_arqueo_det_pkey PRIMARY KEY (id_arqueo_det);


--
-- TOC entry 6230 (class 2606 OID 210762)
-- Dependencies: 213 213
-- Name: tcb_arqueo_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_arqueo
    ADD CONSTRAINT tcb_arqueo_pkey PRIMARY KEY (id_arqueo);


--
-- TOC entry 6238 (class 2606 OID 210764)
-- Dependencies: 219 219
-- Name: tcb_caja_estado_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_caja_estado
    ADD CONSTRAINT tcb_caja_estado_pkey PRIMARY KEY (id_caja_estado);


--
-- TOC entry 6234 (class 2606 OID 210766)
-- Dependencies: 216 216
-- Name: tcb_caja_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_caja
    ADD CONSTRAINT tcb_caja_pkey PRIMARY KEY (id_caja);


--
-- TOC entry 6236 (class 2606 OID 210768)
-- Dependencies: 217 217
-- Name: tcb_cajero_estado_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_caja_cajero
    ADD CONSTRAINT tcb_cajero_estado_pkey PRIMARY KEY (id_caja_cajero);


--
-- TOC entry 6240 (class 2606 OID 210770)
-- Dependencies: 222 222
-- Name: tcb_cajero_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_cajero
    ADD CONSTRAINT tcb_cajero_pkey PRIMARY KEY (id_cajero);


--
-- TOC entry 6242 (class 2606 OID 210772)
-- Dependencies: 225 225 225
-- Name: tcb_cliente_idx; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_cliente
    ADD CONSTRAINT tcb_cliente_idx UNIQUE (id_sistema_dist, id_cliente_dist);


--
-- TOC entry 6244 (class 2606 OID 210774)
-- Dependencies: 225 225
-- Name: tcb_cliente_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_cliente
    ADD CONSTRAINT tcb_cliente_pkey PRIMARY KEY (id_cliente);


--
-- TOC entry 6246 (class 2606 OID 210776)
-- Dependencies: 227 227
-- Name: tcb_cobro_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_cobro
    ADD CONSTRAINT tcb_cobro_pkey PRIMARY KEY (id_cobro);


--
-- TOC entry 6248 (class 2606 OID 210778)
-- Dependencies: 229 229
-- Name: tcb_enti_fin2_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_enti_fin
    ADD CONSTRAINT tcb_enti_fin2_pkey PRIMARY KEY (id_enti_fin);


--
-- TOC entry 6252 (class 2606 OID 210780)
-- Dependencies: 232 232
-- Name: tcb_factura_cob_anulado_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_factura_cob_anulado
    ADD CONSTRAINT tcb_factura_cob_anulado_pkey PRIMARY KEY (id_factura_cob_anulado);


--
-- TOC entry 6254 (class 2606 OID 210782)
-- Dependencies: 234 234
-- Name: tcb_factura_cob_det_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_factura_cob_det
    ADD CONSTRAINT tcb_factura_cob_det_pkey PRIMARY KEY (id_factura_cob_det);


--
-- TOC entry 6250 (class 2606 OID 210784)
-- Dependencies: 231 231
-- Name: tcb_factura_cob_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_factura_cob
    ADD CONSTRAINT tcb_factura_cob_pkey PRIMARY KEY (id_factura_cob);


--
-- TOC entry 6256 (class 2606 OID 210786)
-- Dependencies: 237 237
-- Name: tcb_prueba_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_prueba
    ADD CONSTRAINT tcb_prueba_pkey PRIMARY KEY (id_prueba);


--
-- TOC entry 6264 (class 2606 OID 210788)
-- Dependencies: 240 240
-- Name: tcb_sistema_dist_agencia_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_sistema_dist_agencia
    ADD CONSTRAINT tcb_sistema_dist_agencia_pkey PRIMARY KEY (id_sistema_dist_agencia);


--
-- TOC entry 6258 (class 2606 OID 210790)
-- Dependencies: 239 239
-- Name: tcb_sistema_dist_codigo_key; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_sistema_dist
    ADD CONSTRAINT tcb_sistema_dist_codigo_key UNIQUE (codigo);


--
-- TOC entry 6260 (class 2606 OID 210792)
-- Dependencies: 239 239
-- Name: tcb_sistema_dist_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_sistema_dist
    ADD CONSTRAINT tcb_sistema_dist_pkey PRIMARY KEY (id_sistema_dist);


--
-- TOC entry 6266 (class 2606 OID 210794)
-- Dependencies: 243 243
-- Name: tcb_sistema_dist_usuario_pkey; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_sistema_dist_usuario
    ADD CONSTRAINT tcb_sistema_dist_usuario_pkey PRIMARY KEY (id_sistema_dist_usuario);


--
-- TOC entry 6262 (class 2606 OID 210796)
-- Dependencies: 239 239
-- Name: tcb_sistema_distribucion_nombre_sistema_distribucion_key; Type: CONSTRAINT; Schema: cobra; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcb_sistema_dist
    ADD CONSTRAINT tcb_sistema_distribucion_nombre_sistema_distribucion_key UNIQUE (nombre);


SET search_path = conta, pg_catalog;

--
-- TOC entry 6272 (class 2606 OID 210798)
-- Dependencies: 250 250
-- Name: pk_tdocumento__id_documento; Type: CONSTRAINT; Schema: conta; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tdocumento
    ADD CONSTRAINT pk_tdocumento__id_documento PRIMARY KEY (id_documento);


--
-- TOC entry 6274 (class 2606 OID 210800)
-- Dependencies: 251 251
-- Name: pk_tdocumento_tipo; Type: CONSTRAINT; Schema: conta; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tdocumento_tipo
    ADD CONSTRAINT pk_tdocumento_tipo PRIMARY KEY (id_documento_tipo);


--
-- TOC entry 6268 (class 2606 OID 210802)
-- Dependencies: 246 246
-- Name: tauxiliar_pkey; Type: CONSTRAINT; Schema: conta; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tauxiliar
    ADD CONSTRAINT tauxiliar_pkey PRIMARY KEY (id_auxiliar);


--
-- TOC entry 6270 (class 2606 OID 210804)
-- Dependencies: 248 248
-- Name: tcuenta_pkey; Type: CONSTRAINT; Schema: conta; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcuenta
    ADD CONSTRAINT tcuenta_pkey PRIMARY KEY (id_cuenta);


SET search_path = factur, pg_catalog;

--
-- TOC entry 6277 (class 2606 OID 210806)
-- Dependencies: 252 252
-- Name: tfv_descuento_pkey; Type: CONSTRAINT; Schema: factur; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tfv_descuento
    ADD CONSTRAINT tfv_descuento_pkey PRIMARY KEY (id_descuento);


--
-- TOC entry 6279 (class 2606 OID 210808)
-- Dependencies: 254 254
-- Name: tfv_entidad_fin_pkey; Type: CONSTRAINT; Schema: factur; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tfv_entidad_fin
    ADD CONSTRAINT tfv_entidad_fin_pkey PRIMARY KEY (id_enti_fin);


--
-- TOC entry 6282 (class 2606 OID 210810)
-- Dependencies: 256 256
-- Name: tfv_tasa_pkey; Type: CONSTRAINT; Schema: factur; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tfv_tasa
    ADD CONSTRAINT tfv_tasa_pkey PRIMARY KEY (id_tasa);


SET search_path = gem, pg_catalog;

--
-- TOC entry 6796 (class 2606 OID 313643)
-- Dependencies: 625 625
-- Name: tlocalizacion_pkey; Type: CONSTRAINT; Schema: gem; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlocalizacion
    ADD CONSTRAINT tlocalizacion_pkey PRIMARY KEY (id_localizacion);


SET search_path = gen, pg_catalog;

--
-- TOC entry 6284 (class 2606 OID 210812)
-- Dependencies: 259 259
-- Name: pk_tcolumna__id_columna; Type: CONSTRAINT; Schema: gen; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcolumna
    ADD CONSTRAINT pk_tcolumna__id_columna PRIMARY KEY (id_columna);


--
-- TOC entry 6286 (class 2606 OID 210814)
-- Dependencies: 260 260
-- Name: pk_ttabla__id_tabla; Type: CONSTRAINT; Schema: gen; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ttabla
    ADD CONSTRAINT pk_ttabla__id_tabla PRIMARY KEY (id_tabla);


SET search_path = gev, pg_catalog;

--
-- TOC entry 6289 (class 2606 OID 210816)
-- Dependencies: 263 263
-- Name: tgv_activo_datos_tec_id_activo_fijo_key; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_activo_datos_tec
    ADD CONSTRAINT tgv_activo_datos_tec_id_activo_fijo_key UNIQUE (id_activo_fijo);


--
-- TOC entry 6291 (class 2606 OID 210818)
-- Dependencies: 263 263
-- Name: tgv_activo_datos_tec_modem_id_key; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_activo_datos_tec
    ADD CONSTRAINT tgv_activo_datos_tec_modem_id_key UNIQUE (modem_id);


--
-- TOC entry 6293 (class 2606 OID 210820)
-- Dependencies: 263 263
-- Name: tgv_activo_datos_tec_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_activo_datos_tec
    ADD CONSTRAINT tgv_activo_datos_tec_pkey PRIMARY KEY (id_activo_datos_tec);


--
-- TOC entry 6299 (class 2606 OID 210822)
-- Dependencies: 271 271
-- Name: tgv_activo_fijo_Ultimo_Registro_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_activo_fijo_ultimo_registro
    ADD CONSTRAINT "tgv_activo_fijo_Ultimo_Registro_pkey" PRIMARY KEY (id_ultimo_registro);


--
-- TOC entry 6295 (class 2606 OID 210824)
-- Dependencies: 265 265
-- Name: tgv_activo_fijo_grupo_evento_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_activo_fijo_grupo_evento
    ADD CONSTRAINT tgv_activo_fijo_grupo_evento_pkey PRIMARY KEY (id_activo_fijo_grupo_evento);


--
-- TOC entry 6297 (class 2606 OID 210826)
-- Dependencies: 269 269
-- Name: tgv_activo_fijo_rastreo_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_activo_fijo_rastreo
    ADD CONSTRAINT tgv_activo_fijo_rastreo_pkey PRIMARY KEY (id_activo_fijo_rastreo);


--
-- TOC entry 6303 (class 2606 OID 210828)
-- Dependencies: 274 274
-- Name: tgv_agrupacion_evento_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_agrupacion_evento
    ADD CONSTRAINT tgv_agrupacion_evento_pkey PRIMARY KEY (id_agrupacion_evento);


--
-- TOC entry 6301 (class 2606 OID 210830)
-- Dependencies: 273 273
-- Name: tgv_agrupacion_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_agrupacion
    ADD CONSTRAINT tgv_agrupacion_pkey PRIMARY KEY (id_agrupacion);


--
-- TOC entry 6305 (class 2606 OID 210832)
-- Dependencies: 279 279
-- Name: tgv_bitacora_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_bitacora
    ADD CONSTRAINT tgv_bitacora_pkey PRIMARY KEY (id_bitacora);


--
-- TOC entry 6307 (class 2606 OID 210834)
-- Dependencies: 282 282
-- Name: tgv_datos_tec_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_datos_tec
    ADD CONSTRAINT tgv_datos_tec_pkey PRIMARY KEY (id_datos_tec);


--
-- TOC entry 6309 (class 2606 OID 210836)
-- Dependencies: 284 284
-- Name: tgv_evento_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_evento
    ADD CONSTRAINT tgv_evento_pkey PRIMARY KEY (id_evento);


--
-- TOC entry 6311 (class 2606 OID 210838)
-- Dependencies: 287 287
-- Name: tgv_iboton_codigo_key; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_iboton
    ADD CONSTRAINT tgv_iboton_codigo_key UNIQUE (codigo);


--
-- TOC entry 6313 (class 2606 OID 210840)
-- Dependencies: 287 287
-- Name: tgv_iboton_id_funcionario_key; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_iboton
    ADD CONSTRAINT tgv_iboton_id_funcionario_key UNIQUE (id_funcionario);


--
-- TOC entry 6315 (class 2606 OID 210842)
-- Dependencies: 287 287
-- Name: tgv_iboton_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_iboton
    ADD CONSTRAINT tgv_iboton_pkey PRIMARY KEY (id_iboton);


--
-- TOC entry 6319 (class 2606 OID 210844)
-- Dependencies: 290 290
-- Name: tgv_mantenimiento_det_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_mantenimiento_det
    ADD CONSTRAINT tgv_mantenimiento_det_pkey PRIMARY KEY (id_mantenimiento_det);


--
-- TOC entry 6317 (class 2606 OID 210846)
-- Dependencies: 289 289
-- Name: tgv_mantenimiento_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_mantenimiento
    ADD CONSTRAINT tgv_mantenimiento_pkey PRIMARY KEY (id_mantenimiento);


--
-- TOC entry 6321 (class 2606 OID 210848)
-- Dependencies: 298 298
-- Name: tgv_marca_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_marca
    ADD CONSTRAINT tgv_marca_pkey PRIMARY KEY (id_marca);


--
-- TOC entry 6323 (class 2606 OID 210850)
-- Dependencies: 300 300
-- Name: tgv_modelo_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_modelo
    ADD CONSTRAINT tgv_modelo_pkey PRIMARY KEY (id_modelo);


--
-- TOC entry 6329 (class 2606 OID 210852)
-- Dependencies: 304 304
-- Name: tgv_servicio_det_evento_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_servicio_det_evento
    ADD CONSTRAINT tgv_servicio_det_evento_pkey PRIMARY KEY (id_servicio_det_evento);


--
-- TOC entry 6327 (class 2606 OID 210854)
-- Dependencies: 303 303
-- Name: tgv_servicio_det_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_servicio_det
    ADD CONSTRAINT tgv_servicio_det_pkey PRIMARY KEY (id_servicio_det);


--
-- TOC entry 6325 (class 2606 OID 210856)
-- Dependencies: 302 302
-- Name: tgv_servicio_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_servicio
    ADD CONSTRAINT tgv_servicio_pkey PRIMARY KEY (id_servicio);


--
-- TOC entry 6331 (class 2606 OID 210858)
-- Dependencies: 314 314
-- Name: tgv_tipo_evento_pkey; Type: CONSTRAINT; Schema: gev; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgv_tipo_evento
    ADD CONSTRAINT tgv_tipo_evento_pkey PRIMARY KEY (id_tipo_evento);


SET search_path = hidro, pg_catalog;

--
-- TOC entry 6339 (class 2606 OID 210860)
-- Dependencies: 318 318
-- Name: thd_administrador_hidro_codigo_key; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_administrador_hidro
    ADD CONSTRAINT thd_administrador_hidro_codigo_key UNIQUE (codigo);


--
-- TOC entry 6341 (class 2606 OID 210862)
-- Dependencies: 318 318
-- Name: thd_administrador_hidro_nombre_key; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_administrador_hidro
    ADD CONSTRAINT thd_administrador_hidro_nombre_key UNIQUE (nombre);


--
-- TOC entry 6343 (class 2606 OID 210864)
-- Dependencies: 318 318
-- Name: thd_administrador_hidro_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_administrador_hidro
    ADD CONSTRAINT thd_administrador_hidro_pkey PRIMARY KEY (id_administrador);


--
-- TOC entry 6345 (class 2606 OID 210866)
-- Dependencies: 320 320
-- Name: thd_archivo_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_archivo
    ADD CONSTRAINT thd_archivo_pkey PRIMARY KEY (id_archivo);


--
-- TOC entry 6347 (class 2606 OID 210868)
-- Dependencies: 322 322
-- Name: thd_archivo_sensor_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_archivo_sensor
    ADD CONSTRAINT thd_archivo_sensor_pkey PRIMARY KEY (id_archivo_sensor);


--
-- TOC entry 6349 (class 2606 OID 210870)
-- Dependencies: 325 325
-- Name: thd_cuenca_codigo_key; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_cuenca
    ADD CONSTRAINT thd_cuenca_codigo_key UNIQUE (codigo);


--
-- TOC entry 6351 (class 2606 OID 210872)
-- Dependencies: 325 325
-- Name: thd_cuenca_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_cuenca
    ADD CONSTRAINT thd_cuenca_pkey PRIMARY KEY (id_cuenca);


--
-- TOC entry 6353 (class 2606 OID 210874)
-- Dependencies: 327 327
-- Name: thd_estacion_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_estacion
    ADD CONSTRAINT thd_estacion_pkey PRIMARY KEY (id_estacion);


--
-- TOC entry 6355 (class 2606 OID 210876)
-- Dependencies: 329 329
-- Name: thd_estacion_proyecto_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_estacion_proyecto
    ADD CONSTRAINT thd_estacion_proyecto_pkey PRIMARY KEY (id_estacion_proyecto);


--
-- TOC entry 6357 (class 2606 OID 210878)
-- Dependencies: 331 331
-- Name: thd_medicion_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_medicion
    ADD CONSTRAINT thd_medicion_pkey PRIMARY KEY (id_medicion);


--
-- TOC entry 6360 (class 2606 OID 210880)
-- Dependencies: 333 333
-- Name: thd_operador_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_operador
    ADD CONSTRAINT thd_operador_pkey PRIMARY KEY (id_operador);


--
-- TOC entry 6362 (class 2606 OID 210882)
-- Dependencies: 335 335
-- Name: thd_rio_codigo_key; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_rio
    ADD CONSTRAINT thd_rio_codigo_key UNIQUE (codigo);


--
-- TOC entry 6364 (class 2606 OID 210884)
-- Dependencies: 335 335
-- Name: thd_rio_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_rio
    ADD CONSTRAINT thd_rio_pkey PRIMARY KEY (id_rio);


--
-- TOC entry 6366 (class 2606 OID 210886)
-- Dependencies: 337 337
-- Name: thd_sensores_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_sensor
    ADD CONSTRAINT thd_sensores_pkey PRIMARY KEY (id_sensor);


--
-- TOC entry 6368 (class 2606 OID 210888)
-- Dependencies: 339 339
-- Name: thd_tipo_archivo_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_archivo
    ADD CONSTRAINT thd_tipo_archivo_pkey PRIMARY KEY (id_tipo_archivo);


--
-- TOC entry 6370 (class 2606 OID 210890)
-- Dependencies: 341 341
-- Name: thd_tipo_columna_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_columna
    ADD CONSTRAINT thd_tipo_columna_pkey PRIMARY KEY (id_tipo_columna);


--
-- TOC entry 6373 (class 2606 OID 210892)
-- Dependencies: 343 343
-- Name: thd_tipo_columna_sensor_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_columna_sensor
    ADD CONSTRAINT thd_tipo_columna_sensor_pkey PRIMARY KEY (id_tipo_columna_sensor);


--
-- TOC entry 6375 (class 2606 OID 210894)
-- Dependencies: 345 345
-- Name: thd_tipo_dato_nombre_key; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_dato
    ADD CONSTRAINT thd_tipo_dato_nombre_key UNIQUE (tipo_dato);


--
-- TOC entry 6377 (class 2606 OID 210896)
-- Dependencies: 345 345
-- Name: thd_tipo_dato_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_dato
    ADD CONSTRAINT thd_tipo_dato_pkey PRIMARY KEY (id_tipo_dato);


--
-- TOC entry 6379 (class 2606 OID 210898)
-- Dependencies: 347 347
-- Name: thd_tipo_medicion_abreviacion_key; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor
    ADD CONSTRAINT thd_tipo_medicion_abreviacion_key UNIQUE (abreviacion);


--
-- TOC entry 6381 (class 2606 OID 210900)
-- Dependencies: 347 347
-- Name: thd_tipo_medicion_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor
    ADD CONSTRAINT thd_tipo_medicion_pkey PRIMARY KEY (id_tipo_sensor);


--
-- TOC entry 6385 (class 2606 OID 210902)
-- Dependencies: 349 349
-- Name: thd_tipo_muestra_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_muestra
    ADD CONSTRAINT thd_tipo_muestra_pkey PRIMARY KEY (id_tipo_muestra);


--
-- TOC entry 6387 (class 2606 OID 210904)
-- Dependencies: 351 351
-- Name: thd_tipo_sensor_22_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_22
    ADD CONSTRAINT thd_tipo_sensor_22_pkey PRIMARY KEY (id_tipo_sensor_22);


--
-- TOC entry 6389 (class 2606 OID 210906)
-- Dependencies: 353 353
-- Name: thd_tipo_sensor_33_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_33
    ADD CONSTRAINT thd_tipo_sensor_33_pkey PRIMARY KEY (id_tipo_sensor_33);


--
-- TOC entry 6391 (class 2606 OID 210908)
-- Dependencies: 355 355
-- Name: thd_tipo_sensor_44_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_44
    ADD CONSTRAINT thd_tipo_sensor_44_pkey PRIMARY KEY (id_tipo_sensor_44);


--
-- TOC entry 6393 (class 2606 OID 210910)
-- Dependencies: 357 357
-- Name: thd_tipo_sensor_anemometro_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_anemometro
    ADD CONSTRAINT thd_tipo_sensor_anemometro_pkey PRIMARY KEY (id_tipo_sensor_anemometro);


--
-- TOC entry 6395 (class 2606 OID 210912)
-- Dependencies: 359 359
-- Name: thd_tipo_sensor_caudal_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_caudal
    ADD CONSTRAINT thd_tipo_sensor_caudal_pkey PRIMARY KEY (id_tipo_sensor_caudal);


--
-- TOC entry 6383 (class 2606 OID 210914)
-- Dependencies: 347 347
-- Name: thd_tipo_sensor_codigo_key; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor
    ADD CONSTRAINT thd_tipo_sensor_codigo_key UNIQUE (codigo);


--
-- TOC entry 6397 (class 2606 OID 210916)
-- Dependencies: 361 361
-- Name: thd_tipo_sensor_limnimetrica_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_limnimetrica
    ADD CONSTRAINT thd_tipo_sensor_limnimetrica_pkey PRIMARY KEY (id_tipo_sensor_limnimetrica);


--
-- TOC entry 6399 (class 2606 OID 210918)
-- Dependencies: 363 363
-- Name: thd_tipo_sensor_presion_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_presion
    ADD CONSTRAINT thd_tipo_sensor_presion_pkey PRIMARY KEY (id_tipo_sensor_presion);


--
-- TOC entry 6401 (class 2606 OID 210920)
-- Dependencies: 365 365
-- Name: thd_tipo_sensor_pru_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_pru
    ADD CONSTRAINT thd_tipo_sensor_pru_pkey PRIMARY KEY (id_tipo_sensor_pru);


--
-- TOC entry 6403 (class 2606 OID 210922)
-- Dependencies: 367 367
-- Name: thd_tipo_sensor_prue_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_prue
    ADD CONSTRAINT thd_tipo_sensor_prue_pkey PRIMARY KEY (id_tipo_sensor_prue);


--
-- TOC entry 6405 (class 2606 OID 210924)
-- Dependencies: 369 369
-- Name: thd_tipo_sensor_termo_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_tipo_sensor_termo
    ADD CONSTRAINT thd_tipo_sensor_termo_pkey PRIMARY KEY (id_tipo_sensor_termo);


--
-- TOC entry 6407 (class 2606 OID 210926)
-- Dependencies: 371 371
-- Name: thd_unidad_medida_pkey; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_unidad_medida
    ADD CONSTRAINT thd_unidad_medida_pkey PRIMARY KEY (simbolo);


--
-- TOC entry 6409 (class 2606 OID 210928)
-- Dependencies: 371 371
-- Name: thd_unidad_medida_unidad_medida_key; Type: CONSTRAINT; Schema: hidro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thd_unidad_medida
    ADD CONSTRAINT thd_unidad_medida_unidad_medida_key UNIQUE (unidad_medida);


SET search_path = log, pg_catalog;

--
-- TOC entry 6416 (class 2606 OID 210930)
-- Dependencies: 374 374
-- Name: tlog_2011_02_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_02
    ADD CONSTRAINT tlog_2011_02_id_log_key UNIQUE (id_log);


--
-- TOC entry 6419 (class 2606 OID 210932)
-- Dependencies: 375 375
-- Name: tlog_2011_04_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_04
    ADD CONSTRAINT tlog_2011_04_id_log_key UNIQUE (id_log);


--
-- TOC entry 6422 (class 2606 OID 210934)
-- Dependencies: 376 376
-- Name: tlog_2011_05_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_05
    ADD CONSTRAINT tlog_2011_05_id_log_key UNIQUE (id_log);


--
-- TOC entry 6425 (class 2606 OID 210936)
-- Dependencies: 377 377
-- Name: tlog_2011_06_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_06
    ADD CONSTRAINT tlog_2011_06_id_log_key UNIQUE (id_log);


--
-- TOC entry 6428 (class 2606 OID 210938)
-- Dependencies: 378 378
-- Name: tlog_2011_07_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_07
    ADD CONSTRAINT tlog_2011_07_id_log_key UNIQUE (id_log);


--
-- TOC entry 6431 (class 2606 OID 210940)
-- Dependencies: 379 379
-- Name: tlog_2011_08_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_08
    ADD CONSTRAINT tlog_2011_08_id_log_key UNIQUE (id_log);


--
-- TOC entry 6434 (class 2606 OID 210942)
-- Dependencies: 380 380
-- Name: tlog_2011_09_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_09
    ADD CONSTRAINT tlog_2011_09_id_log_key UNIQUE (id_log);


--
-- TOC entry 6437 (class 2606 OID 210944)
-- Dependencies: 381 381
-- Name: tlog_2011_10_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_10
    ADD CONSTRAINT tlog_2011_10_id_log_key UNIQUE (id_log);


--
-- TOC entry 6440 (class 2606 OID 210946)
-- Dependencies: 382 382
-- Name: tlog_2011_11_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_11
    ADD CONSTRAINT tlog_2011_11_id_log_key UNIQUE (id_log);


--
-- TOC entry 6443 (class 2606 OID 210948)
-- Dependencies: 383 383
-- Name: tlog_2011_12_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2011_12
    ADD CONSTRAINT tlog_2011_12_id_log_key UNIQUE (id_log);


--
-- TOC entry 6446 (class 2606 OID 210950)
-- Dependencies: 384 384
-- Name: tlog_2012_01_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2012_01
    ADD CONSTRAINT tlog_2012_01_id_log_key UNIQUE (id_log);


--
-- TOC entry 6449 (class 2606 OID 210952)
-- Dependencies: 385 385
-- Name: tlog_2012_02_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2012_02
    ADD CONSTRAINT tlog_2012_02_id_log_key UNIQUE (id_log);


--
-- TOC entry 6452 (class 2606 OID 210954)
-- Dependencies: 386 386
-- Name: tlog_2012_03_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2012_03
    ADD CONSTRAINT tlog_2012_03_id_log_key UNIQUE (id_log);


--
-- TOC entry 6455 (class 2606 OID 210956)
-- Dependencies: 387 387
-- Name: tlog_2012_04_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2012_04
    ADD CONSTRAINT tlog_2012_04_id_log_key UNIQUE (id_log);


--
-- TOC entry 6458 (class 2606 OID 210958)
-- Dependencies: 388 388
-- Name: tlog_2012_05_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2012_05
    ADD CONSTRAINT tlog_2012_05_id_log_key UNIQUE (id_log);


--
-- TOC entry 6461 (class 2606 OID 210960)
-- Dependencies: 389 389
-- Name: tlog_2012_06_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2012_06
    ADD CONSTRAINT tlog_2012_06_id_log_key UNIQUE (id_log);


--
-- TOC entry 6798 (class 2606 OID 318942)
-- Dependencies: 626 626
-- Name: tlog_2012_08_id_log_key; Type: CONSTRAINT; Schema: log; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_2012_08
    ADD CONSTRAINT tlog_2012_08_id_log_key UNIQUE (id_log);


SET search_path = param, pg_catalog;

--
-- TOC entry 6490 (class 2606 OID 210962)
-- Dependencies: 414 414
-- Name: pk_pm_id_financiador; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tpm_financiador
    ADD CONSTRAINT pk_pm_id_financiador PRIMARY KEY (id_financiador);


--
-- TOC entry 6494 (class 2606 OID 210964)
-- Dependencies: 416 416
-- Name: pk_pm_id_programa; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tpm_programa
    ADD CONSTRAINT pk_pm_id_programa PRIMARY KEY (id_programa);


--
-- TOC entry 6498 (class 2606 OID 210966)
-- Dependencies: 418 418
-- Name: pk_pm_id_proyecto; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tpm_proyecto
    ADD CONSTRAINT pk_pm_id_proyecto PRIMARY KEY (id_proyecto);


--
-- TOC entry 6502 (class 2606 OID 210968)
-- Dependencies: 420 420
-- Name: pk_pm_id_regional; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tpm_regional
    ADD CONSTRAINT pk_pm_id_regional PRIMARY KEY (id_regional);


--
-- TOC entry 6464 (class 2606 OID 210970)
-- Dependencies: 390 390
-- Name: table1_pkey; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY table1
    ADD CONSTRAINT table1_pkey PRIMARY KEY (id_depto_usuario);


--
-- TOC entry 6466 (class 2606 OID 210972)
-- Dependencies: 392 392
-- Name: talarma_pkey; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY talarma
    ADD CONSTRAINT talarma_pkey PRIMARY KEY (id_alarma);


--
-- TOC entry 6468 (class 2606 OID 210974)
-- Dependencies: 396 396
-- Name: tcorrelativo_pkey; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcorrelativo
    ADD CONSTRAINT tcorrelativo_pkey PRIMARY KEY (id_correlativo);


--
-- TOC entry 6470 (class 2606 OID 210976)
-- Dependencies: 398 398
-- Name: tdepto_pkey; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tdepto
    ADD CONSTRAINT tdepto_pkey PRIMARY KEY (id_depto);


--
-- TOC entry 6472 (class 2606 OID 210978)
-- Dependencies: 400 400
-- Name: tdepto_usuairo_pkey; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tdepto_usuario
    ADD CONSTRAINT tdepto_usuairo_pkey PRIMARY KEY (id_depto_usuario);


--
-- TOC entry 6474 (class 2606 OID 210980)
-- Dependencies: 402 402
-- Name: tdocumento_pkey; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tdocumento
    ADD CONSTRAINT tdocumento_pkey PRIMARY KEY (id_documento);


--
-- TOC entry 6476 (class 2606 OID 210982)
-- Dependencies: 404 404
-- Name: tgestion_pkey; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgestion
    ADD CONSTRAINT tgestion_pkey PRIMARY KEY (id_gestion);


--
-- TOC entry 6478 (class 2606 OID 210984)
-- Dependencies: 406 406
-- Name: tinstitucion_codigo_key; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tinstitucion
    ADD CONSTRAINT tinstitucion_codigo_key UNIQUE (codigo);


--
-- TOC entry 6481 (class 2606 OID 210986)
-- Dependencies: 406 406
-- Name: tinstitucion_pkey; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tinstitucion
    ADD CONSTRAINT tinstitucion_pkey PRIMARY KEY (id_institucion);


--
-- TOC entry 6483 (class 2606 OID 210988)
-- Dependencies: 408 408
-- Name: tlugas_pkey; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlugar
    ADD CONSTRAINT tlugas_pkey PRIMARY KEY (id_lugar);


--
-- TOC entry 6485 (class 2606 OID 210990)
-- Dependencies: 410 410
-- Name: tmoneda_pkey; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tmoneda
    ADD CONSTRAINT tmoneda_pkey PRIMARY KEY (id_moneda);


--
-- TOC entry 6488 (class 2606 OID 210992)
-- Dependencies: 412 412
-- Name: tperiodo_pkey; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tperiodo
    ADD CONSTRAINT tperiodo_pkey PRIMARY KEY (id_periodo);


--
-- TOC entry 6492 (class 2606 OID 210994)
-- Dependencies: 414 414
-- Name: tpm_financiador_codigo_financiador_key; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tpm_financiador
    ADD CONSTRAINT tpm_financiador_codigo_financiador_key UNIQUE (codigo_financiador);


--
-- TOC entry 6496 (class 2606 OID 210996)
-- Dependencies: 416 416
-- Name: tpm_programa_codigo_programa_key; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tpm_programa
    ADD CONSTRAINT tpm_programa_codigo_programa_key UNIQUE (codigo_programa);


--
-- TOC entry 6500 (class 2606 OID 210998)
-- Dependencies: 418 418
-- Name: tpm_proyecto_codigo_proyecto_key; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tpm_proyecto
    ADD CONSTRAINT tpm_proyecto_codigo_proyecto_key UNIQUE (codigo_proyecto);


--
-- TOC entry 6504 (class 2606 OID 211000)
-- Dependencies: 420 420
-- Name: tpm_regional_codigo_regional_key; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tpm_regional
    ADD CONSTRAINT tpm_regional_codigo_regional_key UNIQUE (codigo_regional);


--
-- TOC entry 6506 (class 2606 OID 211002)
-- Dependencies: 422 422 422 422
-- Name: tproveedor_idx; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tproveedor
    ADD CONSTRAINT tproveedor_idx UNIQUE (id_institucion, tipo, estado_reg);


--
-- TOC entry 6508 (class 2606 OID 211004)
-- Dependencies: 422 422 422 422
-- Name: tproveedor_idx1; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tproveedor
    ADD CONSTRAINT tproveedor_idx1 UNIQUE (id_persona, tipo, estado_reg);


--
-- TOC entry 6510 (class 2606 OID 211006)
-- Dependencies: 422 422
-- Name: tproveedor_pkey; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tproveedor
    ADD CONSTRAINT tproveedor_pkey PRIMARY KEY (id_proveedor);


--
-- TOC entry 6512 (class 2606 OID 211008)
-- Dependencies: 424 424
-- Name: tusuario_uo_pkey; Type: CONSTRAINT; Schema: param; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tusuario_uo
    ADD CONSTRAINT tusuario_uo_pkey PRIMARY KEY (id_usuario_uo);


SET search_path = public, pg_catalog;

--
-- TOC entry 6518 (class 2606 OID 211010)
-- Dependencies: 432 432 432 432 432
-- Name: geometry_columns_pk; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY geometry_columns
    ADD CONSTRAINT geometry_columns_pk PRIMARY KEY (f_table_catalog, f_table_schema, f_table_name, f_geometry_column);


--
-- TOC entry 6520 (class 2606 OID 211012)
-- Dependencies: 440 440
-- Name: spatial_ref_sys_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY spatial_ref_sys
    ADD CONSTRAINT spatial_ref_sys_pkey PRIMARY KEY (srid);


--
-- TOC entry 6522 (class 2606 OID 211014)
-- Dependencies: 446 446
-- Name: variable_global_pkey; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY variable_global
    ADD CONSTRAINT variable_global_pkey PRIMARY KEY (id_variable_global);


--
-- TOC entry 6524 (class 2606 OID 211016)
-- Dependencies: 446 446
-- Name: variable_global_variable_key; Type: CONSTRAINT; Schema: public; Owner: -; Tablespace: 
--

ALTER TABLE ONLY variable_global
    ADD CONSTRAINT variable_global_variable_key UNIQUE (variable);


SET search_path = rhum, pg_catalog;

--
-- TOC entry 6526 (class 2606 OID 211018)
-- Dependencies: 448 448
-- Name: tcolumna_pkey; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcolumna
    ADD CONSTRAINT tcolumna_pkey PRIMARY KEY (id_columna);


--
-- TOC entry 6528 (class 2606 OID 211020)
-- Dependencies: 450 450
-- Name: testructura_uo_pkey; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY testructura_uo
    ADD CONSTRAINT testructura_uo_pkey PRIMARY KEY (id_estructura_uo);


--
-- TOC entry 6534 (class 2606 OID 211022)
-- Dependencies: 453 453
-- Name: tfuncionario_horario_pkey; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tfuncionario_horario
    ADD CONSTRAINT tfuncionario_horario_pkey PRIMARY KEY (id_funcionario_horario);


--
-- TOC entry 6530 (class 2606 OID 211024)
-- Dependencies: 452 452
-- Name: tfuncionario_id_persona_key; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tfuncionario
    ADD CONSTRAINT tfuncionario_id_persona_key UNIQUE (id_persona);


--
-- TOC entry 6532 (class 2606 OID 211026)
-- Dependencies: 452 452
-- Name: tfuncionario_pkey; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tfuncionario
    ADD CONSTRAINT tfuncionario_pkey PRIMARY KEY (id_funcionario);


--
-- TOC entry 6537 (class 2606 OID 211028)
-- Dependencies: 456 456
-- Name: thorario_pkey; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thorario
    ADD CONSTRAINT thorario_pkey PRIMARY KEY (id_horario);


--
-- TOC entry 6539 (class 2606 OID 211030)
-- Dependencies: 458 458
-- Name: tnivel_organizacional_numero_nivel_key; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tnivel_organizacional
    ADD CONSTRAINT tnivel_organizacional_numero_nivel_key UNIQUE (numero_nivel);


--
-- TOC entry 6541 (class 2606 OID 211032)
-- Dependencies: 458 458
-- Name: tnivel_organizacional_pk_kp_id_nivel_organizacional; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tnivel_organizacional
    ADD CONSTRAINT tnivel_organizacional_pk_kp_id_nivel_organizacional PRIMARY KEY (id_nivel_organizacional);


--
-- TOC entry 6543 (class 2606 OID 211034)
-- Dependencies: 460 460
-- Name: tobligacion_pkey; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tobligacion
    ADD CONSTRAINT tobligacion_pkey PRIMARY KEY (id_obligacion);


--
-- TOC entry 6545 (class 2606 OID 211036)
-- Dependencies: 462 462
-- Name: tparametro_rhum_pkey; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tparametro_rhum
    ADD CONSTRAINT tparametro_rhum_pkey PRIMARY KEY (id_parametro);


--
-- TOC entry 6547 (class 2606 OID 211038)
-- Dependencies: 464 464
-- Name: tplanilla_pkey; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tplanilla
    ADD CONSTRAINT tplanilla_pkey PRIMARY KEY (id_planilla);


--
-- TOC entry 6549 (class 2606 OID 211040)
-- Dependencies: 466 466
-- Name: ttipo_columna_pkey; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ttipo_columna
    ADD CONSTRAINT ttipo_columna_pkey PRIMARY KEY (id_tipo_columna);


--
-- TOC entry 6551 (class 2606 OID 211042)
-- Dependencies: 468 468
-- Name: ttipo_horario_pkey; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ttipo_horario
    ADD CONSTRAINT ttipo_horario_pkey PRIMARY KEY (id_tipo_horario);


--
-- TOC entry 6553 (class 2606 OID 211044)
-- Dependencies: 470 470
-- Name: ttipo_obligacion_pkey; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ttipo_obligacion
    ADD CONSTRAINT ttipo_obligacion_pkey PRIMARY KEY (id_tipo_obligacion);


--
-- TOC entry 6555 (class 2606 OID 211046)
-- Dependencies: 472 472
-- Name: ttipo_planilla_pkey; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ttipo_planilla
    ADD CONSTRAINT ttipo_planilla_pkey PRIMARY KEY (id_tipo_planilla);


--
-- TOC entry 6559 (class 2606 OID 211048)
-- Dependencies: 475 475
-- Name: tuo_funcionario_pkey; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tuo_funcionario
    ADD CONSTRAINT tuo_funcionario_pkey PRIMARY KEY (id_uo_funcionario);


--
-- TOC entry 6557 (class 2606 OID 211050)
-- Dependencies: 474 474
-- Name: tuo_pkey; Type: CONSTRAINT; Schema: rhum; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tuo
    ADD CONSTRAINT tuo_pkey PRIMARY KEY (id_uo);


SET search_path = saj, pg_catalog;

--
-- TOC entry 6561 (class 2606 OID 211052)
-- Dependencies: 480 480
-- Name: tboleta_pkey; Type: CONSTRAINT; Schema: saj; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tboleta
    ADD CONSTRAINT tboleta_pkey PRIMARY KEY (id_boleta);


--
-- TOC entry 6563 (class 2606 OID 211054)
-- Dependencies: 483 483
-- Name: tdocumento_anexo_pkey; Type: CONSTRAINT; Schema: saj; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tdocumento_anexo
    ADD CONSTRAINT tdocumento_anexo_pkey PRIMARY KEY (id_documento_anexo);


--
-- TOC entry 6565 (class 2606 OID 211056)
-- Dependencies: 485 485
-- Name: testado_codigo_key; Type: CONSTRAINT; Schema: saj; Owner: -; Tablespace: 
--

ALTER TABLE ONLY testado
    ADD CONSTRAINT testado_codigo_key UNIQUE (codigo);


--
-- TOC entry 6567 (class 2606 OID 211058)
-- Dependencies: 485 485
-- Name: testado_nombre_key; Type: CONSTRAINT; Schema: saj; Owner: -; Tablespace: 
--

ALTER TABLE ONLY testado
    ADD CONSTRAINT testado_nombre_key UNIQUE (nombre);


--
-- TOC entry 6569 (class 2606 OID 211060)
-- Dependencies: 485 485
-- Name: testado_orden_key; Type: CONSTRAINT; Schema: saj; Owner: -; Tablespace: 
--

ALTER TABLE ONLY testado
    ADD CONSTRAINT testado_orden_key UNIQUE (orden);


--
-- TOC entry 6571 (class 2606 OID 211062)
-- Dependencies: 485 485
-- Name: testado_pkey; Type: CONSTRAINT; Schema: saj; Owner: -; Tablespace: 
--

ALTER TABLE ONLY testado
    ADD CONSTRAINT testado_pkey PRIMARY KEY (id_estado);


--
-- TOC entry 6573 (class 2606 OID 211064)
-- Dependencies: 487 487
-- Name: testado_proceso_pkey; Type: CONSTRAINT; Schema: saj; Owner: -; Tablespace: 
--

ALTER TABLE ONLY testado_proceso
    ADD CONSTRAINT testado_proceso_pkey PRIMARY KEY (id_estado_proceso);


--
-- TOC entry 6575 (class 2606 OID 211066)
-- Dependencies: 489 489
-- Name: tipo_contrato_pkey; Type: CONSTRAINT; Schema: saj; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ttipo_contrato
    ADD CONSTRAINT tipo_contrato_pkey PRIMARY KEY (id_tipo_contrato);


--
-- TOC entry 6577 (class 2606 OID 211068)
-- Dependencies: 491 491
-- Name: tmodalidad_pkey; Type: CONSTRAINT; Schema: saj; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tmodalidad
    ADD CONSTRAINT tmodalidad_pkey PRIMARY KEY (id_modalidad);


--
-- TOC entry 6579 (class 2606 OID 211070)
-- Dependencies: 493 493
-- Name: tproceso_contrato_pkey; Type: CONSTRAINT; Schema: saj; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT tproceso_contrato_pkey PRIMARY KEY (id_proceso_contrato);


--
-- TOC entry 6581 (class 2606 OID 211072)
-- Dependencies: 495 495
-- Name: tresponsable_proceso_pkey; Type: CONSTRAINT; Schema: saj; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tresponsable_proceso
    ADD CONSTRAINT tresponsable_proceso_pkey PRIMARY KEY (id_responsable_proceso);


SET search_path = sast, pg_catalog;

--
-- TOC entry 6584 (class 2606 OID 211074)
-- Dependencies: 498 498
-- Name: testado_orden_key; Type: CONSTRAINT; Schema: sast; Owner: -; Tablespace: 
--

ALTER TABLE ONLY testado
    ADD CONSTRAINT testado_orden_key UNIQUE (orden);


--
-- TOC entry 6586 (class 2606 OID 211076)
-- Dependencies: 498 498
-- Name: testado_pkey; Type: CONSTRAINT; Schema: sast; Owner: -; Tablespace: 
--

ALTER TABLE ONLY testado
    ADD CONSTRAINT testado_pkey PRIMARY KEY (id_estado);


--
-- TOC entry 6588 (class 2606 OID 211078)
-- Dependencies: 502 502
-- Name: tipo_requerimiento_pkey; Type: CONSTRAINT; Schema: sast; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ttipo_requerimiento
    ADD CONSTRAINT tipo_requerimiento_pkey PRIMARY KEY (id_tipo_requerimiento);


--
-- TOC entry 6590 (class 2606 OID 211080)
-- Dependencies: 505 505
-- Name: trequerimientos_pkey; Type: CONSTRAINT; Schema: sast; Owner: -; Tablespace: 
--

ALTER TABLE ONLY trequerimientos
    ADD CONSTRAINT trequerimientos_pkey PRIMARY KEY (id_requerimiento);


SET search_path = secont, pg_catalog;

--
-- TOC entry 6598 (class 2606 OID 211082)
-- Dependencies: 509 509
-- Name: pk_contratista; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY contratista
    ADD CONSTRAINT pk_contratista PRIMARY KEY (id_contratista);


--
-- TOC entry 6604 (class 2606 OID 211084)
-- Dependencies: 511 511
-- Name: pk_contrato; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY contrato
    ADD CONSTRAINT pk_contrato PRIMARY KEY (id_contrato);


--
-- TOC entry 6610 (class 2606 OID 211086)
-- Dependencies: 513 513
-- Name: pk_correspondencia; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY correspondencia
    ADD CONSTRAINT pk_correspondencia PRIMARY KEY (id_correspondencia);


--
-- TOC entry 6614 (class 2606 OID 211088)
-- Dependencies: 515 515
-- Name: pk_doc_anexo; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY doc_anexo
    ADD CONSTRAINT pk_doc_anexo PRIMARY KEY (id_documento);


--
-- TOC entry 6618 (class 2606 OID 211090)
-- Dependencies: 517 517
-- Name: pk_empleado; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY empleado
    ADD CONSTRAINT pk_empleado PRIMARY KEY (id_personal);


--
-- TOC entry 6623 (class 2606 OID 211092)
-- Dependencies: 519 519
-- Name: pk_estado; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY estado
    ADD CONSTRAINT pk_estado PRIMARY KEY (id_estado);


--
-- TOC entry 6626 (class 2606 OID 211094)
-- Dependencies: 521 521
-- Name: pk_estado_requerimiento; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY estado_requerimiento
    ADD CONSTRAINT pk_estado_requerimiento PRIMARY KEY (id_estado_requerimiento);


--
-- TOC entry 6632 (class 2606 OID 211096)
-- Dependencies: 523 523
-- Name: pk_garantia; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY garantia
    ADD CONSTRAINT pk_garantia PRIMARY KEY (id_garantia);


--
-- TOC entry 6635 (class 2606 OID 211098)
-- Dependencies: 525 525
-- Name: pk_informe; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY informe
    ADD CONSTRAINT pk_informe PRIMARY KEY (id_informe);


--
-- TOC entry 6593 (class 2606 OID 211100)
-- Dependencies: 508 508
-- Name: pk_leg_alarma; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY alarma
    ADD CONSTRAINT pk_leg_alarma PRIMARY KEY (id_alarma);


--
-- TOC entry 6639 (class 2606 OID 211102)
-- Dependencies: 528 528
-- Name: pk_oferta; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY oferta
    ADD CONSTRAINT pk_oferta PRIMARY KEY (id_oferta);


--
-- TOC entry 6643 (class 2606 OID 211104)
-- Dependencies: 530 530
-- Name: pk_persona_juridica; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY persona_juridica
    ADD CONSTRAINT pk_persona_juridica PRIMARY KEY (id_persona_juridica);


--
-- TOC entry 6645 (class 2606 OID 211106)
-- Dependencies: 532 532
-- Name: pk_proyecto; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY proyecto
    ADD CONSTRAINT pk_proyecto PRIMARY KEY (id_proyecto);


--
-- TOC entry 6648 (class 2606 OID 211108)
-- Dependencies: 534 534
-- Name: pk_representante; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY representante
    ADD CONSTRAINT pk_representante PRIMARY KEY (id_representante);


--
-- TOC entry 6652 (class 2606 OID 211110)
-- Dependencies: 536 536
-- Name: pk_requerimiento; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY requerimiento
    ADD CONSTRAINT pk_requerimiento PRIMARY KEY (id_requerimiento);


--
-- TOC entry 6658 (class 2606 OID 211112)
-- Dependencies: 538 538
-- Name: pk_resolucion; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY resolucion
    ADD CONSTRAINT pk_resolucion PRIMARY KEY (id_resolucion);


--
-- TOC entry 6661 (class 2606 OID 211114)
-- Dependencies: 540 540
-- Name: pk_unidad; Type: CONSTRAINT; Schema: secont; Owner: -; Tablespace: 
--

ALTER TABLE ONLY unidad
    ADD CONSTRAINT pk_unidad PRIMARY KEY (id_unidad);


SET search_path = segu, pg_catalog;

--
-- TOC entry 6713 (class 2606 OID 211116)
-- Dependencies: 582 582
-- Name: gui_codigo_gui_key; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgui
    ADD CONSTRAINT gui_codigo_gui_key UNIQUE (codigo_gui);


--
-- TOC entry 6682 (class 2606 OID 211118)
-- Dependencies: 557 557
-- Name: libreta_her_pkey; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY libreta_her
    ADD CONSTRAINT libreta_her_pkey PRIMARY KEY (id_libreta_her);


--
-- TOC entry 6680 (class 2606 OID 211120)
-- Dependencies: 556 556
-- Name: libreta_pkey; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY libreta
    ADD CONSTRAINT libreta_pkey PRIMARY KEY (id_libreta);


--
-- TOC entry 6515 (class 2606 OID 211122)
-- Dependencies: 426 426
-- Name: persona_pk_persona; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tpersona
    ADD CONSTRAINT persona_pk_persona PRIMARY KEY (id_persona);


--
-- TOC entry 6664 (class 2606 OID 211124)
-- Dependencies: 546 546
-- Name: pk_actividad; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tactividad
    ADD CONSTRAINT pk_actividad PRIMARY KEY (id_actividad);


--
-- TOC entry 6706 (class 2606 OID 211126)
-- Dependencies: 579 579
-- Name: pk_clasificador; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tclasificador
    ADD CONSTRAINT pk_clasificador PRIMARY KEY (id_clasificador);


--
-- TOC entry 6668 (class 2606 OID 211128)
-- Dependencies: 549 549
-- Name: pk_estructura_dato; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY testructura_dato
    ADD CONSTRAINT pk_estructura_dato PRIMARY KEY (id_estructura_dato);


--
-- TOC entry 6673 (class 2606 OID 211130)
-- Dependencies: 551 551
-- Name: pk_estructura_gui; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY testructura_gui
    ADD CONSTRAINT pk_estructura_gui PRIMARY KEY (id_estructura_gui);


--
-- TOC entry 6709 (class 2606 OID 211132)
-- Dependencies: 581 581
-- Name: pk_funcion; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tfuncion
    ADD CONSTRAINT pk_funcion PRIMARY KEY (id_funcion);


--
-- TOC entry 6716 (class 2606 OID 211134)
-- Dependencies: 582 582
-- Name: pk_gui; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgui
    ADD CONSTRAINT pk_gui PRIMARY KEY (id_gui);


--
-- TOC entry 6677 (class 2606 OID 211136)
-- Dependencies: 554 554
-- Name: pk_gui_rol; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tgui_rol
    ADD CONSTRAINT pk_gui_rol PRIMARY KEY (id_gui_rol);


--
-- TOC entry 6695 (class 2606 OID 211138)
-- Dependencies: 570 570
-- Name: pk_id_recurso; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY trecurso
    ADD CONSTRAINT pk_id_recurso PRIMARY KEY (id_recurso);


--
-- TOC entry 6720 (class 2606 OID 211140)
-- Dependencies: 586 586
-- Name: pk_id_tipo_documento; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY ttipo_documento
    ADD CONSTRAINT pk_id_tipo_documento PRIMARY KEY (id_tipo_documento);


--
-- TOC entry 6725 (class 2606 OID 211142)
-- Dependencies: 588 588
-- Name: pk_log; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog_
    ADD CONSTRAINT pk_log PRIMARY KEY (id_log);


--
-- TOC entry 6733 (class 2606 OID 211144)
-- Dependencies: 591 591
-- Name: pk_perfil; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tperfil
    ADD CONSTRAINT pk_perfil PRIMARY KEY (id_perfil);


--
-- TOC entry 6686 (class 2606 OID 211146)
-- Dependencies: 561 561
-- Name: pk_permiso; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tpermiso
    ADD CONSTRAINT pk_permiso PRIMARY KEY (id_permiso);


--
-- TOC entry 6735 (class 2606 OID 211148)
-- Dependencies: 593 593
-- Name: pk_primo; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tprimo
    ADD CONSTRAINT pk_primo PRIMARY KEY (id_primo);


--
-- TOC entry 6738 (class 2606 OID 211150)
-- Dependencies: 594 594
-- Name: pk_procedimiento; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tprocedimiento
    ADD CONSTRAINT pk_procedimiento PRIMARY KEY (id_procedimiento);


--
-- TOC entry 6689 (class 2606 OID 211152)
-- Dependencies: 564 564
-- Name: pk_procedimiento_gui; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tprocedimiento_gui
    ADD CONSTRAINT pk_procedimiento_gui PRIMARY KEY (id_procedimiento_gui);


--
-- TOC entry 6692 (class 2606 OID 211154)
-- Dependencies: 567 567
-- Name: pk_proyecto; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tproyecto
    ADD CONSTRAINT pk_proyecto PRIMARY KEY (id_proyecto);


--
-- TOC entry 6744 (class 2606 OID 211156)
-- Dependencies: 595 595
-- Name: pk_regional; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tregional
    ADD CONSTRAINT pk_regional PRIMARY KEY (id_regional);


--
-- TOC entry 6747 (class 2606 OID 211158)
-- Dependencies: 596 596
-- Name: pk_rol; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY trol
    ADD CONSTRAINT pk_rol PRIMARY KEY (id_rol);


--
-- TOC entry 6700 (class 2606 OID 211160)
-- Dependencies: 574 574
-- Name: pk_rol_procedimiento; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY trol_procedimiento_gui
    ADD CONSTRAINT pk_rol_procedimiento PRIMARY KEY (id_rol_procedimiento);


--
-- TOC entry 6752 (class 2606 OID 211162)
-- Dependencies: 599 599
-- Name: pk_subsistema; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tsubsistema
    ADD CONSTRAINT pk_subsistema PRIMARY KEY (id_subsistema);


--
-- TOC entry 6333 (class 2606 OID 211164)
-- Dependencies: 316 316
-- Name: pk_usuario; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tusuario
    ADD CONSTRAINT pk_usuario PRIMARY KEY (id_usuario);


--
-- TOC entry 6761 (class 2606 OID 211166)
-- Dependencies: 601 601
-- Name: pk_usuario_actividad; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tusuario_actividad
    ADD CONSTRAINT pk_usuario_actividad PRIMARY KEY (id_usuario_actividad);


--
-- TOC entry 6764 (class 2606 OID 211168)
-- Dependencies: 602 602
-- Name: pk_usuario_perfil; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tusuario_perfil
    ADD CONSTRAINT pk_usuario_perfil PRIMARY KEY (id_usuario_perfil);


--
-- TOC entry 6771 (class 2606 OID 211170)
-- Dependencies: 603 603
-- Name: pk_usuario_proyecto; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tusuario_proyecto
    ADD CONSTRAINT pk_usuario_proyecto PRIMARY KEY (id_usuario_proyecto);


--
-- TOC entry 6774 (class 2606 OID 211172)
-- Dependencies: 604 604
-- Name: pk_usuario_regional; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tusuario_regional
    ADD CONSTRAINT pk_usuario_regional PRIMARY KEY (id_usuario_regional);


--
-- TOC entry 6780 (class 2606 OID 211174)
-- Dependencies: 605 605
-- Name: pk_usuario_rol; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tusuario_rol
    ADD CONSTRAINT pk_usuario_rol PRIMARY KEY (id_usuario_rol);


--
-- TOC entry 6754 (class 2606 OID 211176)
-- Dependencies: 599 599
-- Name: subsistema_codigo_key; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tsubsistema
    ADD CONSTRAINT subsistema_codigo_key UNIQUE (codigo);


--
-- TOC entry 6757 (class 2606 OID 211178)
-- Dependencies: 599 599
-- Name: subsistema_prefijo_key; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tsubsistema
    ADD CONSTRAINT subsistema_prefijo_key UNIQUE (prefijo);


--
-- TOC entry 6703 (class 2606 OID 211180)
-- Dependencies: 577 577
-- Name: tbloqueo_notificacion_pkey; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tbloqueo_notificacion
    ADD CONSTRAINT tbloqueo_notificacion_pkey PRIMARY KEY (id_bloqueo_notificacion);


--
-- TOC entry 6711 (class 2606 OID 211182)
-- Dependencies: 581 581
-- Name: tfuncion_nombre_key; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tfuncion
    ADD CONSTRAINT tfuncion_nombre_key UNIQUE (nombre);


--
-- TOC entry 6718 (class 2606 OID 211184)
-- Dependencies: 584 584
-- Name: thorario_trabajo_pkey; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY thorario_trabajo
    ADD CONSTRAINT thorario_trabajo_pkey PRIMARY KEY (id_horario_trabajo);


--
-- TOC entry 6413 (class 2606 OID 211186)
-- Dependencies: 373 373
-- Name: tlog_26112010_pk_log; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tlog
    ADD CONSTRAINT tlog_26112010_pk_log PRIMARY KEY (id_log);


--
-- TOC entry 6730 (class 2606 OID 211188)
-- Dependencies: 589 589
-- Name: tpatron_evento_pkey; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tpatron_evento
    ADD CONSTRAINT tpatron_evento_pkey PRIMARY KEY (id_patron_evento);


--
-- TOC entry 6742 (class 2606 OID 211190)
-- Dependencies: 594 594
-- Name: tprocedimiento_codigo_key; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tprocedimiento
    ADD CONSTRAINT tprocedimiento_codigo_key UNIQUE (codigo);


--
-- TOC entry 6750 (class 2606 OID 211192)
-- Dependencies: 597 597
-- Name: tsesion_pkey; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tsesion
    ADD CONSTRAINT tsesion_pkey PRIMARY KEY (id_sesion);


--
-- TOC entry 6336 (class 2606 OID 211194)
-- Dependencies: 316 316
-- Name: tusuario_cuenta_key; Type: CONSTRAINT; Schema: segu; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tusuario
    ADD CONSTRAINT tusuario_cuenta_key UNIQUE (cuenta);


SET search_path = tesor, pg_catalog;

--
-- TOC entry 6784 (class 2606 OID 211196)
-- Dependencies: 616 616
-- Name: pk_tcaja__id_caja; Type: CONSTRAINT; Schema: tesor; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcaja
    ADD CONSTRAINT pk_tcaja__id_caja PRIMARY KEY (id_caja);


--
-- TOC entry 6786 (class 2606 OID 211198)
-- Dependencies: 617 617
-- Name: pk_tcaja_mov__id_caja_mov; Type: CONSTRAINT; Schema: tesor; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcaja_mov
    ADD CONSTRAINT pk_tcaja_mov__id_caja_mov PRIMARY KEY (id_caja_mov);


--
-- TOC entry 6788 (class 2606 OID 211200)
-- Dependencies: 618 618
-- Name: pk_tcajero__id_cajero; Type: CONSTRAINT; Schema: tesor; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tcajero
    ADD CONSTRAINT pk_tcajero__id_cajero PRIMARY KEY (id_cajero);


--
-- TOC entry 6790 (class 2606 OID 211202)
-- Dependencies: 620 620
-- Name: pk_trecibo__id_recibo; Type: CONSTRAINT; Schema: tesor; Owner: -; Tablespace: 
--

ALTER TABLE ONLY trecibo
    ADD CONSTRAINT pk_trecibo__id_recibo PRIMARY KEY (id_recibo);


--
-- TOC entry 6792 (class 2606 OID 211204)
-- Dependencies: 621 621
-- Name: pk_trendicion__id_rendicion; Type: CONSTRAINT; Schema: tesor; Owner: -; Tablespace: 
--

ALTER TABLE ONLY trendicion
    ADD CONSTRAINT pk_trendicion__id_rendicion PRIMARY KEY (id_rendicion);


SET search_path = tesoro, pg_catalog;

--
-- TOC entry 6794 (class 2606 OID 211206)
-- Dependencies: 622 622
-- Name: tts_corte_moneda_pkey; Type: CONSTRAINT; Schema: tesoro; Owner: -; Tablespace: 
--

ALTER TABLE ONLY tts_corte_moneda
    ADD CONSTRAINT tts_corte_moneda_pkey PRIMARY KEY (id_corte);


SET search_path = actif, pg_catalog;

--
-- TOC entry 6209 (class 1259 OID 211207)
-- Dependencies: 204
-- Name: taf_activo_fijo_fk_taf_acti_fijo__id_sub_tipo; Type: INDEX; Schema: actif; Owner: -; Tablespace: 
--

CREATE INDEX taf_activo_fijo_fk_taf_acti_fijo__id_sub_tipo ON taf_activo_fijo USING btree (id_sub_tipo_activo);


--
-- TOC entry 6210 (class 1259 OID 211208)
-- Dependencies: 204
-- Name: taf_activo_fijo_fk_taf_acti_fijo__id_unidad_constructiva; Type: INDEX; Schema: actif; Owner: -; Tablespace: 
--

CREATE INDEX taf_activo_fijo_fk_taf_acti_fijo__id_unidad_constructiva ON taf_activo_fijo USING btree (id_unidad_constructiva);


--
-- TOC entry 6211 (class 1259 OID 211209)
-- Dependencies: 204
-- Name: taf_activo_fijo_fk_taf_acti_fijo_empl__id_moneda; Type: INDEX; Schema: actif; Owner: -; Tablespace: 
--

CREATE INDEX taf_activo_fijo_fk_taf_acti_fijo_empl__id_moneda ON taf_activo_fijo USING btree (id_moneda);


--
-- TOC entry 6212 (class 1259 OID 211210)
-- Dependencies: 204
-- Name: taf_activo_fijo_fk_taf_acti_fijo_empl__id_moneda_original; Type: INDEX; Schema: actif; Owner: -; Tablespace: 
--

CREATE INDEX taf_activo_fijo_fk_taf_acti_fijo_empl__id_moneda_original ON taf_activo_fijo USING btree (id_moneda_original);


--
-- TOC entry 6215 (class 1259 OID 211211)
-- Dependencies: 204
-- Name: taf_activo_fijo_uk_taf_activo_fijo__codigo; Type: INDEX; Schema: actif; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX taf_activo_fijo_uk_taf_activo_fijo__codigo ON taf_activo_fijo USING btree (codigo);


--
-- TOC entry 6216 (class 1259 OID 211212)
-- Dependencies: 206
-- Name: taf_sub_tipo_activo_fk_taf_sub_tipo_acti__id_tipo_activo; Type: INDEX; Schema: actif; Owner: -; Tablespace: 
--

CREATE INDEX taf_sub_tipo_activo_fk_taf_sub_tipo_acti__id_tipo_activo ON taf_sub_tipo_activo USING btree (id_tipo_activo);


--
-- TOC entry 6221 (class 1259 OID 211213)
-- Dependencies: 208
-- Name: taf_tipo_activo_fk_taf_tipo_acti_fijo__id_metodo_depreciacion; Type: INDEX; Schema: actif; Owner: -; Tablespace: 
--

CREATE INDEX taf_tipo_activo_fk_taf_tipo_acti_fijo__id_metodo_depreciacion ON taf_tipo_activo USING btree (id_metodo_depreciacion);


--
-- TOC entry 6224 (class 1259 OID 211214)
-- Dependencies: 208
-- Name: taf_tipo_activo_uk_taf_tipo_activo__codigo; Type: INDEX; Schema: actif; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX taf_tipo_activo_uk_taf_tipo_activo__codigo ON taf_tipo_activo USING btree (codigo);


SET search_path = factur, pg_catalog;

--
-- TOC entry 6275 (class 1259 OID 211215)
-- Dependencies: 252
-- Name: fk_tfv_descuento__id_cuenta; Type: INDEX; Schema: factur; Owner: -; Tablespace: 
--

CREATE INDEX fk_tfv_descuento__id_cuenta ON tfv_descuento USING btree (id_cuenta);


--
-- TOC entry 6280 (class 1259 OID 211216)
-- Dependencies: 256
-- Name: fk_tfv_tasa__id_cuenta; Type: INDEX; Schema: factur; Owner: -; Tablespace: 
--

CREATE INDEX fk_tfv_tasa__id_cuenta ON tfv_tasa USING btree (id_cuenta);


SET search_path = gen, pg_catalog;

--
-- TOC entry 6287 (class 1259 OID 211217)
-- Dependencies: 260 260
-- Name: uk_ttabla_esquema_nombre; Type: INDEX; Schema: gen; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX uk_ttabla_esquema_nombre ON ttabla USING btree (esquema, nombre);


SET search_path = hidro, pg_catalog;

--
-- TOC entry 6358 (class 1259 OID 211218)
-- Dependencies: 333
-- Name: thd_operador_id_persona_key; Type: INDEX; Schema: hidro; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX thd_operador_id_persona_key ON thd_operador USING btree (id_persona);


--
-- TOC entry 6371 (class 1259 OID 211219)
-- Dependencies: 343 343
-- Name: thd_tipo_columna_sensor_idx; Type: INDEX; Schema: hidro; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX thd_tipo_columna_sensor_idx ON thd_tipo_columna_sensor USING btree (id_tipo_sensor, codigo_columna);


SET search_path = log, pg_catalog;

--
-- TOC entry 6417 (class 1259 OID 211220)
-- Dependencies: 374
-- Name: tlog_2011_02_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2011_02_idx ON tlog_2011_02 USING btree (fecha_reg);


--
-- TOC entry 6420 (class 1259 OID 211221)
-- Dependencies: 375
-- Name: tlog_2011_04_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2011_04_idx ON tlog_2011_04 USING btree (fecha_reg);


--
-- TOC entry 6423 (class 1259 OID 211222)
-- Dependencies: 376
-- Name: tlog_2011_05_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2011_05_idx ON tlog_2011_05 USING btree (fecha_reg);


--
-- TOC entry 6426 (class 1259 OID 211223)
-- Dependencies: 377
-- Name: tlog_2011_06_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2011_06_idx ON tlog_2011_06 USING btree (fecha_reg);


--
-- TOC entry 6429 (class 1259 OID 211224)
-- Dependencies: 378
-- Name: tlog_2011_07_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2011_07_idx ON tlog_2011_07 USING btree (fecha_reg);


--
-- TOC entry 6432 (class 1259 OID 211225)
-- Dependencies: 379
-- Name: tlog_2011_08_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2011_08_idx ON tlog_2011_08 USING btree (fecha_reg);


--
-- TOC entry 6435 (class 1259 OID 211226)
-- Dependencies: 380
-- Name: tlog_2011_09_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2011_09_idx ON tlog_2011_09 USING btree (fecha_reg);


--
-- TOC entry 6438 (class 1259 OID 211227)
-- Dependencies: 381
-- Name: tlog_2011_10_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2011_10_idx ON tlog_2011_10 USING btree (fecha_reg);


--
-- TOC entry 6441 (class 1259 OID 211228)
-- Dependencies: 382
-- Name: tlog_2011_11_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2011_11_idx ON tlog_2011_11 USING btree (fecha_reg);


--
-- TOC entry 6444 (class 1259 OID 211229)
-- Dependencies: 383
-- Name: tlog_2011_12_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2011_12_idx ON tlog_2011_12 USING btree (fecha_reg);


--
-- TOC entry 6447 (class 1259 OID 211230)
-- Dependencies: 384
-- Name: tlog_2012_01_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2012_01_idx ON tlog_2012_01 USING btree (fecha_reg);


--
-- TOC entry 6450 (class 1259 OID 211231)
-- Dependencies: 385
-- Name: tlog_2012_02_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2012_02_idx ON tlog_2012_02 USING btree (fecha_reg);


--
-- TOC entry 6453 (class 1259 OID 211232)
-- Dependencies: 386
-- Name: tlog_2012_03_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2012_03_idx ON tlog_2012_03 USING btree (fecha_reg);


--
-- TOC entry 6456 (class 1259 OID 211233)
-- Dependencies: 387
-- Name: tlog_2012_04_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2012_04_idx ON tlog_2012_04 USING btree (fecha_reg);


--
-- TOC entry 6459 (class 1259 OID 211234)
-- Dependencies: 388
-- Name: tlog_2012_05_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2012_05_idx ON tlog_2012_05 USING btree (fecha_reg);


--
-- TOC entry 6462 (class 1259 OID 211235)
-- Dependencies: 389
-- Name: tlog_2012_06_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2012_06_idx ON tlog_2012_06 USING btree (fecha_reg);


--
-- TOC entry 6799 (class 1259 OID 318943)
-- Dependencies: 626
-- Name: tlog_2012_08_idx; Type: INDEX; Schema: log; Owner: -; Tablespace: 
--

CREATE INDEX tlog_2012_08_idx ON tlog_2012_08 USING btree (fecha_reg);


SET search_path = param, pg_catalog;

--
-- TOC entry 6479 (class 1259 OID 211236)
-- Dependencies: 406 406
-- Name: tinstitucion_idx; Type: INDEX; Schema: param; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX tinstitucion_idx ON tinstitucion USING btree (doc_id, estado_reg);


--
-- TOC entry 6486 (class 1259 OID 211237)
-- Dependencies: 412 412 412
-- Name: tperiodo__gestion_per_estado__idx; Type: INDEX; Schema: param; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX tperiodo__gestion_per_estado__idx ON tperiodo USING btree (estado_reg, periodo, id_gestion);


SET search_path = rhum, pg_catalog;

--
-- TOC entry 6535 (class 1259 OID 211238)
-- Dependencies: 456
-- Name: thorario_id_horario_key; Type: INDEX; Schema: rhum; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX thorario_id_horario_key ON thorario USING btree (id_horario);


SET search_path = sast, pg_catalog;

--
-- TOC entry 6582 (class 1259 OID 211239)
-- Dependencies: 498
-- Name: testado_codigo_key; Type: INDEX; Schema: sast; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX testado_codigo_key ON testado USING btree (codigo);


SET search_path = secont, pg_catalog;

--
-- TOC entry 6600 (class 1259 OID 211240)
-- Dependencies: 511
-- Name: abogado_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX abogado_fk ON contrato USING btree (emp_id_empleado);


--
-- TOC entry 6595 (class 1259 OID 211241)
-- Dependencies: 509
-- Name: contratista_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX contratista_pk ON contratista USING btree (id_contratista);


--
-- TOC entry 6629 (class 1259 OID 211242)
-- Dependencies: 523
-- Name: contrato_garantia_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX contrato_garantia_fk ON garantia USING btree (id_contrato);


--
-- TOC entry 6601 (class 1259 OID 211243)
-- Dependencies: 511
-- Name: contrato_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX contrato_pk ON contrato USING btree (id_contrato);


--
-- TOC entry 6656 (class 1259 OID 211244)
-- Dependencies: 538
-- Name: contrato_resolucion_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX contrato_resolucion_fk ON resolucion USING btree (id_contrato);


--
-- TOC entry 6608 (class 1259 OID 211245)
-- Dependencies: 513
-- Name: correspondencia_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX correspondencia_pk ON correspondencia USING btree (id_correspondencia);


--
-- TOC entry 6612 (class 1259 OID 211246)
-- Dependencies: 515
-- Name: doc_anexo_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX doc_anexo_pk ON doc_anexo USING btree (id_documento);


--
-- TOC entry 6596 (class 1259 OID 211247)
-- Dependencies: 509
-- Name: es_persona_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX es_persona_fk ON contratista USING btree (id_persona);


--
-- TOC entry 6621 (class 1259 OID 211248)
-- Dependencies: 519
-- Name: estado_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX estado_pk ON estado USING btree (id_estado);


--
-- TOC entry 6624 (class 1259 OID 211249)
-- Dependencies: 521
-- Name: estado_requerimiento_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX estado_requerimiento_pk ON estado_requerimiento USING btree (id_estado_requerimiento);


--
-- TOC entry 6602 (class 1259 OID 211250)
-- Dependencies: 511
-- Name: firma_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX firma_fk ON contrato USING btree (id_representante);


--
-- TOC entry 6630 (class 1259 OID 211251)
-- Dependencies: 523
-- Name: garantia_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX garantia_pk ON garantia USING btree (id_garantia);


--
-- TOC entry 6616 (class 1259 OID 211252)
-- Dependencies: 517
-- Name: id_empleado_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX id_empleado_pk ON empleado USING btree (id_personal);


--
-- TOC entry 6633 (class 1259 OID 211253)
-- Dependencies: 525
-- Name: informe_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX informe_pk ON informe USING btree (id_informe);


--
-- TOC entry 6591 (class 1259 OID 211254)
-- Dependencies: 508
-- Name: leg_alarma_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX leg_alarma_pk ON alarma USING btree (id_alarma);


--
-- TOC entry 6637 (class 1259 OID 211255)
-- Dependencies: 528
-- Name: oferta_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX oferta_pk ON oferta USING btree (id_oferta);


--
-- TOC entry 6641 (class 1259 OID 211256)
-- Dependencies: 530
-- Name: persona_juridica_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX persona_juridica_pk ON persona_juridica USING btree (id_persona_juridica);


--
-- TOC entry 6594 (class 1259 OID 211257)
-- Dependencies: 508
-- Name: proyecto_alarma_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX proyecto_alarma_fk ON alarma USING btree (id_proyecto);


--
-- TOC entry 6605 (class 1259 OID 211258)
-- Dependencies: 511
-- Name: proyecto_contrato_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX proyecto_contrato_fk ON contrato USING btree (id_proyecto);


--
-- TOC entry 6646 (class 1259 OID 211259)
-- Dependencies: 532
-- Name: proyecto_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX proyecto_pk ON proyecto USING btree (id_proyecto);


--
-- TOC entry 6619 (class 1259 OID 211260)
-- Dependencies: 517
-- Name: relationship_12_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX relationship_12_fk ON empleado USING btree (id_persona);


--
-- TOC entry 6627 (class 1259 OID 211261)
-- Dependencies: 521
-- Name: relationship_13_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX relationship_13_fk ON estado_requerimiento USING btree (id_requerimiento);


--
-- TOC entry 6628 (class 1259 OID 211262)
-- Dependencies: 521
-- Name: relationship_14_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX relationship_14_fk ON estado_requerimiento USING btree (id_estado);


--
-- TOC entry 6653 (class 1259 OID 211263)
-- Dependencies: 536
-- Name: relationship_16_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX relationship_16_fk ON requerimiento USING btree (id_personal);


--
-- TOC entry 6599 (class 1259 OID 211264)
-- Dependencies: 509
-- Name: relationship_22_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX relationship_22_fk ON contratista USING btree (id_persona_juridica);


--
-- TOC entry 6615 (class 1259 OID 211265)
-- Dependencies: 515
-- Name: relationship_26_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX relationship_26_fk ON doc_anexo USING btree (id_contrato);


--
-- TOC entry 6611 (class 1259 OID 211266)
-- Dependencies: 513
-- Name: relationship_4_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX relationship_4_fk ON correspondencia USING btree (id_contrato);


--
-- TOC entry 6636 (class 1259 OID 211267)
-- Dependencies: 525
-- Name: relationship_5_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX relationship_5_fk ON informe USING btree (id_contrato);


--
-- TOC entry 6640 (class 1259 OID 211268)
-- Dependencies: 528
-- Name: relationship_6_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX relationship_6_fk ON oferta USING btree (id_contrato);


--
-- TOC entry 6606 (class 1259 OID 211269)
-- Dependencies: 511
-- Name: relationship_9_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX relationship_9_fk ON contrato USING btree (id_requerimiento);


--
-- TOC entry 6649 (class 1259 OID 211270)
-- Dependencies: 534
-- Name: repre_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX repre_fk ON representante USING btree (id_contratista);


--
-- TOC entry 6650 (class 1259 OID 211271)
-- Dependencies: 534
-- Name: representante_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX representante_pk ON representante USING btree (id_representante);


--
-- TOC entry 6654 (class 1259 OID 211272)
-- Dependencies: 536
-- Name: requerimiento_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX requerimiento_pk ON requerimiento USING btree (id_requerimiento);


--
-- TOC entry 6659 (class 1259 OID 211273)
-- Dependencies: 538
-- Name: resolucion_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX resolucion_pk ON resolucion USING btree (id_resolucion);


--
-- TOC entry 6607 (class 1259 OID 211274)
-- Dependencies: 511
-- Name: responsable_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX responsable_fk ON contrato USING btree (id_empleado);


--
-- TOC entry 6655 (class 1259 OID 211275)
-- Dependencies: 536
-- Name: solicitante_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX solicitante_fk ON requerimiento USING btree (emp_id_personal);


--
-- TOC entry 6620 (class 1259 OID 211276)
-- Dependencies: 517
-- Name: unidad_empleado_fk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE INDEX unidad_empleado_fk ON empleado USING btree (id_unidad);


--
-- TOC entry 6662 (class 1259 OID 211277)
-- Dependencies: 540
-- Name: unidad_pk; Type: INDEX; Schema: secont; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX unidad_pk ON unidad USING btree (id_unidad);


SET search_path = segu, pg_catalog;

--
-- TOC entry 6704 (class 1259 OID 211278)
-- Dependencies: 579
-- Name: clasificador_pk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX clasificador_pk ON tclasificador USING btree (id_clasificador);


--
-- TOC entry 6778 (class 1259 OID 211279)
-- Dependencies: 605
-- Name: es_asignado_fk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX es_asignado_fk ON tusuario_rol USING btree (id_rol);


--
-- TOC entry 6722 (class 1259 OID 211280)
-- Dependencies: 588
-- Name: esta_fk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX esta_fk ON tlog_ USING btree (id_subsistema);


--
-- TOC entry 6666 (class 1259 OID 211281)
-- Dependencies: 549
-- Name: fki_estructura_dato__id_subsistema; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX fki_estructura_dato__id_subsistema ON testructura_dato USING btree (id_subsistema);


--
-- TOC entry 6670 (class 1259 OID 211282)
-- Dependencies: 551
-- Name: fki_estructura_gui__id_hijo; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX fki_estructura_gui__id_hijo ON testructura_gui USING btree (id_gui);


--
-- TOC entry 6671 (class 1259 OID 211283)
-- Dependencies: 551
-- Name: fki_estructura_gui__id_padre; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX fki_estructura_gui__id_padre ON testructura_gui USING btree (fk_id_gui);


--
-- TOC entry 6675 (class 1259 OID 211284)
-- Dependencies: 554
-- Name: fki_gui_rol__id_gui; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX fki_gui_rol__id_gui ON tgui_rol USING btree (id_gui);


--
-- TOC entry 6683 (class 1259 OID 211285)
-- Dependencies: 561
-- Name: fki_permiso__id_estructura; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX fki_permiso__id_estructura ON tpermiso USING btree (id_estructura);


--
-- TOC entry 6684 (class 1259 OID 211286)
-- Dependencies: 561
-- Name: fki_permiso__id_proc; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX fki_permiso__id_proc ON tpermiso USING btree (id_procedimiento);


--
-- TOC entry 6697 (class 1259 OID 211287)
-- Dependencies: 574
-- Name: fki_rol_procedimiento__id_proc; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX fki_rol_procedimiento__id_proc ON trol_procedimiento_gui USING btree (id_procedimiento_gui);


--
-- TOC entry 6698 (class 1259 OID 211288)
-- Dependencies: 574
-- Name: fki_rol_procedimiento__id_rol; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX fki_rol_procedimiento__id_rol ON trol_procedimiento_gui USING btree (id_rol);


--
-- TOC entry 6758 (class 1259 OID 211289)
-- Dependencies: 601
-- Name: fki_usuario_actividad__id_actividad; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX fki_usuario_actividad__id_actividad ON tusuario_actividad USING btree (id_actividad);


--
-- TOC entry 6759 (class 1259 OID 211290)
-- Dependencies: 601
-- Name: fki_usuario_actividad__id_usuario; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX fki_usuario_actividad__id_usuario ON tusuario_actividad USING btree (id_usuario);


--
-- TOC entry 6768 (class 1259 OID 211291)
-- Dependencies: 603
-- Name: fki_usuario_proyecto__id_proyecto; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX fki_usuario_proyecto__id_proyecto ON tusuario_proyecto USING btree (id_proyecto);


--
-- TOC entry 6769 (class 1259 OID 211292)
-- Dependencies: 603
-- Name: fki_usuario_proyecto__id_usuario; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX fki_usuario_proyecto__id_usuario ON tusuario_proyecto USING btree (id_usuario);


--
-- TOC entry 6707 (class 1259 OID 211293)
-- Dependencies: 581
-- Name: funcion_pk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX funcion_pk ON tfuncion USING btree (id_funcion);


--
-- TOC entry 6714 (class 1259 OID 211294)
-- Dependencies: 582
-- Name: gui_pk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX gui_pk ON tgui USING btree (id_gui);


--
-- TOC entry 6723 (class 1259 OID 211295)
-- Dependencies: 588
-- Name: log_pk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX log_pk ON tlog_ USING btree (id_log);


--
-- TOC entry 6731 (class 1259 OID 211296)
-- Dependencies: 591
-- Name: perfil_pk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX perfil_pk ON tperfil USING btree (id_perfil);


--
-- TOC entry 6513 (class 1259 OID 211297)
-- Dependencies: 426
-- Name: persona_pk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX persona_pk ON tpersona USING btree (id_persona);


--
-- TOC entry 6516 (class 1259 OID 211298)
-- Dependencies: 426
-- Name: persona_relationship_11_fk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX persona_relationship_11_fk ON tpersona USING btree (id_persona);


--
-- TOC entry 6665 (class 1259 OID 211299)
-- Dependencies: 546
-- Name: pki_actividad__id_actividad; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX pki_actividad__id_actividad ON tactividad USING btree (id_actividad);


--
-- TOC entry 6669 (class 1259 OID 211300)
-- Dependencies: 549
-- Name: pki_estructura_dato__id_estructura_dato; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX pki_estructura_dato__id_estructura_dato ON testructura_dato USING btree (id_estructura_dato);


--
-- TOC entry 6674 (class 1259 OID 211301)
-- Dependencies: 551
-- Name: pki_estructura_gui__id_estructura_gui; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX pki_estructura_gui__id_estructura_gui ON testructura_gui USING btree (id_estructura_gui);


--
-- TOC entry 6678 (class 1259 OID 211302)
-- Dependencies: 554
-- Name: pki_gui_rol__id_gui_rol; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX pki_gui_rol__id_gui_rol ON tgui_rol USING btree (id_gui_rol);


--
-- TOC entry 6687 (class 1259 OID 211303)
-- Dependencies: 561
-- Name: pki_permiso__id_permiso; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX pki_permiso__id_permiso ON tpermiso USING btree (id_permiso);


--
-- TOC entry 6693 (class 1259 OID 211304)
-- Dependencies: 567
-- Name: pki_proyecto__id_proyecto; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX pki_proyecto__id_proyecto ON tproyecto USING btree (id_proyecto);


--
-- TOC entry 6696 (class 1259 OID 211305)
-- Dependencies: 570
-- Name: pki_recurso__id_recurso; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX pki_recurso__id_recurso ON trecurso USING btree (id_recurso);


--
-- TOC entry 6701 (class 1259 OID 211306)
-- Dependencies: 574
-- Name: pki_rol_procedimiento__id_rol_proc; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX pki_rol_procedimiento__id_rol_proc ON trol_procedimiento_gui USING btree (id_rol_procedimiento);


--
-- TOC entry 6721 (class 1259 OID 211307)
-- Dependencies: 586
-- Name: pki_tipo_documento__id_tipo_doc; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX pki_tipo_documento__id_tipo_doc ON ttipo_documento USING btree (id_tipo_documento);


--
-- TOC entry 6762 (class 1259 OID 211308)
-- Dependencies: 601
-- Name: pki_usuario_actividad__id_usuario_actividad; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX pki_usuario_actividad__id_usuario_actividad ON tusuario_actividad USING btree (id_usuario_actividad);


--
-- TOC entry 6772 (class 1259 OID 211309)
-- Dependencies: 603
-- Name: pki_usuario_proyecto__id_usuario_proyecto; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX pki_usuario_proyecto__id_usuario_proyecto ON tusuario_proyecto USING btree (id_usuario_proyecto);


--
-- TOC entry 6736 (class 1259 OID 211310)
-- Dependencies: 593
-- Name: primo_pk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX primo_pk ON tprimo USING btree (id_primo);


--
-- TOC entry 6726 (class 1259 OID 211311)
-- Dependencies: 588
-- Name: procedimiento_esta_en_log_fk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX procedimiento_esta_en_log_fk ON tlog_ USING btree (id_procedimiento);


--
-- TOC entry 6739 (class 1259 OID 211312)
-- Dependencies: 594
-- Name: procedimiento_pk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX procedimiento_pk ON tprocedimiento USING btree (id_procedimiento);


--
-- TOC entry 6745 (class 1259 OID 211313)
-- Dependencies: 595
-- Name: regional_pk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX regional_pk ON tregional USING btree (id_regional);


--
-- TOC entry 6775 (class 1259 OID 211314)
-- Dependencies: 604
-- Name: regional_tiene_usuarios_fk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX regional_tiene_usuarios_fk ON tusuario_regional USING btree (id_regional);


--
-- TOC entry 6748 (class 1259 OID 211315)
-- Dependencies: 596
-- Name: rol_pk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX rol_pk ON trol USING btree (id_rol);


--
-- TOC entry 6765 (class 1259 OID 211316)
-- Dependencies: 602
-- Name: se_asigna_a_usuario_fk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX se_asigna_a_usuario_fk ON tusuario_perfil USING btree (id_perfil);


--
-- TOC entry 6334 (class 1259 OID 211317)
-- Dependencies: 316
-- Name: se_asigna_fk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX se_asigna_fk ON tusuario USING btree (id_clasificador);


--
-- TOC entry 6755 (class 1259 OID 211318)
-- Dependencies: 599
-- Name: subsistema_pk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX subsistema_pk ON tsubsistema USING btree (id_subsistema);


--
-- TOC entry 6766 (class 1259 OID 211319)
-- Dependencies: 602
-- Name: tiene_perfil_fk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX tiene_perfil_fk ON tusuario_perfil USING btree (id_usuario);


--
-- TOC entry 6781 (class 1259 OID 211320)
-- Dependencies: 605
-- Name: tiene_privilegios_fk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX tiene_privilegios_fk ON tusuario_rol USING btree (id_usuario);


--
-- TOC entry 6740 (class 1259 OID 211321)
-- Dependencies: 594
-- Name: tiene_procedimientos_fk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX tiene_procedimientos_fk ON tprocedimiento USING btree (id_funcion);


--
-- TOC entry 6410 (class 1259 OID 211322)
-- Dependencies: 373
-- Name: tlog_26112010_esta_fk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX tlog_26112010_esta_fk ON tlog USING btree (id_subsistema);


--
-- TOC entry 6411 (class 1259 OID 211323)
-- Dependencies: 373
-- Name: tlog_26112010_log_pk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX tlog_26112010_log_pk ON tlog USING btree (id_log);


--
-- TOC entry 6414 (class 1259 OID 211324)
-- Dependencies: 373
-- Name: tlog_26112010_usuario_esta_en_log_fk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX tlog_26112010_usuario_esta_en_log_fk ON tlog USING btree (id_usuario);


--
-- TOC entry 6727 (class 1259 OID 211325)
-- Dependencies: 588
-- Name: tlog_idx; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX tlog_idx ON tlog_ USING btree (ip_maquina);


--
-- TOC entry 6690 (class 1259 OID 211326)
-- Dependencies: 564 564
-- Name: tprocedimiento_gui_idx; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX tprocedimiento_gui_idx ON tprocedimiento_gui USING btree (id_gui, id_procedimiento);


--
-- TOC entry 6728 (class 1259 OID 211327)
-- Dependencies: 588
-- Name: usuario_esta_en_log_fk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX usuario_esta_en_log_fk ON tlog_ USING btree (id_usuario);


--
-- TOC entry 6767 (class 1259 OID 211328)
-- Dependencies: 602
-- Name: usuario_perfil_pk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX usuario_perfil_pk ON tusuario_perfil USING btree (id_usuario_perfil);


--
-- TOC entry 6776 (class 1259 OID 211329)
-- Dependencies: 604
-- Name: usuario_pertenece_a_regional_fk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE INDEX usuario_pertenece_a_regional_fk ON tusuario_regional USING btree (id_usuario);


--
-- TOC entry 6337 (class 1259 OID 211330)
-- Dependencies: 316
-- Name: usuario_pk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX usuario_pk ON tusuario USING btree (id_usuario);


--
-- TOC entry 6777 (class 1259 OID 211331)
-- Dependencies: 604
-- Name: usuario_regional_pk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX usuario_regional_pk ON tusuario_regional USING btree (id_usuario_regional);


--
-- TOC entry 6782 (class 1259 OID 211332)
-- Dependencies: 605
-- Name: usuario_rol_pk; Type: INDEX; Schema: segu; Owner: -; Tablespace: 
--

CREATE UNIQUE INDEX usuario_rol_pk ON tusuario_rol USING btree (id_usuario_rol);


--
-- TOC entry 7035 (class 2620 OID 211333)
-- Dependencies: 1836 373
-- Name: trig_log; Type: TRIGGER; Schema: segu; Owner: -
--

CREATE TRIGGER trig_log BEFORE INSERT ON tlog FOR EACH ROW EXECUTE PROCEDURE ftrig_log();


--
-- TOC entry 7034 (class 2620 OID 211334)
-- Dependencies: 316 1672
-- Name: trigger_usuario; Type: TRIGGER; Schema: segu; Owner: -
--

CREATE TRIGGER trigger_usuario AFTER INSERT OR DELETE OR UPDATE ON tusuario FOR EACH ROW EXECUTE PROCEDURE public.trigger_usuario();


SET search_path = actif, pg_catalog;

--
-- TOC entry 6802 (class 2606 OID 211335)
-- Dependencies: 204 206 6217
-- Name: fk_taf_acti_fijo__id_sub_tipo; Type: FK CONSTRAINT; Schema: actif; Owner: -
--

ALTER TABLE ONLY taf_activo_fijo
    ADD CONSTRAINT fk_taf_acti_fijo__id_sub_tipo FOREIGN KEY (id_sub_tipo_activo) REFERENCES taf_sub_tipo_activo(id_sub_tipo_activo) ON UPDATE CASCADE;


--
-- TOC entry 6803 (class 2606 OID 211340)
-- Dependencies: 204 204 6213
-- Name: fk_taf_activo_fijo__id_clon_origen; Type: FK CONSTRAINT; Schema: actif; Owner: -
--

ALTER TABLE ONLY taf_activo_fijo
    ADD CONSTRAINT fk_taf_activo_fijo__id_clon_origen FOREIGN KEY (id_clon_origen) REFERENCES taf_activo_fijo(id_activo_fijo);


--
-- TOC entry 6804 (class 2606 OID 211345)
-- Dependencies: 206 208 6222
-- Name: fk_taf_sub_tipo_acti__id_tipo_activo; Type: FK CONSTRAINT; Schema: actif; Owner: -
--

ALTER TABLE ONLY taf_sub_tipo_activo
    ADD CONSTRAINT fk_taf_sub_tipo_acti__id_tipo_activo FOREIGN KEY (id_tipo_activo) REFERENCES taf_tipo_activo(id_tipo_activo) MATCH FULL ON UPDATE CASCADE;


SET search_path = cobra, pg_catalog;

--
-- TOC entry 6806 (class 2606 OID 211350)
-- Dependencies: 211 229 6247
-- Name: fk_tcb_agencia__id_enti_fin; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_agencia
    ADD CONSTRAINT fk_tcb_agencia__id_enti_fin FOREIGN KEY (id_enti_fin) REFERENCES tcb_enti_fin(id_enti_fin);


--
-- TOC entry 6807 (class 2606 OID 211355)
-- Dependencies: 213 216 6233
-- Name: fk_tcb_arqueo__id_caja; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_arqueo
    ADD CONSTRAINT fk_tcb_arqueo__id_caja FOREIGN KEY (id_caja) REFERENCES tcb_caja(id_caja);


--
-- TOC entry 6808 (class 2606 OID 211360)
-- Dependencies: 214 213 6229
-- Name: fk_tcb_arqueo_det__id_arqueo; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_arqueo_det
    ADD CONSTRAINT fk_tcb_arqueo_det__id_arqueo FOREIGN KEY (id_arqueo) REFERENCES tcb_arqueo(id_arqueo);


--
-- TOC entry 6809 (class 2606 OID 211365)
-- Dependencies: 214 622 6793
-- Name: fk_tcb_arqueo_det__id_corte; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_arqueo_det
    ADD CONSTRAINT fk_tcb_arqueo_det__id_corte FOREIGN KEY (id_corte) REFERENCES tesoro.tts_corte_moneda(id_corte);


--
-- TOC entry 6810 (class 2606 OID 211370)
-- Dependencies: 216 211 6227
-- Name: fk_tcb_caja__id_agencia; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_caja
    ADD CONSTRAINT fk_tcb_caja__id_agencia FOREIGN KEY (id_agencia) REFERENCES tcb_agencia(id_agencia);


--
-- TOC entry 6811 (class 2606 OID 211375)
-- Dependencies: 217 216 6233
-- Name: fk_tcb_caja_cajero__id_caja; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_caja_cajero
    ADD CONSTRAINT fk_tcb_caja_cajero__id_caja FOREIGN KEY (id_caja) REFERENCES tcb_caja(id_caja);


--
-- TOC entry 6812 (class 2606 OID 211380)
-- Dependencies: 217 222 6239
-- Name: fk_tcb_caja_cajero__id_cajero; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_caja_cajero
    ADD CONSTRAINT fk_tcb_caja_cajero__id_cajero FOREIGN KEY (id_cajero) REFERENCES tcb_cajero(id_cajero);


--
-- TOC entry 6813 (class 2606 OID 211385)
-- Dependencies: 219 216 6233
-- Name: fk_tcb_caja_estado__id_caja; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_caja_estado
    ADD CONSTRAINT fk_tcb_caja_estado__id_caja FOREIGN KEY (id_caja) REFERENCES tcb_caja(id_caja);


--
-- TOC entry 6814 (class 2606 OID 211390)
-- Dependencies: 222 216 6233
-- Name: fk_tcb_cajero__id_caja; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_cajero
    ADD CONSTRAINT fk_tcb_cajero__id_caja FOREIGN KEY (id_caja) REFERENCES tcb_caja(id_caja);


--
-- TOC entry 6815 (class 2606 OID 211395)
-- Dependencies: 225 239 6259
-- Name: fk_tcb_cliente__id_sistema_dist; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_cliente
    ADD CONSTRAINT fk_tcb_cliente__id_sistema_dist FOREIGN KEY (id_sistema_dist) REFERENCES tcb_sistema_dist(id_sistema_dist);


--
-- TOC entry 6816 (class 2606 OID 211400)
-- Dependencies: 229 406 6480
-- Name: fk_tcb_enti_fin__id_institucion; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_enti_fin
    ADD CONSTRAINT fk_tcb_enti_fin__id_institucion FOREIGN KEY (id_institucion) REFERENCES param.tinstitucion(id_institucion);


--
-- TOC entry 6817 (class 2606 OID 211405)
-- Dependencies: 231 216 6233
-- Name: fk_tcb_factura_cob__id_caja; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob
    ADD CONSTRAINT fk_tcb_factura_cob__id_caja FOREIGN KEY (id_caja) REFERENCES tcb_caja(id_caja);


--
-- TOC entry 6818 (class 2606 OID 211410)
-- Dependencies: 222 231 6239
-- Name: fk_tcb_factura_cob__id_cajero; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob
    ADD CONSTRAINT fk_tcb_factura_cob__id_cajero FOREIGN KEY (id_cajero) REFERENCES tcb_cajero(id_cajero);


--
-- TOC entry 6819 (class 2606 OID 211415)
-- Dependencies: 231 410 6484
-- Name: fk_tcb_factura_cob__id_moneda; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob
    ADD CONSTRAINT fk_tcb_factura_cob__id_moneda FOREIGN KEY (id_moneda) REFERENCES param.tmoneda(id_moneda);


--
-- TOC entry 6820 (class 2606 OID 211420)
-- Dependencies: 232 216 6233
-- Name: fk_tcb_factura_cob_anulado__id_caja; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob_anulado
    ADD CONSTRAINT fk_tcb_factura_cob_anulado__id_caja FOREIGN KEY (id_caja) REFERENCES tcb_caja(id_caja);


--
-- TOC entry 6821 (class 2606 OID 211425)
-- Dependencies: 232 222 6239
-- Name: fk_tcb_factura_cob_anulado__id_cajero; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob_anulado
    ADD CONSTRAINT fk_tcb_factura_cob_anulado__id_cajero FOREIGN KEY (id_cajero) REFERENCES tcb_cajero(id_cajero);


--
-- TOC entry 6822 (class 2606 OID 211430)
-- Dependencies: 232 227 6245
-- Name: fk_tcb_factura_cob_anulado__id_cobro; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob_anulado
    ADD CONSTRAINT fk_tcb_factura_cob_anulado__id_cobro FOREIGN KEY (id_cobro) REFERENCES tcb_cobro(id_cobro);


--
-- TOC entry 6823 (class 2606 OID 211435)
-- Dependencies: 232 231 6249
-- Name: fk_tcb_factura_cob_anulado__id_factura_cob; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob_anulado
    ADD CONSTRAINT fk_tcb_factura_cob_anulado__id_factura_cob FOREIGN KEY (id_factura_cob) REFERENCES tcb_factura_cob(id_factura_cob);


--
-- TOC entry 6824 (class 2606 OID 211440)
-- Dependencies: 232 316 6332
-- Name: fk_tcb_factura_cob_anulado__id_usuario; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob_anulado
    ADD CONSTRAINT fk_tcb_factura_cob_anulado__id_usuario FOREIGN KEY (id_usuario) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6825 (class 2606 OID 211445)
-- Dependencies: 234 252 6276
-- Name: fk_tcb_factura_cob_det__id_descuento; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob_det
    ADD CONSTRAINT fk_tcb_factura_cob_det__id_descuento FOREIGN KEY (id_descuento) REFERENCES factur.tfv_descuento(id_descuento);


--
-- TOC entry 6826 (class 2606 OID 211450)
-- Dependencies: 234 231 6249
-- Name: fk_tcb_factura_cob_det__id_factura_cob; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob_det
    ADD CONSTRAINT fk_tcb_factura_cob_det__id_factura_cob FOREIGN KEY (id_factura_cob) REFERENCES tcb_factura_cob(id_factura_cob);


--
-- TOC entry 6827 (class 2606 OID 211455)
-- Dependencies: 234 256 6281
-- Name: fk_tcb_factura_cob_det__id_tasa; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_factura_cob_det
    ADD CONSTRAINT fk_tcb_factura_cob_det__id_tasa FOREIGN KEY (id_tasa) REFERENCES factur.tfv_tasa(id_tasa);


--
-- TOC entry 6828 (class 2606 OID 211460)
-- Dependencies: 211 240 6227
-- Name: fk_tcb_sistema_dist_agencia__id_agencia; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_sistema_dist_agencia
    ADD CONSTRAINT fk_tcb_sistema_dist_agencia__id_agencia FOREIGN KEY (id_agencia) REFERENCES tcb_agencia(id_agencia);


--
-- TOC entry 6829 (class 2606 OID 211465)
-- Dependencies: 240 239 6259
-- Name: fk_tcb_sistema_dist_agencia__id_sistema_dist; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_sistema_dist_agencia
    ADD CONSTRAINT fk_tcb_sistema_dist_agencia__id_sistema_dist FOREIGN KEY (id_sistema_dist) REFERENCES tcb_sistema_dist(id_sistema_dist);


--
-- TOC entry 6805 (class 2606 OID 211470)
-- Dependencies: 209 213 6229
-- Name: tcb_arqueo_estado_fk; Type: FK CONSTRAINT; Schema: cobra; Owner: -
--

ALTER TABLE ONLY tcb_arqueo_estado
    ADD CONSTRAINT tcb_arqueo_estado_fk FOREIGN KEY (id_arqueo) REFERENCES tcb_arqueo(id_arqueo);


SET search_path = conta, pg_catalog;

--
-- TOC entry 6830 (class 2606 OID 211475)
-- Dependencies: 250 251 6273
-- Name: fk_tdocumento__id_documento_tipo; Type: FK CONSTRAINT; Schema: conta; Owner: -
--

ALTER TABLE ONLY tdocumento
    ADD CONSTRAINT fk_tdocumento__id_documento_tipo FOREIGN KEY (id_documento_tipo) REFERENCES tdocumento_tipo(id_documento_tipo);


SET search_path = gem, pg_catalog;

--
-- TOC entry 7033 (class 2606 OID 313644)
-- Dependencies: 6795 625 625
-- Name: tlocalizacion_fk; Type: FK CONSTRAINT; Schema: gem; Owner: -
--

ALTER TABLE ONLY tlocalizacion
    ADD CONSTRAINT tlocalizacion_fk FOREIGN KEY (id_localizacion_fk) REFERENCES tlocalizacion(id_localizacion);


SET search_path = gen, pg_catalog;

--
-- TOC entry 6831 (class 2606 OID 211480)
-- Dependencies: 259 6285 260
-- Name: fk_tcolumna__id_tabla; Type: FK CONSTRAINT; Schema: gen; Owner: -
--

ALTER TABLE ONLY tcolumna
    ADD CONSTRAINT fk_tcolumna__id_tabla FOREIGN KEY (id_tabla) REFERENCES ttabla(id_tabla);


--
-- TOC entry 6832 (class 2606 OID 211485)
-- Dependencies: 6751 599 260
-- Name: fk_ttabla__id_subsistema; Type: FK CONSTRAINT; Schema: gen; Owner: -
--

ALTER TABLE ONLY ttabla
    ADD CONSTRAINT fk_ttabla__id_subsistema FOREIGN KEY (id_subsistema) REFERENCES segu.tsubsistema(id_subsistema);


SET search_path = gev, pg_catalog;

--
-- TOC entry 6833 (class 2606 OID 211490)
-- Dependencies: 269 6213 204
-- Name: fk_tgv_activo_fijo_rastreo__id_activo_fijo; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_activo_fijo_rastreo
    ADD CONSTRAINT fk_tgv_activo_fijo_rastreo__id_activo_fijo FOREIGN KEY (id_activo_fijo) REFERENCES actif.taf_activo_fijo(id_activo_fijo);


--
-- TOC entry 6841 (class 2606 OID 211495)
-- Dependencies: 6531 452 289
-- Name: fk_tgv_mantenimiento__id_funcionario; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_mantenimiento
    ADD CONSTRAINT fk_tgv_mantenimiento__id_funcionario FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 6842 (class 2606 OID 211500)
-- Dependencies: 6509 422 289
-- Name: fk_tgv_mantenimiento__id_proveedor; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_mantenimiento
    ADD CONSTRAINT fk_tgv_mantenimiento__id_proveedor FOREIGN KEY (id_proveedor) REFERENCES param.tproveedor(id_proveedor);


--
-- TOC entry 6844 (class 2606 OID 211505)
-- Dependencies: 6213 204 290
-- Name: fk_tgv_mantenimiento_det__id_activo_fijo; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_mantenimiento_det
    ADD CONSTRAINT fk_tgv_mantenimiento_det__id_activo_fijo FOREIGN KEY (id_activo_fijo) REFERENCES actif.taf_activo_fijo(id_activo_fijo);


--
-- TOC entry 6845 (class 2606 OID 211510)
-- Dependencies: 6308 284 290
-- Name: fk_tgv_mantenimiento_det__id_evento; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_mantenimiento_det
    ADD CONSTRAINT fk_tgv_mantenimiento_det__id_evento FOREIGN KEY (id_evento) REFERENCES tgv_evento(id_evento);


--
-- TOC entry 6846 (class 2606 OID 211515)
-- Dependencies: 289 290 6316
-- Name: fk_tgv_mantenimiento_det__id_mantenimiento; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_mantenimiento_det
    ADD CONSTRAINT fk_tgv_mantenimiento_det__id_mantenimiento FOREIGN KEY (id_mantenimiento) REFERENCES tgv_mantenimiento(id_mantenimiento);


--
-- TOC entry 6848 (class 2606 OID 211520)
-- Dependencies: 302 452 6531
-- Name: fk_tgv_servicio__id_funcionario; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_servicio
    ADD CONSTRAINT fk_tgv_servicio__id_funcionario FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 6849 (class 2606 OID 211525)
-- Dependencies: 302 408 6482
-- Name: fk_tgv_servicio__id_lugar_destino; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_servicio
    ADD CONSTRAINT fk_tgv_servicio__id_lugar_destino FOREIGN KEY (id_lugar_destino) REFERENCES param.tlugar(id_lugar);


--
-- TOC entry 6850 (class 2606 OID 211530)
-- Dependencies: 302 408 6482
-- Name: fk_tgv_servicio__id_lugar_origen; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_servicio
    ADD CONSTRAINT fk_tgv_servicio__id_lugar_origen FOREIGN KEY (id_lugar_origen) REFERENCES param.tlugar(id_lugar);


--
-- TOC entry 6835 (class 2606 OID 211535)
-- Dependencies: 204 6213 271
-- Name: tgv_acf_ultreg_fk; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_activo_fijo_ultimo_registro
    ADD CONSTRAINT tgv_acf_ultreg_fk FOREIGN KEY (id_activo_fijo) REFERENCES actif.taf_activo_fijo(id_activo_fijo);


--
-- TOC entry 6834 (class 2606 OID 211540)
-- Dependencies: 452 269 6531
-- Name: tgv_activo_fijo_rastreo__id_funcionario_fk; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_activo_fijo_rastreo
    ADD CONSTRAINT tgv_activo_fijo_rastreo__id_funcionario_fk FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 6836 (class 2606 OID 211545)
-- Dependencies: 6531 271 452
-- Name: tgv_activo_fijo_ultimo_registro__id_funcionarioo_fk; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_activo_fijo_ultimo_registro
    ADD CONSTRAINT tgv_activo_fijo_ultimo_registro__id_funcionarioo_fk FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 6837 (class 2606 OID 211550)
-- Dependencies: 274 284 6308
-- Name: tgv_agrupacion_evento_fk; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_agrupacion_evento
    ADD CONSTRAINT tgv_agrupacion_evento_fk FOREIGN KEY (id_evento) REFERENCES tgv_evento(id_evento);


--
-- TOC entry 6838 (class 2606 OID 211555)
-- Dependencies: 273 274 6300
-- Name: tgv_agrupacion_evento_fk1; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_agrupacion_evento
    ADD CONSTRAINT tgv_agrupacion_evento_fk1 FOREIGN KEY (id_agrupacion) REFERENCES tgv_agrupacion(id_agrupacion);


--
-- TOC entry 6839 (class 2606 OID 211560)
-- Dependencies: 6322 300 282
-- Name: tgv_datos_tec_fk; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_datos_tec
    ADD CONSTRAINT tgv_datos_tec_fk FOREIGN KEY (id_modelo) REFERENCES tgv_modelo(id_modelo);


--
-- TOC entry 6840 (class 2606 OID 211565)
-- Dependencies: 287 452 6531
-- Name: tgv_iboton_fk; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_iboton
    ADD CONSTRAINT tgv_iboton_fk FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 6843 (class 2606 OID 211570)
-- Dependencies: 314 6330 289
-- Name: tgv_mantenimiento_fk; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_mantenimiento
    ADD CONSTRAINT tgv_mantenimiento_fk FOREIGN KEY (id_tipo_evento) REFERENCES tgv_tipo_evento(id_tipo_evento);


--
-- TOC entry 6847 (class 2606 OID 211575)
-- Dependencies: 6320 300 298
-- Name: tgv_modelo_fk; Type: FK CONSTRAINT; Schema: gev; Owner: -
--

ALTER TABLE ONLY tgv_modelo
    ADD CONSTRAINT tgv_modelo_fk FOREIGN KEY (id_marca) REFERENCES tgv_marca(id_marca);


SET search_path = hidro, pg_catalog;

--
-- TOC entry 6861 (class 2606 OID 211580)
-- Dependencies: 327 318 6342
-- Name: fk_estacion__id_administrador; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_estacion
    ADD CONSTRAINT fk_estacion__id_administrador FOREIGN KEY (id_administrador) REFERENCES thd_administrador_hidro(id_administrador);


--
-- TOC entry 6862 (class 2606 OID 211585)
-- Dependencies: 6350 327 325
-- Name: fk_estacion__id_cuenca; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_estacion
    ADD CONSTRAINT fk_estacion__id_cuenca FOREIGN KEY (id_cuenca) REFERENCES thd_cuenca(id_cuenca);


--
-- TOC entry 6863 (class 2606 OID 211590)
-- Dependencies: 327 6482 408
-- Name: fk_estacion__id_lugar; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_estacion
    ADD CONSTRAINT fk_estacion__id_lugar FOREIGN KEY (id_lugar) REFERENCES param.tlugar(id_lugar);


--
-- TOC entry 6864 (class 2606 OID 211595)
-- Dependencies: 6363 335 327
-- Name: fk_estacion__id_rio; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_estacion
    ADD CONSTRAINT fk_estacion__id_rio FOREIGN KEY (id_rio) REFERENCES thd_rio(id_rio);


--
-- TOC entry 6865 (class 2606 OID 211600)
-- Dependencies: 329 6352 327
-- Name: fk_estacion_proyecto__id_estacion; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_estacion_proyecto
    ADD CONSTRAINT fk_estacion_proyecto__id_estacion FOREIGN KEY (id_estacion) REFERENCES thd_estacion(id_estacion);


--
-- TOC entry 6866 (class 2606 OID 211605)
-- Dependencies: 418 329 6497
-- Name: fk_estacion_proyecto__id_proyecto; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_estacion_proyecto
    ADD CONSTRAINT fk_estacion_proyecto__id_proyecto FOREIGN KEY (id_proyecto) REFERENCES param.tpm_proyecto(id_proyecto);


--
-- TOC entry 6867 (class 2606 OID 211610)
-- Dependencies: 331 320 6344
-- Name: fk_medicion__id_archivo; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_medicion
    ADD CONSTRAINT fk_medicion__id_archivo FOREIGN KEY (id_archivo) REFERENCES thd_archivo(id_archivo);


--
-- TOC entry 6868 (class 2606 OID 211615)
-- Dependencies: 331 333 6359
-- Name: fk_medicion__id_operador; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_medicion
    ADD CONSTRAINT fk_medicion__id_operador FOREIGN KEY (id_operador) REFERENCES thd_operador(id_operador);


--
-- TOC entry 6869 (class 2606 OID 211620)
-- Dependencies: 337 331 6365
-- Name: fk_medicion__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_medicion
    ADD CONSTRAINT fk_medicion__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 6870 (class 2606 OID 211625)
-- Dependencies: 6514 426 333
-- Name: fk_operador__id_persona; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_operador
    ADD CONSTRAINT fk_operador__id_persona FOREIGN KEY (id_persona) REFERENCES segu.tpersona(id_persona);


--
-- TOC entry 6871 (class 2606 OID 211630)
-- Dependencies: 418 6497 333
-- Name: fk_operador__id_proyecto; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_operador
    ADD CONSTRAINT fk_operador__id_proyecto FOREIGN KEY (id_proyecto) REFERENCES param.tpm_proyecto(id_proyecto);


--
-- TOC entry 6872 (class 2606 OID 211635)
-- Dependencies: 327 6352 337
-- Name: fk_sensor__id_estacion; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_sensor
    ADD CONSTRAINT fk_sensor__id_estacion FOREIGN KEY (id_estacion) REFERENCES thd_estacion(id_estacion);


--
-- TOC entry 6873 (class 2606 OID 211640)
-- Dependencies: 347 6380 337
-- Name: fk_sensor__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_sensor
    ADD CONSTRAINT fk_sensor__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 6879 (class 2606 OID 211645)
-- Dependencies: 6365 337 351
-- Name: fk_thd_sensor_22__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_22
    ADD CONSTRAINT fk_thd_sensor_22__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 6881 (class 2606 OID 211650)
-- Dependencies: 337 6365 353
-- Name: fk_thd_sensor_33__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_33
    ADD CONSTRAINT fk_thd_sensor_33__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 6883 (class 2606 OID 211655)
-- Dependencies: 355 6365 337
-- Name: fk_thd_sensor_44__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_44
    ADD CONSTRAINT fk_thd_sensor_44__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 6885 (class 2606 OID 211660)
-- Dependencies: 357 337 6365
-- Name: fk_thd_sensor_anemometro__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_anemometro
    ADD CONSTRAINT fk_thd_sensor_anemometro__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 6887 (class 2606 OID 211665)
-- Dependencies: 337 6365 359
-- Name: fk_thd_sensor_caudal__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_caudal
    ADD CONSTRAINT fk_thd_sensor_caudal__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 6889 (class 2606 OID 211670)
-- Dependencies: 361 337 6365
-- Name: fk_thd_sensor_limnimetrica__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_limnimetrica
    ADD CONSTRAINT fk_thd_sensor_limnimetrica__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 6891 (class 2606 OID 211675)
-- Dependencies: 363 6365 337
-- Name: fk_thd_sensor_presion__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_presion
    ADD CONSTRAINT fk_thd_sensor_presion__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 6893 (class 2606 OID 211680)
-- Dependencies: 6365 365 337
-- Name: fk_thd_sensor_pru__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_pru
    ADD CONSTRAINT fk_thd_sensor_pru__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 6895 (class 2606 OID 211685)
-- Dependencies: 6365 367 337
-- Name: fk_thd_sensor_prue__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_prue
    ADD CONSTRAINT fk_thd_sensor_prue__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 6897 (class 2606 OID 211690)
-- Dependencies: 369 337 6365
-- Name: fk_thd_sensor_termo__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_termo
    ADD CONSTRAINT fk_thd_sensor_termo__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 6880 (class 2606 OID 211695)
-- Dependencies: 6380 351 347
-- Name: fk_thd_tipo_sensor_22__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_22
    ADD CONSTRAINT fk_thd_tipo_sensor_22__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 6882 (class 2606 OID 211700)
-- Dependencies: 6380 347 353
-- Name: fk_thd_tipo_sensor_33__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_33
    ADD CONSTRAINT fk_thd_tipo_sensor_33__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 6884 (class 2606 OID 211705)
-- Dependencies: 355 347 6380
-- Name: fk_thd_tipo_sensor_44__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_44
    ADD CONSTRAINT fk_thd_tipo_sensor_44__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 6886 (class 2606 OID 211710)
-- Dependencies: 357 347 6380
-- Name: fk_thd_tipo_sensor_anemometro__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_anemometro
    ADD CONSTRAINT fk_thd_tipo_sensor_anemometro__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 6888 (class 2606 OID 211715)
-- Dependencies: 6380 347 359
-- Name: fk_thd_tipo_sensor_caudal__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_caudal
    ADD CONSTRAINT fk_thd_tipo_sensor_caudal__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 6890 (class 2606 OID 211720)
-- Dependencies: 361 347 6380
-- Name: fk_thd_tipo_sensor_limnimetrica__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_limnimetrica
    ADD CONSTRAINT fk_thd_tipo_sensor_limnimetrica__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 6892 (class 2606 OID 211725)
-- Dependencies: 6380 347 363
-- Name: fk_thd_tipo_sensor_presion__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_presion
    ADD CONSTRAINT fk_thd_tipo_sensor_presion__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 6894 (class 2606 OID 211730)
-- Dependencies: 365 6380 347
-- Name: fk_thd_tipo_sensor_pru__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_pru
    ADD CONSTRAINT fk_thd_tipo_sensor_pru__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 6896 (class 2606 OID 211735)
-- Dependencies: 6380 347 367
-- Name: fk_thd_tipo_sensor_prue__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_prue
    ADD CONSTRAINT fk_thd_tipo_sensor_prue__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 6898 (class 2606 OID 211740)
-- Dependencies: 369 6380 347
-- Name: fk_thd_tipo_sensor_termo__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_sensor_termo
    ADD CONSTRAINT fk_thd_tipo_sensor_termo__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 6878 (class 2606 OID 211745)
-- Dependencies: 6380 347 343
-- Name: fk_tipo_columna_sensor__id_tipo_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_columna_sensor
    ADD CONSTRAINT fk_tipo_columna_sensor__id_tipo_sensor FOREIGN KEY (id_tipo_sensor) REFERENCES thd_tipo_sensor(id_tipo_sensor);


--
-- TOC entry 6874 (class 2606 OID 211750)
-- Dependencies: 6384 349 337
-- Name: fkthd_sensor1240; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_sensor
    ADD CONSTRAINT fkthd_sensor1240 FOREIGN KEY (id_tipo_muestra) REFERENCES thd_tipo_muestra(id_tipo_muestra);


--
-- TOC entry 6853 (class 2606 OID 211755)
-- Dependencies: 6367 339 320
-- Name: thd_archivo__id_tipo_archivo; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_archivo
    ADD CONSTRAINT thd_archivo__id_tipo_archivo FOREIGN KEY (id_tipo_archivo) REFERENCES thd_tipo_archivo(id_tipo_archivo);


--
-- TOC entry 6854 (class 2606 OID 211760)
-- Dependencies: 6332 316 320
-- Name: thd_archivo__id_usuario_mod; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_archivo
    ADD CONSTRAINT thd_archivo__id_usuario_mod FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6855 (class 2606 OID 211765)
-- Dependencies: 320 6332 316
-- Name: thd_archivo__id_usuario_reg; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_archivo
    ADD CONSTRAINT thd_archivo__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6856 (class 2606 OID 211770)
-- Dependencies: 320 6358 333
-- Name: thd_archivo_fk; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_archivo
    ADD CONSTRAINT thd_archivo_fk FOREIGN KEY (id_operador) REFERENCES thd_operador(id_persona);


--
-- TOC entry 6857 (class 2606 OID 211775)
-- Dependencies: 322 6365 337
-- Name: thd_archivo_sensor__id_sensor; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_archivo_sensor
    ADD CONSTRAINT thd_archivo_sensor__id_sensor FOREIGN KEY (id_sensor) REFERENCES thd_sensor(id_sensor);


--
-- TOC entry 6858 (class 2606 OID 211780)
-- Dependencies: 322 339 6367
-- Name: thd_archivo_sensor__id_tipo_archivo; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_archivo_sensor
    ADD CONSTRAINT thd_archivo_sensor__id_tipo_archivo FOREIGN KEY (id_tipo_archivo) REFERENCES thd_tipo_archivo(id_tipo_archivo);


--
-- TOC entry 6859 (class 2606 OID 211785)
-- Dependencies: 322 316 6332
-- Name: thd_archivo_sensor__id_usuario_mod; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_archivo_sensor
    ADD CONSTRAINT thd_archivo_sensor__id_usuario_mod FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6860 (class 2606 OID 211790)
-- Dependencies: 316 6332 322
-- Name: thd_archivo_sensor__id_usuario_reg; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_archivo_sensor
    ADD CONSTRAINT thd_archivo_sensor__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6875 (class 2606 OID 211795)
-- Dependencies: 339 327 6352
-- Name: thd_tipo_archivo__id_estacion; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_archivo
    ADD CONSTRAINT thd_tipo_archivo__id_estacion FOREIGN KEY (id_estacion) REFERENCES thd_estacion(id_estacion);


--
-- TOC entry 6876 (class 2606 OID 211800)
-- Dependencies: 6332 339 316
-- Name: thd_tipo_archivo__id_usuairo_reg; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_archivo
    ADD CONSTRAINT thd_tipo_archivo__id_usuairo_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6877 (class 2606 OID 211805)
-- Dependencies: 316 339 6332
-- Name: thd_tipo_archivo__id_usuario_mod; Type: FK CONSTRAINT; Schema: hidro; Owner: -
--

ALTER TABLE ONLY thd_tipo_archivo
    ADD CONSTRAINT thd_tipo_archivo__id_usuario_mod FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


SET search_path = param, pg_catalog;

--
-- TOC entry 6901 (class 2606 OID 211810)
-- Dependencies: 599 394 6751
-- Name: fk_tconfig_alarma__id_subsistema; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tconfig_alarma
    ADD CONSTRAINT fk_tconfig_alarma__id_subsistema FOREIGN KEY (id_subsistema) REFERENCES segu.tsubsistema(id_subsistema);


--
-- TOC entry 6902 (class 2606 OID 211815)
-- Dependencies: 396 6469 398
-- Name: fk_tcorrelativo__id_depto; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tcorrelativo
    ADD CONSTRAINT fk_tcorrelativo__id_depto FOREIGN KEY (id_depto) REFERENCES tdepto(id_depto);


--
-- TOC entry 6903 (class 2606 OID 211820)
-- Dependencies: 396 402 6473
-- Name: fk_tcorrelativo__id_documento; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tcorrelativo
    ADD CONSTRAINT fk_tcorrelativo__id_documento FOREIGN KEY (id_documento) REFERENCES tdocumento(id_documento);


--
-- TOC entry 6904 (class 2606 OID 211825)
-- Dependencies: 396 404 6475
-- Name: fk_tcorrelativo__id_gestion; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tcorrelativo
    ADD CONSTRAINT fk_tcorrelativo__id_gestion FOREIGN KEY (id_gestion) REFERENCES tgestion(id_gestion);


--
-- TOC entry 6905 (class 2606 OID 211830)
-- Dependencies: 396 412 6487
-- Name: fk_tcorrelativo__id_periodo; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tcorrelativo
    ADD CONSTRAINT fk_tcorrelativo__id_periodo FOREIGN KEY (id_periodo) REFERENCES tperiodo(id_periodo);


--
-- TOC entry 6906 (class 2606 OID 211835)
-- Dependencies: 396 474 6556
-- Name: fk_tcorrelativo__id_uo; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tcorrelativo
    ADD CONSTRAINT fk_tcorrelativo__id_uo FOREIGN KEY (id_uo) REFERENCES rhum.tuo(id_uo);


--
-- TOC entry 6907 (class 2606 OID 211840)
-- Dependencies: 396 316 6332
-- Name: fk_tcorrelativo__id_usuario_mod; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tcorrelativo
    ADD CONSTRAINT fk_tcorrelativo__id_usuario_mod FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6908 (class 2606 OID 211845)
-- Dependencies: 396 316 6332
-- Name: fk_tcorrelativo__id_usuario_reg; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tcorrelativo
    ADD CONSTRAINT fk_tcorrelativo__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6909 (class 2606 OID 211850)
-- Dependencies: 398 599 6751
-- Name: fk_tdepto__id_subsistema; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tdepto
    ADD CONSTRAINT fk_tdepto__id_subsistema FOREIGN KEY (id_subsistema) REFERENCES segu.tsubsistema(id_subsistema);


--
-- TOC entry 6910 (class 2606 OID 211855)
-- Dependencies: 402 6751 599
-- Name: fk_tdocumento__id_subsistema; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tdocumento
    ADD CONSTRAINT fk_tdocumento__id_subsistema FOREIGN KEY (id_subsistema) REFERENCES segu.tsubsistema(id_subsistema);


--
-- TOC entry 6914 (class 2606 OID 211860)
-- Dependencies: 414 6332 316
-- Name: fk_tpm_financiador__id_usuario; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tpm_financiador
    ADD CONSTRAINT fk_tpm_financiador__id_usuario FOREIGN KEY (id_usuario) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6915 (class 2606 OID 211865)
-- Dependencies: 316 6332 416
-- Name: fk_tpm_programa__id_usuario; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tpm_programa
    ADD CONSTRAINT fk_tpm_programa__id_usuario FOREIGN KEY (id_usuario) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6916 (class 2606 OID 211870)
-- Dependencies: 418 6332 316
-- Name: fk_tpm_proyecto__id_usuario; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tpm_proyecto
    ADD CONSTRAINT fk_tpm_proyecto__id_usuario FOREIGN KEY (id_usuario) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6918 (class 2606 OID 211875)
-- Dependencies: 406 422 6480
-- Name: fk_tproveedor__id_institucion; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tproveedor
    ADD CONSTRAINT fk_tproveedor__id_institucion FOREIGN KEY (id_institucion) REFERENCES tinstitucion(id_institucion);


--
-- TOC entry 6919 (class 2606 OID 211880)
-- Dependencies: 426 422 6514
-- Name: fk_tproveedor__id_persona; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tproveedor
    ADD CONSTRAINT fk_tproveedor__id_persona FOREIGN KEY (id_persona) REFERENCES segu.tpersona(id_persona);


--
-- TOC entry 6920 (class 2606 OID 211885)
-- Dependencies: 474 424 6556
-- Name: fk_tusuario_uo__id_uo; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tusuario_uo
    ADD CONSTRAINT fk_tusuario_uo__id_uo FOREIGN KEY (id_uo) REFERENCES rhum.tuo(id_uo);


--
-- TOC entry 6921 (class 2606 OID 211890)
-- Dependencies: 6332 424 316
-- Name: fk_tusuario_uo__id_ususario; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tusuario_uo
    ADD CONSTRAINT fk_tusuario_uo__id_ususario FOREIGN KEY (id_usuario) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6911 (class 2606 OID 211895)
-- Dependencies: 406 426 6514
-- Name: tinstitucion_fk; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tinstitucion
    ADD CONSTRAINT tinstitucion_fk FOREIGN KEY (id_persona) REFERENCES segu.tpersona(id_persona);


--
-- TOC entry 6912 (class 2606 OID 211900)
-- Dependencies: 408 408 6482
-- Name: tlugar_fk; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tlugar
    ADD CONSTRAINT tlugar_fk FOREIGN KEY (id_lugar_fk) REFERENCES tlugar(id_lugar);


--
-- TOC entry 6913 (class 2606 OID 211905)
-- Dependencies: 412 404 6475
-- Name: tperiodo_fk; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tperiodo
    ADD CONSTRAINT tperiodo_fk FOREIGN KEY (id_gestion) REFERENCES tgestion(id_gestion);


--
-- TOC entry 6917 (class 2606 OID 211910)
-- Dependencies: 420 6332 316
-- Name: tpm_regional_fk; Type: FK CONSTRAINT; Schema: param; Owner: -
--

ALTER TABLE ONLY tpm_regional
    ADD CONSTRAINT tpm_regional_fk FOREIGN KEY (id_usuario) REFERENCES segu.tusuario(id_usuario);


SET search_path = public, pg_catalog;

--
-- TOC entry 6800 (class 2606 OID 211915)
-- Dependencies: 316 203 6332
-- Name: fk_tbase__id_usuario_mod; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY tbase
    ADD CONSTRAINT fk_tbase__id_usuario_mod FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6801 (class 2606 OID 211920)
-- Dependencies: 6332 203 316
-- Name: fk_tbase__id_usuario_reg; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY tbase
    ADD CONSTRAINT fk_tbase__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


SET search_path = rhum, pg_catalog;

--
-- TOC entry 6922 (class 2606 OID 211925)
-- Dependencies: 452 426 6514
-- Name: fk_tfuncionario__id_persona; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tfuncionario
    ADD CONSTRAINT fk_tfuncionario__id_persona FOREIGN KEY (id_persona) REFERENCES segu.tpersona(id_persona);


--
-- TOC entry 6923 (class 2606 OID 211930)
-- Dependencies: 6332 316 452
-- Name: fk_tfuncionario__id_usuario_mod; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tfuncionario
    ADD CONSTRAINT fk_tfuncionario__id_usuario_mod FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6924 (class 2606 OID 211935)
-- Dependencies: 452 316 6332
-- Name: fk_tfuncionario__id_usuario_reg; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tfuncionario
    ADD CONSTRAINT fk_tfuncionario__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6925 (class 2606 OID 211940)
-- Dependencies: 452 6531 453
-- Name: fk_tfuncionario_horario__id_funcionario; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tfuncionario_horario
    ADD CONSTRAINT fk_tfuncionario_horario__id_funcionario FOREIGN KEY (id_funcionario) REFERENCES tfuncionario(id_funcionario);


--
-- TOC entry 6926 (class 2606 OID 211945)
-- Dependencies: 453 6536 456
-- Name: fk_tfuncionario_horario__id_horario; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tfuncionario_horario
    ADD CONSTRAINT fk_tfuncionario_horario__id_horario FOREIGN KEY (id_horario) REFERENCES thorario(id_horario);


--
-- TOC entry 6927 (class 2606 OID 211950)
-- Dependencies: 6332 453 316
-- Name: fk_tfuncionario_horario__id_usuario_reg; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tfuncionario_horario
    ADD CONSTRAINT fk_tfuncionario_horario__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6928 (class 2606 OID 211955)
-- Dependencies: 462 6475 404
-- Name: fk_tparametro__id_gestion; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tparametro_rhum
    ADD CONSTRAINT fk_tparametro__id_gestion FOREIGN KEY (id_gestion) REFERENCES param.tgestion(id_gestion);


--
-- TOC entry 6929 (class 2606 OID 211960)
-- Dependencies: 462 6332 316
-- Name: fk_tparametro__id_usuario_mod; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tparametro_rhum
    ADD CONSTRAINT fk_tparametro__id_usuario_mod FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6930 (class 2606 OID 211965)
-- Dependencies: 462 6332 316
-- Name: fk_tparametro__id_usuario_reg; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tparametro_rhum
    ADD CONSTRAINT fk_tparametro__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6931 (class 2606 OID 211970)
-- Dependencies: 462 410 6484
-- Name: fk_tparametro_rhum__id_moneda_sal_min_nal; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY tparametro_rhum
    ADD CONSTRAINT fk_tparametro_rhum__id_moneda_sal_min_nal FOREIGN KEY (id_moneda_sal_min_nal) REFERENCES param.tmoneda(id_moneda);


--
-- TOC entry 6932 (class 2606 OID 211975)
-- Dependencies: 246 466 6267
-- Name: fk_ttipo_columna__id_auxiliar_pasivo; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY ttipo_columna
    ADD CONSTRAINT fk_ttipo_columna__id_auxiliar_pasivo FOREIGN KEY (id_auxiliar_pasivo) REFERENCES conta.tauxiliar(id_auxiliar);


--
-- TOC entry 6933 (class 2606 OID 211980)
-- Dependencies: 248 466 6269
-- Name: fk_ttipo_columna__id_cuenta_pasivo; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY ttipo_columna
    ADD CONSTRAINT fk_ttipo_columna__id_cuenta_pasivo FOREIGN KEY (id_cuenta_pasivo) REFERENCES conta.tcuenta(id_cuenta);


--
-- TOC entry 6934 (class 2606 OID 211985)
-- Dependencies: 466 410 6484
-- Name: fk_ttipo_columna__id_moneda; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY ttipo_columna
    ADD CONSTRAINT fk_ttipo_columna__id_moneda FOREIGN KEY (id_moneda) REFERENCES param.tmoneda(id_moneda);


--
-- TOC entry 6935 (class 2606 OID 211990)
-- Dependencies: 466 462 6544
-- Name: fk_ttipo_columna__id_parametro_rhum; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY ttipo_columna
    ADD CONSTRAINT fk_ttipo_columna__id_parametro_rhum FOREIGN KEY (id_parametro_rhum) REFERENCES tparametro_rhum(id_parametro);


--
-- TOC entry 6936 (class 2606 OID 211995)
-- Dependencies: 466 470 6552
-- Name: fk_ttipo_columna__id_tipo_obligacion; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY ttipo_columna
    ADD CONSTRAINT fk_ttipo_columna__id_tipo_obligacion FOREIGN KEY (id_tipo_obligacion) REFERENCES ttipo_obligacion(id_tipo_obligacion);


--
-- TOC entry 6937 (class 2606 OID 212000)
-- Dependencies: 6332 316 466
-- Name: fk_ttipo_columna__id_usuario_reg; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY ttipo_columna
    ADD CONSTRAINT fk_ttipo_columna__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6938 (class 2606 OID 212005)
-- Dependencies: 410 472 6484
-- Name: fk_ttipo_planilla__id_moneda; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY ttipo_planilla
    ADD CONSTRAINT fk_ttipo_planilla__id_moneda FOREIGN KEY (id_moneda) REFERENCES param.tmoneda(id_moneda);


--
-- TOC entry 6939 (class 2606 OID 212010)
-- Dependencies: 472 316 6332
-- Name: fk_ttipo_planilla__id_usuario_mod; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY ttipo_planilla
    ADD CONSTRAINT fk_ttipo_planilla__id_usuario_mod FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6940 (class 2606 OID 212015)
-- Dependencies: 6332 472 316
-- Name: fk_ttipo_planilla__id_usuario_reg; Type: FK CONSTRAINT; Schema: rhum; Owner: -
--

ALTER TABLE ONLY ttipo_planilla
    ADD CONSTRAINT fk_ttipo_planilla__id_usuario_reg FOREIGN KEY (id_usuario_reg) REFERENCES segu.tusuario(id_usuario);


SET search_path = saj, pg_catalog;

--
-- TOC entry 6946 (class 2606 OID 212020)
-- Dependencies: 6578 493 487
-- Name: fk_testado_proceso_id_proceso_contrato; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY testado_proceso
    ADD CONSTRAINT fk_testado_proceso_id_proceso_contrato FOREIGN KEY (id_proceso_contrato) REFERENCES tproceso_contrato(id_proceso_contrato);


--
-- TOC entry 6950 (class 2606 OID 212025)
-- Dependencies: 493 6531 452
-- Name: fk_tproceso_contrato__id_funcionario; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_funcionario FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 6951 (class 2606 OID 212030)
-- Dependencies: 493 6475 404
-- Name: fk_tproceso_contrato__id_gestion; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_gestion FOREIGN KEY (id_gestion) REFERENCES param.tgestion(id_gestion);


--
-- TOC entry 6952 (class 2606 OID 212035)
-- Dependencies: 493 6576 491
-- Name: fk_tproceso_contrato__id_modalidad; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_modalidad FOREIGN KEY (id_modalidad) REFERENCES tmodalidad(id_modalidad);


--
-- TOC entry 6953 (class 2606 OID 212040)
-- Dependencies: 493 410 6484
-- Name: fk_tproceso_contrato__id_moneda; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_moneda FOREIGN KEY (id_moneda) REFERENCES param.tmoneda(id_moneda);


--
-- TOC entry 6954 (class 2606 OID 212045)
-- Dependencies: 422 6509 493
-- Name: fk_tproceso_contrato__id_proveedor; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_proveedor FOREIGN KEY (id_proveedor) REFERENCES param.tproveedor(id_proveedor);


--
-- TOC entry 6955 (class 2606 OID 212050)
-- Dependencies: 6497 418 493
-- Name: fk_tproceso_contrato__id_proyecto; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_proyecto FOREIGN KEY (id_proyecto) REFERENCES param.tpm_proyecto(id_proyecto);


--
-- TOC entry 6956 (class 2606 OID 212055)
-- Dependencies: 495 6580 493
-- Name: fk_tproceso_contrato__id_rep_legal; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_rep_legal FOREIGN KEY (id_representante_legal) REFERENCES tresponsable_proceso(id_responsable_proceso);


--
-- TOC entry 6957 (class 2606 OID 212060)
-- Dependencies: 6580 495 493
-- Name: fk_tproceso_contrato__id_rpc; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_rpc FOREIGN KEY (id_rpc) REFERENCES tresponsable_proceso(id_responsable_proceso);


--
-- TOC entry 6958 (class 2606 OID 212065)
-- Dependencies: 495 6580 493
-- Name: fk_tproceso_contrato__id_supervisor; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_supervisor FOREIGN KEY (id_supervisor) REFERENCES tresponsable_proceso(id_responsable_proceso);


--
-- TOC entry 6959 (class 2606 OID 212070)
-- Dependencies: 489 493 6574
-- Name: fk_tproceso_contrato__id_tipo_contrato; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato__id_tipo_contrato FOREIGN KEY (id_tipo_contrato) REFERENCES ttipo_contrato(id_tipo_contrato);


--
-- TOC entry 6960 (class 2606 OID 212075)
-- Dependencies: 474 493 6556
-- Name: fk_tproceso_contrato_id_uo; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tproceso_contrato
    ADD CONSTRAINT fk_tproceso_contrato_id_uo FOREIGN KEY (id_uo) REFERENCES rhum.tuo(id_uo);


--
-- TOC entry 6961 (class 2606 OID 212080)
-- Dependencies: 6531 495 452
-- Name: fk_tresponsable_proceso__id_funcionario; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tresponsable_proceso
    ADD CONSTRAINT fk_tresponsable_proceso__id_funcionario FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 6962 (class 2606 OID 212085)
-- Dependencies: 495 495 6580
-- Name: fk_tresponsable_proceso__id_responsable_anterior; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tresponsable_proceso
    ADD CONSTRAINT fk_tresponsable_proceso__id_responsable_anterior FOREIGN KEY (id_responsable_proceso_anterior) REFERENCES tresponsable_proceso(id_responsable_proceso);


--
-- TOC entry 6941 (class 2606 OID 212090)
-- Dependencies: 6480 480 406
-- Name: tboleta__id_institucion_fk; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tboleta
    ADD CONSTRAINT tboleta__id_institucion_fk FOREIGN KEY (id_institucion_banco) REFERENCES param.tinstitucion(id_institucion);


--
-- TOC entry 6942 (class 2606 OID 212095)
-- Dependencies: 410 480 6484
-- Name: tboleta__id_moneda_fk; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tboleta
    ADD CONSTRAINT tboleta__id_moneda_fk FOREIGN KEY (id_moneda) REFERENCES param.tmoneda(id_moneda);


--
-- TOC entry 6943 (class 2606 OID 212100)
-- Dependencies: 493 480 6578
-- Name: tboleta__id_proceso_contrato_fk; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tboleta
    ADD CONSTRAINT tboleta__id_proceso_contrato_fk FOREIGN KEY (id_proceso_contrato) REFERENCES tproceso_contrato(id_proceso_contrato);


--
-- TOC entry 6944 (class 2606 OID 212105)
-- Dependencies: 316 480 6332
-- Name: tboleta__id_usuario_fk; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tboleta
    ADD CONSTRAINT tboleta__id_usuario_fk FOREIGN KEY (id_usuario_mod) REFERENCES segu.tusuario(id_usuario);


--
-- TOC entry 6945 (class 2606 OID 212110)
-- Dependencies: 480 480 6560
-- Name: tboleta_fk; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY tboleta
    ADD CONSTRAINT tboleta_fk FOREIGN KEY (id_boleta_fk) REFERENCES tboleta(id_boleta);


--
-- TOC entry 6947 (class 2606 OID 212115)
-- Dependencies: 485 487 6564
-- Name: testado_proceso_estado_anterior_fk; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY testado_proceso
    ADD CONSTRAINT testado_proceso_estado_anterior_fk FOREIGN KEY (estado_anterior) REFERENCES testado(codigo);


--
-- TOC entry 6948 (class 2606 OID 212120)
-- Dependencies: 6564 487 485
-- Name: testado_proceso_estado_vigente_fk; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY testado_proceso
    ADD CONSTRAINT testado_proceso_estado_vigente_fk FOREIGN KEY (estado_vigente) REFERENCES testado(codigo);


--
-- TOC entry 6949 (class 2606 OID 212125)
-- Dependencies: 487 495 6580
-- Name: testado_proceso_fk; Type: FK CONSTRAINT; Schema: saj; Owner: -
--

ALTER TABLE ONLY testado_proceso
    ADD CONSTRAINT testado_proceso_fk FOREIGN KEY (id_responsable_proceso) REFERENCES tresponsable_proceso(id_responsable_proceso);


SET search_path = sast, pg_catalog;

--
-- TOC entry 6963 (class 2606 OID 212130)
-- Dependencies: 6471 500 400
-- Name: fk_testado_requerimiento__id_depto_usuario; Type: FK CONSTRAINT; Schema: sast; Owner: -
--

ALTER TABLE ONLY testado_requerimiento
    ADD CONSTRAINT fk_testado_requerimiento__id_depto_usuario FOREIGN KEY (id_depto_usuario) REFERENCES param.tdepto_usuario(id_depto_usuario);


--
-- TOC entry 6964 (class 2606 OID 212135)
-- Dependencies: 505 500 6589
-- Name: fk_testado_requerimiento__id_requerimiento; Type: FK CONSTRAINT; Schema: sast; Owner: -
--

ALTER TABLE ONLY testado_requerimiento
    ADD CONSTRAINT fk_testado_requerimiento__id_requerimiento FOREIGN KEY (id_requerimiento) REFERENCES trequerimientos(id_requerimiento);


--
-- TOC entry 6967 (class 2606 OID 212140)
-- Dependencies: 398 505 6469
-- Name: fk_trequerimientos__id_depto; Type: FK CONSTRAINT; Schema: sast; Owner: -
--

ALTER TABLE ONLY trequerimientos
    ADD CONSTRAINT fk_trequerimientos__id_depto FOREIGN KEY (id_depto) REFERENCES param.tdepto(id_depto);


--
-- TOC entry 6968 (class 2606 OID 212145)
-- Dependencies: 452 505 6531
-- Name: fk_trequerimientos__id_funcionario; Type: FK CONSTRAINT; Schema: sast; Owner: -
--

ALTER TABLE ONLY trequerimientos
    ADD CONSTRAINT fk_trequerimientos__id_funcionario FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 6969 (class 2606 OID 212150)
-- Dependencies: 404 505 6475
-- Name: fk_trequerimientos__id_gestion; Type: FK CONSTRAINT; Schema: sast; Owner: -
--

ALTER TABLE ONLY trequerimientos
    ADD CONSTRAINT fk_trequerimientos__id_gestion FOREIGN KEY (id_gestion) REFERENCES param.tgestion(id_gestion);


--
-- TOC entry 6970 (class 2606 OID 212155)
-- Dependencies: 502 505 6587
-- Name: fk_trequerimientos__id_tipo_requerimiento; Type: FK CONSTRAINT; Schema: sast; Owner: -
--

ALTER TABLE ONLY trequerimientos
    ADD CONSTRAINT fk_trequerimientos__id_tipo_requerimiento FOREIGN KEY (id_tipo_requerimiento) REFERENCES ttipo_requerimiento(id_tipo_requerimiento);


--
-- TOC entry 6965 (class 2606 OID 212160)
-- Dependencies: 500 498 6582
-- Name: testado_requerimiento_estado_anterior_fk; Type: FK CONSTRAINT; Schema: sast; Owner: -
--

ALTER TABLE ONLY testado_requerimiento
    ADD CONSTRAINT testado_requerimiento_estado_anterior_fk FOREIGN KEY (estado_anterior) REFERENCES testado(codigo);


--
-- TOC entry 6966 (class 2606 OID 212165)
-- Dependencies: 500 498 6582
-- Name: testado_requerimiento_estado_vigente_fk; Type: FK CONSTRAINT; Schema: sast; Owner: -
--

ALTER TABLE ONLY testado_requerimiento
    ADD CONSTRAINT testado_requerimiento_estado_vigente_fk FOREIGN KEY (estado_vigente) REFERENCES testado(codigo);


SET search_path = secont, pg_catalog;

--
-- TOC entry 6972 (class 2606 OID 212170)
-- Dependencies: 6514 509 426
-- Name: fk_contrati_es_person_persona; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY contratista
    ADD CONSTRAINT fk_contrati_es_person_persona FOREIGN KEY (id_persona) REFERENCES segu.tpersona(id_persona) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6973 (class 2606 OID 212175)
-- Dependencies: 530 509 6642
-- Name: fk_contrati_relations_persona_; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY contratista
    ADD CONSTRAINT fk_contrati_relations_persona_ FOREIGN KEY (id_persona_juridica) REFERENCES persona_juridica(id_persona_juridica) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6974 (class 2606 OID 212180)
-- Dependencies: 511 517 6617
-- Name: fk_contrato_abogado_empleado; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY contrato
    ADD CONSTRAINT fk_contrato_abogado_empleado FOREIGN KEY (emp_id_empleado) REFERENCES empleado(id_personal) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6975 (class 2606 OID 212185)
-- Dependencies: 511 6647 534
-- Name: fk_contrato_firma_represen; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY contrato
    ADD CONSTRAINT fk_contrato_firma_represen FOREIGN KEY (id_representante) REFERENCES representante(id_representante) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6976 (class 2606 OID 212190)
-- Dependencies: 6644 532 511
-- Name: fk_contrato_proyecto__proyecto; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY contrato
    ADD CONSTRAINT fk_contrato_proyecto__proyecto FOREIGN KEY (id_proyecto) REFERENCES proyecto(id_proyecto) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6977 (class 2606 OID 212195)
-- Dependencies: 536 6651 511
-- Name: fk_contrato_relations_requerim; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY contrato
    ADD CONSTRAINT fk_contrato_relations_requerim FOREIGN KEY (id_requerimiento) REFERENCES requerimiento(id_requerimiento) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6978 (class 2606 OID 212200)
-- Dependencies: 6617 511 517
-- Name: fk_contrato_responsab_empleado; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY contrato
    ADD CONSTRAINT fk_contrato_responsab_empleado FOREIGN KEY (id_empleado) REFERENCES empleado(id_personal) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6979 (class 2606 OID 212205)
-- Dependencies: 513 511 6603
-- Name: fk_correspo_relations_contrato; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY correspondencia
    ADD CONSTRAINT fk_correspo_relations_contrato FOREIGN KEY (id_contrato) REFERENCES contrato(id_contrato) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6980 (class 2606 OID 212210)
-- Dependencies: 6603 515 511
-- Name: fk_doc_anex_relations_contrato; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY doc_anexo
    ADD CONSTRAINT fk_doc_anex_relations_contrato FOREIGN KEY (id_contrato) REFERENCES contrato(id_contrato) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6981 (class 2606 OID 212215)
-- Dependencies: 426 517 6514
-- Name: fk_empleado_relations_persona; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY empleado
    ADD CONSTRAINT fk_empleado_relations_persona FOREIGN KEY (id_persona) REFERENCES segu.tpersona(id_persona) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6982 (class 2606 OID 212220)
-- Dependencies: 540 517 6660
-- Name: fk_empleado_unidad_em_unidad; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY empleado
    ADD CONSTRAINT fk_empleado_unidad_em_unidad FOREIGN KEY (id_unidad) REFERENCES unidad(id_unidad) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6983 (class 2606 OID 212225)
-- Dependencies: 519 521 6622
-- Name: fk_estado_r_relations_estado; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY estado_requerimiento
    ADD CONSTRAINT fk_estado_r_relations_estado FOREIGN KEY (id_estado) REFERENCES estado(id_estado) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6984 (class 2606 OID 212230)
-- Dependencies: 536 521 6651
-- Name: fk_estado_r_relations_requerim; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY estado_requerimiento
    ADD CONSTRAINT fk_estado_r_relations_requerim FOREIGN KEY (id_requerimiento) REFERENCES requerimiento(id_requerimiento) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6985 (class 2606 OID 212235)
-- Dependencies: 511 523 6603
-- Name: fk_garantia_contrato__contrato; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY garantia
    ADD CONSTRAINT fk_garantia_contrato__contrato FOREIGN KEY (id_contrato) REFERENCES contrato(id_contrato) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6986 (class 2606 OID 212240)
-- Dependencies: 511 525 6603
-- Name: fk_informe_relations_contrato; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY informe
    ADD CONSTRAINT fk_informe_relations_contrato FOREIGN KEY (id_contrato) REFERENCES contrato(id_contrato) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6971 (class 2606 OID 212245)
-- Dependencies: 532 508 6644
-- Name: fk_leg_alar_proyecto__proyecto; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY alarma
    ADD CONSTRAINT fk_leg_alar_proyecto__proyecto FOREIGN KEY (id_proyecto) REFERENCES proyecto(id_proyecto) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6987 (class 2606 OID 212250)
-- Dependencies: 511 528 6603
-- Name: fk_oferta_relations_contrato; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY oferta
    ADD CONSTRAINT fk_oferta_relations_contrato FOREIGN KEY (id_contrato) REFERENCES contrato(id_contrato) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6988 (class 2606 OID 212255)
-- Dependencies: 534 509 6597
-- Name: fk_represen_repre_contrati; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY representante
    ADD CONSTRAINT fk_represen_repre_contrati FOREIGN KEY (id_contratista) REFERENCES contratista(id_contratista) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6989 (class 2606 OID 212260)
-- Dependencies: 534 426 6514
-- Name: fk_representante__id_persona; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY representante
    ADD CONSTRAINT fk_representante__id_persona FOREIGN KEY (id_persona) REFERENCES segu.tpersona(id_persona) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6990 (class 2606 OID 212265)
-- Dependencies: 6617 536 517
-- Name: fk_requerim_relations_empleado; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY requerimiento
    ADD CONSTRAINT fk_requerim_relations_empleado FOREIGN KEY (id_personal) REFERENCES empleado(id_personal) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6991 (class 2606 OID 212270)
-- Dependencies: 517 536 6617
-- Name: fk_requerim_solicitan_empleado; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY requerimiento
    ADD CONSTRAINT fk_requerim_solicitan_empleado FOREIGN KEY (emp_id_personal) REFERENCES empleado(id_personal) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6992 (class 2606 OID 212275)
-- Dependencies: 540 536 6660
-- Name: fk_requerimiento__id_unidad; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY requerimiento
    ADD CONSTRAINT fk_requerimiento__id_unidad FOREIGN KEY (id_unidad) REFERENCES unidad(id_unidad) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6993 (class 2606 OID 212280)
-- Dependencies: 511 538 6603
-- Name: fk_resoluci_contrato__contrato; Type: FK CONSTRAINT; Schema: secont; Owner: -
--

ALTER TABLE ONLY resolucion
    ADD CONSTRAINT fk_resoluci_contrato__contrato FOREIGN KEY (id_contrato) REFERENCES contrato(id_contrato) ON UPDATE RESTRICT ON DELETE RESTRICT;


SET search_path = segu, pg_catalog;

--
-- TOC entry 6994 (class 2606 OID 212285)
-- Dependencies: 599 549 6751
-- Name: fk_estructura_dato__id_subsistema; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY testructura_dato
    ADD CONSTRAINT fk_estructura_dato__id_subsistema FOREIGN KEY (id_subsistema) REFERENCES tsubsistema(id_subsistema);


--
-- TOC entry 6995 (class 2606 OID 212290)
-- Dependencies: 582 551 6715
-- Name: fk_estructura_gui__id_hijo; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY testructura_gui
    ADD CONSTRAINT fk_estructura_gui__id_hijo FOREIGN KEY (id_gui) REFERENCES tgui(id_gui);


--
-- TOC entry 6996 (class 2606 OID 212295)
-- Dependencies: 582 551 6715
-- Name: fk_estructura_gui__id_padre; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY testructura_gui
    ADD CONSTRAINT fk_estructura_gui__id_padre FOREIGN KEY (fk_id_gui) REFERENCES tgui(id_gui);


--
-- TOC entry 7006 (class 2606 OID 212300)
-- Dependencies: 599 581 6751
-- Name: fk_funcion__id_subsistema; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tfuncion
    ADD CONSTRAINT fk_funcion__id_subsistema FOREIGN KEY (id_subsistema) REFERENCES tsubsistema(id_subsistema);


--
-- TOC entry 7007 (class 2606 OID 212305)
-- Dependencies: 582 6751 599
-- Name: fk_gui__id_subsistema; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tgui
    ADD CONSTRAINT fk_gui__id_subsistema FOREIGN KEY (id_subsistema) REFERENCES tsubsistema(id_subsistema);


--
-- TOC entry 6997 (class 2606 OID 212310)
-- Dependencies: 554 582 6715
-- Name: fk_gui_rol__id_gui; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tgui_rol
    ADD CONSTRAINT fk_gui_rol__id_gui FOREIGN KEY (id_gui) REFERENCES tgui(id_gui);


--
-- TOC entry 6998 (class 2606 OID 212315)
-- Dependencies: 554 596 6746
-- Name: fk_gui_rol__id_rol; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tgui_rol
    ADD CONSTRAINT fk_gui_rol__id_rol FOREIGN KEY (id_rol) REFERENCES trol(id_rol);


--
-- TOC entry 7005 (class 2606 OID 212320)
-- Dependencies: 6729 577 589
-- Name: fk_id_patron_evento; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tbloqueo_notificacion
    ADD CONSTRAINT fk_id_patron_evento FOREIGN KEY (id_patron_evento) REFERENCES tpatron_evento(id_patron_evento) ON UPDATE CASCADE;


--
-- TOC entry 7008 (class 2606 OID 212325)
-- Dependencies: 599 588 6751
-- Name: fk_log_esta_subsiste; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tlog_
    ADD CONSTRAINT fk_log_esta_subsiste FOREIGN KEY (id_subsistema) REFERENCES tsubsistema(id_subsistema) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6899 (class 2606 OID 212330)
-- Dependencies: 599 373 6751
-- Name: fk_log_esta_subsiste; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tlog
    ADD CONSTRAINT fk_log_esta_subsiste FOREIGN KEY (id_subsistema) REFERENCES tsubsistema(id_subsistema) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 7009 (class 2606 OID 212335)
-- Dependencies: 594 588 6737
-- Name: fk_log_procedimi_procedim; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tlog_
    ADD CONSTRAINT fk_log_procedimi_procedim FOREIGN KEY (id_procedimiento) REFERENCES tprocedimiento(id_procedimiento) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 7010 (class 2606 OID 212340)
-- Dependencies: 316 588 6332
-- Name: fk_log_usuario_e_usuario; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tlog_
    ADD CONSTRAINT fk_log_usuario_e_usuario FOREIGN KEY (id_usuario) REFERENCES tusuario(id_usuario) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6900 (class 2606 OID 212345)
-- Dependencies: 316 373 6332
-- Name: fk_log_usuario_e_usuario; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tlog
    ADD CONSTRAINT fk_log_usuario_e_usuario FOREIGN KEY (id_usuario) REFERENCES tusuario(id_usuario) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 7011 (class 2606 OID 212350)
-- Dependencies: 570 591 6694
-- Name: fk_perfil__id_recurso; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tperfil
    ADD CONSTRAINT fk_perfil__id_recurso FOREIGN KEY (id_recurso) REFERENCES trecurso(id_recurso);


--
-- TOC entry 6999 (class 2606 OID 212355)
-- Dependencies: 549 561 6667
-- Name: fk_permiso__id_estructura; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tpermiso
    ADD CONSTRAINT fk_permiso__id_estructura FOREIGN KEY (id_estructura) REFERENCES testructura_dato(id_estructura_dato);


--
-- TOC entry 7000 (class 2606 OID 212360)
-- Dependencies: 594 561 6737
-- Name: fk_permiso__id_proc; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tpermiso
    ADD CONSTRAINT fk_permiso__id_proc FOREIGN KEY (id_procedimiento) REFERENCES tprocedimiento(id_procedimiento);


--
-- TOC entry 7012 (class 2606 OID 212365)
-- Dependencies: 594 581 6708
-- Name: fk_procedim_tiene_pro_funcion; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tprocedimiento
    ADD CONSTRAINT fk_procedim_tiene_pro_funcion FOREIGN KEY (id_funcion) REFERENCES tfuncion(id_funcion) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 7001 (class 2606 OID 212370)
-- Dependencies: 564 582 6715
-- Name: fk_procedimiento_gui__id_gui; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tprocedimiento_gui
    ADD CONSTRAINT fk_procedimiento_gui__id_gui FOREIGN KEY (id_gui) REFERENCES tgui(id_gui);


--
-- TOC entry 7002 (class 2606 OID 212375)
-- Dependencies: 6737 564 594
-- Name: fk_procedimiento_gui__id_proc; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tprocedimiento_gui
    ADD CONSTRAINT fk_procedimiento_gui__id_proc FOREIGN KEY (id_procedimiento) REFERENCES tprocedimiento(id_procedimiento);


--
-- TOC entry 7013 (class 2606 OID 212380)
-- Dependencies: 599 596 6751
-- Name: fk_rol__id_subsistema; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY trol
    ADD CONSTRAINT fk_rol__id_subsistema FOREIGN KEY (id_subsistema) REFERENCES tsubsistema(id_subsistema);


--
-- TOC entry 7003 (class 2606 OID 212385)
-- Dependencies: 564 574 6688
-- Name: fk_rol_procedimiento__id_procedimiento_gui; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY trol_procedimiento_gui
    ADD CONSTRAINT fk_rol_procedimiento__id_procedimiento_gui FOREIGN KEY (id_procedimiento_gui) REFERENCES tprocedimiento_gui(id_procedimiento_gui);


--
-- TOC entry 7004 (class 2606 OID 212390)
-- Dependencies: 596 574 6746
-- Name: fk_rol_procedimiento__id_rol; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY trol_procedimiento_gui
    ADD CONSTRAINT fk_rol_procedimiento__id_rol FOREIGN KEY (id_rol) REFERENCES trol(id_rol);


--
-- TOC entry 7022 (class 2606 OID 212395)
-- Dependencies: 596 605 6746
-- Name: fk_usuario__es_asigna_rol; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tusuario_rol
    ADD CONSTRAINT fk_usuario__es_asigna_rol FOREIGN KEY (id_rol) REFERENCES trol(id_rol) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 6851 (class 2606 OID 212400)
-- Dependencies: 426 316 6514
-- Name: fk_usuario__id_persona; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tusuario
    ADD CONSTRAINT fk_usuario__id_persona FOREIGN KEY (id_persona) REFERENCES tpersona(id_persona);


--
-- TOC entry 7020 (class 2606 OID 212405)
-- Dependencies: 595 604 6743
-- Name: fk_usuario__regional__regional; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tusuario_regional
    ADD CONSTRAINT fk_usuario__regional__regional FOREIGN KEY (id_regional) REFERENCES tregional(id_regional) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 7016 (class 2606 OID 212410)
-- Dependencies: 591 602 6732
-- Name: fk_usuario__se_asigna_perfil; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tusuario_perfil
    ADD CONSTRAINT fk_usuario__se_asigna_perfil FOREIGN KEY (id_perfil) REFERENCES tperfil(id_perfil) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 7017 (class 2606 OID 212415)
-- Dependencies: 6332 316 602
-- Name: fk_usuario__tiene_per_usuario; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tusuario_perfil
    ADD CONSTRAINT fk_usuario__tiene_per_usuario FOREIGN KEY (id_usuario) REFERENCES tusuario(id_usuario) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 7023 (class 2606 OID 212420)
-- Dependencies: 6332 316 605
-- Name: fk_usuario__tiene_pri_usuario; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tusuario_rol
    ADD CONSTRAINT fk_usuario__tiene_pri_usuario FOREIGN KEY (id_usuario) REFERENCES tusuario(id_usuario) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 7021 (class 2606 OID 212425)
-- Dependencies: 604 6332 316
-- Name: fk_usuario__usuario_p_usuario; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tusuario_regional
    ADD CONSTRAINT fk_usuario__usuario_p_usuario FOREIGN KEY (id_usuario) REFERENCES tusuario(id_usuario) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 7014 (class 2606 OID 212430)
-- Dependencies: 601 6663 546
-- Name: fk_usuario_actividad__id_actividad; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tusuario_actividad
    ADD CONSTRAINT fk_usuario_actividad__id_actividad FOREIGN KEY (id_actividad) REFERENCES tactividad(id_actividad);


--
-- TOC entry 7015 (class 2606 OID 212435)
-- Dependencies: 6332 316 601
-- Name: fk_usuario_actividad__id_usuario; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tusuario_actividad
    ADD CONSTRAINT fk_usuario_actividad__id_usuario FOREIGN KEY (id_usuario) REFERENCES tusuario(id_usuario);


--
-- TOC entry 7018 (class 2606 OID 212440)
-- Dependencies: 603 567 6691
-- Name: fk_usuario_proyecto__id_proyecto; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tusuario_proyecto
    ADD CONSTRAINT fk_usuario_proyecto__id_proyecto FOREIGN KEY (id_proyecto) REFERENCES tproyecto(id_proyecto);


--
-- TOC entry 7019 (class 2606 OID 212445)
-- Dependencies: 603 6332 316
-- Name: fk_usuario_proyecto__id_usuario; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tusuario_proyecto
    ADD CONSTRAINT fk_usuario_proyecto__id_usuario FOREIGN KEY (id_usuario) REFERENCES tusuario(id_usuario);


--
-- TOC entry 6852 (class 2606 OID 212450)
-- Dependencies: 6705 316 579
-- Name: fk_usuario_se_asigna_clasific; Type: FK CONSTRAINT; Schema: segu; Owner: -
--

ALTER TABLE ONLY tusuario
    ADD CONSTRAINT fk_usuario_se_asigna_clasific FOREIGN KEY (id_clasificador) REFERENCES tclasificador(id_clasificador) ON UPDATE RESTRICT ON DELETE RESTRICT;


SET search_path = tesor, pg_catalog;

--
-- TOC entry 7024 (class 2606 OID 212455)
-- Dependencies: 6783 616 617
-- Name: fk_tcaja_mov; Type: FK CONSTRAINT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY tcaja_mov
    ADD CONSTRAINT fk_tcaja_mov FOREIGN KEY (id_caja) REFERENCES tcaja(id_caja);


--
-- TOC entry 7025 (class 2606 OID 212460)
-- Dependencies: 616 6783 618
-- Name: fk_tcajero__id_caja; Type: FK CONSTRAINT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY tcajero
    ADD CONSTRAINT fk_tcajero__id_caja FOREIGN KEY (id_caja) REFERENCES tcaja(id_caja);


--
-- TOC entry 7026 (class 2606 OID 212465)
-- Dependencies: 452 6531 618
-- Name: fk_tcajero__id_funcionario; Type: FK CONSTRAINT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY tcajero
    ADD CONSTRAINT fk_tcajero__id_funcionario FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 7027 (class 2606 OID 212470)
-- Dependencies: 6787 620 618
-- Name: fk_trecibo__id_cajero; Type: FK CONSTRAINT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY trecibo
    ADD CONSTRAINT fk_trecibo__id_cajero FOREIGN KEY (id_cajero) REFERENCES tcajero(id_cajero);


--
-- TOC entry 7028 (class 2606 OID 212475)
-- Dependencies: 6531 452 620
-- Name: fk_trecibo__id_funcionario; Type: FK CONSTRAINT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY trecibo
    ADD CONSTRAINT fk_trecibo__id_funcionario FOREIGN KEY (id_funcionario) REFERENCES rhum.tfuncionario(id_funcionario);


--
-- TOC entry 7029 (class 2606 OID 212480)
-- Dependencies: 620 410 6484
-- Name: fk_trecibo__id_moneda; Type: FK CONSTRAINT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY trecibo
    ADD CONSTRAINT fk_trecibo__id_moneda FOREIGN KEY (id_moneda) REFERENCES param.tmoneda(id_moneda);


--
-- TOC entry 7030 (class 2606 OID 212485)
-- Dependencies: 621 6271 250
-- Name: fk_trendicion__id_documento; Type: FK CONSTRAINT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY trendicion
    ADD CONSTRAINT fk_trendicion__id_documento FOREIGN KEY (id_documento) REFERENCES conta.tdocumento(id_documento);


--
-- TOC entry 7031 (class 2606 OID 212490)
-- Dependencies: 6789 620 621
-- Name: fk_trendicion__id_recibo; Type: FK CONSTRAINT; Schema: tesor; Owner: -
--

ALTER TABLE ONLY trendicion
    ADD CONSTRAINT fk_trendicion__id_recibo FOREIGN KEY (id_recibo) REFERENCES trecibo(id_recibo);


SET search_path = tesoro, pg_catalog;

--
-- TOC entry 7032 (class 2606 OID 212495)
-- Dependencies: 6484 622 410
-- Name: fk_tts_corte__id_moneda; Type: FK CONSTRAINT; Schema: tesoro; Owner: -
--

ALTER TABLE ONLY tts_corte_moneda
    ADD CONSTRAINT fk_tts_corte__id_moneda FOREIGN KEY (id_moneda) REFERENCES param.tmoneda(id_moneda) ON UPDATE CASCADE;


-- Completed on 2012-08-08 21:00:08 BOT

--
-- PostgreSQL database dump complete
--

